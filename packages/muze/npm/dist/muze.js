(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("muze", [], factory);
	else if(typeof exports === 'object')
		exports["muze"] = factory();
	else
		root["muze"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./packages/muze/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../datamodel/dist/datamodel.js":
/*!**************************************!*\
  !*** ../datamodel/dist/datamodel.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/d3-dsv/src/autoType.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-dsv/src/autoType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return autoType; });
function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(),
        number;
    if (!value) value = null;else if (value === "true") value = true;else if (value === "false") value = false;else if (value === "NaN") value = NaN;else if (!isNaN(number = +value)) value = number;else if (/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/.test(value)) value = new Date(value);else continue;
    object[key] = value;
  }
  return object;
}

/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/*! exports provided: csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return csvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");


var csv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;

/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "",
      length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}

/* harmony default export */ __webpack_exports__["default"] = (function (delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i,
          j = I,
          c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {}
        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) {
        row.push(t), t = token();
      }if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\"" : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows
  };
});

/***/ }),

/***/ "./node_modules/d3-dsv/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/d3-dsv/src/index.js ***!
  \******************************************/
/*! exports provided: dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, autoType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return _dsv__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _csv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return _csv__WEBPACK_IMPORTED_MODULE_1__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return _csv__WEBPACK_IMPORTED_MODULE_1__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return _csv__WEBPACK_IMPORTED_MODULE_1__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return _csv__WEBPACK_IMPORTED_MODULE_1__["csvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return _csv__WEBPACK_IMPORTED_MODULE_1__["csvFormatRows"]; });

/* harmony import */ var _tsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return _tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return _tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return _tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return _tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return _tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRows"]; });

/* harmony import */ var _autoType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autoType */ "./node_modules/d3-dsv/src/autoType.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autoType", function() { return _autoType__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/*! exports provided: tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return tsvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, description, homepage, version, license, main, keywords, author, repository, contributors, dependencies, devDependencies, scripts, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"datamodel\",\"description\":\"Relational algebra compliant in-memory tabular data store\",\"homepage\":\"https://github.com/chartshq/datamodel\",\"version\":\"2.2.1\",\"license\":\"MIT\",\"main\":\"dist/datamodel.js\",\"keywords\":[\"datamodel\",\"data\",\"relational\",\"algebra\",\"model\",\"muze\",\"fusioncharts\",\"table\",\"tabular\",\"operation\"],\"author\":\"Muzejs.org (https://muzejs.org/)\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/chartshq/datamodel.git\"},\"contributors\":[{\"name\":\"Akash Goswami\",\"email\":\"akashgoswami90s@gmail.com\"},{\"name\":\"Subhash Haldar\"},{\"name\":\"Rousan Ali\",\"email\":\"rousanali786@gmail.com\",\"url\":\"https://rousan.io\"},{\"name\":\"Ujjal Kumar Dutta\",\"email\":\"duttaujjalkumar@live.com\"}],\"dependencies\":{\"d3-dsv\":\"^1.0.8\"},\"devDependencies\":{\"babel-cli\":\"6.26.0\",\"babel-core\":\"^6.26.3\",\"babel-eslint\":\"6.1.2\",\"babel-loader\":\"^7.1.4\",\"babel-plugin-transform-runtime\":\"^6.23.0\",\"babel-preset-env\":\"^1.7.0\",\"babel-preset-es2015\":\"^6.24.1\",\"babel-preset-flow\":\"^6.23.0\",\"chai\":\"3.5.0\",\"cross-env\":\"^5.0.5\",\"eslint\":\"3.19.0\",\"eslint-config-airbnb\":\"15.1.0\",\"eslint-plugin-import\":\"2.7.0\",\"eslint-plugin-jsx-a11y\":\"5.1.1\",\"eslint-plugin-react\":\"7.3.0\",\"istanbul-instrumenter-loader\":\"^3.0.0\",\"jsdoc\":\"3.5.5\",\"json2yaml\":\"^1.1.0\",\"karma\":\"1.7.1\",\"karma-chai\":\"0.1.0\",\"karma-chrome-launcher\":\"2.1.1\",\"karma-coverage-istanbul-reporter\":\"^1.3.0\",\"karma-mocha\":\"1.3.0\",\"karma-spec-reporter\":\"0.0.31\",\"karma-webpack\":\"2.0.3\",\"marked\":\"^0.5.0\",\"mocha\":\"3.4.2\",\"mocha-webpack\":\"0.7.0\",\"transform-runtime\":\"0.0.0\",\"webpack\":\"^4.12.0\",\"webpack-cli\":\"^3.0.7\",\"webpack-dev-server\":\"^3.1.4\"},\"scripts\":{\"test\":\"npm run lint && npm run ut\",\"ut\":\"karma start karma.conf.js\",\"utd\":\"karma start --single-run false --browsers Chrome karma.conf.js \",\"build\":\"npm run build:prod\",\"build:dev\":\"webpack --mode development\",\"build:prod\":\"webpack --mode production\",\"start\":\"webpack-dev-server --config webpack.config.dev.js --mode development --open\",\"lint\":\"eslint ./src\",\"lint-errors\":\"eslint --quiet ./src\",\"docs\":\"rm -rf yaml && mkdir yaml && jsdoc -c jsdoc.conf.json\"}}");

/***/ }),

/***/ "./src/constants/geo.js":
/*!******************************!*\
  !*** ./src/constants/geo.js ***!
  \******************************/
/*! exports provided: START, END, BOTH, BOUNDARY_POINTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "START", function() { return START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "END", function() { return END; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTH", function() { return BOTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOUNDARY_POINTS", function() { return BOUNDARY_POINTS; });
var START = 'start';
var END = 'end';
var BOTH = 'both';

var BOUNDARY_POINTS = {
    START: 'start',
    END: 'end',
    BOTH: 'both'
};

/***/ }),

/***/ "./src/constants/index.js":
/*!********************************!*\
  !*** ./src/constants/index.js ***!
  \********************************/
/*! exports provided: DataFormat, FilteringMode, PROPAGATION, ROW_ID, DM_DERIVATIVES, JOINS, LOGICAL_OPERATORS, GEOM_FIELD */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPAGATION", function() { return PROPAGATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_ID", function() { return ROW_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DM_DERIVATIVES", function() { return DM_DERIVATIVES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JOINS", function() { return JOINS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOGICAL_OPERATORS", function() { return LOGICAL_OPERATORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOM_FIELD", function() { return GEOM_FIELD; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataFormat", function() { return _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FilteringMode", function() { return _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"]; });


/**
 * The event name for data propagation.
 */
var PROPAGATION = 'propagation';

/**
 * The name of the unique row id column in DataModel.
 */
var ROW_ID = '__id__';

/**
 * The enums for operation names performed on DataModel.
 */
var DM_DERIVATIVES = {
    SELECT: 'select',
    PROJECT: 'project',
    GROUPBY: 'group',
    COMPOSE: 'compose',
    CAL_VAR: 'calculatedVariable',
    BIN: 'bin',
    SORT: 'sort'
};

var JOINS = {
    CROSS: 'cross',
    LEFTOUTER: 'leftOuter',
    RIGHTOUTER: 'rightOuter',
    NATURAL: 'natural',
    FULLOUTER: 'fullOuter'
};

var LOGICAL_OPERATORS = {
    AND: 'and',
    OR: 'or'
};

var GEOM_FIELD = 'geometry';

/***/ }),

/***/ "./src/converter/auto-resolver.js":
/*!****************************************!*\
  !*** ./src/converter/auto-resolver.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _flat_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flat-json */ "./src/converter/flat-json.js");
/* harmony import */ var _dsv_arr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv-arr */ "./src/converter/dsv-arr.js");
/* harmony import */ var _dsv_str__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dsv-str */ "./src/converter/dsv-str.js");
/* harmony import */ var _geo_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geo-json */ "./src/converter/geo-json.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");






/**
 * Parses the input data and detect the format automatically.
 *
 * @param {string|Array} data - The input data.
 * @param {Array} schema - The schema for input data.
 * @param {Object} options - An optional config specific to data format.
 * @return {Array.<Object>} Returns an array of headers and column major data.
 */
function Auto(data, schema, options) {
    var converters = { FlatJSON: _flat_json__WEBPACK_IMPORTED_MODULE_0__["default"], DSVStr: _dsv_str__WEBPACK_IMPORTED_MODULE_2__["default"], DSVArr: _dsv_arr__WEBPACK_IMPORTED_MODULE_1__["default"], GeoJSON: _geo_json__WEBPACK_IMPORTED_MODULE_3__["default"] };
    var dataFormat = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["detectDataFormat"])(data);

    if (!dataFormat) {
        throw new Error('Couldn\'t detect the data format');
    }
    return converters[dataFormat](data, schema, options);
}

/* harmony default export */ __webpack_exports__["default"] = (Auto);

/***/ }),

/***/ "./src/converter/dsv-arr.js":
/*!**********************************!*\
  !*** ./src/converter/dsv-arr.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }



/**
 * Parses and converts data formatted in DSV array to a manageable internal format.
 *
 * @param {Array.<Array>} arr - A 2D array containing of the DSV data.
 * @param {Object} options - Option to control the behaviour of the parsing.
 * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv data is header or not.
 * @return {Array} Returns an array of headers and column major data.
 * @example
 *
 * // Sample input data:
 * const data = [
 *    ["a", "b", "c"],
 *    [1, 2, 3],
 *    [4, 5, 6],
 *    [7, 8, 9]
 * ];
 */
function DSVArr(arr, schema, options) {
    if (!Array.isArray(schema)) {
        throw new Error('Schema missing or is in an unsupported format');
    }
    var defaultOption = {
        firstRowHeader: true
    };
    var schemaFields = schema.map(function (unitSchema) {
        return unitSchema.name;
    });
    options = Object.assign({}, defaultOption, options);

    var columns = [];
    var push = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["columnMajor"])(columns);

    if (options.firstRowHeader) {
        // If header present then remove the first header row.
        // Do in-place mutation to save space.
        arr.splice(0, 1)[0];
    }

    arr.forEach(function (field) {
        return push.apply(undefined, _toConsumableArray(field));
    });

    return [schemaFields, columns];
}

/* harmony default export */ __webpack_exports__["default"] = (DSVArr);

/***/ }),

/***/ "./src/converter/dsv-str.js":
/*!**********************************!*\
  !*** ./src/converter/dsv-str.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/index.js");
/* harmony import */ var _dsv_arr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv-arr */ "./src/converter/dsv-arr.js");



/**
 * Parses and converts data formatted in DSV string to a manageable internal format.
 *
 * @todo Support to be given for https://tools.ietf.org/html/rfc4180.
 * @todo Sample implementation https://github.com/knrz/CSV.js/.
 *
 * @param {string} str - The input DSV string.
 * @param {Object} options - Option to control the behaviour of the parsing.
 * @param {boolean} [options.firstRowHeader=true] - Whether the first row of the dsv string data is header or not.
 * @param {string} [options.fieldSeparator=","] - The separator of two consecutive field.
 * @return {Array} Returns an array of headers and column major data.
 * @example
 *
 * // Sample input data:
 * const data = `
 * a,b,c
 * 1,2,3
 * 4,5,6
 * 7,8,9
 * `
 */
function DSVStr(str, schema, options) {
    var defaultOption = {
        firstRowHeader: true,
        fieldSeparator: ','
    };
    options = Object.assign({}, defaultOption, options);

    var dsv = Object(d3_dsv__WEBPACK_IMPORTED_MODULE_0__["dsvFormat"])(options.fieldSeparator);
    return Object(_dsv_arr__WEBPACK_IMPORTED_MODULE_1__["default"])(dsv.parseRows(str), schema, options);
}

/* harmony default export */ __webpack_exports__["default"] = (DSVStr);

/***/ }),

/***/ "./src/converter/flat-json.js":
/*!************************************!*\
  !*** ./src/converter/flat-json.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");



/**
 * This function takes the schema field passed and checks if has the subtype field
 * which ensure the data to be geo data
 *
 * @param {Object} obj any object
 * @return {boolean} Checks if a field is geoField or not
 */
var isGeoField = function isGeoField(obj) {
    return obj.subtype === _enums__WEBPACK_IMPORTED_MODULE_1__["DimensionSubtype"].GEO;
};

/**
 * This function takes the schema field passed and checks if has the delimiter field
 * which ensure the data is provided in lat long form
 *
 * @param {Object} obj any object
 * @return {boolean} Checks the format of geo Data
 */
var isLatLong = function isLatLong(obj) {
    return !!obj.delimiter;
};

/**
 * There are three formats of data:
 * 1. lon-lat 2. data having type and coordinate fields
 * 3. geo fields of schema have lat long fields
 * All the three types are processed and changed as per
 * required type and returned from here
 *
 * @param {Object} selectedSchema the selected index of input schema
 * @param {Object} data the selected data
 * @param {string} selectedName the selected index of field names array.
 * @return {Array.<Object>} single entity of geo data with type and coordinates
 * [{ type: 'Point', coordinates: [23, 24] }]]
 */
var prepareGeoFields = function prepareGeoFields(selectedSchema, data, selectedName) {
    var result = null;
    var selectedData = data[selectedName];
    var delimiter = selectedSchema.delimiter,
        lat = selectedSchema.lat,
        long = selectedSchema.long;

    var la = void 0;
    var lo = void 0;
    if ('lat' in selectedSchema && 'long' in selectedSchema) {
        la = +data[lat];
        lo = +data[long];
        if (!(Number.isNaN(la) || Number.isNaN(lo))) {
            result = { type: 'Point', coordinates: [lo, la] };
        }
    } else if (selectedData && isLatLong(selectedSchema) && selectedData.includes(delimiter)) {
        var coordinate = selectedData.split(delimiter);
        result = { type: 'Point', coordinates: [+coordinate[0], +coordinate[1]] };
    } else if (selectedData && 'type' in selectedData && 'coordinates' in selectedData) {
        result = selectedData;
    }

    return result;
};

/**
 * Parses and converts data formatted in JSON to a manageable internal format.
 *
 * @param {Array.<Object>} arr - The input data formatted in JSON.
 * @param {Array.<Object>} schema - The input schema.
 * @return {Array.<Object>} Returns an array of headers and column major data.
 * @example
 *
 * // Sample input data:
 * const data = [
 *    {
 *      "a": 1,
 *      "b": 2,
 *      "c": 3
 *    },
 *    {
 *      "a": 4,
 *      "b": 5,
 *      "c": 6
 *    },
 *    {
 *      "a": 7,
 *      "b": 8,
 *      "c": 9
 *    }
 * ];
 */
function FlatJSON(arr, schema) {
    if (!Array.isArray(schema)) {
        throw new Error('Schema missing or is in an unsupported format');
    }

    var header = {};
    var i = 0;
    var insertionIndex = void 0;
    var columns = [];
    var push = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["columnMajor"])(columns);
    var schemaFieldsName = schema.map(function (unitSchema) {
        return unitSchema.name;
    });

    arr.forEach(function (item, index) {
        var fields = [];
        schemaFieldsName.forEach(function (unitSchema, ind) {
            if (unitSchema in header) {
                insertionIndex = header[unitSchema];
            } else {
                header[unitSchema] = i++;
                insertionIndex = i - 1;
            }

            // separate logic for geo Fields
            fields[insertionIndex] = isGeoField(schema[ind]) ? prepareGeoFields(schema[ind], arr[index], unitSchema) : item[unitSchema];
        });
        push.apply(undefined, fields);
    });
    return [Object.keys(header), columns];
}

/* harmony default export */ __webpack_exports__["default"] = (FlatJSON);

/***/ }),

/***/ "./src/converter/geo-json.js":
/*!***********************************!*\
  !*** ./src/converter/geo-json.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _enums_geo_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/geo-props */ "./src/enums/geo-props.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./src/constants/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
var _geometryRetriever;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var GEOM_DEFAULT = 'geom_default';

/**
 * Returns all the geometry objects and their properties in an array based on the type of the geometry.
 */
var geometryRetriever = (_geometryRetriever = {}, _defineProperty(_geometryRetriever, _enums_geo_props__WEBPACK_IMPORTED_MODULE_1__["GeoProps"].Feature, function (obj) {
    return [obj];
}), _defineProperty(_geometryRetriever, _enums_geo_props__WEBPACK_IMPORTED_MODULE_1__["GeoProps"].FeatureCollection, function (obj) {
    return obj.features;
}), _defineProperty(_geometryRetriever, GEOM_DEFAULT, function (obj) {
    var type = obj.type,
        coordinates = obj.coordinates;


    return [{
        geometry: {
            type: type,
            coordinates: coordinates
        },
        properties: {}
    }];
}), _geometryRetriever);

/**
 * Retrieves all the feature objects from a featureCollection or any feature object in an array.
 *
 * @return {Array} Array of features
 */
var getFeatures = function getFeatures(obj) {
    var type = obj.type;

    var retriever = geometryRetriever[type] || geometryRetriever[GEOM_DEFAULT];

    return retriever(obj);
};

/**
 * Inserts the values of the fields in an array and returns the index of the last field.
 *
 * @param {Array} fieldNames Array of field names
 * @param {Object} fieldInf Information about fields
 * @param {Array} fieldInf.fields Fields array
 * @param {Object} fieldInf.props Properties of each geometry
 * @param {Array} fieldInf.header Field names
 * @param {number} index Index of the field
 *
 * @return {number} Index of the last field.
 */
var insertValues = function insertValues(fieldNames, fieldInf, index) {
    var insertionIndex = void 0;
    var fields = fieldInf.fields,
        props = fieldInf.props,
        header = fieldInf.header;


    fieldNames.forEach(function (unitSchema) {
        if (unitSchema in header) {
            insertionIndex = header[unitSchema];
        } else {
            header[unitSchema] = index++;
            insertionIndex = index - 1;
        }
        fields[insertionIndex] = props[unitSchema];
    });

    return index;
};
/**
 * Parses and converts data formatted in GeoJSON to a manageable internal format.
 *
 * @param {Array.<Object>} arr - The input data formatted in GeoJSON.
 * @return {Array.<Object>} Returns an array of headers and column major data.
 * @example
 *
 * // Sample input data:
 *  {
 *    "type": "FeatureCollection",
 *    "features": [
 *      {
 *        "type": "Feature",
 *        "geometry": {
 *          "type": "Point",
 *          "coordinates": [-2.960847, 53.430828]
 *         },
 *         "properties": {
 *           "name": "Anfield",
 *           "amenity": "Football Stadium"
 *         }
 *       }
 *     ]
 *  }
 *
 *  // Output data
 *  [
 *      ['country', 'population', 'geometry'],
 *      [ ['India'], [1200000000], [{ type: 'Point', coordinates: [-2.960847, 53.430828] }] ]
 *  ]
 */
var GeoJSON = function GeoJSON(obj) {
    var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var i = 0;
    var geoField = void 0;

    var header = {};
    var columns = [];
    var push = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["columnMajor"])(columns);
    var schemaFieldsName = [];
    var features = getFeatures(obj);

    for (var idx = 0, len = schema.length; idx < len; idx++) {
        var _schema$idx = schema[idx],
            name = _schema$idx.name,
            subtype = _schema$idx.subtype;

        schemaFieldsName.push(name);
        if (name === _constants__WEBPACK_IMPORTED_MODULE_2__["GEOM_FIELD"] && subtype === _enums__WEBPACK_IMPORTED_MODULE_3__["DimensionSubtype"].GEO) {
            geoField = name;
        }
    }

    !geoField && schemaFieldsName.push(_constants__WEBPACK_IMPORTED_MODULE_2__["GEOM_FIELD"]);
    features.forEach(function (feature) {
        var fields = [];
        var geometry = feature.geometry,
            properties = feature.properties;

        var allProps = Object.assign({}, properties, { geometry: geometry });

        i = insertValues(schemaFieldsName, { fields: fields, props: allProps, header: header }, i);
        push.apply(undefined, fields);
    });

    return [Object.keys(header), columns];
};

/* harmony default export */ __webpack_exports__["default"] = (GeoJSON);

/***/ }),

/***/ "./src/converter/index.js":
/*!********************************!*\
  !*** ./src/converter/index.js ***!
  \********************************/
/*! exports provided: DSVArr, DSVStr, FlatJSON, Auto */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dsv_arr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv-arr */ "./src/converter/dsv-arr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DSVArr", function() { return _dsv_arr__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _dsv_str__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv-str */ "./src/converter/dsv-str.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DSVStr", function() { return _dsv_str__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _flat_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat-json */ "./src/converter/flat-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlatJSON", function() { return _flat_json__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _auto_resolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auto-resolver */ "./src/converter/auto-resolver.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Auto", function() { return _auto_resolver__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),

/***/ "./src/datamodel.js":
/*!**************************!*\
  !*** ./src/datamodel.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./src/helper.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./src/constants/index.js");
/* harmony import */ var _operator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operator */ "./src/operator/index.js");
/* harmony import */ var _operator_bucket_creator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./operator/bucket-creator */ "./src/operator/bucket-creator.js");
/* harmony import */ var _relation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./relation */ "./src/relation.js");
/* harmony import */ var _utils_reducer_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/reducer-store */ "./src/utils/reducer-store.js");
/* harmony import */ var _field_creator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./field-creator */ "./src/field-creator.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./invalid-aware-types */ "./src/invalid-aware-types.js");
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./value */ "./src/value.js");
/* harmony import */ var _enums_geo_bin_shapes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./enums/geo-bin-shapes */ "./src/enums/geo-bin-shapes.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable default-case */













/**
 * DataModel is an in-browser representation of tabular data. It supports
 * {@link https://en.wikipedia.org/wiki/Relational_algebra | relational algebra} operators as well as generic data
 * processing opearators.
 * DataModel extends {@link Relation} class which defines all the relational algebra opreators. DataModel gives
 * definition of generic data processing operators which are not relational algebra complient.
 *
 * @public
 * @class
 * @extends Relation
 * @memberof Datamodel
 */

var DataModel = function (_Relation) {
    _inherits(DataModel, _Relation);

    /**
     * Creates a new DataModel instance by providing data and schema. Data could be in the form of
     * - Flat JSON
     * - DSV String
     * - 2D Array
     *
     * By default DataModel finds suitable adapter to serialize the data. DataModel also expects a
     * {@link Schema | schema} for identifying the variables present in data.
     *
     * @constructor
     * @example
     * const data = loadData('cars.csv');
     * const schema = [
     *      { name: 'Name', type: 'dimension' },
     *      { name: 'Miles_per_Gallon', type: 'measure', unit : 'cm', scale: '1000', numberformat: val => `${val}G`},
     *      { name: 'Cylinders', type: 'dimension' },
     *      { name: 'Displacement', type: 'measure' },
     *      { name: 'Horsepower', type: 'measure' },
     *      { name: 'Weight_in_lbs', type: 'measure' },
     *      { name: 'Acceleration', type: 'measure' },
     *      { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },
     *      { name: 'Origin', type: 'dimension' }
     * ];
     * const dm = new DataModel(data, schema, { name: 'Cars' });
     * table(dm);
     *
     * @public
     *
     * @param {Array.<Object> | string | Array.<Array>} data Input data in any of the mentioned formats
     * @param {Array.<Schema>} schema Defination of the variables. Order of the variables in data and order of the
     *      variables in schema has to be same.
     * @param {object} [options] Optional arguments to specify more settings regarding the creation part
     * @param {string} [options.name] Name of the datamodel instance. If no name is given an auto generated name is
     *      assigned to the instance.
     * @param {string} [options.fieldSeparator=','] specify field separator type if the data is of type dsv string.
     */
    function DataModel() {
        var _ref;

        _classCallCheck(this, DataModel);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, (_ref = DataModel.__proto__ || Object.getPrototypeOf(DataModel)).call.apply(_ref, [this].concat(args)));

        _this._onPropagation = [];
        return _this;
    }

    /**
     * Reducers are simple functions which reduces an array of numbers to a representative number of the set.
     * Like an array of numbers `[10, 20, 5, 15]` can be reduced to `12.5` if average / mean reducer function is
     * applied. All the measure fields in datamodel (variables in data) needs a reducer to handle aggregation.
     *
     * @public
     *
     * @return {ReducerStore} Singleton instance of {@link ReducerStore}.
     */


    _createClass(DataModel, [{
        key: 'getData',


        /**
         * Retrieve the data attached to an instance in JSON format.
         *
         * @example
         * // DataModel instance is already prepared and assigned to dm variable
         *  const data = dm.getData({
         *      order: 'column',
         *      formatter: {
         *          origin: (val) => val === 'European Union' ? 'EU' : val;
         *      }
         *  });
         *  console.log(data);
         *
         * @public
         *
         * @param {Object} [options] Options to control how the raw data is to be returned.
         * @param {string} [options.order='row'] Defines if data is retieved in row order or column order. Possible values
         *      are `'rows'` and `'columns'`
         * @param {Function} [options.formatter=null] Formats the output data. This expects an object, where the keys are
         *      the name of the variable needs to be formatted. The formatter function is called for each row passing the
         *      value of the cell for a particular row as arguments. The formatter is a function in the form of
         *      `function (value, rowId, schema) => { ... }`
         *      Know more about {@link Fomatter}.
         *
         * @return {Array} Returns a multidimensional array of the data with schema. The return format looks like
         *      ```
         *          {
         *              data,
         *              schema
         *          }
         *      ```
         */
        value: function getData(options) {
            var defOptions = {
                order: 'row',
                formatter: null,
                withUid: false,
                getAllFields: false,
                sort: []
            };
            options = Object.assign({}, defOptions, options);
            var fields = this.getPartialFieldspace().fields;

            var dataGenerated = _operator__WEBPACK_IMPORTED_MODULE_3__["dataBuilder"].call(this, this.getPartialFieldspace().fields, this._rowDiffset, options.getAllFields ? fields.map(function (d) {
                return d.name();
            }).join() : this._colIdentifier, options.sort, {
                columnWise: options.order === 'column',
                addUid: !!options.withUid
            });

            if (!options.formatter) {
                return dataGenerated;
            }

            var _options = options,
                formatter = _options.formatter;
            var data = dataGenerated.data,
                schema = dataGenerated.schema,
                uids = dataGenerated.uids;

            var fieldNames = schema.map(function (e) {
                return e.name;
            });
            var fmtFieldNames = Object.keys(formatter);
            var fmtFieldIdx = fmtFieldNames.reduce(function (acc, next) {
                var idx = fieldNames.indexOf(next);
                if (idx !== -1) {
                    acc.push([idx, formatter[next]]);
                }
                return acc;
            }, []);

            if (options.order === 'column') {
                fmtFieldIdx.forEach(function (elem) {
                    var fIdx = elem[0];
                    var fmtFn = elem[1];

                    data[fIdx].forEach(function (datum, datumIdx) {
                        data[fIdx][datumIdx] = fmtFn.call(undefined, datum, uids[datumIdx], schema[fIdx]);
                    });
                });
            } else {
                data.forEach(function (datum, datumIdx) {
                    fmtFieldIdx.forEach(function (elem) {
                        var fIdx = elem[0];
                        var fmtFn = elem[1];

                        datum[fIdx] = fmtFn.call(undefined, datum[fIdx], uids[datumIdx], schema[fIdx]);
                    });
                });
            }

            return dataGenerated;
        }

        /**
         * Returns the unique ids in an array.
         *
         * @return {Array} Returns an array of ids.
         */

    }, {
        key: 'getUids',
        value: function getUids() {
            var rowDiffset = this._rowDiffset;
            var ids = [];

            if (rowDiffset.length) {
                var diffSets = rowDiffset.split(',');

                diffSets.forEach(function (set) {
                    var _set$split$map = set.split('-').map(Number),
                        _set$split$map2 = _slicedToArray(_set$split$map, 2),
                        start = _set$split$map2[0],
                        end = _set$split$map2[1];

                    end = end !== undefined ? end : start;
                    ids.push.apply(ids, _toConsumableArray(Array(end - start + 1).fill().map(function (_, idx) {
                        return start + idx;
                    })));
                });
            }

            return ids;
        }
        /**
         * Groups the data using particular dimensions and by reducing measures. It expects a list of dimensions using which
         * it projects the datamodel and perform aggregations to reduce the duplicate tuples. Refer this
         * {@link link_to_one_example_with_group_by | document} to know the intuition behind groupBy.
         *
         * DataModel by default provides definition of few {@link reducer | Reducers}.
         * {@link ReducerStore | User defined reducers} can also be registered.
         *
         * This is the chained implementation of `groupBy`.
         * `groupBy` also supports {@link link_to_compose_groupBy | composability}
         *
         * @example
         * const groupedDM = dm.groupBy(['Year'], { horsepower: 'max' } );
         * console.log(groupedDm);
         *
         * @public
         *
         * @param {Array.<string>} fieldsArr - Array containing the name of dimensions
         * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its
         *      not passed, or any variable is ommitted from the object, default aggregation function is used from the
         *      schema of the variable.
         *
         * @return {DataModel} Returns a new DataModel instance after performing the groupby.
         */

    }, {
        key: 'groupBy',
        value: function groupBy(fieldsArr) {
            var reducers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { saveChild: true };

            var groupByString = '' + fieldsArr.join();
            var params = [this, fieldsArr, reducers];
            var newDataModel = _operator__WEBPACK_IMPORTED_MODULE_3__["groupBy"].apply(undefined, params);

            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["persistDerivations"])(this, newDataModel, _constants__WEBPACK_IMPORTED_MODULE_2__["DM_DERIVATIVES"].GROUPBY, { fieldsArr: fieldsArr, groupByString: groupByString, defaultReducer: _utils_reducer_store__WEBPACK_IMPORTED_MODULE_6__["default"].defaultReducer() }, reducers);

            if (config.saveChild) {
                newDataModel.setParent(this);
            } else {
                newDataModel.setParent(null);
            }

            return newDataModel;
        }

        /**
         * Performs sorting operation on the current {@link DataModel} instance according to the specified sorting details.
         * Like every other operator it doesn't mutate the current DataModel instance on which it was called, instead
         * returns a new DataModel instance containing the sorted data.
         *
         * DataModel support multi level sorting by listing the variables using which sorting needs to be performed and
         * the type of sorting `ASC` or `DESC`.
         *
         * In the following example, data is sorted by `Origin` field in `DESC` order in first level followed by another
         * level of sorting by `Acceleration` in `ASC` order.
         *
         * @example
         * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file
         * let sortedDm = dm.sort([
         *    ["Origin", "DESC"]
         *    ["Acceleration"] // Default value is ASC
         * ]);
         *
         * console.log(dm.getData());
         * console.log(sortedDm.getData());
         *
         * // Sort with a custom sorting function
         * sortedDm = dm.sort([
         *    ["Origin", "DESC"]
         *    ["Acceleration", (a, b) => a - b] // Custom sorting function
         * ]);
         *
         * console.log(dm.getData());
         * console.log(sortedDm.getData());
         *
         * @text
         * DataModel also provides another sorting mechanism out of the box where sort is applied to a variable using
         * another variable which determines the order.
         * Like the above DataModel contains three fields `Origin`, `Name` and `Acceleration`. Now, the data in this
         * model can be sorted by `Origin` field according to the average value of all `Acceleration` for a
         * particular `Origin` value.
         *
         * @example
         * // here dm is the pre-declared DataModel instance containing the data of 'cars.json' file
         * const sortedDm = dm.sort([
         *     ['Origin', ['Acceleration', (a, b) => avg(...a.Acceleration) - avg(...b.Acceleration)]]
         * ]);
         *
         * console.log(dm.getData());
         * console.log(sortedDm.getData());
         *
         * @public
         *
         * @param {Array.<Array>} sortingDetails - Sorting details based on which the sorting will be performed.
         * @return {DataModel} Returns a new instance of DataModel with sorted data.
         */

    }, {
        key: 'sort',
        value: function sort(sortingDetails) {
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { saveChild: false };

            var rawData = this.getData({
                order: 'row',
                sort: sortingDetails
            });
            var header = rawData.schema.map(function (field) {
                return field.name;
            });
            var dataInCSVArr = [header].concat(rawData.data);

            var sortedDm = new this.constructor(dataInCSVArr, rawData.schema, { dataFormat: 'DSVArr' });

            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["persistDerivations"])(this, sortedDm, _constants__WEBPACK_IMPORTED_MODULE_2__["DM_DERIVATIVES"].SORT, config, sortingDetails);

            if (config.saveChild) {
                sortedDm.setParent(this);
            } else {
                sortedDm.setParent(null);
            }

            return sortedDm;
        }

        /**
         * Performs the serialization operation on the current {@link DataModel} instance according to the specified data
         * type. When an {@link DataModel} instance is created, it de-serializes the input data into its internal format,
         * and during its serialization process, it converts its internal data format to the specified data type and returns
         * that data regardless what type of data is used during the {@link DataModel} initialization.
         *
         * @example
         * // here dm is the pre-declared DataModel instance.
         * const csvData = dm.serialize(DataModel.DataFormat.DSV_STR, { fieldSeparator: "," });
         * console.log(csvData); // The csv formatted data.
         *
         * const jsonData = dm.serialize(DataModel.DataFormat.FLAT_JSON);
         * console.log(jsonData); // The json data.
         *
         * @public
         *
         * @param {string} type - The data type name for serialization.
         * @param {Object} options - The optional option object.
         * @param {string} options.fieldSeparator - The field separator character for DSV data type.
         * @return {Array|string} Returns the serialized data.
         */

    }, {
        key: 'serialize',
        value: function serialize(type, options) {
            type = type || this._dataFormat;
            options = Object.assign({}, { fieldSeparator: ',' }, options);

            var fields = this.getFieldspace().fields;
            var colData = fields.map(function (f) {
                return f.formattedData();
            });
            var rowsCount = colData[0].length;
            var serializedData = void 0;
            var rowIdx = void 0;
            var colIdx = void 0;

            if (type === _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].FLAT_JSON) {
                serializedData = [];
                for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
                    var row = {};
                    for (colIdx = 0; colIdx < fields.length; colIdx++) {
                        row[fields[colIdx].name()] = colData[colIdx][rowIdx];
                    }
                    serializedData.push(row);
                }
            } else if (type === _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].DSV_STR) {
                serializedData = [fields.map(function (f) {
                    return f.name();
                }).join(options.fieldSeparator)];
                for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
                    var _row = [];
                    for (colIdx = 0; colIdx < fields.length; colIdx++) {
                        _row.push(colData[colIdx][rowIdx]);
                    }
                    serializedData.push(_row.join(options.fieldSeparator));
                }
                serializedData = serializedData.join('\n');
            } else if (type === _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].DSV_ARR) {
                serializedData = [fields.map(function (f) {
                    return f.name();
                })];
                for (rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
                    var _row2 = [];
                    for (colIdx = 0; colIdx < fields.length; colIdx++) {
                        _row2.push(colData[colIdx][rowIdx]);
                    }
                    serializedData.push(_row2);
                }
            } else {
                throw new Error('Data type ' + type + ' is not supported');
            }

            return serializedData;
        }
    }, {
        key: 'addField',
        value: function addField(field) {
            var fieldName = field.name();
            this._colIdentifier += ',' + fieldName;
            var partialFieldspace = this._partialFieldspace;
            var cachedValueObjects = partialFieldspace._cachedValueObjects;
            var formattedData = field.formattedData();
            var rawData = field.partialField.data;

            if (!partialFieldspace.fieldsObj()[field.name()]) {
                partialFieldspace.fields.push(field);
                cachedValueObjects.forEach(function (obj, i) {
                    obj[field.name()] = new _value__WEBPACK_IMPORTED_MODULE_9__["default"](formattedData[i], rawData[i], field);
                });
            } else {
                var fieldIndex = partialFieldspace.fields.findIndex(function (fieldinst) {
                    return fieldinst.name() === fieldName;
                });
                fieldIndex >= 0 && (partialFieldspace.fields[fieldIndex] = field);
            }

            // flush out cached namespace values on addition of new fields
            partialFieldspace._cachedFieldsObj = null;
            partialFieldspace._cachedDimension = null;
            partialFieldspace._cachedMeasure = null;

            this.__calculateFieldspace().calculateFieldsConfig();
            return this;
        }

        /**
        * Creates a new variable calculated from existing variables. This method expects the definition of the newly created
        * variable and a function which resolves the value of the new variable from existing variables.
        *
        * Can create a new measure based on existing variables:
        * @example
        *  // DataModel already prepared and assigned to dm variable;
        *  const newDm = dataModel.calculateVariable({
        *      name: 'powerToWeight',
        *      type: 'measure'
        *  }, ['horsepower', 'weight_in_lbs', (hp, weight) => hp / weight ]);
        *
        *
        * Can create a new dimension based on existing variables:
        * @example
        *  // DataModel already prepared and assigned to dm variable;
        *  const child = dataModel.calculateVariable(
        *     {
        *       name: 'Efficiency',
        *       type: 'dimension'
        *     }, ['horsepower', (hp) => {
        *      if (hp < 80) { return 'low'; },
        *      else if (hp < 120) { return 'moderate'; }
        *      else { return 'high' }
        *  }]);
        *
        * @public
        *
        * @param {Object} schema - The schema of newly defined variable.
        * @param {Array.<string|function>} dependency - An array containing the dependency variable names and a resolver
        * function as the last element.
        * @param {Object} config - An optional config object.
        * @param {boolean} [config.saveChild] - Whether the newly created DataModel will be a child.
        * @param {boolean} [config.replaceVar] - Whether the newly created variable will replace the existing variable.
        * @return {DataModel} Returns an instance of DataModel with the new field.
        */

    }, {
        key: 'calculateVariable',
        value: function calculateVariable(schema, dependency, config) {
            var _this2 = this;

            schema = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["sanitizeUnitSchema"])(schema);
            config = Object.assign({}, { saveChild: true, replaceVar: false }, config);

            var fieldsConfig = this.getFieldsConfig();
            var depVars = dependency.slice(0, dependency.length - 1);
            var retrieveFn = dependency[dependency.length - 1];

            if (fieldsConfig[schema.name] && !config.replaceVar) {
                throw new Error(schema.name + ' field already exists in datamodel');
            }

            var depFieldIndices = depVars.map(function (field) {
                var fieldSpec = fieldsConfig[field];
                if (!fieldSpec) {
                    // @todo dont throw error here, use warning in production mode
                    throw new Error(field + ' is not a valid column name.');
                }
                return fieldSpec.index;
            });

            var clone = this.clone(config.saveChild);

            var fs = clone.getFieldspace().fields;
            var suppliedFields = depFieldIndices.map(function (idx) {
                return fs[idx];
            });

            var cachedStore = {};
            var cloneProvider = function cloneProvider() {
                return _this2.detachedRoot();
            };

            var computedValues = [];
            Object(_operator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(clone._rowDiffset, function (i) {
                var fieldsData = suppliedFields.map(function (field) {
                    return field.partialField.data[i];
                });
                computedValues[i] = retrieveFn.apply(undefined, _toConsumableArray(fieldsData).concat([i, cloneProvider, cachedStore]));
            });

            var _createFields = Object(_field_creator__WEBPACK_IMPORTED_MODULE_7__["createFields"])([computedValues], [schema], [schema.name]),
                _createFields2 = _slicedToArray(_createFields, 1),
                field = _createFields2[0];

            clone.addField(field);

            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["persistDerivations"])(this, clone, _constants__WEBPACK_IMPORTED_MODULE_2__["DM_DERIVATIVES"].CAL_VAR, { config: schema, fields: depVars }, retrieveFn);

            return clone;
        }

        /**
         * Propagates changes across all the connected DataModel instances.
         *
         * @param {Array} identifiers - A list of identifiers that were interacted with.
         * @param {Object} payload - The interaction specific details.
         *
         * @return {DataModel} DataModel instance.
         */

    }, {
        key: 'propagate',
        value: function propagate(identifiers) {
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var addToNameSpace = arguments[2];
            var propConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

            var isMutableAction = config.isMutableAction;
            var propagationSourceId = config.sourceId;
            var payload = config.payload;
            var rootModel = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getRootDataModel"])(this);
            var propagationNameSpace = rootModel._propagationNameSpace;
            var rootGroupByModel = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getRootGroupByModel"])(this);
            var rootModels = {
                groupByModel: rootGroupByModel,
                model: rootModel
            };

            addToNameSpace && Object(_helper__WEBPACK_IMPORTED_MODULE_1__["addToPropNamespace"])(propagationNameSpace, config, this);
            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["propagateToAllDataModels"])(identifiers, rootModels, { propagationNameSpace: propagationNameSpace, sourceId: propagationSourceId }, Object.assign({
                payload: payload
            }, config));

            if (isMutableAction) {
                Object(_helper__WEBPACK_IMPORTED_MODULE_1__["propagateImmutableActions"])(propagationNameSpace, rootModels, {
                    config: config,
                    propConfig: propConfig
                }, this);
            }

            return this;
        }

        /**
         * Associates a callback with an event name.
         *
         * @param {string} eventName - The name of the event.
         * @param {Function} callback - The callback to invoke.
         * @return {DataModel} Returns this current DataModel instance itself.
         */

    }, {
        key: 'on',
        value: function on(eventName, callback) {
            switch (eventName) {
                case _constants__WEBPACK_IMPORTED_MODULE_2__["PROPAGATION"]:
                    this._onPropagation.push(callback);
                    break;
            }
            return this;
        }

        /**
         * Unsubscribes the callbacks for the provided event name.
         *
         * @param {string} eventName - The name of the event to unsubscribe.
         * @return {DataModel} Returns the current DataModel instance itself.
         */

    }, {
        key: 'unsubscribe',
        value: function unsubscribe(eventName) {
            switch (eventName) {
                case _constants__WEBPACK_IMPORTED_MODULE_2__["PROPAGATION"]:
                    this._onPropagation = [];
                    break;

            }
            return this;
        }

        /**
         * This method is used to invoke the method associated with propagation.
         *
         * @param {Object} payload The interaction payload.
         * @param {DataModel} identifiers The propagated DataModel.
         * @memberof DataModel
         */

    }, {
        key: 'handlePropagation',
        value: function handlePropagation(propModel, payload) {
            var _this3 = this;

            var propListeners = this._onPropagation;
            propListeners.forEach(function (fn) {
                return fn.call(_this3, propModel, payload);
            });
        }

        /**
         * Performs the binning operation on a measure field based on the binning configuration. Binning means discretizing
         * values of a measure. Binning configuration contains an array; subsequent values from the array marks the boundary
         * of buckets in [inclusive, exclusive) range format. This operation does not mutate the subject measure field,
         * instead, it creates a new field (variable) of type dimension and subtype binned.
         *
         * Binning can be configured by
         * - providing custom bin configuration with non-uniform buckets,
         * - providing bins count,
         * - providing each bin size,
         *
         * When custom `buckets` are provided as part of binning configuration:
         * @example
         *  // DataModel already prepared and assigned to dm variable
         *  const config = { name: 'binnedHP', buckets: [30, 80, 100, 110] }
         *  const binnedDM = dataModel.bin('horsepower', config);
         *
         * @text
         * When `binsCount` is defined as part of binning configuration:
         * @example
         *  // DataModel already prepared and assigned to dm variable
         *  const config = { name: 'binnedHP', binsCount: 5, start: 0, end: 100 }
         *  const binDM = dataModel.bin('horsepower', config);
         *
         * @text
         * When `binSize` is defined as part of binning configuration:
         * @example
         *  // DataModel already prepared and assigned to dm variable
         *  const config = { name: 'binnedHorsepower', binSize: 20, start: 5}
         *  const binDM = dataModel.bin('horsepower', config);
         *
         * @public
         *
         * @param {string} fieldName - The name of the target measure field.
         * @param {Object} config - The config object.
         * @param {string} [config.name] - The name of the new field which will be created.
         * @param {string} [config.buckets] - An array containing the bucket ranges.
         * @param {string} [config.binSize] - The size of each bin. It is ignored when buckets are given.
         * @param {string} [config.binsCount] - The total number of bins to generate. It is ignored when buckets are given.
         * @param {string} [config.start] - The start value of the bucket ranges. It is ignored when buckets are given.
         * @param {string} [config.end] - The end value of the bucket ranges. It is ignored when buckets are given.
         * @return {DataModel} Returns a new {@link DataModel} instance with the new field.
         */

    }, {
        key: 'bin',
        value: function bin(fieldName) {
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var binField = void 0;
            var defConfig = {
                shapeType: _enums_geo_bin_shapes__WEBPACK_IMPORTED_MODULE_10__["GEO_BIN_SHAPES"].HEX
            };
            config = Object.assign(defConfig, config);
            var fieldsConfig = this.getFieldsConfig();

            if (!fieldsConfig[fieldName]) {
                throw new Error('Field ' + fieldName + ' doesn\'t exist');
            }

            var binFieldName = config.name || fieldName + '_binned';

            if (fieldsConfig[binFieldName]) {
                throw new Error('Field ' + binFieldName + ' already exists');
            }

            var field = this.getFieldspace().fieldsObj()[fieldName];

            var subtype = field.subtype();

            if (subtype === _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].GEO) {
                var binnedData = Object(_operator_bucket_creator__WEBPACK_IMPORTED_MODULE_4__["createBinnedGeoData"])(field, this._rowDiffset, config);
                binField = Object(_field_creator__WEBPACK_IMPORTED_MODULE_7__["createFields"])([binnedData], [{
                    name: binFieldName,
                    type: _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION,
                    subtype: _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED_GEO,
                    shapeType: config.shapeType,
                    binSize: config.binSize
                }], [binFieldName])[0];
            } else {
                var _createBinnedFieldDat = Object(_operator_bucket_creator__WEBPACK_IMPORTED_MODULE_4__["createBinnedFieldData"])(field, this._rowDiffset, config),
                    _binnedData = _createBinnedFieldDat.binnedData,
                    bins = _createBinnedFieldDat.bins;

                binField = Object(_field_creator__WEBPACK_IMPORTED_MODULE_7__["createFields"])([_binnedData], [{
                    name: binFieldName,
                    type: _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION,
                    subtype: _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED,
                    bins: bins
                }], [binFieldName])[0];
            }

            var clone = this.clone(config.saveChild);
            clone.addField(binField);

            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["persistDerivations"])(this, clone, _constants__WEBPACK_IMPORTED_MODULE_2__["DM_DERIVATIVES"].BIN, { fieldName: fieldName, config: config, binFieldName: binFieldName }, null);

            return clone;
        }

        /**
         * Creates a new {@link DataModel} instance with completely detached root from current {@link DataModel} instance,
         * the new {@link DataModel} instance has no parent-children relationship with the current one, but has same data as
         * the current one.
         * This API is useful when a completely different {@link DataModel} but with same data as the current instance is
         * needed.
         *
         * @example
         *  const dm = new DataModel(data, schema);
         *  const detachedDm = dm.detachedRoot();
         *
         * // has different namespace
         * console.log(dm.getPartialFieldspace().name);
         * console.log(detachedDm.getPartialFieldspace().name);
         *
         * // has same data
         * console.log(dm.getData());
         * console.log(detachedDm.getData());
         *
         * @public
         *
         * @return {DataModel} Returns a detached {@link DataModel} instance.
         */

    }, {
        key: 'detachedRoot',
        value: function detachedRoot() {
            var data = this.serialize(_enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].FLAT_JSON);
            var schema = this.getSchema();

            return new DataModel(data, schema);
        }

        /**
         * Creates a set of new {@link DataModel} instances by splitting the set of rows in the source {@link DataModel}
         * instance based on a set of dimensions.
         *
         * For each unique dimensional value, a new split is created which creates a unique {@link DataModel} instance for
         *  that split
         *
         * If multiple dimensions are provided, it splits the source {@link DataModel} instance with all possible
         * combinations of the dimensional values for all the dimensions provided
         *
         * Additionally, it also accepts a predicate function to reduce the set of rows provided. A
         * {@link link_to_selection | Selection} is performed on all the split {@link DataModel} instances based on
         * the predicate function
         *
         * @example
         *  // without predicate function:
         *  const splitDt = dt.splitByRow(['Origin'])
         *  console.log(splitDt));
         * // This should give three unique DataModel instances, one each having rows only for 'USA',
         * // 'Europe' and 'Japan' respectively
         *
         * @example
         *  // without predicate function:
         *  const splitDtMulti = dt.splitByRow(['Origin', 'Cylinders'])
         *  console.log(splitDtMulti));
         * // This should give DataModel instances for all unique combinations of Origin and Cylinder values
         *
         * @example
         * // with predicate function:
         * const splitWithPredDt = dt.select(['Origin'], fields => fields.Origin.value === "USA")
         * console.log(splitWithPredDt);
         * // This should not include the DataModel for the Origin : 'USA'
         *
         *
         * @public
         *
         * @param {Array} dimensionArr - Set of dimensions based on which the split should occur
         * @param {Object} config - The configuration object
         * @param {string} [config.saveChild] - Configuration to save child or not
         * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.
         * @return {Array}  Returns the new DataModel instances after operation.
         */

    }, {
        key: 'splitByRow',
        value: function splitByRow(dimensionArr, reducerFn, config) {
            var fieldsConfig = this.getFieldsConfig();

            dimensionArr.forEach(function (fieldName) {
                if (!fieldsConfig[fieldName]) {
                    throw new Error('Field ' + fieldName + ' doesn\'t exist in the schema');
                }
            });

            var defConfig = {
                mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL,
                saveChild: true
            };

            config = Object.assign({}, defConfig, config);

            return Object(_helper__WEBPACK_IMPORTED_MODULE_1__["splitWithSelect"])(this, dimensionArr, reducerFn, config);
        }

        /**
         * Creates a set of new {@link DataModel} instances by splitting the set of fields in the source {@link DataModel}
         * instance based on a set of common and unique field names provided.
         *
         * Each DataModel created contains a set of fields which are common to all and a set of unique fields.
         * It also accepts configurations such as saveChild and mode(inverse or normal) to include/exclude the respective
         * fields
         *
         * @example
         *  // without predicate function:
         *  const splitDt = dt.splitByColumn( [['Acceleration'], ['Horsepower']], ['Origin'])
         *  console.log(splitDt));
         * // This should give two unique DataModel instances, both having the field 'Origin' and
         * // one each having 'Acceleration' and 'Horsepower' fields respectively
         *
         * @example
         *  // without predicate function:
         *  const splitDtInv = dt.splitByColumn( [['Acceleration'], ['Horsepower'],['Origin', 'Cylinders'],
         *                           {mode: 'inverse'})
         *  console.log(splitDtInv));
         * // This should give DataModel instances in the following way:
         * // All DataModel Instances do not have the fields 'Origin' and 'Cylinders'
         * // One DataModel Instance has rest of the fields except 'Acceleration' and the other DataModel instance
         * // has rest of the fields except 'Horsepower'
         *
         *
         *
         * @public
         *
         * @param {Array} uniqueFields - Set of unique fields included in each datamModel instance
         * @param {Array} commonFields - Set of common fields included in all datamModel instances
         * @param {Object} config - The configuration object
         * @param {string} [config.saveChild] - Configuration to save child or not
         * @param {string}[config.mode=FilteringMode.NORMAL] -The mode of the selection.
         * @return {Array}  Returns the new DataModel instances after operation.
         */

    }, {
        key: 'splitByColumn',
        value: function splitByColumn() {
            var uniqueFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var commonFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var config = arguments[2];

            var defConfig = {
                mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL,
                saveChild: true
            };
            var fieldConfig = this.getFieldsConfig();
            var allFields = Object.keys(fieldConfig);
            var normalizedProjFieldSets = [[commonFields]];

            config = Object.assign({}, defConfig, config);
            uniqueFields = uniqueFields.length ? uniqueFields : [[]];

            uniqueFields.forEach(function (fieldSet, i) {
                normalizedProjFieldSets[i] = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getNormalizedProFields"])([].concat(_toConsumableArray(fieldSet), _toConsumableArray(commonFields)), allFields, fieldConfig);
            });

            return Object(_helper__WEBPACK_IMPORTED_MODULE_1__["splitWithProject"])(this, normalizedProjFieldSets, config, allFields);
        }
    }], [{
        key: 'configureInvalidAwareTypes',


        /**
         * Configure null, undefined, invalid values in the source data
         *
         * @public
         *
         * @param {Object} [config] - Configuration to control how null, undefined and non-parsable values are
         * represented in DataModel.
         * @param {string} [config.undefined] - Define how an undefined value will be represented.
         * @param {string} [config.null] - Define how a null value will be represented.
         * @param {string} [config.invalid] - Define how a non-parsable value will be represented.
         */
        value: function configureInvalidAwareTypes(config) {
            return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_8__["default"].invalidAwareVals(config);
        }
    }, {
        key: 'Reducers',
        get: function get() {
            return _utils_reducer_store__WEBPACK_IMPORTED_MODULE_6__["default"];
        }
    }]);

    return DataModel;
}(_relation__WEBPACK_IMPORTED_MODULE_5__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DataModel);

/***/ }),

/***/ "./src/default-config.js":
/*!*******************************!*\
  !*** ./src/default-config.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");


/* harmony default export */ __webpack_exports__["default"] = ({
    dataFormat: _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].AUTO
});

/***/ }),

/***/ "./src/enums/data-format.js":
/*!**********************************!*\
  !*** ./src/enums/data-format.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * DataFormat Enum defines the format of the input data.
 * Based on the format of the data the respective adapter is loaded.
 *
 * @readonly
 * @enum {string}
 */
var DataFormat = {
  FLAT_JSON: 'FlatJSON',
  DSV_STR: 'DSVStr',
  DSV_ARR: 'DSVArr',
  GEO_JSON: 'GeoJSON',
  AUTO: 'Auto'
};

/* harmony default export */ __webpack_exports__["default"] = (DataFormat);

/***/ }),

/***/ "./src/enums/dimension-subtype.js":
/*!****************************************!*\
  !*** ./src/enums/dimension-subtype.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * DimensionSubtype enum defines the sub types of the Dimensional Field.
 *
 * @readonly
 * @enum {string}
 */
var DimensionSubtype = {
  CATEGORICAL: 'categorical',
  TEMPORAL: 'temporal',
  GEO: 'geo',
  BINNED: 'binned',
  BINNED_GEO: 'binnedgeo'
};

/* harmony default export */ __webpack_exports__["default"] = (DimensionSubtype);

/***/ }),

/***/ "./src/enums/distance-factors.js":
/*!***************************************!*\
  !*** ./src/enums/distance-factors.js ***!
  \***************************************/
/*! exports provided: earthRadius, UNITS, factors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "earthRadius", function() { return earthRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNITS", function() { return UNITS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factors", function() { return factors; });
/* harmony import */ var _distance_units__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./distance-units */ "./src/enums/distance-units.js");
var _factors;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
var earthRadius = 6371008.8;

/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
var UNITS = {
  CENTIMETERS: 'centimeters',
  DEGREES: 'degrees',
  FEET: 'feet',
  INCHES: 'inches',
  KILOMETERS: 'kilometers',
  METERS: 'meters',
  METRES: 'metres',
  MILES: 'miles',
  MILLIMETERS: 'millimeters',
  NAUTICALMILES: 'nauticalmiles',
  RADIANS: 'radians',
  YARDS: 'yards'
};

/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
var factors = (_factors = {}, _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].CENTIMETERS, earthRadius * 100), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].DEGREES, earthRadius / 111325), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].FEET, earthRadius * 3.28084), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].INCHES, earthRadius * 39.370), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].KILOMETERS, earthRadius / 1000), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].METERS, earthRadius), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].METRES, earthRadius), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].MILES, earthRadius / 1609.344), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].MILLIMETERS, earthRadius * 1000), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].NAUTICALMILES, earthRadius / 1852), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].RADIANS, 1), _defineProperty(_factors, _distance_units__WEBPACK_IMPORTED_MODULE_0__["default"].YARDS, earthRadius / 1.0936), _factors);

/***/ }),

/***/ "./src/enums/distance-units.js":
/*!*************************************!*\
  !*** ./src/enums/distance-units.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var DistanceUnits = {
    CENTIMETERS: 'centimeters',
    DEGREES: 'degrees',
    FEET: 'feet',
    INCHES: 'inches',
    KILOMETERS: 'kilometers',
    METERS: 'meters',
    METRES: 'metres',
    MILES: 'miles',
    MILLIMETERS: 'millimeters',
    NAUTICALMILES: 'nauticalmiles',
    RADIANS: 'radians',
    YARDS: 'yards'
};

/* harmony default export */ __webpack_exports__["default"] = (DistanceUnits);

/***/ }),

/***/ "./src/enums/error-messages.js":
/*!*************************************!*\
  !*** ./src/enums/error-messages.js ***!
  \*************************************/
/*! exports provided: GEO_ERR_MESSAGES, POLYGON_ERR_MESSAGES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEO_ERR_MESSAGES", function() { return GEO_ERR_MESSAGES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_ERR_MESSAGES", function() { return POLYGON_ERR_MESSAGES; });
var GEO_ERR_MESSAGES = {
    isArray: 'Coordinates must be an array',
    hasMinimumPoints: 'Coordinates must have atleast two points',
    hasValidLatLong: 'Latitude and longitude must have valid values'
};

var POLYGON_ERR_MESSAGES = {
    hasMinimumCoordinates: 'Polygon coordinates should contain atleast one array',
    hasIdenticalPoints: 'The first point and last point of polygon coordinates should be identical',
    hasMinimumFourPoints: 'Polygon coordinates should minimum four points'
};

/***/ }),

/***/ "./src/enums/field-type.js":
/*!*********************************!*\
  !*** ./src/enums/field-type.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * FieldType enum defines the high level field based on which visuals are controlled.
 * Measure in a high level is numeric field and Dimension in a high level is string field.
 *
 * @readonly
 * @enum {string}
 */
var FieldType = {
  MEASURE: 'measure',
  DIMENSION: 'dimension'
};

/* harmony default export */ __webpack_exports__["default"] = (FieldType);

/***/ }),

/***/ "./src/enums/filtering-mode.js":
/*!*************************************!*\
  !*** ./src/enums/filtering-mode.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Filtering mode enum defines the filering modes of DataModel.
 *
 * @readonly
 * @enum {string}
 */
var FilteringMode = {
  NORMAL: 'normal',
  INVERSE: 'inverse',
  ALL: 'all'
};

/* harmony default export */ __webpack_exports__["default"] = (FilteringMode);

/***/ }),

/***/ "./src/enums/geo-bin-shapes.js":
/*!*************************************!*\
  !*** ./src/enums/geo-bin-shapes.js ***!
  \*************************************/
/*! exports provided: GEO_BIN_SHAPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEO_BIN_SHAPES", function() { return GEO_BIN_SHAPES; });
var GEO_BIN_SHAPES = {
    HEX: 'hex'
};

/***/ }),

/***/ "./src/enums/geo-props.js":
/*!********************************!*\
  !*** ./src/enums/geo-props.js ***!
  \********************************/
/*! exports provided: GeoProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoProps", function() { return GeoProps; });
/**
 * This object contains the additional properties in geojson.
 */
var GeoProps = {
  /**
   * A Feature object contains a geometry object which has the coordinates array of the geographical region.
   * https://tools.ietf.org/html/rfc7946#section-3.2
   */
  Feature: 'Feature',
  /**
   * A FeatureCollection object contains an array of feature objects.
   * https://tools.ietf.org/html/rfc7946#section-3.3
   */
  FeatureCollection: 'FeatureCollection'
};

/***/ }),

/***/ "./src/enums/geom-types.js":
/*!*********************************!*\
  !*** ./src/enums/geom-types.js ***!
  \*********************************/
/*! exports provided: GeomTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeomTypes", function() { return GeomTypes; });
/**
 * GeomTypes enum defines the geometry types available in geojson. Each geometry has a coordinates array which contains
 * the latitude and longitudinal positions of the geometry.
 */
var GeomTypes = {
    Polygon: 'Polygon',
    Point: 'Point',
    MultiPoint: 'MultiPoint',
    LineString: 'LineString',
    MultiLineString: 'MultiLineString',
    MultiPolygon: 'MultiPolygon'
};

/***/ }),

/***/ "./src/enums/group-by-functions.js":
/*!*****************************************!*\
  !*** ./src/enums/group-by-functions.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Group by function names
 *
 * @readonly
 * @enum {string}
 */
var GROUP_BY_FUNCTIONS = {
    SUM: 'sum',
    AVG: 'avg',
    MIN: 'min',
    MAX: 'max',
    FIRST: 'first',
    LAST: 'last',
    COUNT: 'count',
    STD: 'std'
};

/* harmony default export */ __webpack_exports__["default"] = (GROUP_BY_FUNCTIONS);

/***/ }),

/***/ "./src/enums/index.js":
/*!****************************!*\
  !*** ./src/enums/index.js ***!
  \****************************/
/*! exports provided: DataFormat, DimensionSubtype, MeasureSubtype, FieldType, FilteringMode, GROUP_BY_FUNCTIONS, GeomTypes, GeoProps, DistanceUnits, GEO_BIN_SHAPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _data_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-format */ "./src/enums/data-format.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataFormat", function() { return _data_format__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _dimension_subtype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dimension-subtype */ "./src/enums/dimension-subtype.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DimensionSubtype", function() { return _dimension_subtype__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _measure_subtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure-subtype */ "./src/enums/measure-subtype.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeasureSubtype", function() { return _measure_subtype__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _field_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./field-type */ "./src/enums/field-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FieldType", function() { return _field_type__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _filtering_mode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filtering-mode */ "./src/enums/filtering-mode.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FilteringMode", function() { return _filtering_mode__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _group_by_functions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./group-by-functions */ "./src/enums/group-by-functions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GROUP_BY_FUNCTIONS", function() { return _group_by_functions__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _geom_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geom-types */ "./src/enums/geom-types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeomTypes", function() { return _geom_types__WEBPACK_IMPORTED_MODULE_6__["GeomTypes"]; });

/* harmony import */ var _geo_props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geo-props */ "./src/enums/geo-props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeoProps", function() { return _geo_props__WEBPACK_IMPORTED_MODULE_7__["GeoProps"]; });

/* harmony import */ var _distance_units__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./distance-units */ "./src/enums/distance-units.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DistanceUnits", function() { return _distance_units__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _geo_bin_shapes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./geo-bin-shapes */ "./src/enums/geo-bin-shapes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GEO_BIN_SHAPES", function() { return _geo_bin_shapes__WEBPACK_IMPORTED_MODULE_9__["GEO_BIN_SHAPES"]; });

/**
 * FilteringMode determines if resultant DataModel should be created from selection set or rejection set.
 *
 * The following modes are available
 * - `NORMAL`: Only entries from selection set are included in the resulatant DataModel instance
 * - `INVERSE`: Only entries from rejection set are included in the resulatant DataModel instance
 * - ALL: Both the entries from selection and rejection set are returned in two different DataModel instance
 */












/***/ }),

/***/ "./src/enums/measure-subtype.js":
/*!**************************************!*\
  !*** ./src/enums/measure-subtype.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * MeasureSubtype enum defines the sub types of the Measure Field.
 *
 * @readonly
 * @enum {string}
 */
var MeasureSubtype = {
  CONTINUOUS: 'continuous'
};

/* harmony default export */ __webpack_exports__["default"] = (MeasureSubtype);

/***/ }),

/***/ "./src/export.js":
/*!***********************!*\
  !*** ./src/export.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _datamodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./datamodel */ "./src/datamodel.js");
/* harmony import */ var _operator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operator */ "./src/operator/index.js");
/* harmony import */ var _fields_geo_field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fields/geo-field */ "./src/fields/geo-field/index.js");
/* harmony import */ var _stats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stats */ "./src/stats/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./src/utils/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./src/constants/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./invalid-aware-types */ "./src/invalid-aware-types.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_8___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);










var Operators = {
    compose: _operator__WEBPACK_IMPORTED_MODULE_1__["compose"],
    bin: _operator__WEBPACK_IMPORTED_MODULE_1__["bin"],
    select: _operator__WEBPACK_IMPORTED_MODULE_1__["select"],
    project: _operator__WEBPACK_IMPORTED_MODULE_1__["project"],
    groupBy: _operator__WEBPACK_IMPORTED_MODULE_1__["groupby"],
    calculateVariable: _operator__WEBPACK_IMPORTED_MODULE_1__["calculateVariable"],
    sort: _operator__WEBPACK_IMPORTED_MODULE_1__["sort"],
    crossProduct: _operator__WEBPACK_IMPORTED_MODULE_1__["crossProduct"],
    difference: _operator__WEBPACK_IMPORTED_MODULE_1__["difference"],
    naturalJoin: _operator__WEBPACK_IMPORTED_MODULE_1__["naturalJoin"],
    leftOuterJoin: _operator__WEBPACK_IMPORTED_MODULE_1__["leftOuterJoin"],
    rightOuterJoin: _operator__WEBPACK_IMPORTED_MODULE_1__["rightOuterJoin"],
    fullOuterJoin: _operator__WEBPACK_IMPORTED_MODULE_1__["fullOuterJoin"],
    union: _operator__WEBPACK_IMPORTED_MODULE_1__["union"],
    hexbin: _operator__WEBPACK_IMPORTED_MODULE_1__["hexbin"]
};

var utils = {
    geo: {
        isSame: _utils__WEBPACK_IMPORTED_MODULE_5__["isSame"],
        geoUnion: _utils__WEBPACK_IMPORTED_MODULE_5__["geoUnion"],
        perimeter: _utils__WEBPACK_IMPORTED_MODULE_5__["perimeter"],
        nearestPoint: _utils__WEBPACK_IMPORTED_MODULE_5__["nearestPoint"],
        bounds: _utils__WEBPACK_IMPORTED_MODULE_5__["bounds"],
        centroid: _utils__WEBPACK_IMPORTED_MODULE_5__["centroid"],
        center: _utils__WEBPACK_IMPORTED_MODULE_5__["center"],
        area: _utils__WEBPACK_IMPORTED_MODULE_5__["area"],
        distance: _utils__WEBPACK_IMPORTED_MODULE_5__["distance"],
        isInBounds: _utils__WEBPACK_IMPORTED_MODULE_5__["isInBounds"],
        includes: _utils__WEBPACK_IMPORTED_MODULE_5__["includes"],
        within: _utils__WEBPACK_IMPORTED_MODULE_5__["within"]
    }
};

var version = _package_json__WEBPACK_IMPORTED_MODULE_8__.version;
Object.assign(_datamodel__WEBPACK_IMPORTED_MODULE_0__["default"], {
    Operators: Operators,
    Stats: _stats__WEBPACK_IMPORTED_MODULE_3__,
    DM_DERIVATIVES: _constants__WEBPACK_IMPORTED_MODULE_6__["DM_DERIVATIVES"],
    DateTimeFormatter: _utils__WEBPACK_IMPORTED_MODULE_5__["DateTimeFormatter"],
    DataFormat: _constants__WEBPACK_IMPORTED_MODULE_6__["DataFormat"],
    FilteringMode: _constants__WEBPACK_IMPORTED_MODULE_6__["FilteringMode"],
    ROW_ID: _constants__WEBPACK_IMPORTED_MODULE_6__["ROW_ID"],
    InvalidAwareTypes: _invalid_aware_types__WEBPACK_IMPORTED_MODULE_7__["default"],
    utils: utils,
    version: version,
    GeoField: _fields_geo_field__WEBPACK_IMPORTED_MODULE_2__["default"]
}, _enums__WEBPACK_IMPORTED_MODULE_4__);

/* harmony default export */ __webpack_exports__["default"] = (_datamodel__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./src/field-creator.js":
/*!******************************!*\
  !*** ./src/field-creator.js ***!
  \******************************/
/*! exports provided: createUnitFieldFromPartial, createFields */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createUnitFieldFromPartial", function() { return createUnitFieldFromPartial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFields", function() { return createFields; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fields */ "./src/fields/index.js");
/* harmony import */ var _fields_binned_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fields/binned-geo */ "./src/fields/binned-geo/index.js");




/**
 * Creates a field instance according to the provided data and schema.
 *
 * @param {Array} data - The field data array.
 * @param {Object} schema - The field schema object.
 * @return {Field} Returns the newly created field instance.
 */
var createUnitField = function createUnitField(data, schema) {
    data = data || [];
    var partialField = void 0;

    switch (schema.type) {
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE:
            switch (schema.subtype) {
                case _enums__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["ContinuousParser"]());
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Continuous"](partialField, '0-' + (data.length - 1));
                default:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["ContinuousParser"]());
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Continuous"](partialField, '0-' + (data.length - 1));
            }
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION:
            switch (schema.subtype) {
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["CategoricalParser"]());
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, '0-' + (data.length - 1));
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["TemporalParser"](schema));
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Temporal"](partialField, '0-' + (data.length - 1));
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["BinnedParser"]());
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Binned"](partialField, '0-' + (data.length - 1));
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].GEO:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["GeoParser"](schema));
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["GeoField"](partialField, '0-' + (data.length - 1));
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED_GEO:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["GeoParser"](schema));
                    return new _fields_binned_geo__WEBPACK_IMPORTED_MODULE_2__["default"](partialField, '0-' + (data.length - 1));
                default:
                    partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["CategoricalParser"]());
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, '0-' + (data.length - 1));
            }
        default:
            partialField = new _fields__WEBPACK_IMPORTED_MODULE_1__["PartialField"](schema.name, data, schema, new _fields__WEBPACK_IMPORTED_MODULE_1__["CategoricalParser"]());
            return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, '0-' + (data.length - 1));
    }
};

/**
 * Creates a field instance from partialField and rowDiffset.
 *
 * @param {PartialField} partialField - The corresponding partial field.
 * @param {string} rowDiffset - The data subset config.
 * @return {Field} Returns the newly created field instance.
 */
function createUnitFieldFromPartial(partialField, rowDiffset) {
    var schema = partialField.schema;


    switch (schema.type) {
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE:
            switch (schema.subtype) {
                case _enums__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Continuous"](partialField, rowDiffset);
                default:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Continuous"](partialField, rowDiffset);
            }
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION:
            switch (schema.subtype) {
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, rowDiffset);
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Temporal"](partialField, rowDiffset);
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Binned"](partialField, rowDiffset);
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].GEO:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["GeoField"](partialField, rowDiffset);
                case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED_GEO:
                    return new _fields_binned_geo__WEBPACK_IMPORTED_MODULE_2__["default"](partialField, rowDiffset);
                default:
                    return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, rowDiffset);
            }
        default:
            return new _fields__WEBPACK_IMPORTED_MODULE_1__["Categorical"](partialField, rowDiffset);
    }
}

/**
 * Creates the field instances with input data and schema.
 *
 * @param {Array} dataColumn - The data array for fields.
 * @param {Array} schema - The schema array for fields.
 * @param {Array} headers - The array of header names.
 * @return {Array.<Field>} Returns an array of newly created field instances.
 */
function createFields(dataColumn, schema, headers) {
    var headersObj = {};

    if (!(headers && headers.length)) {
        headers = schema.map(function (item) {
            return item.name;
        });
    }

    headers.forEach(function (header, i) {
        headersObj[header] = i;
    });

    return schema.map(function (item) {
        return createUnitField(dataColumn[headersObj[item.name]], item);
    });
}

/***/ }),

/***/ "./src/field-store.js":
/*!****************************!*\
  !*** ./src/field-store.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils/index.js");



var fieldStore = {
    data: {},

    createNamespace: function createNamespace(fieldArr, name) {
        var dataId = name || Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getUniqueId"])();

        this.data[dataId] = {
            name: dataId,
            fields: fieldArr,

            fieldsObj: function fieldsObj() {
                var fieldsObj = this._cachedFieldsObj;

                if (!fieldsObj) {
                    fieldsObj = this._cachedFieldsObj = {};
                    this.fields.forEach(function (field) {
                        fieldsObj[field.name()] = field;
                    });
                }
                return fieldsObj;
            },
            getMeasure: function getMeasure() {
                var measureFields = this._cachedMeasure;

                if (!measureFields) {
                    measureFields = this._cachedMeasure = {};
                    this.fields.forEach(function (field) {
                        if (field.schema().type === _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE) {
                            measureFields[field.name()] = field;
                        }
                    });
                }
                return measureFields;
            },
            getDimension: function getDimension() {
                var dimensionFields = this._cachedDimension;

                if (!this._cachedDimension) {
                    dimensionFields = this._cachedDimension = {};
                    this.fields.forEach(function (field) {
                        if (field.schema().type === _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION) {
                            dimensionFields[field.name()] = field;
                        }
                    });
                }
                return dimensionFields;
            }
        };
        return this.data[dataId];
    }
};

/* harmony default export */ __webpack_exports__["default"] = (fieldStore);

/***/ }),

/***/ "./src/fields/binned-geo/index.js":
/*!****************************************!*\
  !*** ./src/fields/binned-geo/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geo_field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geo-field */ "./src/fields/geo-field/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "./src/enums/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * Represents binned geo field subtype.
 *
 * @public
 * @class
 * @extends Dimension
 */

var BinnedGeoField = function (_GeoField) {
    _inherits(BinnedGeoField, _GeoField);

    /**
     * Initialize a new instance.
     *
     * @public
     * @param {PartialField} partialField - The partialField instance which holds the whole data.
     * @param {string} rowDiffset - The data subset definition.
     */
    function BinnedGeoField(partialField, rowDiffset) {
        _classCallCheck(this, BinnedGeoField);

        var _this = _possibleConstructorReturn(this, (BinnedGeoField.__proto__ || Object.getPrototypeOf(BinnedGeoField)).call(this, partialField, rowDiffset));

        _this._cachedBounds = null;
        return _this;
    }

    _createClass(BinnedGeoField, [{
        key: 'subtype',
        value: function subtype() {
            return _enums__WEBPACK_IMPORTED_MODULE_1__["DimensionSubtype"].BINNED_GEO;
        }
    }, {
        key: 'shapeType',
        value: function shapeType() {
            return this.partialField.schema.shapeType;
        }
    }, {
        key: 'binSize',
        value: function binSize() {
            return this.partialField.schema.binSize;
        }
    }]);

    return BinnedGeoField;
}(_geo_field__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BinnedGeoField);

/***/ }),

/***/ "./src/fields/binned/index.js":
/*!************************************!*\
  !*** ./src/fields/binned/index.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dimension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dimension */ "./src/fields/dimension/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



/**
 * Represents binned field subtype.
 *
 * @public
 * @class
 * @extends Dimension
 */

var Binned = function (_Dimension) {
  _inherits(Binned, _Dimension);

  function Binned() {
    _classCallCheck(this, Binned);

    return _possibleConstructorReturn(this, (Binned.__proto__ || Object.getPrototypeOf(Binned)).apply(this, arguments));
  }

  _createClass(Binned, [{
    key: 'calculateDataDomain',

    /**
     * Calculates the corresponding field domain.
     *
     * @public
     * @override
     * @return {Array} Returns the last and first values of bins config array.
     */
    value: function calculateDataDomain() {
      var binsArr = this.partialField.schema.bins;
      return [binsArr[0], binsArr[binsArr.length - 1]];
    }

    /**
     * Returns the bins config provided while creating the field instance.
     *
     * @public
     * @return {Array} Returns the bins array config.
     */

  }, {
    key: 'bins',
    value: function bins() {
      return this.partialField.schema.bins;
    }
  }]);

  return Binned;
}(_dimension__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Binned);

/***/ }),

/***/ "./src/fields/categorical/index.js":
/*!*****************************************!*\
  !*** ./src/fields/categorical/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../operator/row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "./src/enums/index.js");
/* harmony import */ var _dimension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dimension */ "./src/fields/dimension/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * Represents categorical field subtype.
 *
 * @public
 * @class
 * @extends Dimension
 */

var Categorical = function (_Dimension) {
    _inherits(Categorical, _Dimension);

    function Categorical() {
        _classCallCheck(this, Categorical);

        return _possibleConstructorReturn(this, (Categorical.__proto__ || Object.getPrototypeOf(Categorical)).apply(this, arguments));
    }

    _createClass(Categorical, [{
        key: 'subtype',

        /**
         * Returns the subtype of the field.
         *
         * @public
         * @override
         * @return {string} Returns the subtype of the field.
         */
        value: function subtype() {
            return _enums__WEBPACK_IMPORTED_MODULE_1__["DimensionSubtype"].CATEGORICAL;
        }

        /**
         * Calculates the corresponding field domain.
         *
         * @public
         * @override
         * @return {Array} Returns the unique values.
         */

    }, {
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            var _this2 = this;

            var hash = new Set();
            var domain = [];

            // here don't use this.data() as the iteration will be occurred two times on same data.
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this2.partialField.data[i];
                if (!hash.has(datum)) {
                    hash.add(datum);
                    domain.push(datum);
                }
            });
            return domain;
        }
    }]);

    return Categorical;
}(_dimension__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Categorical);

/***/ }),

/***/ "./src/fields/continuous/index.js":
/*!****************************************!*\
  !*** ./src/fields/continuous/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../operator/row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums */ "./src/enums/index.js");
/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../measure */ "./src/fields/measure/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * Represents continuous field subtype.
 *
 * @public
 * @class
 * @extends Measure
 */

var Continuous = function (_Measure) {
    _inherits(Continuous, _Measure);

    function Continuous() {
        _classCallCheck(this, Continuous);

        return _possibleConstructorReturn(this, (Continuous.__proto__ || Object.getPrototypeOf(Continuous)).apply(this, arguments));
    }

    _createClass(Continuous, [{
        key: 'subtype',

        /**
         * Returns the subtype of the field.
         *
         * @public
         * @override
         * @return {string} Returns the subtype of the field.
         */
        value: function subtype() {
            return _enums__WEBPACK_IMPORTED_MODULE_1__["MeasureSubtype"].CONTINUOUS;
        }

        /**
         * Calculates the corresponding field domain.
         *
         * @public
         * @override
         * @return {Array} Returns the min and max values.
         */

    }, {
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            var _this2 = this;

            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;

            // here don't use this.data() as the iteration will be occurred two times on same data.
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this2.partialField.data[i];
                if (datum instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__["default"]) {
                    return;
                }

                if (datum < min) {
                    min = datum;
                }
                if (datum > max) {
                    max = datum;
                }
            });

            return [min, max];
        }
    }]);

    return Continuous;
}(_measure__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Continuous);

/***/ }),

/***/ "./src/fields/dimension/index.js":
/*!***************************************!*\
  !*** ./src/fields/dimension/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../field */ "./src/fields/field/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



/**
 * Represents dimension field type.
 *
 * @public
 * @class
 * @extends Field
 */

var Dimension = function (_Field) {
    _inherits(Dimension, _Field);

    function Dimension() {
        _classCallCheck(this, Dimension);

        return _possibleConstructorReturn(this, (Dimension.__proto__ || Object.getPrototypeOf(Dimension)).apply(this, arguments));
    }

    _createClass(Dimension, [{
        key: 'domain',

        /**
         * Returns the domain for the dimension field.
         *
         * @override
         * @public
         * @return {any} Returns the calculated domain.
         */
        value: function domain() {
            if (!this._cachedDomain) {
                this._cachedDomain = this.calculateDataDomain();
            }
            return this._cachedDomain;
        }

        /**
         * Calculates the corresponding field domain.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            throw new Error('Not yet implemented');
        }

        /**
        * Returns the formatted version of the underlying field data.
        *
        * @public
        * @override
        * @return {Array} Returns the formatted data.
        */

    }, {
        key: 'formattedData',
        value: function formattedData() {
            return this.data();
        }
    }]);

    return Dimension;
}(_field__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Dimension);

/***/ }),

/***/ "./src/fields/field/index.js":
/*!***********************************!*\
  !*** ./src/fields/field/index.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../operator/row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



/**
 * In {@link DataModel}, every tabular data consists of column, a column is stored as field.
 * Field contains all the data for a given column in an array.
 *
 * Each record consists of several fields; the fields of all records form the columns.
 * Examples of fields: name, gender, sex etc.
 *
 * In DataModel, each field can have multiple attributes which describes its data and behaviour.
 * A field can have two types of data: Measure and Dimension.
 *
 * A Dimension Field is the context on which a data is categorized and the measure is the numerical values that
 * quantify the data set.
 * In short a dimension is the lens through which you are looking at your measure data.
 *
 * Refer to {@link Schema} to get info about possible field attributes.
 *
 * @public
 * @class
 */

var Field = function () {
    /**
     * Initialize a new instance.
     *
     * @public
     * @param {PartialField} partialField - The partialField instance which holds the whole data.
     * @param {string} rowDiffset - The data subset definition.
     */
    function Field(partialField, rowDiffset) {
        _classCallCheck(this, Field);

        this.partialField = partialField;
        this.rowDiffset = rowDiffset;
    }

    /**
     * Generates the field type specific domain.
     *
     * @public
     * @abstract
     */


    _createClass(Field, [{
        key: 'domain',
        value: function domain() {
            throw new Error('Not yet implemented');
        }

        /**
         * Returns the the field schema.
         *
         * @public
         * @return {string} Returns the field schema.
         */

    }, {
        key: 'schema',
        value: function schema() {
            return this.partialField.schema;
        }

        /**
         * Returns the name of the field.
         *
         * @public
         * @return {string} Returns the name of the field.
         */

    }, {
        key: 'name',
        value: function name() {
            return this.partialField.name;
        }

        /**
         * Returns the type of the field.
         *
         * @public
         * @return {string} Returns the type of the field.
         */

    }, {
        key: 'type',
        value: function type() {
            return this.partialField.schema.type;
        }

        /**
         * Returns the subtype of the field.
         *
         * @public
         * @return {string} Returns the subtype of the field.
         */

    }, {
        key: 'subtype',
        value: function subtype() {
            return this.partialField.schema.subtype;
        }

        /**
         * Returns the description of the field.
         *
         * @public
         * @return {string} Returns the description of the field.
         */

    }, {
        key: 'description',
        value: function description() {
            return this.partialField.schema.description;
        }

        /**
         * Returns the display name of the field.
         *
         * @public
         * @return {string} Returns the display name of the field.
         */

    }, {
        key: 'displayName',
        value: function displayName() {
            return this.partialField.schema.displayName || this.partialField.schema.name;
        }

        /**
         * Returns the data associated with the field.
         *
         * @public
         * @return {Array} Returns the data.
         */

    }, {
        key: 'data',
        value: function data() {
            var _this = this;

            var data = [];
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                data.push(_this.partialField.data[i]);
            });
            return data;
        }

        /**
         * Returns the formatted version of the underlying field data.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'formattedData',
        value: function formattedData() {
            throw new Error('Not yet implemented');
        }
    }]);

    return Field;
}();

/* harmony default export */ __webpack_exports__["default"] = (Field);

/***/ }),

/***/ "./src/fields/geo-field/index.js":
/*!***************************************!*\
  !*** ./src/fields/geo-field/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dimension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dimension */ "./src/fields/dimension/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../invalid-aware-types */ "./src/invalid-aware-types.js");
/* harmony import */ var _operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../operator/row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * Represents geo field subtype.
 *
 * @public
 * @class
 * @extends Dimension
 */

var GeoField = function (_Dimension) {
    _inherits(GeoField, _Dimension);

    /**
     * Initialize a new instance.
     *
     * @public
     * @param {PartialField} partialField - The partialField instance which holds the whole data.
     * @param {string} rowDiffset - The data subset definition.
     */
    function GeoField(partialField, rowDiffset) {
        _classCallCheck(this, GeoField);

        var _this = _possibleConstructorReturn(this, (GeoField.__proto__ || Object.getPrototypeOf(GeoField)).call(this, partialField, rowDiffset));

        _this._cachedBounds = null;
        return _this;
    }

    /**
     * Gets the coordinates of all the geofields.
     * @return {Array} coordinates
     */


    _createClass(GeoField, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            var _this2 = this;

            var coordinates = [];
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this2.partialField.data[i];
                coordinates.push(datum.getCoordinates());
            });

            return coordinates;
        }

        /**
         * Caches and returns the bounds for the geo field.
         * @return {Array} Result of this.bounds
         *
         * @public
         */

    }, {
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            if (!this._cachedBounds) {
                this._cachedBounds = this.bounds();
            }
            return this._cachedBounds;
        }

        /**
         * Returns bounds for all of the geo fields.
         * @return {Array} Array of bounds
         *
         * @public
         */

    }, {
        key: 'bounds',
        value: function bounds() {
            var _this3 = this,
                _ref;

            if (this._cachedBounds) {
                return this._cachedBounds;
            }

            var boundsArr = [];
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this3.partialField.data[i];

                if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].isInvalid(datum)) {
                    boundsArr.push(datum.bounds());
                }
            });

            var boundsFlattened = (_ref = []).concat.apply(_ref, boundsArr);
            this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["bounds"])(boundsFlattened);
            return this._cachedBounds;
        }
    }]);

    return GeoField;
}(_dimension__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (GeoField);

/***/ }),

/***/ "./src/fields/index.js":
/*!*****************************!*\
  !*** ./src/fields/index.js ***!
  \*****************************/
/*! exports provided: Field, Dimension, Categorical, Temporal, Binned, Measure, Continuous, GeoField, FieldParser, CategoricalParser, TemporalParser, BinnedParser, ContinuousParser, GeoParser, PartialField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./field */ "./src/fields/field/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return _field__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _dimension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dimension */ "./src/fields/dimension/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dimension", function() { return _dimension__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _categorical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categorical */ "./src/fields/categorical/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Categorical", function() { return _categorical__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _temporal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./temporal */ "./src/fields/temporal/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Temporal", function() { return _temporal__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _binned__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binned */ "./src/fields/binned/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Binned", function() { return _binned__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _measure__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./measure */ "./src/fields/measure/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Measure", function() { return _measure__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./continuous */ "./src/fields/continuous/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Continuous", function() { return _continuous__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _geo_field__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geo-field */ "./src/fields/geo-field/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeoField", function() { return _geo_field__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _parsers_field_parser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parsers/field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FieldParser", function() { return _parsers_field_parser__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _parsers_categorical_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parsers/categorical-parser */ "./src/fields/parsers/categorical-parser/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CategoricalParser", function() { return _parsers_categorical_parser__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _parsers_temporal_parser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parsers/temporal-parser */ "./src/fields/parsers/temporal-parser/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemporalParser", function() { return _parsers_temporal_parser__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _parsers_binned_parser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parsers/binned-parser */ "./src/fields/parsers/binned-parser/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BinnedParser", function() { return _parsers_binned_parser__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _parsers_continuous_parser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parsers/continuous-parser */ "./src/fields/parsers/continuous-parser/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContinuousParser", function() { return _parsers_continuous_parser__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _parsers_geometry_parsers_geometry__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parsers/geometry-parsers/geometry */ "./src/fields/parsers/geometry-parsers/geometry/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeoParser", function() { return _parsers_geometry_parsers_geometry__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _partial_field__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./partial-field */ "./src/fields/partial-field/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PartialField", function() { return _partial_field__WEBPACK_IMPORTED_MODULE_14__["default"]; });

















/***/ }),

/***/ "./src/fields/measure/index.js":
/*!*************************************!*\
  !*** ./src/fields/measure/index.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");
/* harmony import */ var _operator_group_by_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../operator/group-by-function */ "./src/operator/group-by-function.js");
/* harmony import */ var _field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../field */ "./src/fields/field/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * Represents measure field type.
 *
 * @public
 * @class
 * @extends Field
 */

var Measure = function (_Field) {
    _inherits(Measure, _Field);

    function Measure() {
        _classCallCheck(this, Measure);

        return _possibleConstructorReturn(this, (Measure.__proto__ || Object.getPrototypeOf(Measure)).apply(this, arguments));
    }

    _createClass(Measure, [{
        key: 'domain',

        /**
         * Returns the domain for the measure field.
         *
         * @override
         * @public
         * @return {any} Returns the calculated domain.
         */
        value: function domain() {
            if (!this._cachedDomain) {
                this._cachedDomain = this.calculateDataDomain();
            }
            return this._cachedDomain;
        }

        /**
         * Returns the unit of the measure field.
         *
         * @public
         * @return {string} Returns unit of the field.
         */

    }, {
        key: 'unit',
        value: function unit() {
            return this.partialField.schema.unit;
        }

        /**
         * Returns the aggregation function name of the measure field.
         *
         * @public
         * @return {string} Returns aggregation function name of the field.
         */

    }, {
        key: 'defAggFn',
        value: function defAggFn() {
            return this.partialField.schema.defAggFn || _operator_group_by_function__WEBPACK_IMPORTED_MODULE_1__["defaultReducerName"];
        }

        /**
         * Returns the number format of the measure field.
         *
         * @public
         * @return {Function} Returns number format of the field.
         */

    }, {
        key: 'numberFormat',
        value: function numberFormat() {
            var numberFormat = this.partialField.schema.numberFormat;

            return numberFormat instanceof Function ? numberFormat : _utils__WEBPACK_IMPORTED_MODULE_0__["formatNumber"];
        }

        /**
         * Calculates the corresponding field domain.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            throw new Error('Not yet implemented');
        }

        /**
         * Returns the formatted version of the underlying field data.
         *
         * @public
         * @override
         * @return {Array} Returns the formatted data.
         */

    }, {
        key: 'formattedData',
        value: function formattedData() {
            return this.data();
        }
    }]);

    return Measure;
}(_field__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Measure);

/***/ }),

/***/ "./src/fields/parsers/binned-parser/index.js":
/*!***************************************************!*\
  !*** ./src/fields/parsers/binned-parser/index.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * A FieldParser which parses the binned values.
 *
 * @public
 * @class
 * @implements {FieldParser}
 */

var BinnedParser = function (_FieldParser) {
    _inherits(BinnedParser, _FieldParser);

    function BinnedParser() {
        _classCallCheck(this, BinnedParser);

        return _possibleConstructorReturn(this, (BinnedParser.__proto__ || Object.getPrototypeOf(BinnedParser)).apply(this, arguments));
    }

    _createClass(BinnedParser, [{
        key: 'parse',

        /**
         * Parses a single binned value of a field and returns the sanitized value.
         *
         * @public
         * @param {string} val - The value of the field.
         * @return {string} Returns the sanitized value.
         */
        value: function parse(val) {
            var regex = /^\s*([+-]?\d+(?:\.\d+)?)\s*-\s*([+-]?\d+(?:\.\d+)?)\s*$/;
            val = String(val);
            var result = void 0;
            // check if invalid date value
            if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].isInvalid(val)) {
                var matched = val.match(regex);
                result = matched ? Number.parseFloat(matched[1]) + '-' + Number.parseFloat(matched[2]) : _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NA;
            } else {
                result = _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].getInvalidType(val);
            }
            return result;
        }
    }]);

    return BinnedParser;
}(_field_parser__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (BinnedParser);

/***/ }),

/***/ "./src/fields/parsers/categorical-parser/index.js":
/*!********************************************************!*\
  !*** ./src/fields/parsers/categorical-parser/index.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * A FieldParser which parses the categorical values.
 *
 * @public
 * @class
 * @implements {FieldParser}
 */

var CategoricalParser = function (_FieldParser) {
    _inherits(CategoricalParser, _FieldParser);

    function CategoricalParser() {
        _classCallCheck(this, CategoricalParser);

        return _possibleConstructorReturn(this, (CategoricalParser.__proto__ || Object.getPrototypeOf(CategoricalParser)).apply(this, arguments));
    }

    _createClass(CategoricalParser, [{
        key: 'parse',

        /**
         * Parses a single value of a field and returns the stringified form.
         *
         * @public
         * @param {string|number} val - The value of the field.
         * @return {string} Returns the stringified value.
         */
        value: function parse(val) {
            var result = void 0;
            // check if invalid date value
            if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].isInvalid(val)) {
                result = String(val).trim();
            } else {
                result = _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].getInvalidType(val);
            }
            return result;
        }
    }]);

    return CategoricalParser;
}(_field_parser__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (CategoricalParser);

/***/ }),

/***/ "./src/fields/parsers/continuous-parser/index.js":
/*!*******************************************************!*\
  !*** ./src/fields/parsers/continuous-parser/index.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * A FieldParser which parses the continuous values.
 *
 * @public
 * @class
 * @implements {FieldParser}
 */

var ContinuousParser = function (_FieldParser) {
    _inherits(ContinuousParser, _FieldParser);

    function ContinuousParser() {
        _classCallCheck(this, ContinuousParser);

        return _possibleConstructorReturn(this, (ContinuousParser.__proto__ || Object.getPrototypeOf(ContinuousParser)).apply(this, arguments));
    }

    _createClass(ContinuousParser, [{
        key: 'parse',

        /**
         * Parses a single value of a field and returns the number form.
         *
         * @public
         * @param {string|number} val - The value of the field.
         * @return {string} Returns the number value.
         */
        value: function parse(val) {
            var result = void 0;
            // check if invalid date value
            if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].isInvalid(val)) {
                var parsedVal = parseFloat(val, 10);
                result = Number.isNaN(parsedVal) ? _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NA : parsedVal;
            } else {
                result = _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].getInvalidType(val);
            }
            return result;
        }
    }]);

    return ContinuousParser;
}(_field_parser__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (ContinuousParser);

/***/ }),

/***/ "./src/fields/parsers/field-parser/index.js":
/*!**************************************************!*\
  !*** ./src/fields/parsers/field-parser/index.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A interface to represent a parser which is responsible to parse the field.
 *
 * @public
 * @interface
 */
var FieldParser = function () {
  function FieldParser() {
    _classCallCheck(this, FieldParser);
  }

  _createClass(FieldParser, [{
    key: 'parse',

    /**
     * Parses a single value of a field and return the sanitized form.
     *
     * @public
     * @abstract
     */
    value: function parse() {
      throw new Error('Not yet implemented');
    }
  }]);

  return FieldParser;
}();

/* harmony default export */ __webpack_exports__["default"] = (FieldParser);

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/geometry/index.js":
/*!***************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/geometry/index.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _field_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! .. */ "./src/fields/parsers/geometry-parsers/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * An abstract GeoParser class which parses the geo data values and creates the geom instance.
 *
 * @public
 * @class
 * @implements {FieldParser}
 */

var GeoParser = function (_FieldParser) {
    _inherits(GeoParser, _FieldParser);

    /**
     * Initialize a new instance.
     *
     * @public
     * @param {Object} schema - The schema object for the corresponding field.
     */
    function GeoParser(schema) {
        _classCallCheck(this, GeoParser);

        var _this = _possibleConstructorReturn(this, (GeoParser.__proto__ || Object.getPrototypeOf(GeoParser)).call(this));

        _this.schema = schema;
        return _this;
    }

    /**
     * Parses a single value of a field and returns the geom instance.
     *
     * @public
     * @param {string|number} val - The value of the field.
     * @return {number} Returns the geom instance.
     */


    _createClass(GeoParser, [{
        key: 'parse',
        value: function parse(val) {
            if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].isInvalid(val)) {
                var type = val.type;


                return ___WEBPACK_IMPORTED_MODULE_1__["geometryParsers"][type](val);
            }
            return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].getInvalidType(val);
        }
    }]);

    return GeoParser;
}(_field_parser__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (GeoParser);

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/index.js":
/*!******************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/index.js ***!
  \******************************************************/
/*! exports provided: geometryParsers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryParsers", function() { return geometryParsers; });
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../enums/geom-types */ "./src/enums/geom-types.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./src/fields/parsers/geometry-parsers/point/index.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon */ "./src/fields/parsers/geometry-parsers/polygon/index.js");
/* harmony import */ var _multi_polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./multi-polygon */ "./src/fields/parsers/geometry-parsers/multi-polygon/index.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line-string */ "./src/fields/parsers/geometry-parsers/line-string/index.js");
/* harmony import */ var _multi_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multi-point */ "./src/fields/parsers/geometry-parsers/multi-point/index.js");
/* harmony import */ var _multi_line_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multi-line-string */ "./src/fields/parsers/geometry-parsers/multi-line-string/index.js");
var _geometryParsers;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/**
 * All types of geometry parsers.
 */
var geometryParsers = (_geometryParsers = {}, _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].Point, _point__WEBPACK_IMPORTED_MODULE_1__["pointParser"]), _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].Polygon, _polygon__WEBPACK_IMPORTED_MODULE_2__["polygonParser"]), _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].LineString, _line_string__WEBPACK_IMPORTED_MODULE_4__["lineParser"]), _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiPolygon, _multi_polygon__WEBPACK_IMPORTED_MODULE_3__["multiPolygonParser"]), _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiPoint, _multi_point__WEBPACK_IMPORTED_MODULE_5__["multiPointParser"]), _defineProperty(_geometryParsers, _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiLineString, _multi_line_string__WEBPACK_IMPORTED_MODULE_6__["multiLineParser"]), _geometryParsers);

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/line-string/index.js":
/*!******************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/line-string/index.js ***!
  \******************************************************************/
/*! exports provided: checkLineStringCoordinates, lineParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkLineStringCoordinates", function() { return checkLineStringCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineParser", function() { return lineParser; });
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./src/fields/parsers/geometry-parsers/point/index.js");
/* harmony import */ var _geo_line_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/line-string */ "./src/geo/line-string/index.js");




/**
 * Checks the line string coordinates and throws if any invalid values are given.
 *
 * @param {Array} coordinates Array of coordinates.
 */
var checkLineStringCoordinates = function checkLineStringCoordinates(coordinates) {
    if (!Array.isArray(coordinates)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_0__["GEO_ERR_MESSAGES"].isArray);
    }
    if (!(coordinates.length > 1)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_0__["GEO_ERR_MESSAGES"].hasMinimumPoints);
    }

    coordinates.forEach(function (coord) {
        Object(_point__WEBPACK_IMPORTED_MODULE_1__["checkPointCoordinates"])(coord);
    });

    return true;
};

/**
 * Returns a new LineString instance if the coordinates are valid. Throws error if coordinates are invalid or
 * the structure is not proper.
 *
 * @param {Object} val
 * @param {string} val.type Type of geometry
 * @param {Array} val.coordinates Coordinates array.
 *
 * @return {LineString} Instance of LineString.
 */
var lineParser = function lineParser(val) {
    var coordinates = val.coordinates;

    checkLineStringCoordinates(coordinates);

    return new _geo_line_string__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/multi-line-string/index.js":
/*!************************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/multi-line-string/index.js ***!
  \************************************************************************/
/*! exports provided: multiLineParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiLineParser", function() { return multiLineParser; });
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../line-string */ "./src/fields/parsers/geometry-parsers/line-string/index.js");
/* harmony import */ var _geo_multi_line_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/multi-line-string */ "./src/geo/multi-line-string/index.js");




/**
 * Returns a new MultiLineString instance if the coordinates are valid. Throws error if coordinates are invalid or
 * the structure is not proper.
 *
 * @param {Object} val
 * @param {string} val.type Type of geometry
 * @param {Array} val.coordinates Coordinates array.
 *
 * @return {MultiLineString} Instance of MultiLineString.
 */
var multiLineParser = function multiLineParser(val) {
    var coordinates = val.coordinates;

    if (!Array.isArray(coordinates)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_0__["GEO_ERR_MESSAGES"].isArray);
    }

    coordinates.forEach(function (coord) {
        Object(_line_string__WEBPACK_IMPORTED_MODULE_1__["checkLineStringCoordinates"])(coord);
    });

    return new _geo_multi_line_string__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/multi-point/index.js":
/*!******************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/multi-point/index.js ***!
  \******************************************************************/
/*! exports provided: multiPointParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiPointParser", function() { return multiPointParser; });
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./src/fields/parsers/geometry-parsers/point/index.js");
/* harmony import */ var _geo_multi_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/multi-point */ "./src/geo/multi-point/index.js");




/**
 * Returns a new MultiPoint instance if the coordinates are valid. Throws error if coordinates are invalid or
 * the structure is not proper.
 *
 * @param {Object} val
 * @param {string} val.type Type of geometry
 * @param {Array} val.coordinates Coordinates array.
 *
 * @return {MultiPoint} Instance of MultiPoint.
 */
var multiPointParser = function multiPointParser(val) {
    var coordinates = val.coordinates;

    if (!Array.isArray(coordinates)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_0__["GEO_ERR_MESSAGES"].isArray);
    }

    coordinates.forEach(function (coord) {
        Object(_point__WEBPACK_IMPORTED_MODULE_1__["checkPointCoordinates"])(coord);
    });

    return new _geo_multi_point__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/multi-polygon/index.js":
/*!********************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/multi-polygon/index.js ***!
  \********************************************************************/
/*! exports provided: multiPolygonParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiPolygonParser", function() { return multiPolygonParser; });
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../polygon */ "./src/fields/parsers/geometry-parsers/polygon/index.js");
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _geo_multi_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/multi-polygon */ "./src/geo/multi-polygon/index.js");




/**
 * Returns a new MultiPolygon instance if the coordinates are valid. Throws error if coordinates are invalid or
 * the structure is not proper.
 *
 * @param {Object} val
 * @param {string} val.type Type of geometry
 * @param {Array} val.coordinates Coordinates array.
 *
 * @return {MultiPolygon} Instance of multipolygon.
 */
var multiPolygonParser = function multiPolygonParser(val) {
    var coordinates = val.coordinates;


    if (!Array.isArray(coordinates)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_1__["GEO_ERR_MESSAGES"].isArray);
    }

    coordinates.forEach(function (coordArr) {
        Object(_polygon__WEBPACK_IMPORTED_MODULE_0__["checkPolygonCoordinates"])(coordArr);
    });

    return new _geo_multi_polygon__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/point/index.js":
/*!************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/point/index.js ***!
  \************************************************************/
/*! exports provided: pointPredicates, checkPointCoordinates, pointParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointPredicates", function() { return pointPredicates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPointCoordinates", function() { return checkPointCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointParser", function() { return pointParser; });
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _geo_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/point */ "./src/geo/point/index.js");




var pointPredicates = {
    isArray: function isArray(coordinates) {
        return Array.isArray(coordinates);
    },
    hasMinimumPoints: function hasMinimumPoints(coordinates) {
        return coordinates.length >= 2;
    },
    hasValidLatLong: function hasValidLatLong(coordinates) {
        var hasValidLatLong = coordinates.every(function (coord, index) {
            return typeof coord === 'number' && _utils_geo__WEBPACK_IMPORTED_MODULE_0__["latLongPredicates"][index](coord);
        });
        return hasValidLatLong;
    }
};

var checkPointCoordinates = function checkPointCoordinates(coordinates) {
    var error = void 0;

    var isValid = Object.keys(pointPredicates).every(function (key) {
        var valid = pointPredicates[key](coordinates);
        if (!valid) {
            error = _enums_error_messages__WEBPACK_IMPORTED_MODULE_1__["GEO_ERR_MESSAGES"][key];
        }
        return valid;
    });

    if (!isValid) {
        throw new Error(error);
    }

    return true;
};

/**
 * Returns a new point instance if the coordinates are valid. Throws error if coordinates are invalid or the structure
 * is not proper.
 *
 * @param {Object} val
 * @param {string} val.type Type of geometry
 * @param {Array} val.coordinates Coordinates array.
 *
 * @return {Point} Instance of point.
 */
var pointParser = function pointParser(val) {
    var coordinates = val.coordinates;

    checkPointCoordinates(coordinates);

    return new _geo_point__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/geometry-parsers/polygon/index.js":
/*!**************************************************************!*\
  !*** ./src/fields/parsers/geometry-parsers/polygon/index.js ***!
  \**************************************************************/
/*! exports provided: polygonPredicates, checkLinearRing, checkPolygonCoordinates, polygonParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonPredicates", function() { return polygonPredicates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkLinearRing", function() { return checkLinearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPolygonCoordinates", function() { return checkPolygonCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonParser", function() { return polygonParser; });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "./src/fields/parsers/geometry-parsers/point/index.js");
/* harmony import */ var _enums_error_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../enums/error-messages */ "./src/enums/error-messages.js");
/* harmony import */ var _geo_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../geo/polygon */ "./src/geo/polygon/index.js");




var polygonPredicates = {
    hasIdenticalPoints: function hasIdenticalPoints(coordinates) {
        var len = coordinates.length;
        return '' + coordinates[0] === '' + coordinates[len - 1];
    },
    hasMinimumFourPoints: function hasMinimumFourPoints(coordinates) {
        return coordinates.length >= 4;
    }
};

/**
 * Checks the coordinates of a linear ring in a polygon and throws error if any invalid values are given.
 *
 * @param {Array} coordinates Array of coordinates.
 */
var checkLinearRing = function checkLinearRing(coordinates) {
    var error = void 0;

    coordinates.forEach(function (coord) {
        Object(_point__WEBPACK_IMPORTED_MODULE_0__["checkPointCoordinates"])(coord);
    });

    var isValid = Object.keys(polygonPredicates).every(function (key) {
        var valid = polygonPredicates[key](coordinates);
        if (!valid) {
            error = _enums_error_messages__WEBPACK_IMPORTED_MODULE_1__["POLYGON_ERR_MESSAGES"][key];
        }
        return valid;
    });

    if (!isValid) {
        throw new Error(error);
    }

    return true;
};

var checkPolygonCoordinates = function checkPolygonCoordinates(coordinates) {
    if (!Array.isArray(coordinates)) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_1__["GEO_ERR_MESSAGES"].isArray);
    }
    if (!coordinates.length) {
        throw new Error(_enums_error_messages__WEBPACK_IMPORTED_MODULE_1__["POLYGON_ERR_MESSAGES"].hasMinimumCoordinates);
    }
    coordinates.forEach(function (coordArr) {
        checkLinearRing(coordArr);
    });
    return true;
};

var polygonParser = function polygonParser(val) {
    var coordinates = val.coordinates;

    checkPolygonCoordinates(coordinates);

    return new _geo_polygon__WEBPACK_IMPORTED_MODULE_2__["default"](val);
};

/***/ }),

/***/ "./src/fields/parsers/temporal-parser/index.js":
/*!*****************************************************!*\
  !*** ./src/fields/parsers/temporal-parser/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils */ "./src/utils/index.js");
/* harmony import */ var _field_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../field-parser */ "./src/fields/parsers/field-parser/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * A FieldParser which parses the temporal values.
 *
 * @public
 * @class
 * @implements {FieldParser}
 */

var TemporalParser = function (_FieldParser) {
    _inherits(TemporalParser, _FieldParser);

    /**
     * Initialize a new instance.
     *
     * @public
     * @param {Object} schema - The schema object for the corresponding field.
     */
    function TemporalParser(schema) {
        _classCallCheck(this, TemporalParser);

        var _this = _possibleConstructorReturn(this, (TemporalParser.__proto__ || Object.getPrototypeOf(TemporalParser)).call(this));

        _this.schema = schema;
        _this._dtf = new _utils__WEBPACK_IMPORTED_MODULE_0__["DateTimeFormatter"](_this.schema.format);
        return _this;
    }

    /**
     * Parses a single value of a field and returns the millisecond value.
     *
     * @public
     * @param {string|number} val - The value of the field.
     * @return {number} Returns the millisecond value.
     */


    _createClass(TemporalParser, [{
        key: 'parse',
        value: function parse(val) {
            var result = void 0;
            // check if invalid date value
            if (!_invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].isInvalid(val)) {
                var nativeDate = this._dtf.getNativeDate(val);
                result = nativeDate ? nativeDate.getTime() : _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].NA;
            } else {
                result = _invalid_aware_types__WEBPACK_IMPORTED_MODULE_2__["default"].getInvalidType(val);
            }
            return result;
        }
    }]);

    return TemporalParser;
}(_field_parser__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (TemporalParser);

/***/ }),

/***/ "./src/fields/partial-field/index.js":
/*!*******************************************!*\
  !*** ./src/fields/partial-field/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Stores the full data and the metadata of a field. It provides
 * a single source of data from which the future Field
 * instance can get a subset of it with a rowDiffset config.
 *
 * @class
 * @public
 */
var PartialField = function () {
  /**
   * Initialize a new instance.
   *
   * @public
   * @param {string} name - The name of the field.
   * @param {Array} data - The data array.
   * @param {Object} schema - The schema object of the corresponding field.
   * @param {FieldParser} parser - The parser instance corresponding to that field.
   */
  function PartialField(name, data, schema, parser) {
    _classCallCheck(this, PartialField);

    this.name = name;
    this.schema = schema;
    this.parser = parser;
    this.data = this._sanitize(data);
  }

  /**
   * Sanitizes the field data.
   *
   * @private
   * @param {Array} data - The actual input data.
   * @return {Array} Returns the sanitized data.
   */


  _createClass(PartialField, [{
    key: "_sanitize",
    value: function _sanitize(data) {
      var _this = this;

      return data.map(function (datum) {
        return _this.parser.parse(datum);
      });
    }
  }]);

  return PartialField;
}();

/* harmony default export */ __webpack_exports__["default"] = (PartialField);

/***/ }),

/***/ "./src/fields/temporal/index.js":
/*!**************************************!*\
  !*** ./src/fields/temporal/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../operator/row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _dimension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dimension */ "./src/fields/dimension/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../invalid-aware-types */ "./src/invalid-aware-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * Represents temporal field subtype.
 *
 * @public
 * @class
 * @extends Dimension
 */

var Temporal = function (_Dimension) {
    _inherits(Temporal, _Dimension);

    /**
    * Initialize a new instance.
    *
    * @public
    * @param {PartialField} partialField - The partialField instance which holds the whole data.
    * @param {string} rowDiffset - The data subset definition.
    */
    function Temporal(partialField, rowDiffset) {
        _classCallCheck(this, Temporal);

        var _this = _possibleConstructorReturn(this, (Temporal.__proto__ || Object.getPrototypeOf(Temporal)).call(this, partialField, rowDiffset));

        _this._cachedMinDiff = null;
        return _this;
    }

    /**
    * Calculates the corresponding field domain.
    *
    * @public
    * @override
    * @return {Array} Returns the unique values.
    */


    _createClass(Temporal, [{
        key: 'calculateDataDomain',
        value: function calculateDataDomain() {
            var _this2 = this;

            var hash = new Set();
            var domain = [];

            // here don't use this.data() as the iteration will be
            // occurred two times on same data.
            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this2.partialField.data[i];
                if (!hash.has(datum)) {
                    hash.add(datum);
                    domain.push(datum);
                }
            });

            return domain;
        }

        /**
         * Calculates the minimum consecutive difference from the associated field data.
         *
         * @public
         * @return {number} Returns the minimum consecutive diff in milliseconds.
         */

    }, {
        key: 'minimumConsecutiveDifference',
        value: function minimumConsecutiveDifference() {
            if (this._cachedMinDiff) {
                return this._cachedMinDiff;
            }

            var sortedData = this.data().filter(function (item) {
                return !(item instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__["default"]);
            }).sort(function (a, b) {
                return a - b;
            });
            var arrLn = sortedData.length;
            var minDiff = Number.POSITIVE_INFINITY;
            var prevDatum = void 0;
            var nextDatum = void 0;
            var processedCount = 0;

            for (var i = 1; i < arrLn; i++) {
                prevDatum = sortedData[i - 1];
                nextDatum = sortedData[i];

                if (nextDatum === prevDatum) {
                    continue;
                }

                minDiff = Math.min(minDiff, nextDatum - sortedData[i - 1]);
                processedCount++;
            }

            if (!processedCount) {
                minDiff = null;
            }
            this._cachedMinDiff = minDiff;

            return this._cachedMinDiff;
        }

        /**
         * Returns the format specified in the input schema while creating field.
         *
         * @public
         * @return {string} Returns the datetime format.
         */

    }, {
        key: 'format',
        value: function format() {
            return this.partialField.schema.format;
        }

        /**
         * Returns the formatted version of the underlying field data
         * If data is of type invalid or has missing format use the raw value
         * @public
         * @override
         * @return {Array} Returns the formatted data.
         */

    }, {
        key: 'formattedData',
        value: function formattedData() {
            var _this3 = this;

            var data = [];
            var dataFormat = this.format();

            Object(_operator_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(this.rowDiffset, function (i) {
                var datum = _this3.partialField.data[i];
                // If value is of invalid type or format is missing
                if (_invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__["default"].isInvalid(datum) || !dataFormat && Number.isFinite(datum)) {
                    // Use the invalid map value or the raw value
                    var parsedDatum = _invalid_aware_types__WEBPACK_IMPORTED_MODULE_3__["default"].getInvalidType(datum) || datum;
                    data.push(parsedDatum);
                } else {
                    data.push(_utils__WEBPACK_IMPORTED_MODULE_2__["DateTimeFormatter"].formatAs(datum, dataFormat));
                }
            });
            return data;
        }
    }]);

    return Temporal;
}(_dimension__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Temporal);

/***/ }),

/***/ "./src/geo/geometry/index.js":
/*!***********************************!*\
  !*** ./src/geo/geometry/index.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents Geometry.
 *
 * @public
 * @class
 */
var Geometry = function () {
    /**
     * Initialize a new instance.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the geometry
     * @param {string} value.type - The coordinates of the geometry
     */
    function Geometry(value) {
        _classCallCheck(this, Geometry);

        var type = value.type,
            coordinates = value.coordinates;

        this._cachedBounds = null;
        this.type = type;
        this.coordinates = coordinates;
    }

    /**
     * Get co-ordinates of the geometry.
     *
     * @public
     * @abstract
     * @return {Array} coordinates of geometry
     */


    _createClass(Geometry, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this.coordinates;
        }

        /**
         * Get bounds box of the geometry.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'bounds',
        value: function bounds() {
            throw new Error('Not yet implemented');
        }

        /**
         * Get center of the geometry.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'center',
        value: function center() {
            throw new Error('Not yet implemented');
        }

        /**
         * Get area of the geometry.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'area',
        value: function area() {
            throw new Error('Not yet implemented');
        }

        /**
         * includes a point or not in the geometry.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'includes',
        value: function includes() {
            throw new Error('Not yet implemented');
        }

        /**
         * Get the type and coordinates for a geometry
         * @return {Object} type and coordinates for a geometry
         */

    }, {
        key: 'serialize',
        value: function serialize() {
            return {
                type: this.type,
                coordinates: this.getCoordinates()
            };
        }

        /**
         * Get distance of the geometry.
         *
         * @public
         * @abstract
         */

    }, {
        key: 'distance',
        value: function distance() {
            throw new Error('Not yet implemented');
        }
    }]);

    return Geometry;
}();

/* harmony default export */ __webpack_exports__["default"] = (Geometry);

/***/ }),

/***/ "./src/geo/index.js":
/*!**************************!*\
  !*** ./src/geo/index.js ***!
  \**************************/
/*! exports provided: geometryMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryMap", function() { return geometryMap; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./src/geo/point/index.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon */ "./src/geo/polygon/index.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line-string */ "./src/geo/line-string/index.js");
/* harmony import */ var _multi_polygon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./multi-polygon */ "./src/geo/multi-polygon/index.js");
/* harmony import */ var _multi_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multi-point */ "./src/geo/multi-point/index.js");
/* harmony import */ var _multi_line_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multi-line-string */ "./src/geo/multi-line-string/index.js");
var _geometryMap;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/**
 * All types of geometries
 */
var geometryMap = (_geometryMap = {}, _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].Point, _point__WEBPACK_IMPORTED_MODULE_1__["default"]), _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].Polygon, _polygon__WEBPACK_IMPORTED_MODULE_2__["default"]), _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].LineString, _line_string__WEBPACK_IMPORTED_MODULE_3__["default"]), _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiPolygon, _multi_polygon__WEBPACK_IMPORTED_MODULE_4__["default"]), _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiPoint, _multi_point__WEBPACK_IMPORTED_MODULE_5__["default"]), _defineProperty(_geometryMap, _enums__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].MultiLineString, _multi_line_string__WEBPACK_IMPORTED_MODULE_6__["default"]), _geometryMap);

/***/ }),

/***/ "./src/geo/line-string/helper.js":
/*!***************************************!*\
  !*** ./src/geo/line-string/helper.js ***!
  \***************************************/
/*! exports provided: distanceToLine, convertLength, isPointOnLineSegment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceToLine", function() { return distanceToLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertLength", function() { return convertLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPointOnLineSegment", function() { return isPointOnLineSegment; });
/* harmony import */ var _constants_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants/geo */ "./src/constants/geo.js");
/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/helper */ "./src/utils/helper.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/distance-factors */ "./src/enums/distance-factors.js");





var dot = function dot(u, v) {
    return u[0] * v[0] + u[1] * v[1];
};

/**
 * Returns the distance between a point P on a segment AB.
 *
 * @private
 * @param {Array<number>} p external point
 * @param {Array<number>} a first segment point
 * @param {Array<number>} b second segment point
 * @param {Object} [options={}] Optional parameters
 * @returns {number} distance
 */
var distanceToLine = function distanceToLine(p, a, b) {
    var v = [b[0] - a[0], b[1] - a[1]];
    var w = [p[0] - a[0], p[1] - a[1]];
    var c1 = dot(w, v);
    if (c1 <= 0) {
        return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["distance"])(p, a, _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["UNITS"].DEGREES);
    }
    var c2 = dot(v, v);
    if (c2 <= c1) {
        return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["distance"])(p, b, _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["UNITS"].DEGREES);
    }
    var b2 = c1 / c2;
    var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
    return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["distance"])(p, Pb, _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["UNITS"].DEGREES);
};

/**
* Converts a length to the requested unit.
* Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
*
* @param {number} length to be converted
* @param {Units} [originalUnit='kilometers'] of the length
* @param {Units} [finalUnit='kilometers'] returned unit
* @returns {number} the converted length
*/
var convertLength = function convertLength(length) {
    var originalUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["UNITS"].KILOMETERS;
    var finalUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["UNITS"].KILOMETERS;

    if (length < 0) {
        throw new Error('length must be a positive number');
    }
    return Object(_utils_helper__WEBPACK_IMPORTED_MODULE_1__["radiansToLength"])(Object(_utils_helper__WEBPACK_IMPORTED_MODULE_1__["lengthToRadians"])(length, originalUnit), finalUnit);
};

/**
 * component logic to check if point lies on a line
 *
 * @private
 * @param {Object} params params for the operation
 * @param {Position} startPoint coord pair of start of line
 * @param {Position} endPoint coord pair of end of line
 * @param {Position} point coord pair of point to check
 * @param {boolean|string} ignoreBoundary whether the point is allowed to fall on the line ends.
 * If true which end to ignore.
 * @return {boolean} true/false
 */
var isPointOnLineSegment = function isPointOnLineSegment(params) {
    var point = params.point,
        startPoint = params.startPoint,
        endPoint = params.endPoint,
        ignoreBoundary = params.ignoreBoundary;

    var x = point[0];
    var y = point[1];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x2 = endPoint[0];
    var y2 = endPoint[1];
    var dxc = point[0] - x1;
    var dyc = point[1] - y1;
    var dxl = x2 - x1;
    var dyl = y2 - y1;
    var cross = dxc * dyl - dyc * dxl;
    var returnData = false;

    if (cross !== 0) {
        returnData = false;
    } else if (!ignoreBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            returnData = dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        returnData = dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (ignoreBoundary === _constants_geo__WEBPACK_IMPORTED_MODULE_0__["BOUNDARY_POINTS"].START) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            returnData = dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        } else {
            returnData = dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
        }
    } else if (ignoreBoundary === _constants_geo__WEBPACK_IMPORTED_MODULE_0__["BOUNDARY_POINTS"].END) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            returnData = dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        } else {
            returnData = dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
        }
    } else if (ignoreBoundary === _constants_geo__WEBPACK_IMPORTED_MODULE_0__["BOUNDARY_POINTS"].BOTH) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            returnData = dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        } else {
            returnData = dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
        }
    }
    return returnData;
};

/***/ }),

/***/ "./src/geo/line-string/index.js":
/*!**************************************!*\
  !*** ./src/geo/line-string/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/geom-types */ "./src/enums/geom-types.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./src/geo/line-string/helper.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../point */ "./src/geo/point/index.js");
/* harmony import */ var _constants_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants/geo */ "./src/constants/geo.js");
/* harmony import */ var _enums_distance_factors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../enums/distance-factors */ "./src/enums/distance-factors.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









/**
 * Represents LineString.
 *
 * @public
 * @class
 */

var LineString = function (_Geometry) {
    _inherits(LineString, _Geometry);

    /**
     * Initialize a new instance of LineString.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the lineString
     * @param {string} value.type - The coordinates of the lineString
     */
    function LineString(value) {
        _classCallCheck(this, LineString);

        var _this = _possibleConstructorReturn(this, (LineString.__proto__ || Object.getPrototypeOf(LineString)).call(this, value));

        _this._realCoordinates = value.coordinates;
        _this.coordinates = value.coordinates.map(function (coordinate) {
            return new _point__WEBPACK_IMPORTED_MODULE_4__["default"]({
                type: _enums_geom_types__WEBPACK_IMPORTED_MODULE_1__["GeomTypes"].Point,
                coordinates: coordinate
            });
        });
        return _this;
    }

    /**
     * Get co-ordinates of the lineString.
     *
     * @public
     * @return {Array} array of points
     */


    _createClass(LineString, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this._realCoordinates;
        }

        /**
         * Get bounds box of the lineString.
         *
         * @public
         * @param {Array} coordinates coordinates of the lineString
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                var lineStringData = this.coordinates.map(function (point) {
                    return point.coordinates;
                });
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["bounds"])(lineStringData);
            }

            return boundsArr;
        }

        /**
         * Returns true if a point is on a line. Accepts a optional parameter to ignore the
         * start and end vertices of the linestring.
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @param {boolean} excludeBoundary whether to ignore the start and end vertices.
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point, excludeBoundary) {
            var lineCoords = this.getCoordinates();

            for (var i = 0; i < lineCoords.length - 1; i++) {
                var ignoreBoundary = '';
                if (excludeBoundary) {
                    if (i === 0) {
                        ignoreBoundary = _constants_geo__WEBPACK_IMPORTED_MODULE_5__["BOUNDARY_POINTS"].START;
                    }
                    if (i === lineCoords.length - 2) {
                        ignoreBoundary = _constants_geo__WEBPACK_IMPORTED_MODULE_5__["BOUNDARY_POINTS"].END;
                    }
                    if (i === 0 && i + 1 === lineCoords.length - 1) {
                        ignoreBoundary = _constants_geo__WEBPACK_IMPORTED_MODULE_5__["BOUNDARY_POINTS"].BOTH;
                    }
                }
                if (Object(_helper__WEBPACK_IMPORTED_MODULE_3__["isPointOnLineSegment"])({
                    startPoint: lineCoords[i],
                    endPoint: lineCoords[i + 1],
                    point: point,
                    ignoreBoundary: ignoreBoundary
                })) {
                    return true;
                }
            }
            return false;
        }

        /** Get area of the line string.
        *
        * @public
        * @return {number} area of the line string
        */

    }, {
        key: 'area',
        value: function area() {
            return 0;
        }

        /**
         * Get center of the line string.
         *
         * @public
         * @return {Array} center of the bounds
         */

    }, {
        key: 'center',
        value: function center() {
            return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["center"])(this._realCoordinates);
        }

        /**
         * Returns the minimum distance between from a point
         * minimum distance between the point and any segment of the `LineString`.
         *
         * @name distance
         * @param {Array<number>} pt Coordinates
         * @param {string} units can be anything supported
         * (ex: degrees, radians, miles, or kilometers)
         * @returns {number} distance between point and line
         */

    }, {
        key: 'distance',
        value: function distance(pt) {
            var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _enums_distance_factors__WEBPACK_IMPORTED_MODULE_6__["UNITS"].KILOMETERS;

            // validation
            if (!pt && !Array.isArray(pt)) {
                throw new Error('Enter valid point.');
            }
            var distance = Infinity;
            for (var i = 1; i < this._realCoordinates.length; i++) {
                var a = this._realCoordinates[i - 1];
                var b = this._realCoordinates[i];
                var d = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["distanceToLine"])(pt, a, b);
                if (d < distance) {
                    distance = d;
                }
            }
            return Object(_helper__WEBPACK_IMPORTED_MODULE_3__["convertLength"])(distance, _enums_distance_factors__WEBPACK_IMPORTED_MODULE_6__["UNITS"].DEGREES, units);
        }
    }]);

    return LineString;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LineString);

/***/ }),

/***/ "./src/geo/multi-line-string/index.js":
/*!********************************************!*\
  !*** ./src/geo/multi-line-string/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../line-string */ "./src/geo/line-string/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/geom-types */ "./src/enums/geom-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * Represents MultiLineString.
 *
 * @public
 * @class
 */

var MultiLineString = function (_Geometry) {
    _inherits(MultiLineString, _Geometry);

    /**
     * Initialize a new instance of MultiLineString.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the multiLineString
     * @param {string} value.type - The coordinates of the multiLineString
     */
    function MultiLineString(value) {
        _classCallCheck(this, MultiLineString);

        var _this = _possibleConstructorReturn(this, (MultiLineString.__proto__ || Object.getPrototypeOf(MultiLineString)).call(this, value));

        _this._realCoordinates = value.coordinates;
        _this.coordinates = value.coordinates.map(function (coordinate) {
            return new _line_string__WEBPACK_IMPORTED_MODULE_1__["default"]({
                type: _enums_geom_types__WEBPACK_IMPORTED_MODULE_3__["GeomTypes"].LineString,
                coordinates: coordinate
            });
        });
        return _this;
    }

    /**
     * Get co-ordinates of the multiLineString.
     *
     * @public
     * @return {Array} an array of LineString
     */


    _createClass(MultiLineString, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this._realCoordinates;
        }

        /**
         * Get bounds box of the multiLineString.
         *
         * @public
         * @param {Array} coordinates coordinates of the multiLineString
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                var lineData = this.coordinates.map(function (line) {
                    return line.bounds();
                });
                var data = lineData.flat(1);
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["bounds"])(data);
            }

            return boundsArr;
        }

        /**
         * Returns true if a point is on a line. Accepts a optional parameter to ignore the
         * start and end vertices of the line string.
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @param {boolean} excludeBoundary whether to ignore the start and end vertices.
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point, excludeBoundary) {
            return this.coordinates.some(function (line) {
                return line.includes(point, excludeBoundary);
            });
        }

        /**
         * Get area of the multi line string.
         *
         * @public
         * @return {number} area of the multi line string
         */

    }, {
        key: 'area',
        value: function area() {
            return 0;
        }

        /**
         * Get center of the multi line string.
         *
         * @public
         * @return {Array} center of the center
         */

    }, {
        key: 'center',
        value: function center() {
            var lineData = this.coordinates.map(function (line) {
                return line.center();
            });
            return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["center"])(lineData);
        }
    }]);

    return MultiLineString;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiLineString);

/***/ }),

/***/ "./src/geo/multi-point/index.js":
/*!**************************************!*\
  !*** ./src/geo/multi-point/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./src/geo/point/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/geom-types */ "./src/enums/geom-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * Represents MultiPoint.
 *
 * @public
 * @class
 */

var MultiPoint = function (_Geometry) {
    _inherits(MultiPoint, _Geometry);

    /**
     * Initialize a new instance of MultiPoint.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the multiPoint
     * @param {string} value.type - The coordinates of the multiPoint
     */
    function MultiPoint(value) {
        _classCallCheck(this, MultiPoint);

        var _this = _possibleConstructorReturn(this, (MultiPoint.__proto__ || Object.getPrototypeOf(MultiPoint)).call(this, value));

        _this._realCoordinates = value.coordinates;
        _this.coordinates = value.coordinates.map(function (coordinate) {
            return new _point__WEBPACK_IMPORTED_MODULE_1__["default"]({
                type: _enums_geom_types__WEBPACK_IMPORTED_MODULE_3__["GeomTypes"].Point,
                coordinates: coordinate
            });
        });
        return _this;
    }

    /**
     * Get co-ordinates of the multiPoint.
     *
     * @public
     * @return {Array} array of coordinates
     */


    _createClass(MultiPoint, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this._realCoordinates;
        }

        /**
         * Get bounds box of the multiPoint.
         *
         * @public
         * @param {Array} coordinates coordinates of the multiPoint
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                var multiPointData = this.coordinates.map(function (point) {
                    return point.coordinates;
                });
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["bounds"])(multiPointData);
            }

            return boundsArr;
        }

        /**
         * Get area of the multi point.
         *
         * @public
         * @return {number} area of the multi point
         */

    }, {
        key: 'area',
        value: function area() {
            return 0;
        }

        /**
         * Get center of the multiPoint.
         *
         * @public
         * @return {Array} center of the bounds
         */

    }, {
        key: 'center',
        value: function center() {
            return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["center"])(this._realCoordinates);
        }

        /**
         * Returns true if a point is in multiline.
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point) {
            var output = false;
            var mPointCoord = this.getCoordinates();
            for (var i = 0; i < mPointCoord.length; i++) {
                if (mPointCoord[i][0] === point[0] && mPointCoord[i][1] === point[1]) {
                    output = true;
                    break;
                }
            }
            return output;
        }
    }]);

    return MultiPoint;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiPoint);

/***/ }),

/***/ "./src/geo/multi-polygon/index.js":
/*!****************************************!*\
  !*** ./src/geo/multi-polygon/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../polygon */ "./src/geo/polygon/index.js");
/* harmony import */ var _multi_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../multi-point */ "./src/geo/multi-point/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/geom-types */ "./src/enums/geom-types.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * Represents MultiPolygon.
 *
 * @public
 * @class
 */

var MultiPolygon = function (_Geometry) {
    _inherits(MultiPolygon, _Geometry);

    /**
     * Initialize a new instance of MultiPolygon.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the multiPolygon
     * @param {string} value.type - The coordinates of the multiPolygon
     */
    function MultiPolygon(value) {
        _classCallCheck(this, MultiPolygon);

        var _this = _possibleConstructorReturn(this, (MultiPolygon.__proto__ || Object.getPrototypeOf(MultiPolygon)).call(this, value));

        _this._realCoordinates = value.coordinates;
        _this.coordinates = value.coordinates.map(function (coordinate) {
            return new _polygon__WEBPACK_IMPORTED_MODULE_1__["default"]({
                type: _enums_geom_types__WEBPACK_IMPORTED_MODULE_4__["GeomTypes"].Polygon,
                coordinates: coordinate
            });
        });
        return _this;
    }

    /**
     * Get co-ordinates of the multiPolygon.
     *
     * @public
     * @return {Array} array of Polygons
     */


    _createClass(MultiPolygon, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this._realCoordinates;
        }

        /**
         * Get bounds box of the multi polygon.
         *
         * @public
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                var polyData = this.coordinates.map(function (poly) {
                    return poly.bounds();
                });
                var data = polyData.flat(1);
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_3__["bounds"])(data);
            }
            return boundsArr;
        }

        /**
         * Get area of the multi polygon.
         *
         * @public
         * @return {number} area of the multi polygon
         */

    }, {
        key: 'area',
        value: function area() {
            var polyAreaData = this.coordinates.map(function (poly) {
                return poly.area();
            });
            return polyAreaData.reduce(function (a, b) {
                return a + b;
            }, 0);
        }

        /**
         * Get center of the multi polygon.
         *
         * @public
         * @return {number} center of the multi polygon
         */

    }, {
        key: 'center',
        value: function center() {
            var polyCenterData = this.coordinates.map(function (poly) {
                return poly.center();
            });
            var multiPoint = new _multi_point__WEBPACK_IMPORTED_MODULE_2__["default"]({
                type: _enums_geom_types__WEBPACK_IMPORTED_MODULE_4__["GeomTypes"].MultiPoint,
                coordinates: polyCenterData
            });
            return multiPoint.center();
        }

        /**
         * Returns true if a point is on one of the polygons in multi-polygons.
         * Accepts a optional parameter to ignore the boundaries of multi polygon
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @param {boolean} excludeBoundary whether to ignore boundaries.
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point, excludeBoundary) {
            return this.coordinates.some(function (poly) {
                return poly.includes(point, excludeBoundary);
            });
        }
    }]);

    return MultiPolygon;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (MultiPolygon);

/***/ }),

/***/ "./src/geo/point/index.js":
/*!********************************!*\
  !*** ./src/geo/point/index.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _enums_distance_factors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/distance-factors */ "./src/enums/distance-factors.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * Represents Point.
 *
 * @public
 * @class
 */

var Point = function (_Geometry) {
    _inherits(Point, _Geometry);

    function Point() {
        _classCallCheck(this, Point);

        return _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));
    }

    _createClass(Point, [{
        key: 'getCoordinates',

        /**
         * Get co-ordinates of the point.
         *
         * @public
         * @return {Array} coordinates of the Point
         */
        value: function getCoordinates() {
            return this.coordinates;
        }

        /**
         * Get bounds box of the point.
         *
         * @public
         * @param {Array} coordinates coordinates of the point
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["bounds"])([this.coordinates]);
            }

            return boundsArr;
        }
        /**
         * Returns true if a point is in a point.
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point) {
            return this.coordinates[0] === point[0] && this.coordinates[1] === point[1];
        }

        /**
         * Get area of the point.
         *
         * @public
         * @return {number} area of the point
         */

    }, {
        key: 'area',
        value: function area() {
            return 0;
        }

        /**
         * Get center of the point.
         *
         * @public
         * @return {Array} the point
         */

    }, {
        key: 'center',
        value: function center() {
            return this.coordinates;
        }

        /**
         * Returns the minimum distance between from a point
         *
         * @name distance
         * @param {Array<number>} pt Coordinates
         * @param {string} units can be anything supported
         * (ex: degrees, radians, miles, or kilometers)
         * @returns {number} distance between point and point
         */

    }, {
        key: 'distance',
        value: function distance(pt) {
            var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _enums_distance_factors__WEBPACK_IMPORTED_MODULE_2__["UNITS"].KILOMETERS;

            // validation
            if (!pt && !Array.isArray(pt)) {
                throw new Error('Enter valid point.');
            }
            return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["distance"])(pt, this.getCoordinates(), units);
        }
    }]);

    return Point;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Point);

/***/ }),

/***/ "./src/geo/polygon/helper.js":
/*!***********************************!*\
  !*** ./src/geo/polygon/helper.js ***!
  \***********************************/
/*! exports provided: sanitizeConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeConfig", function() { return sanitizeConfig; });
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/geom-types */ "./src/enums/geom-types.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../line-string */ "./src/geo/line-string/index.js");



/**
 * sanitize the config of the coordinate to change it to
 * an array of line strings
 * @param {Array} value array of original values
 * @return {Array} array of Line Strings
 */
var sanitizeConfig = function sanitizeConfig(value) {
    var coordinates = [];
    var type = _enums_geom_types__WEBPACK_IMPORTED_MODULE_0__["GeomTypes"].LineString;

    for (var i = 0; i < value.length; i++) {
        coordinates[i] = [];
        for (var j = 0; j < value[i].length - 1; j++) {
            coordinates[i].push(new _line_string__WEBPACK_IMPORTED_MODULE_1__["default"]({
                type: type, coordinates: [value[i][j], value[i][j + 1]]
            }));
        }
    }
    return coordinates;
};

/***/ }),

/***/ "./src/geo/polygon/index.js":
/*!**********************************!*\
  !*** ./src/geo/polygon/index.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./src/geo/geometry/index.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./src/geo/polygon/helper.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * Represents Polygon.
 * Coordinates of a Polygon are an array of linear ring coordinate arrays.
 * The first element in the array represents the exterior ring.
 * Any subsequent elements represent interior rings (or holes).
 * https://tools.ietf.org/html/rfc7946#section-3.1.6
 * @public
 * @class
 */

var Polygon = function (_Geometry) {
    _inherits(Polygon, _Geometry);

    /**
     * Initialize a new instance of Polygon.
     *
     * @public
     * @param {Object} value - Value type value
     * @param {Array} value.coordinates - The coordinates of the polygon
     * @param {string} value.type - The coordinates of the polygon
     */
    function Polygon(value) {
        _classCallCheck(this, Polygon);

        var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, value));

        _this._realCoordinates = value.coordinates;
        _this.coordinates = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["sanitizeConfig"])(value.coordinates);
        return _this;
    }

    /**
     * Get co-ordinates of the polygon.
     *
     * @public
     * @return {Array} array of line strings
     */


    _createClass(Polygon, [{
        key: 'getCoordinates',
        value: function getCoordinates() {
            return this._realCoordinates;
        }

        /**
         * Get bounds box of the polygon.
         *
         * @public
         * @return {Array} an array of format [[minX, minY],[maxX, maxY]]
        */

    }, {
        key: 'bounds',
        value: function bounds() {
            var boundsArr = this._cachedBounds;

            if (!boundsArr) {
                var polygon = this.coordinates.map(function (poly) {
                    return poly.map(function (line) {
                        return line.bounds();
                    });
                });
                var data = polygon.flat(1).flat(1);
                boundsArr = this._cachedBounds = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["bounds"])(data);
            }

            return boundsArr;
        }

        /**
         * Get area of the Polygon.
         *
         * @public
         * @return {number} the area of the polygon
         */

    }, {
        key: 'area',
        value: function area() {
            var areaObj = [];
            var tempArray = void 0;
            var coordinates = this._realCoordinates;
            for (var i = 0, l = coordinates.length; i < l; i++) {
                tempArray = [];
                for (var j = 0, k = coordinates[i].length; j < k; j++) {
                    tempArray.push(coordinates[i][j]);
                }
                areaObj.push(Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["area"])(tempArray));
            }
            var netArea = 0;
            for (var m = 0, n = areaObj.length; m < n; m++) {
                if (m === 0) {
                    netArea = areaObj[m];
                } else {
                    netArea -= areaObj[m];
                }
            }
            return netArea;
        }

        /**
         * Get center of the Polygon.
         *
         * @public
         * @return {Array} center of the Polygon
         */

    }, {
        key: 'center',
        value: function center() {
            return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["center"])(this._realCoordinates[0]);
        }

        /**
         * Returns true if a point is in a polygon. Accepts an optional parameter to ignore the
         * start and end vertices of the polygon.
         *
         * @name includes
         * @param {Array.<number>} point point Coordinates of form [x, y]
         * @param {boolean} excludeBoundary whether to ignore the Boundary coordinates.
         * @return {boolean} true/false
         */

    }, {
        key: 'includes',
        value: function includes(point, excludeBoundary) {
            var result = false;
            var polyCoords = this.getCoordinates();
            var includeMap = polyCoords.map(function (poly) {
                return Object(_utils_geo__WEBPACK_IMPORTED_MODULE_1__["includes"])(poly, point, excludeBoundary);
            });
            if (includeMap[0] && includeMap.filter(function (i) {
                return i;
            }).length === 1) {
                result = true;
            }
            return result;
        }
    }]);

    return Polygon;
}(_geometry__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Polygon);

/***/ }),

/***/ "./src/helper.js":
/*!***********************!*\
  !*** ./src/helper.js ***!
  \***********************/
/*! exports provided: prepareJoinData, updateFields, persistCurrentDerivation, persistAncestorDerivation, persistDerivations, selectRowDiffsetIterator, rowSplitDiffsetIterator, selectHelper, cloneWithAllFields, splitWithSelect, addDiffsetToClonedDm, cloneWithSelect, cloneWithProject, splitWithProject, sanitizeUnitSchema, validateUnitSchema, sanitizeAndValidateSchema, resolveFieldName, updateData, fieldInSchema, getDerivationArguments, getRootGroupByModel, getRootDataModel, getPathToRootModel, filterPropagationModel, propagateToAllDataModels, propagateImmutableActions, addToPropNamespace, getNormalizedProFields, getNumberFormattedVal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareJoinData", function() { return prepareJoinData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateFields", function() { return updateFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "persistCurrentDerivation", function() { return persistCurrentDerivation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "persistAncestorDerivation", function() { return persistAncestorDerivation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "persistDerivations", function() { return persistDerivations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectRowDiffsetIterator", function() { return selectRowDiffsetIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rowSplitDiffsetIterator", function() { return rowSplitDiffsetIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectHelper", function() { return selectHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneWithAllFields", function() { return cloneWithAllFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitWithSelect", function() { return splitWithSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDiffsetToClonedDm", function() { return addDiffsetToClonedDm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneWithSelect", function() { return cloneWithSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneWithProject", function() { return cloneWithProject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitWithProject", function() { return splitWithProject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeUnitSchema", function() { return sanitizeUnitSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateUnitSchema", function() { return validateUnitSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeAndValidateSchema", function() { return sanitizeAndValidateSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveFieldName", function() { return resolveFieldName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateData", function() { return updateData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fieldInSchema", function() { return fieldInSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDerivationArguments", function() { return getDerivationArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRootGroupByModel", function() { return getRootGroupByModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRootDataModel", function() { return getRootDataModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathToRootModel", function() { return getPathToRootModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterPropagationModel", function() { return filterPropagationModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagateToAllDataModels", function() { return propagateToAllDataModels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagateImmutableActions", function() { return propagateImmutableActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToPropNamespace", function() { return addToPropNamespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNormalizedProFields", function() { return getNormalizedProFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNumberFormattedVal", function() { return getNumberFormattedVal; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _field_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field-store */ "./src/field-store.js");
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./value */ "./src/value.js");
/* harmony import */ var _operator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operator */ "./src/operator/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./src/constants/index.js");
/* harmony import */ var _field_creator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./field-creator */ "./src/field-creator.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./default-config */ "./src/default-config.js");
/* harmony import */ var _converter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./converter */ "./src/converter/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ "./src/utils/index.js");
/* harmony import */ var _geo_geometry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./geo/geometry */ "./src/geo/geometry/index.js");
var _selectModeMap,
    _this = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }












/**
 * Prepares the selection data.
 */
function prepareSelectionData(fields, formattedData, rawData, i) {
    var resp = {};

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = fields.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ref = _step.value;

            var _ref2 = _slicedToArray(_ref, 2);

            var key = _ref2[0];
            var field = _ref2[1];

            resp[field.name()] = new _value__WEBPACK_IMPORTED_MODULE_2__["default"](formattedData[key][i], rawData[key][i], field);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return resp;
}

function prepareJoinData(fields) {
    var resp = {};

    for (var key in fields) {
        resp[key] = new _value__WEBPACK_IMPORTED_MODULE_2__["default"](fields[key].formattedValue, fields[key].rawValue, key);
    }
    return resp;
}

var updateFields = function updateFields(_ref3, partialFieldspace, fieldStoreName) {
    var _ref4 = _slicedToArray(_ref3, 2),
        rowDiffset = _ref4[0],
        colIdentifier = _ref4[1];

    var collID = colIdentifier.length ? colIdentifier.split(',') : [];
    var partialFieldMap = partialFieldspace.fieldsObj();
    var newFields = collID.map(function (coll) {
        return Object(_field_creator__WEBPACK_IMPORTED_MODULE_5__["createUnitFieldFromPartial"])(partialFieldMap[coll].partialField, rowDiffset);
    });
    return _field_store__WEBPACK_IMPORTED_MODULE_1__["default"].createNamespace(newFields, fieldStoreName);
};

var persistCurrentDerivation = function persistCurrentDerivation(model, operation) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var criteriaFn = arguments[3];

    if (operation === _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].COMPOSE) {
        var _model$_derivation;

        model._derivation.length = 0;
        (_model$_derivation = model._derivation).push.apply(_model$_derivation, _toConsumableArray(criteriaFn));
    } else {
        model._derivation.push({
            op: operation,
            meta: config,
            criteria: criteriaFn
        });
    }
};
var persistAncestorDerivation = function persistAncestorDerivation(sourceDm, newDm) {
    var _newDm$_ancestorDeriv;

    (_newDm$_ancestorDeriv = newDm._ancestorDerivation).push.apply(_newDm$_ancestorDeriv, _toConsumableArray(sourceDm._ancestorDerivation).concat(_toConsumableArray(sourceDm._derivation)));
};

var persistDerivations = function persistDerivations(sourceDm, model, operation) {
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var criteriaFn = arguments[4];

    persistCurrentDerivation(model, operation, config, criteriaFn);
    persistAncestorDerivation(sourceDm, model);
};

var selectModeMap = (_selectModeMap = {}, _defineProperty(_selectModeMap, _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL, {
    diffIndex: ['rowDiffset'],
    calcDiff: [true, false]
}), _defineProperty(_selectModeMap, _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].INVERSE, {
    diffIndex: ['rejectRowDiffset'],
    calcDiff: [false, true]
}), _defineProperty(_selectModeMap, _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].ALL, {
    diffIndex: ['rowDiffset', 'rejectRowDiffset'],
    calcDiff: [true, true]
}), _selectModeMap);

var generateRowDiffset = function generateRowDiffset(rowDiffset, i, lastInsertedValue) {
    if (lastInsertedValue !== -1 && i === lastInsertedValue + 1) {
        var li = rowDiffset.length - 1;

        rowDiffset[li] = rowDiffset[li].split('-')[0] + '-' + i;
    } else {
        rowDiffset.push('' + i);
    }
};

var selectRowDiffsetIterator = function selectRowDiffsetIterator(rowDiffset, checker, mode) {
    var lastInsertedValueSel = -1;
    var lastInsertedValueRej = -1;
    var newRowDiffSet = [];
    var rejRowDiffSet = [];

    var _selectModeMap$mode$c = _slicedToArray(selectModeMap[mode].calcDiff, 2),
        shouldSelect = _selectModeMap$mode$c[0],
        shouldReject = _selectModeMap$mode$c[1];

    Object(_operator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(rowDiffset, function (i) {
        var checkerResult = checker(i);
        checkerResult && shouldSelect && generateRowDiffset(newRowDiffSet, i, lastInsertedValueSel);
        !checkerResult && shouldReject && generateRowDiffset(rejRowDiffSet, i, lastInsertedValueRej);
    });
    return {
        rowDiffset: newRowDiffSet.join(','),
        rejectRowDiffset: rejRowDiffSet.join(',')
    };
};

var rowSplitDiffsetIterator = function rowSplitDiffsetIterator(rowDiffset, checker, mode, dimensionArr, fieldStoreObj) {
    var lastInsertedValue = {};
    var splitRowDiffset = {};
    var dimensionMap = {};

    Object(_operator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(rowDiffset, function (i) {
        if (checker(i)) {
            var hash = '';

            var dimensionSet = { keys: {} };

            dimensionArr.forEach(function (_) {
                var data = fieldStoreObj[_].partialField.data[i];
                hash = hash + '-' + data;
                dimensionSet.keys[_] = data;
            });

            if (splitRowDiffset[hash] === undefined) {
                splitRowDiffset[hash] = [];
                lastInsertedValue[hash] = -1;
                dimensionMap[hash] = dimensionSet;
            }

            generateRowDiffset(splitRowDiffset[hash], i, lastInsertedValue[hash]);
            lastInsertedValue[hash] = i;
        }
    });

    return {
        splitRowDiffset: splitRowDiffset,
        dimensionMap: dimensionMap
    };
};

var selectHelper = function selectHelper(clonedDm, selectFn, config, sourceDm, iterator) {
    var cachedStore = {};
    var cloneProvider = function cloneProvider() {
        return sourceDm.detachedRoot();
    };
    var mode = config.mode;

    var rowDiffset = clonedDm._rowDiffset;
    var cachedValueObjects = clonedDm.getPartialFieldspace()._cachedValueObjects;

    var selectorHelperFn = function selectorHelperFn(index) {
        return selectFn(cachedValueObjects[index], index, cloneProvider, cachedStore);
    };

    return iterator(rowDiffset, selectorHelperFn, mode);
};

var cloneWithAllFields = function cloneWithAllFields(model) {
    var clonedDm = model.clone(false);
    var partialFieldspace = model.getPartialFieldspace();
    clonedDm._colIdentifier = partialFieldspace.fields.map(function (f) {
        return f.name();
    }).join(',');

    // flush out cached namespace values on addition of new fields
    partialFieldspace._cachedFieldsObj = null;
    partialFieldspace._cachedDimension = null;
    partialFieldspace._cachedMeasure = null;
    clonedDm.__calculateFieldspace().calculateFieldsConfig();

    return clonedDm;
};

var splitWithSelect = function splitWithSelect(sourceDm, dimensionArr) {
    var reducerFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (val) {
        return val;
    };
    var config = arguments[3];
    var saveChild = config.saveChild;

    var fieldStoreObj = sourceDm.getFieldspace().fieldsObj();

    var _selectHelper = selectHelper(sourceDm.clone(saveChild), reducerFn, config, sourceDm, function () {
        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
        }

        return rowSplitDiffsetIterator.apply(undefined, params.concat([dimensionArr, fieldStoreObj]));
    }),
        splitRowDiffset = _selectHelper.splitRowDiffset,
        dimensionMap = _selectHelper.dimensionMap;

    var clonedDMs = [];
    Object.keys(splitRowDiffset).sort().forEach(function (e) {
        if (splitRowDiffset[e]) {
            var cloned = sourceDm.clone(saveChild);
            var derivation = dimensionMap[e];
            cloned._rowDiffset = splitRowDiffset[e].join(',');
            cloned.__calculateFieldspace().calculateFieldsConfig();

            var derivationFormula = function derivationFormula(fields) {
                return dimensionArr.every(function (_) {
                    return fields[_].internalValue === derivation.keys[_];
                });
            };
            // Store reference to child model and selector function
            if (saveChild) {
                persistDerivations(sourceDm, cloned, _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].SELECT, config, derivationFormula);
            }
            cloned._derivation[cloned._derivation.length - 1].meta = dimensionMap[e];

            clonedDMs.push(cloned);
        }
    });

    return clonedDMs;
};
var addDiffsetToClonedDm = function addDiffsetToClonedDm(clonedDm, rowDiffset, sourceDm, selectConfig, selectFn) {
    clonedDm._rowDiffset = rowDiffset;
    clonedDm.__calculateFieldspace().calculateFieldsConfig();
    persistDerivations(sourceDm, clonedDm, _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].SELECT, { config: selectConfig }, selectFn);
};

var cloneWithSelect = function cloneWithSelect(sourceDm, selectFn, selectConfig, cloneConfig) {
    var extraCloneDm = {};

    var mode = selectConfig.mode;


    var cloned = sourceDm.clone(cloneConfig.saveChild);
    var setOfRowDiffsets = selectHelper(cloned, selectFn, selectConfig, sourceDm, selectRowDiffsetIterator);
    var diffIndex = selectModeMap[mode].diffIndex;

    addDiffsetToClonedDm(cloned, setOfRowDiffsets[diffIndex[0]], sourceDm, selectConfig, selectFn);

    if (diffIndex.length > 1) {
        extraCloneDm = sourceDm.clone(cloneConfig.saveChild);
        addDiffsetToClonedDm(extraCloneDm, setOfRowDiffsets[diffIndex[1]], sourceDm, selectConfig, selectFn);
        return [cloned, extraCloneDm];
    }

    return cloned;
};

var cloneWithProject = function cloneWithProject(sourceDm, projField, config, allFields) {
    var cloned = sourceDm.clone(config.saveChild);
    var projectionSet = projField;
    if (config.mode === _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].INVERSE) {
        projectionSet = allFields.filter(function (fieldName) {
            return projField.indexOf(fieldName) === -1;
        });
    }
    // cloned._colIdentifier = sourceDm._colIdentifier.split(',')
    //                         .filter(coll => projectionSet.indexOf(coll) !== -1).join();
    cloned._colIdentifier = projectionSet.join(',');
    cloned.__calculateFieldspace().calculateFieldsConfig();

    persistDerivations(sourceDm, cloned, _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].PROJECT, { projField: projField, config: config, actualProjField: projectionSet }, null);

    return cloned;
};

var splitWithProject = function splitWithProject(sourceDm, projFieldSet, config, allFields) {
    return projFieldSet.map(function (projFields) {
        return cloneWithProject(sourceDm, projFields, config, allFields);
    });
};

var sanitizeUnitSchema = function sanitizeUnitSchema(unitSchema) {
    // Do deep clone of the unit schema as the user might change it later.
    unitSchema = Object(_utils__WEBPACK_IMPORTED_MODULE_8__["extend2"])({}, unitSchema);
    if (!unitSchema.type) {
        unitSchema.type = _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
    }

    if (!unitSchema.subtype) {
        switch (unitSchema.type) {
            case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE:
                unitSchema.subtype = _enums__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS;
                break;
            default:
            case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION:
                unitSchema.subtype = _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL;
                break;
        }
    }

    return unitSchema;
};

var validateUnitSchema = function validateUnitSchema(unitSchema) {
    var supportedMeasureSubTypes = [_enums__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS];
    var supportedDimSubTypes = [_enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL, _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED, _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL, _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].GEO, _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].BINNED_GEO];
    var type = unitSchema.type,
        subtype = unitSchema.subtype,
        name = unitSchema.name;

    switch (type) {
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION:
            if (!supportedDimSubTypes.includes(subtype)) {
                throw new Error('DataModel doesn\'t support dimension field subtype ' + subtype + ' used for ' + name + ' field');
            }
            break;
        case _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE:
            if (!supportedMeasureSubTypes.includes(subtype)) {
                throw new Error('DataModel doesn\'t support measure field subtype ' + subtype + ' used for ' + name + ' field');
            }
            break;
        default:
            throw new Error('DataModel doesn\'t support field type ' + type + ' used for ' + name + ' field');
    }
};

var sanitizeAndValidateSchema = function sanitizeAndValidateSchema(schema) {
    return schema.map(function (unitSchema) {
        unitSchema = sanitizeUnitSchema(unitSchema);
        validateUnitSchema(unitSchema);
        return unitSchema;
    });
};

var resolveFieldName = function resolveFieldName(schema, dataHeader) {
    schema.forEach(function (unitSchema) {
        var fieldNameAs = unitSchema.as;
        if (!fieldNameAs) {
            return;
        }

        var idx = dataHeader.indexOf(unitSchema.name);
        dataHeader[idx] = fieldNameAs;
        unitSchema.name = fieldNameAs;
        delete unitSchema.as;
    });
};

var addGeometrySchemaField = function addGeometrySchemaField(schema, dataHeader) {
    if (schema.length !== dataHeader.length && dataHeader.includes(_constants__WEBPACK_IMPORTED_MODULE_4__["GEOM_FIELD"])) {
        schema.push({ name: _constants__WEBPACK_IMPORTED_MODULE_4__["GEOM_FIELD"], type: _enums__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION, subtype: _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].GEO });
    }
};

var updateData = function updateData(relation, data, schema, options) {
    schema = sanitizeAndValidateSchema(schema);
    options = Object.assign(Object.assign({}, _default_config__WEBPACK_IMPORTED_MODULE_6__["default"]), options);
    var converterFn = _converter__WEBPACK_IMPORTED_MODULE_7__[options.dataFormat];

    if (!(converterFn && typeof converterFn === 'function')) {
        throw new Error('No converter function found for ' + options.dataFormat + ' format');
    }

    var _converterFn = converterFn(data, schema, options),
        _converterFn2 = _slicedToArray(_converterFn, 2),
        header = _converterFn2[0],
        formattedData = _converterFn2[1];

    addGeometrySchemaField(schema, header);
    resolveFieldName(schema, header);
    var fieldArr = Object(_field_creator__WEBPACK_IMPORTED_MODULE_5__["createFields"])(formattedData, schema, header);

    // This will create a new fieldStore with the fields
    var nameSpace = _field_store__WEBPACK_IMPORTED_MODULE_1__["default"].createNamespace(fieldArr, options.name);
    relation._partialFieldspace = nameSpace;

    // If data is provided create the default colIdentifier and rowDiffset
    relation._rowDiffset = formattedData.length && formattedData[0].length ? '0-' + (formattedData[0].length - 1) : '';

    // This stores the value objects which is passed to the filter method when selection operation is done.
    var valueObjects = [];
    var fields = nameSpace.fields;

    var rawFieldsData = fields.map(function (field) {
        return field.data();
    });
    var formattedFieldsData = fields.map(function (field) {
        return field.formattedData();
    });
    Object(_operator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(relation._rowDiffset, function (i) {
        valueObjects[i] = prepareSelectionData(fields, formattedFieldsData, rawFieldsData, i);
    });
    nameSpace._cachedValueObjects = valueObjects;

    relation._colIdentifier = schema.map(function (_) {
        return _.name;
    }).join();
    relation._dataFormat = options.dataFormat === _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].AUTO ? Object(_utils__WEBPACK_IMPORTED_MODULE_8__["detectDataFormat"])(data) : options.dataFormat;
    return relation;
};

var fieldInSchema = function fieldInSchema(schema, field) {
    var i = 0;

    for (; i < schema.length; ++i) {
        if (field === schema[i].name) {
            return {
                name: field,
                type: schema[i].subtype || schema[i].type,
                index: i
            };
        }
    }
    return null;
};

var getDerivationArguments = function getDerivationArguments(derivation) {
    var params = [];
    var operation = void 0;
    operation = derivation.op;
    switch (operation) {
        case _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].SELECT:
            params = [derivation.criteria];
            break;
        case _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].PROJECT:
            params = [derivation.meta.actualProjField];
            break;
        case _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].SORT:
            params = [derivation.criteria];
            break;
        case _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].GROUPBY:
            operation = 'groupBy';
            params = [derivation.meta.groupByString.split(','), derivation.criteria];
            break;
        default:
            operation = null;
    }

    return {
        operation: operation,
        params: params
    };
};

var applyExistingOperationOnModel = function applyExistingOperationOnModel(propModel, dataModel) {
    var derivations = dataModel.getDerivations();
    var selectionModel = propModel;

    derivations.forEach(function (derivation) {
        if (!derivation) {
            return;
        }

        var _getDerivationArgumen = getDerivationArguments(derivation),
            operation = _getDerivationArgumen.operation,
            params = _getDerivationArgumen.params;

        if (operation) {
            var _selectionModel;

            selectionModel = (_selectionModel = selectionModel)[operation].apply(_selectionModel, _toConsumableArray(params).concat([{
                saveChild: false
            }]));
        }
    });

    return selectionModel;
};

var getFilteredModel = function getFilteredModel(propModel, path) {
    for (var i = 0, len = path.length; i < len; i++) {
        var model = path[i];
        propModel = applyExistingOperationOnModel(propModel, model);
    }
    return propModel;
};

var propagateIdentifiers = function propagateIdentifiers(dataModel, propModel) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var propModelInf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var nonTraversingModel = propModelInf.nonTraversingModel;
    var excludeModels = propModelInf.excludeModels || [];

    if (dataModel === nonTraversingModel) {
        return;
    }

    var propagate = excludeModels.length ? excludeModels.indexOf(dataModel) === -1 : true;

    propagate && dataModel.handlePropagation(propModel, config);

    var children = dataModel._children;
    children.forEach(function (child) {
        var selectionModel = applyExistingOperationOnModel(propModel, child);
        propagateIdentifiers(child, selectionModel, config, propModelInf);
    });
};

var getRootGroupByModel = function getRootGroupByModel(model) {
    while (model._parent && model._derivation.find(function (d) {
        return d.op !== _constants__WEBPACK_IMPORTED_MODULE_4__["DM_DERIVATIVES"].GROUPBY;
    })) {
        model = model._parent;
    }
    return model;
};

var getRootDataModel = function getRootDataModel(model) {
    while (model._parent) {
        model = model._parent;
    }
    return model;
};

var getPathToRootModel = function getPathToRootModel(model) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    while (model._parent) {
        path.push(model);
        model = model._parent;
    }
    return path;
};

var getKey = function getKey(arr, data, fn, rowId) {
    var key = fn(arr, data, 0, rowId);

    for (var i = 1, len = arr.length; i < len; i++) {
        key = key + ',' + fn(arr, data, i, rowId);
    }
    return key;
};

var filterPropagationModel = function filterPropagationModel(model, propModels) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var fns = [];
    var operation = config.operation || _constants__WEBPACK_IMPORTED_MODULE_4__["LOGICAL_OPERATORS"].AND;
    var filterByMeasure = config.filterByMeasure || false;
    var checkUids = config.checkUids !== undefined ? config.checkUids : true;
    var clonedModel = cloneWithAllFields(model);
    var modelFieldsConfig = clonedModel.getFieldsConfig();

    if (!propModels.length) {
        fns = [function () {
            return false;
        }];
    } else {
        fns = propModels.map(function (propModel) {
            return function (dataModel) {
                var keyFn = void 0;
                var dataObj = dataModel.getData();
                var fieldsConfig = dataModel.getFieldsConfig();

                var dimensions = Object.keys(dataModel.getFieldspace().getDimension()).filter(function (d) {
                    return checkUids ? d in modelFieldsConfig || d === _constants__WEBPACK_IMPORTED_MODULE_4__["ROW_ID"] : d in modelFieldsConfig;
                });

                var dLen = dimensions.length;
                var indices = dimensions.map(function (d) {
                    return fieldsConfig[d].index;
                });
                var measures = Object.keys(dataModel.getFieldspace().getMeasure()).filter(function (d) {
                    return d in modelFieldsConfig;
                });
                var fieldsSpace = dataModel.getFieldspace().fieldsObj();
                var data = dataObj.data;
                var domain = measures.reduce(function (acc, v) {
                    acc[v] = fieldsSpace[v].domain();
                    return acc;
                }, {});
                var valuesMap = {};

                keyFn = function keyFn(arr, row, idx) {
                    var val = row[arr[idx]];

                    return val instanceof _geo_geometry__WEBPACK_IMPORTED_MODULE_9__["default"] ? val.bounds() : val;
                };

                if (dLen) {
                    data.forEach(function (row) {
                        var key = getKey(indices, row, keyFn);
                        valuesMap[key] = 1;
                    });
                }

                keyFn = function keyFn(arr, fields, idx, rowId) {
                    var val = fields[arr[idx]].internalValue;
                    var hash = val instanceof _geo_geometry__WEBPACK_IMPORTED_MODULE_9__["default"] ? val.bounds() : val;
                    return arr[idx] === _constants__WEBPACK_IMPORTED_MODULE_4__["ROW_ID"] ? rowId : hash;
                };

                return data.length ? function (fields, i) {
                    var present = dLen ? valuesMap[getKey(dimensions, fields, keyFn, i)] : true;

                    if (filterByMeasure) {
                        return measures.every(function (field) {
                            return fields[field].internalValue >= domain[field][0] && fields[field].internalValue <= domain[field][1];
                        }) && present;
                    }
                    return present;
                } : function () {
                    return false;
                };
            }(propModel);
        });
    }

    var filteredModel = void 0;
    if (operation === _constants__WEBPACK_IMPORTED_MODULE_4__["LOGICAL_OPERATORS"].AND) {
        filteredModel = clonedModel.select(function (fields, i) {
            return fns.every(function (fn) {
                return fn(fields, i);
            });
        }, {
            saveChild: false
        });
    } else {
        filteredModel = clonedModel.select(function (fields, i) {
            return fns.some(function (fn) {
                return fn(fields, i);
            });
        }, {
            saveChild: false
        });
    }

    return filteredModel;
};

var propagateToAllDataModels = function propagateToAllDataModels(identifiers, rootModels, propagationInf, config) {
    var criteria = void 0;
    var propModel = void 0;
    var propagationNameSpace = propagationInf.propagationNameSpace,
        propagateToSource = propagationInf.propagateToSource;

    var propagationSourceId = propagationInf.sourceId;
    var propagateInterpolatedValues = config.propagateInterpolatedValues;
    var filterFn = function filterFn(entry) {
        var filter = config.filterFn || function () {
            return true;
        };
        return filter(entry, config);
    };

    var criterias = [];

    if (identifiers === null && config.persistent !== true) {
        criterias = [{
            criteria: []
        }];
        criteria = [];
    } else {
        var _ref5;

        var actionCriterias = Object.values(propagationNameSpace.mutableActions);
        if (propagateToSource !== false) {
            actionCriterias = actionCriterias.filter(function (d) {
                return d.config.sourceId !== propagationSourceId;
            });
        }

        var filteredCriteria = actionCriterias.filter(filterFn).map(function (action) {
            return action.config.criteria;
        });

        var excludeModels = [];

        if (propagateToSource !== false) {
            var sourceActionCriterias = Object.values(propagationNameSpace.mutableActions);

            sourceActionCriterias.forEach(function (actionInf) {
                var actionConf = actionInf.config;
                if (actionConf.applyOnSource === false && actionConf.action === config.action && actionConf.sourceId !== propagationSourceId) {
                    excludeModels.push(actionInf.model);
                    criteria = sourceActionCriterias.filter(function (d) {
                        return d !== actionInf;
                    }).map(function (d) {
                        return d.config.criteria;
                    });
                    criteria.length && criterias.push({
                        criteria: criteria,
                        models: actionInf.model,
                        path: getPathToRootModel(actionInf.model)
                    });
                }
            });
        }

        criteria = (_ref5 = []).concat.apply(_ref5, [].concat(_toConsumableArray(filteredCriteria), [identifiers])).filter(function (d) {
            return d !== null;
        });
        criterias.push({
            criteria: criteria,
            excludeModels: [].concat(excludeModels, _toConsumableArray(config.excludeModels || []))
        });
    }

    var rootModel = rootModels.model;

    var propConfig = Object.assign({
        sourceIdentifiers: identifiers,
        propagationSourceId: propagationSourceId
    }, config);

    var rootGroupByModel = rootModels.groupByModel;
    if (propagateInterpolatedValues && rootGroupByModel) {
        propModel = filterPropagationModel(rootGroupByModel, criteria, {
            filterByMeasure: propagateInterpolatedValues
        });
        propagateIdentifiers(rootGroupByModel, propModel, propConfig);
    }

    criterias.forEach(function (inf) {
        var propagationModel = filterPropagationModel(rootModel, inf.criteria, {
            checkUids: rootGroupByModel && propagateInterpolatedValues
        });
        var path = inf.path;

        if (path) {
            var filteredModel = getFilteredModel(propagationModel, path.reverse());
            inf.models.handlePropagation(filteredModel, propConfig);
        } else {
            propagateIdentifiers(rootModel, propagationModel, propConfig, {
                excludeModels: inf.excludeModels,
                nonTraversingModel: propagateInterpolatedValues && rootGroupByModel
            });
        }
    });
};

var propagateImmutableActions = function propagateImmutableActions(propagationNameSpace, rootModels, propagationInf) {
    var immutableActions = propagationNameSpace.immutableActions;

    for (var action in immutableActions) {
        var actionInf = immutableActions[action];
        var actionConf = actionInf.config;
        var propagationSourceId = propagationInf.config.sourceId;
        var filterImmutableAction = propagationInf.propConfig.filterImmutableAction ? propagationInf.propConfig.filterImmutableAction(actionConf, propagationInf.config) : true;
        if (actionConf.sourceId !== propagationSourceId && filterImmutableAction) {
            var criteriaModel = actionConf.criteria;
            propagateToAllDataModels(criteriaModel, rootModels, {
                propagationNameSpace: propagationNameSpace,
                propagateToSource: false,
                sourceId: propagationSourceId
            }, actionConf);
        }
    }
};

var addToPropNamespace = function addToPropNamespace(propagationNameSpace) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var model = arguments[2];

    var sourceNamespace = void 0;
    var isMutableAction = config.isMutableAction;
    var criteria = config.criteria;
    var key = config.action + '-' + config.sourceId;

    if (isMutableAction) {
        sourceNamespace = propagationNameSpace.mutableActions;
    } else {
        sourceNamespace = propagationNameSpace.immutableActions;
    }

    if (criteria === null) {
        delete sourceNamespace[key];
    } else {
        sourceNamespace[key] = {
            model: model,
            config: config
        };
    }

    return _this;
};

var getNormalizedProFields = function getNormalizedProFields(projField, allFields, fieldConfig) {
    var normalizedProjField = projField.reduce(function (acc, field) {
        if (field.constructor.name === 'RegExp') {
            acc.push.apply(acc, _toConsumableArray(allFields.filter(function (fieldName) {
                return fieldName.search(field) !== -1;
            })));
        } else if (field in fieldConfig) {
            acc.push(field);
        }
        return acc;
    }, []);
    return Array.from(new Set(normalizedProjField)).map(function (field) {
        return field.trim();
    });
};

/**
 * Get the numberFormatted value if numberFormat present,
 * else returns the supplied value.
 * @param {Object} field Field Instance
 * @param {Number|String} value
 * @return {Number|String}
 */
var getNumberFormattedVal = function getNumberFormattedVal(field, value) {
    if (field.numberFormat) {
        return field.numberFormat()(value);
    }
    return value;
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataModel = __webpack_require__(/*! ./export */ "./src/export.js");

module.exports = DataModel.default ? DataModel.default : DataModel;

/***/ }),

/***/ "./src/invalid-aware-types.js":
/*!************************************!*\
  !*** ./src/invalid-aware-types.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A parser to parser null, undefined, invalid and NIL values.
 *
 * @public
 * @class
 */
var InvalidAwareTypes = function () {
    _createClass(InvalidAwareTypes, null, [{
        key: 'invalidAwareVals',

        /**
         * Static method which gets/sets the invalid value registry.
         *
         * @public
         * @param {Object} config - The custom configuration supplied by user.
         * @return {Object} Returns the invalid values registry.
         */
        value: function invalidAwareVals(config) {
            if (!config) {
                return InvalidAwareTypes._invalidAwareValsMap;
            }
            return Object.assign(InvalidAwareTypes._invalidAwareValsMap, config);
        }

        /**
         * Initialize a new instance.
         *
         * @public
         * @param {string} value - The value of the invalid data type.
         */

    }]);

    function InvalidAwareTypes(value) {
        _classCallCheck(this, InvalidAwareTypes);

        this._value = value;
    }

    /**
     * Returns the current value of the instance.
     *
     * @public
     * @return {string} Returns the value of the invalid data type.
     */


    _createClass(InvalidAwareTypes, [{
        key: 'value',
        value: function value() {
            return this._value;
        }

        /**
         * Returns the current value of the instance in string format.
         *
         * @public
         * @return {string} Returns the value of the invalid data type.
         */

    }, {
        key: 'toString',
        value: function toString() {
            return String(this._value);
        }
    }], [{
        key: 'isInvalid',
        value: function isInvalid(val) {
            return val instanceof InvalidAwareTypes || !!InvalidAwareTypes.invalidAwareVals()[val];
        }
    }, {
        key: 'getInvalidType',
        value: function getInvalidType(val) {
            return val instanceof InvalidAwareTypes ? val : InvalidAwareTypes.invalidAwareVals()[val];
        }
    }]);

    return InvalidAwareTypes;
}();

/**
 * Enums for Invalid types.
 */


InvalidAwareTypes.NULL = new InvalidAwareTypes('null');
InvalidAwareTypes.NA = new InvalidAwareTypes('na');
InvalidAwareTypes.NIL = new InvalidAwareTypes('nil');

/**
 * Default Registry for mapping the invalid values.
 *
 * @private
 */
InvalidAwareTypes._invalidAwareValsMap = {
    invalid: InvalidAwareTypes.NA,
    nil: InvalidAwareTypes.NIL,
    null: InvalidAwareTypes.NULL,
    undefined: InvalidAwareTypes.NA
};

/* harmony default export */ __webpack_exports__["default"] = (InvalidAwareTypes);

/***/ }),

/***/ "./src/operator/bucket-creator.js":
/*!****************************************!*\
  !*** ./src/operator/bucket-creator.js ***!
  \****************************************/
/*! exports provided: createBinnedFieldData, createBinnedGeoData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBinnedFieldData", function() { return createBinnedFieldData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBinnedGeoData", function() { return createBinnedGeoData; });
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../invalid-aware-types */ "./src/invalid-aware-types.js");
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/geo */ "./src/utils/geo.js");
/* harmony import */ var _utils_r_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/r-tree */ "./src/utils/r-tree.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony import */ var _enums_geo_bin_shapes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums/geo-bin-shapes */ "./src/enums/geo-bin-shapes.js");
/* harmony import */ var _hexbin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hexbin */ "./src/operator/hexbin.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var generateBuckets = function generateBuckets(binSize, start, end) {
    var buckets = [];
    var next = start;

    while (next < end) {
        buckets.push(next);
        next += binSize;
    }
    buckets.push(next);

    return buckets;
};

var findBucketRange = function findBucketRange(bucketRanges, value) {
    var leftIdx = 0;
    var rightIdx = bucketRanges.length - 1;
    var midIdx = void 0;
    var range = void 0;

    // Here use binary search as the bucketRanges is a sorted array
    while (leftIdx <= rightIdx) {
        midIdx = leftIdx + Math.floor((rightIdx - leftIdx) / 2);
        range = bucketRanges[midIdx];

        if (value >= range.start && value < range.end) {
            return range;
        } else if (value >= range.end) {
            leftIdx = midIdx + 1;
        } else if (value < range.start) {
            rightIdx = midIdx - 1;
        }
    }

    return null;
};

/**
 * Creates the bin data from input measure field and supplied configs.
 *
 * @param {Measure} measureField - The Measure field instance.
 * @param {string} rowDiffset - The datamodel rowDiffset values.
 * @param {Object} config - The config object.
 * @return {Object} Returns the binned data and the corresponding bins.
 */
function createBinnedFieldData(measureField, rowDiffset, config) {
    var buckets = config.buckets,
        binsCount = config.binsCount,
        binSize = config.binSize,
        start = config.start,
        end = config.end;

    var _measureField$domain = measureField.domain(),
        _measureField$domain2 = _slicedToArray(_measureField$domain, 2),
        dMin = _measureField$domain2[0],
        dMax = _measureField$domain2[1];

    if (!buckets) {
        start = start !== 0 && (!start || start > dMin) ? dMin : start;
        end = end !== 0 && (!end || end < dMax) ? dMax + 1 : end;

        if (binsCount) {
            binSize = Math.ceil(Math.abs(end - start) / binsCount);
        }

        buckets = generateBuckets(binSize, start, end);
    }

    if (buckets[0] > dMin) {
        buckets.unshift(dMin);
    }
    if (buckets[buckets.length - 1] <= dMax) {
        buckets.push(dMax + 1);
    }

    var bucketRanges = [];
    for (var i = 0; i < buckets.length - 1; i++) {
        bucketRanges.push({
            start: buckets[i],
            end: buckets[i + 1]
        });
    }

    var binnedData = [];
    Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(rowDiffset, function (i) {
        var datum = measureField.partialField.data[i];
        if (datum instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            binnedData.push(datum);
            return;
        }

        var range = findBucketRange(bucketRanges, datum);
        binnedData.push(range.start + '-' + range.end);
    });

    return { binnedData: binnedData, bins: buckets };
}

var bucketCreators = _defineProperty({}, _enums_geo_bin_shapes__WEBPACK_IMPORTED_MODULE_5__["GEO_BIN_SHAPES"].HEX, _hexbin__WEBPACK_IMPORTED_MODULE_6__["hexbin"]);

var createBinnedGeoData = function createBinnedGeoData(field, rowDiffset, config) {
    var buckets = config.buckets;
    var binSize = config.binSize,
        shapeType = config.shapeType,
        units = config.units;
    var data = field.partialField.data;


    if (!buckets) {
        var bucketCreatorFn = bucketCreators[shapeType];

        if (shapeType in bucketCreators) {
            buckets = bucketCreatorFn(field.bounds(), binSize, { units: units });
        } else {
            throw new Error('Unsupported shape for binning');
        }
    }

    var binnedData = [];
    var points = [];
    Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(rowDiffset, function (i) {
        var datum = data[i];
        if (!(datum instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            points.push({
                geometry: datum,
                id: i
            });
        }
        binnedData[i] = null;
    });

    var rtree = new _utils_r_tree__WEBPACK_IMPORTED_MODULE_3__["default"](6);

    var treeItems = points.map(function (item) {
        var coords = item.geometry.center();
        return {
            minX: coords[0],
            minY: coords[1],
            maxX: coords[0],
            maxY: coords[1],
            id: item.id
        };
    });

    rtree.load(treeItems);
    var Polygon = _enums__WEBPACK_IMPORTED_MODULE_4__["GeomTypes"].Polygon;


    buckets.forEach(function (poly) {
        var coordinates = poly.coordinates.flat();
        var bbox = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["bounds"])(coordinates).flat();
        var potentialPoints = rtree.search({ minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3] });

        potentialPoints.forEach(function (pt) {
            if (Object(_utils_geo__WEBPACK_IMPORTED_MODULE_2__["includes"])(coordinates, [pt.minX, pt.minY])) {
                binnedData[pt.id] = {
                    center: poly.center,
                    side: poly.side,
                    radius: poly.radius,
                    type: Polygon,
                    coordinates: poly.coordinates
                };
            }
        });
    });

    return binnedData;
};

/***/ }),

/***/ "./src/operator/compose.js":
/*!*********************************!*\
  !*** ./src/operator/compose.js ***!
  \*********************************/
/*! exports provided: select, project, bin, groupBy, compose */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select", function() { return select; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "project", function() { return project; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bin", function() { return bin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return groupBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper */ "./src/helper.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants/index.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }




/**
 * DataModel's opearators are exposed as composable functional operators as well as chainable operators. Chainable
 * operators are called on the instances of {@link Datamodel} and {@link Relation} class.
 *
 * Those same operators can be used as composable operators from `DataModel.Operators` namespace.
 *
 * All these operators have similar behaviour. All these operators when called with the argument returns a function
 * which expects a DataModel instance.
 *
 * @public
 * @module Operators
 * @namespace DataModel
 */

/**
 * This is functional version of selection operator. {@link link_to_selection | Selection} is a row filtering operation.
 * It takes {@link SelectionPredicate | predicate} for filtering criteria and returns a function.
 * The returned function is called with the DataModel instance on which the action needs to be performed.
 *
 * {@link SelectionPredicate} is a function which returns a boolean value. For selection opearation the selection
 * function is called for each row of DataModel instance with the current row passed as argument.
 *
 * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry
 * of rejection set.
 *
 * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the
 * resulatant datamodel.
 *
 * @warning
 * [Warn] Selection and rejection set is only a logical idea for concept explanation purpose.
 *
 * @error
 * [Error] `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the
 * chained version.
 *
 * @example
 * const select = DataModel.Operators.select;
 * usaCarsFn = select(fields => fields.Origin.value === 'USA');
 * usaCarsDm = usaCarsFn(dm);
 * console.log(usaCarsDm);
 *
 * @public
 * @namespace DataModel
 * @module Operators
 *
 * @param {SelectionPredicate} selectFn - Predicate funciton which is called for each row with the current row
 *      ```
 *          function (row, i)  { ... }
 *      ```
 * @param {Object} [config] - The configuration object to control the inclusion exclusion of a row in resultant
 *      DataModel instance
 * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection
 *
 * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be
 *      applied.
 */
var select = function select() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return function (dm) {
        return dm.select.apply(dm, args);
    };
};

/**
 * This is functional version of projection operator. {@link link_to_projection | Projection} is a column filtering
 * operation.It expects list of fields name and either include those or exclude those based on {@link FilteringMode} on
 * the  resultant variable.It returns a function which is called with the DataModel instance on which the action needs
 * to be performed.
 *
 * Projection expects array of fields name based on which it creates the selection and rejection set. All the field
 * whose name is present in array goes in selection set and rest of the fields goes in rejection set.
 *
 * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the
 * resulatant datamodel.
 *
 * @warning
 * Selection and rejection set is only a logical idea for concept explanation purpose.
 *
 * @error
 * `FilteringMode.ALL` is not a valid working mode for functional version of `select`. Its only avialable on the
 * chained version.
 *
 * @public
 * @namespace DataModel
 * @module Operators
 *
 * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.
 * @param {Object} [config] - An optional config to control the creation of new DataModel
 * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection
 *
 * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be
 *      applied.
 */
var project = function project() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
    }

    return function (dm) {
        return dm.project.apply(dm, args);
    };
};

/**
 * This is functional version of binnig operator. Binning happens on a measure field based on a binning configuration.
 * Binning in DataModel does not aggregate the number of rows present in DataModel instance after binning, it just adds
 * a new field with the binned value. Refer binning {@link example_of_binning | example} to have a intuition of what
 * binning is and the use case.
 *
 * Binning can be configured by
 * - providing custom bin configuration with non uniform buckets
 * - providing bin count
 * - providing each bin size
 *
 * When custom buckets are provided as part of binning configuration
 * @example
 *  // DataModel already prepared and assigned to dm vairable
 *  const buckets = {
 *      start: 30
 *      stops: [80, 100, 110]
 *  };
 *  const config = { buckets, name: 'binnedHP' }
 *  const binFn = bin('horsepower', config);
 *  const binnedDm = binFn(dm);
 *
 * @text
 * When `binCount` is defined as part of binning configuration
 * @example
 *  // DataModel already prepared and assigned to dm vairable
 *  const config = { binCount: 5, name: 'binnedHP' }
 *  const binFn = bin('horsepower', config);
 *  const binnedDm = binFn(Dm);
 *
 * @text
 * When `binSize` is defined as part of binning configuration
 * @example
 *  // DataModel already prepared and assigned to dm vairable
 *  const config = { binSize: 200, name: 'binnedHorsepower' }
 *  const binnedDm = dataModel.bin('horsepower', config);
 *  const binnedDm = binFn(Dm);
 *
 * @public
 * @namespace DataModel
 * @module Operators
 *
 * @param {String} name Name of measure which will be used to create bin
 * @param {Object} config Config required for bin creation
 * @param {Array.<Number>} config.bucketObj.stops Defination of bucket ranges. Two subsequent number from arrays
 *      are picked and a range is created. The first number from range is inclusive and the second number from range
 *      is exclusive.
 * @param {Number} [config.bucketObj.startAt] Force the start of the bin from a particular number.
 *      If not mentioned, the start of the bin or the lower domain of the data if stops is not mentioned, else its
 *      the first value of the stop.
 * @param {Number} config.binSize Bucket size for each bin
 * @param {Number} config.binCount Number of bins which will be created
 * @param {String} config.name Name of the new binned field to be created
 *
 * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be
 *      applied.
 */
var bin = function bin() {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
    }

    return function (dm) {
        return dm.bin.apply(dm, args);
    };
};

/**
 * This is functional version of `groupBy` operator.Groups the data using particular dimensions and by reducing
 * measures. It expects a list of dimensions using which it projects the datamodel and perform aggregations to reduce
 * the duplicate tuples. Refer this {@link link_to_one_example_with_group_by | document} to know the intuition behind
 * groupBy.
 *
 * DataModel by default provides definition of few {@link reducer | Reducers}.
 * {@link ReducerStore | User defined reducers} can also be registered.
 *
 * This is the chained implementation of `groupBy`.
 * `groupBy` also supports {@link link_to_compose_groupBy | composability}
 *
 * @example
 * const groupBy = DataModel.Operators.groupBy;
 * const groupedFn = groupBy(['Year'], { horsepower: 'max' } );
 * groupedDM = groupByFn(dm);
 *
 * @public
 *
 * @param {Array.<string>} fieldsArr - Array containing the name of dimensions
 * @param {Object} [reducers={}] - A map whose key is the variable name and value is the name of the reducer. If its
 *      not passed, or any variable is ommitted from the object, default aggregation function is used from the
 *      schema of the variable.
 *
 * @return {PreparatorFunction} Function which expects an instance of DataModel on which the operator needs to be
 *      applied.
 */
var groupBy = function groupBy() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
    }

    return function (dm) {
        return dm.groupBy.apply(dm, args);
    };
};

/**
 * Enables composing operators to run multiple operations and save group of operataion as named opration on a DataModel.
 * The resulting DataModel will be the result of all the operation provided. The operations provided will be executed in
 * a serial manner ie. result of one operation will be the input for the next operations (like pipe operator in unix).
 *
 * Suported operations in compose are
 * - `select`
 * - `project`
 * - `groupBy`
 * - `bin`
 * - `compose`
 *
 * @example
 * const compose = DataModel.Operators.compose;
 * const select = DataModel.Operators.select;
 * const project = DataModel.Operators.project;
 *
 * let composedFn = compose(
 *    select(fields => fields.netprofit.value <= 15),
 *    project(['netprofit', 'netsales']));
 *
 * const dataModel = new DataModel(data1, schema1);
 *
 * let composedDm = composedFn(dataModel);
 *
 * @public
 * @namespace DataModel
 * @module Operators
 *
 * @param {Array.<Operators>} operators: An array of operation that will be applied on the
 * datatable.
 *
 * @returns {DataModel} Instance of resultant DataModel
 */
var compose = function compose() {
    for (var _len5 = arguments.length, operations = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        operations[_key5] = arguments[_key5];
    }

    return function (dm) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { saveChild: true };

        var currentDM = dm;
        var firstChild = void 0;
        var derivations = [];

        operations.forEach(function (operation) {
            currentDM = operation(currentDM);
            derivations.push.apply(derivations, _toConsumableArray(currentDM._derivation));
            if (!firstChild) {
                firstChild = currentDM;
            }
        });

        if (firstChild && firstChild !== currentDM) {
            firstChild.dispose();
        }

        // reset all ancestorDerivation saved in-between compose
        currentDM._ancestorDerivation = [];
        Object(_helper__WEBPACK_IMPORTED_MODULE_0__["persistDerivations"])(dm, currentDM, _constants__WEBPACK_IMPORTED_MODULE_1__["DM_DERIVATIVES"].COMPOSE, null, derivations);

        if (config.saveChild) {
            currentDM.setParent(dm);
        } else {
            currentDM.setParent(null);
        }

        return currentDM;
    };
};

/***/ }),

/***/ "./src/operator/cross-product.js":
/*!***************************************!*\
  !*** ./src/operator/cross-product.js ***!
  \***************************************/
/*! exports provided: crossProduct */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossProduct", function() { return crossProduct; });
/* harmony import */ var _datamodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datamodel */ "./src/datamodel.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _get_common_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-common-schema */ "./src/operator/get-common-schema.js");
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./src/constants/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helper */ "./src/helper.js");






/**
 * Default filter function for crossProduct.
 *
 * @return {boolean} Always returns true.
 */
function defaultFilterFn() {
    return true;
}

/**
 * Implementation of cross product operation between two DataModel instances.
 * It internally creates the data and schema for the new DataModel.
 *
 * @param {DataModel} dataModel1 - The left DataModel instance.
 * @param {DataModel} dataModel2 - The right DataModel instance.
 * @param {Function} filterFn - The filter function which is used to filter the tuples.
 * @param {boolean} [replaceCommonSchema=false] - The flag if the common name schema should be there.
 * @return {DataModel} Returns The newly created DataModel instance from the crossProduct operation.
 */
function crossProduct(dm1, dm2, filterFn) {
    var replaceCommonSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var jointype = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _constants__WEBPACK_IMPORTED_MODULE_4__["JOINS"].CROSS;

    var schema = [];
    var data = [];
    var applicableFilterFn = filterFn || defaultFilterFn;
    var dm1FieldStore = dm1.getFieldspace();
    var dm2FieldStore = dm2.getFieldspace();
    var dm1FieldStoreName = dm1FieldStore.name;
    var dm2FieldStoreName = dm2FieldStore.name;
    var name = dm1FieldStore.name + '.' + dm2FieldStore.name;
    var commonSchemaList = Object(_get_common_schema__WEBPACK_IMPORTED_MODULE_2__["getCommonSchema"])(dm1FieldStore, dm2FieldStore);

    if (dm1FieldStoreName === dm2FieldStoreName) {
        throw new Error('DataModels must have different alias names');
    }
    // Here prepare the schema
    dm1FieldStore.fields.forEach(function (field) {
        var tmpSchema = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extend2"])({}, field.schema());
        if (commonSchemaList.indexOf(tmpSchema.name) !== -1 && !replaceCommonSchema) {
            tmpSchema.name = dm1FieldStore.name + '.' + tmpSchema.name;
        }
        schema.push(tmpSchema);
    });
    dm2FieldStore.fields.forEach(function (field) {
        var tmpSchema = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extend2"])({}, field.schema());
        if (commonSchemaList.indexOf(tmpSchema.name) !== -1) {
            if (!replaceCommonSchema) {
                tmpSchema.name = dm2FieldStore.name + '.' + tmpSchema.name;
                schema.push(tmpSchema);
            }
        } else {
            schema.push(tmpSchema);
        }
    });

    // Here prepare Data
    Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(dm1._rowDiffset, function (i) {
        var rowAdded = false;
        var rowPosition = void 0;
        Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_3__["rowDiffsetIterator"])(dm2._rowDiffset, function (ii) {
            var tuple = [];
            var userArg = {};
            userArg[dm1FieldStoreName] = {};
            userArg[dm2FieldStoreName] = {};
            dm1FieldStore.fields.forEach(function (field) {
                tuple.push(field.partialField.data[i]);
                userArg[dm1FieldStoreName][field.name()] = {
                    rawValue: field.partialField.data[i],
                    formattedValue: field.formattedData()[i]
                };
            });
            dm2FieldStore.fields.forEach(function (field) {
                if (!(commonSchemaList.indexOf(field.schema().name) !== -1 && replaceCommonSchema)) {
                    tuple.push(field.partialField.data[ii]);
                }
                userArg[dm2FieldStoreName][field.name()] = {
                    rawValue: field.partialField.data[ii],
                    formattedValue: field.formattedData()[ii]
                };
            });

            var cachedStore = {};
            var cloneProvider1 = function cloneProvider1() {
                return dm1.detachedRoot();
            };
            var cloneProvider2 = function cloneProvider2() {
                return dm2.detachedRoot();
            };

            var dm1Fields = Object(_helper__WEBPACK_IMPORTED_MODULE_5__["prepareJoinData"])(userArg[dm1FieldStoreName]);
            var dm2Fields = Object(_helper__WEBPACK_IMPORTED_MODULE_5__["prepareJoinData"])(userArg[dm2FieldStoreName]);
            if (applicableFilterFn(dm1Fields, dm2Fields, cloneProvider1, cloneProvider2, cachedStore)) {
                var tupleObj = {};
                tuple.forEach(function (cellVal, iii) {
                    tupleObj[schema[iii].name] = cellVal;
                });
                if (rowAdded && _constants__WEBPACK_IMPORTED_MODULE_4__["JOINS"].CROSS !== jointype) {
                    data[rowPosition] = tupleObj;
                } else {
                    data.push(tupleObj);
                    rowAdded = true;
                    rowPosition = i;
                }
            } else if ((jointype === _constants__WEBPACK_IMPORTED_MODULE_4__["JOINS"].LEFTOUTER || jointype === _constants__WEBPACK_IMPORTED_MODULE_4__["JOINS"].RIGHTOUTER) && !rowAdded) {
                var _tupleObj = {};
                var len = dm1FieldStore.fields.length - 1;
                tuple.forEach(function (cellVal, iii) {
                    if (iii <= len) {
                        _tupleObj[schema[iii].name] = cellVal;
                    } else {
                        _tupleObj[schema[iii].name] = null;
                    }
                });
                rowAdded = true;
                rowPosition = i;
                data.push(_tupleObj);
            }
        });
    });

    return new _datamodel__WEBPACK_IMPORTED_MODULE_0__["default"](data, schema, { name: name });
}

/***/ }),

/***/ "./src/operator/data-builder.js":
/*!**************************************!*\
  !*** ./src/operator/data-builder.js ***!
  \**************************************/
/*! exports provided: dataBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataBuilder", function() { return dataBuilder; });
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sort */ "./src/operator/sort.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }




/**
 * Builds the actual data array.
 *
 * @param {Array} fieldStore - An array of field.
 * @param {string} rowDiffset - A string consisting of which rows to be included eg. '0-2,4,6';
 * @param {string} colIdentifier - A string consisting of the details of which column
 * to be included eg 'date,sales,profit';
 * @param {Object} sortingDetails - An object containing the sorting details of the DataModel instance.
 * @param {Object} options - The options required to create the type of the data.
 * @return {Object} Returns an object containing the multidimensional array and the relative schema.
 */
function dataBuilder(fieldStore, rowDiffset, colIdentifier, sortingDetails, options) {
    var defOptions = {
        addUid: false,
        columnWise: false
    };
    options = Object.assign({}, defOptions, options);

    var retObj = {
        schema: [],
        data: [],
        uids: []
    };
    var addUid = options.addUid;
    var reqSorting = sortingDetails && sortingDetails.length > 0;
    // It stores the fields according to the colIdentifier argument
    var tmpDataArr = [];
    // Stores the fields according to the colIdentifier argument
    var colIArr = colIdentifier.split(',');

    colIArr.forEach(function (colName) {
        for (var i = 0; i < fieldStore.length; i += 1) {
            if (fieldStore[i].name() === colName) {
                tmpDataArr.push(fieldStore[i]);
                break;
            }
        }
    });

    // Inserts the schema to the schema object
    tmpDataArr.forEach(function (field) {
        /** @todo Need to use extend2 here otherwise user can overwrite the schema. */
        retObj.schema.push(field.schema());
    });

    if (addUid) {
        retObj.schema.push({
            name: 'uid',
            type: 'identifier'
        });
    }

    Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_0__["rowDiffsetIterator"])(rowDiffset, function (i) {
        retObj.data.push([]);
        var insertInd = retObj.data.length - 1;
        var start = 0;
        tmpDataArr.forEach(function (field, ii) {
            retObj.data[insertInd][ii + start] = field.partialField.data[i];
        });
        if (addUid) {
            retObj.data[insertInd][tmpDataArr.length] = i;
        }
        // Creates an array of unique identifiers for each row
        retObj.uids.push(i);

        // If sorting needed then there is the need to expose the index
        // mapping from the old index to its new index
        if (reqSorting) {
            retObj.data[insertInd].push(i);
        }
    });

    // Handles the sort functionality
    if (reqSorting) {
        Object(_sort__WEBPACK_IMPORTED_MODULE_1__["sortData"])(retObj, sortingDetails);
    }

    if (options.columnWise) {
        var tmpData = Array.apply(undefined, _toConsumableArray(Array(retObj.schema.length))).map(function () {
            return [];
        });
        retObj.data.forEach(function (tuple) {
            tuple.forEach(function (data, i) {
                tmpData[i].push(data);
            });
        });
        retObj.data = tmpData;
    }

    return retObj;
}

/***/ }),

/***/ "./src/operator/difference.js":
/*!************************************!*\
  !*** ./src/operator/difference.js ***!
  \************************************/
/*! exports provided: difference */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return difference; });
/* harmony import */ var _datamodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datamodel */ "./src/datamodel.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/helper */ "./src/utils/helper.js");





/**
 * Performs the union operation between two dm instances.
 *
 * @todo Fix the conflicts between union and difference terminology here.
 *
 * @param {dm} dm1 - The first dm instance.
 * @param {dm} dm2 - The second dm instance.
 * @return {dm} Returns the newly created dm after union operation.
 */
function difference(dm1, dm2) {
    var hashTable = {};
    var schema = [];
    var schemaNameArr = [];
    var data = [];
    var dm1FieldStore = dm1.getFieldspace();
    var dm2FieldStore = dm2.getFieldspace();
    var dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();
    var dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();
    var name = dm1FieldStore.name + ' union ' + dm2FieldStore.name;

    // For union the columns should match otherwise return a clone of the dm1
    if (!Object(_utils_helper__WEBPACK_IMPORTED_MODULE_3__["isArrEqual"])(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {
        return null;
    }

    // Prepare the schema
    dm1._colIdentifier.split(',').forEach(function (fieldName) {
        var field = dm1FieldStoreFieldObj[fieldName];
        schema.push(Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extend2"])({}, field.schema()));
        schemaNameArr.push(field.schema().name);
    });

    /**
     * The helper function to create the data.
     *
     * @param {dm} dm - The dm instance for which the data is inserted.
     * @param {Object} fieldsObj - The fieldStore object format.
     * @param {boolean} addData - If true only tuple will be added to the data.
     */
    function prepareDataHelper(dm, fieldsObj, addData) {
        Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_2__["rowDiffsetIterator"])(dm._rowDiffset, function (i) {
            var tuple = {};
            var hashData = '';
            schemaNameArr.forEach(function (schemaName) {
                var value = fieldsObj[schemaName].partialField.data[i];
                hashData += '-' + value;
                tuple[schemaName] = value;
            });
            if (!hashTable[hashData]) {
                if (addData) {
                    data.push(tuple);
                }
                hashTable[hashData] = true;
            }
        });
    }

    // Prepare the data
    prepareDataHelper(dm2, dm2FieldStoreFieldObj, false);
    prepareDataHelper(dm1, dm1FieldStoreFieldObj, true);

    return new _datamodel__WEBPACK_IMPORTED_MODULE_0__["default"](data, schema, { name: name });
}

/***/ }),

/***/ "./src/operator/get-common-schema.js":
/*!*******************************************!*\
  !*** ./src/operator/get-common-schema.js ***!
  \*******************************************/
/*! exports provided: getCommonSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommonSchema", function() { return getCommonSchema; });
/**
 * The helper function that returns an array of common schema
 * from two fieldStore instances.
 *
 * @param {FieldStore} fs1 - The first FieldStore instance.
 * @param {FieldStore} fs2 - The second FieldStore instance.
 * @return {Array} An array containing the common schema.
 */
function getCommonSchema(fs1, fs2) {
    var retArr = [];
    var fs1Arr = [];
    fs1.fields.forEach(function (field) {
        fs1Arr.push(field.schema().name);
    });
    fs2.fields.forEach(function (field) {
        if (fs1Arr.indexOf(field.schema().name) !== -1) {
            retArr.push(field.schema().name);
        }
    });
    return retArr;
}

/***/ }),

/***/ "./src/operator/group-by-function.js":
/*!*******************************************!*\
  !*** ./src/operator/group-by-function.js ***!
  \*******************************************/
/*! exports provided: defaultReducerName, defReducer, fnList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultReducerName", function() { return defaultReducerName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defReducer", function() { return sum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fnList", function() { return fnList; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../invalid-aware-types */ "./src/invalid-aware-types.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
var _fnList;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }





var SUM = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].SUM,
    AVG = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].AVG,
    FIRST = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].FIRST,
    LAST = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].LAST,
    COUNT = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].COUNT,
    STD = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].STD,
    MIN = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].MIN,
    MAX = _enums__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].MAX;


function getFilteredValues(arr) {
    return arr.filter(function (item) {
        return !(item instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"]);
    });
}
/**
 * Reducer function that returns the sum of all the values.
 *
 * @public
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the sum of the array.
 */
function sum(arr) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr) && !(arr[0] instanceof Array)) {
        var filteredNumber = getFilteredValues(arr);
        var totalSum = filteredNumber.length ? filteredNumber.reduce(function (acc, curr) {
            return acc + curr;
        }, 0) : _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
        return totalSum;
    }
    return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
}

/**
 * Reducer function that returns the average of all the values.
 *
 * @public
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the mean value of the array.
 */
function avg(arr) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr) && !(arr[0] instanceof Array)) {
        var totalSum = sum(arr);
        var len = arr.length || 1;
        return Number.isNaN(totalSum) || totalSum instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"] ? _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL : totalSum / len;
    }
    return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
}

/**
 * Reducer function that gives the min value amongst all the values.
 *
 * @public
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the minimum value of the array.
 */
function min(arr) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr) && !(arr[0] instanceof Array)) {
        // Filter out undefined, null and NaN values
        var filteredValues = getFilteredValues(arr);

        return filteredValues.length ? Math.min.apply(Math, _toConsumableArray(filteredValues)) : _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
    }
    return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
}

/**
 * Reducer function that gives the max value amongst all the values.
 *
 * @public
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the maximum value of the array.
 */
function max(arr) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr) && !(arr[0] instanceof Array)) {
        // Filter out undefined, null and NaN values
        var filteredValues = getFilteredValues(arr);

        return filteredValues.length ? Math.max.apply(Math, _toConsumableArray(filteredValues)) : _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
    }
    return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
}

/**
 * Reducer function that gives the first value of the array.
 *
 * @public
 * @param  {Array} arr - The input array.
 * @return {number} Returns the first value of the array.
 */
function first(arr) {
    return arr[0];
}

/**
 * Reducer function that gives the last value of the array.
 *
 * @public
 * @param  {Array} arr - The input array.
 * @return {number} Returns the last value of the array.
 */
function last(arr) {
    return arr[arr.length - 1];
}

/**
 * Reducer function that gives the count value of the array.
 *
 * @public
 * @param  {Array} arr - The input array.
 * @return {number} Returns the length of the array.
 */
function count(arr) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(arr)) {
        return arr.length;
    }
    return _invalid_aware_types__WEBPACK_IMPORTED_MODULE_1__["default"].NULL;
}

/**
 * Calculates the variance of the input array.
 *
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the variance of the input array.
 */
function variance(arr) {
    var mean = avg(arr);
    return avg(arr.map(function (num) {
        return Math.pow(num - mean, 2);
    }));
}

/**
 * Calculates the square root of the variance of the input array.
 *
 * @public
 * @param  {Array.<number>} arr - The input array.
 * @return {number} Returns the square root of the variance.
 */
function std(arr) {
    return Math.sqrt(variance(arr));
}

var fnList = (_fnList = {}, _defineProperty(_fnList, SUM, sum), _defineProperty(_fnList, AVG, avg), _defineProperty(_fnList, MIN, min), _defineProperty(_fnList, MAX, max), _defineProperty(_fnList, FIRST, first), _defineProperty(_fnList, LAST, last), _defineProperty(_fnList, COUNT, count), _defineProperty(_fnList, STD, std), _fnList);

var defaultReducerName = SUM;



/***/ }),

/***/ "./src/operator/group-by.js":
/*!**********************************!*\
  !*** ./src/operator/group-by.js ***!
  \**********************************/
/*! exports provided: groupBy, getFieldArr, getReducerObj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return groupBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFieldArr", function() { return getFieldArr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReducerObj", function() { return getReducerObj; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _export__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../export */ "./src/export.js");
/* harmony import */ var _utils_reducer_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/reducer-store */ "./src/utils/reducer-store.js");
/* harmony import */ var _group_by_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./group-by-function */ "./src/operator/group-by-function.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony import */ var _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../invalid-aware-types */ "./src/invalid-aware-types.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();









/**
 * This function sanitize the user given field and return a common Array structure field
 * list
 * @param  {DataModel} dataModel the dataModel operating on
 * @param  {Array} fieldArr  user input of field Array
 * @return {Array}           arrays of field name
 */
function getFieldArr(dataModel, fieldArr) {
    var retArr = [];
    var fieldStore = dataModel.getFieldspace();
    var dimensions = fieldStore.getDimension();

    Object.entries(dimensions).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            key = _ref2[0];

        if (fieldArr && fieldArr.length) {
            if (fieldArr.indexOf(key) !== -1) {
                retArr.push(key);
            }
        } else {
            retArr.push(key);
        }
    });

    return retArr;
}

/**
 * This sanitize the reducer provide by the user and create a common type of object.
 * user can give function Also
 * @param  {DataModel} dataModel     dataModel to worked on
 * @param  {Object|function} [reducers={}] reducer provided by the users
 * @return {Object}               object containing reducer function for every measure
 */
function getReducerObj(dataModel) {
    var reducers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var retObj = {};
    var fieldStore = dataModel.getFieldspace();
    var measures = fieldStore.getMeasure();
    var defReducer = _utils_reducer_store__WEBPACK_IMPORTED_MODULE_3__["default"].defaultReducer();

    Object.keys(measures).forEach(function (measureName) {
        if (typeof reducers[measureName] !== 'string') {
            reducers[measureName] = measures[measureName].defAggFn();
        }
        var reducerFn = _utils_reducer_store__WEBPACK_IMPORTED_MODULE_3__["default"].resolve(reducers[measureName]);
        if (reducerFn) {
            retObj[measureName] = reducerFn;
        } else {
            retObj[measureName] = defReducer;
            reducers[measureName] = _group_by_function__WEBPACK_IMPORTED_MODULE_4__["defaultReducerName"];
        }
    });
    return retObj;
}

/**
 * main function which perform the group-by operations which reduce the measures value is the
 * fields are common according to the reducer function provided
 * @param  {DataModel} dataModel the dataModel to worked
 * @param  {Array} fieldArr  fields according to which the groupby should be worked
 * @param  {Object|Function} reducers  reducers function
 * @param {DataModel} existingDataModel Existing datamodel instance
 * @return {DataModel} new dataModel with the group by
 */
function groupBy(dataModel, fieldArr, reducers, existingDataModel) {
    var sFieldArr = getFieldArr(dataModel, fieldArr);
    var reducerObj = getReducerObj(dataModel, reducers);
    var fieldStore = dataModel.getFieldspace();
    var fieldStoreObj = fieldStore.fieldsObj();
    var dbName = fieldStore.name;
    var dimensionArr = [];
    var measureArr = [];
    var schema = [];
    var hashMap = {};
    var data = [];
    var binnedGeoFieldArr = [];
    var geoFieldArr = [];
    var newDataModel = void 0;

    // Prepare the schema
    Object.entries(fieldStoreObj).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (sFieldArr.indexOf(key) !== -1 || reducerObj[key]) {
            schema.push(Object(_utils__WEBPACK_IMPORTED_MODULE_0__["extend2"])({}, value.schema()));

            var _value$schema = value.schema(),
                type = _value$schema.type,
                subtype = _value$schema.subtype;

            switch (type) {
                case _enums__WEBPACK_IMPORTED_MODULE_5__["FieldType"].MEASURE:
                    measureArr.push(key);
                    break;
                default:
                case _enums__WEBPACK_IMPORTED_MODULE_5__["FieldType"].DIMENSION:
                    if (subtype === _enums__WEBPACK_IMPORTED_MODULE_5__["DimensionSubtype"].BINNED_GEO) {
                        binnedGeoFieldArr.push(key);
                    } else if (subtype === _enums__WEBPACK_IMPORTED_MODULE_5__["DimensionSubtype"].GEO) {
                        geoFieldArr.push(key);
                    } else {
                        dimensionArr.push(key);
                    }
            }
        }
    });
    // Prepare the data
    var rowCount = 0;
    Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_1__["rowDiffsetIterator"])(dataModel._rowDiffset, function (i) {
        var hash = '';
        dimensionArr.forEach(function (_) {
            hash = hash + '-' + fieldStoreObj[_].partialField.data[i];
        });
        geoFieldArr.forEach(function (_) {
            var val = fieldStoreObj[_].partialField.data[i];
            hash = hash + '-' + (val instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__["default"] ? null : val.bounds());
        });
        binnedGeoFieldArr.forEach(function (_) {
            var geom = fieldStoreObj[_].partialField.data[i];

            hash = hash + '-' + (geom instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__["default"] ? null : geom.center());
        });

        geoFieldArr.forEach(function (_) {
            var geom = fieldStoreObj[_].partialField.data[i];

            hash = hash + '-' + (geom instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__["default"] ? null : geom.bounds());
        });

        if (hashMap[hash] === undefined) {
            hashMap[hash] = rowCount;
            data.push({});
            dimensionArr.forEach(function (_) {
                data[rowCount][_] = fieldStoreObj[_].partialField.data[i];
            });
            geoFieldArr.forEach(function (_) {
                var val = fieldStoreObj[_].partialField.data[i];
                data[rowCount][_] = val instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__["default"] ? null : val.serialize();
            });
            binnedGeoFieldArr.forEach(function (_) {
                var geom = fieldStoreObj[_].partialField.data[i];
                data[rowCount][_] = geom instanceof _invalid_aware_types__WEBPACK_IMPORTED_MODULE_6__["default"] ? geom.value() : fieldStoreObj[_].partialField.data[i].serialize();
            });
            measureArr.forEach(function (_) {
                data[rowCount][_] = [fieldStoreObj[_].partialField.data[i]];
            });
            rowCount += 1;
        } else {
            measureArr.forEach(function (_) {
                data[hashMap[hash]][_].push(fieldStoreObj[_].partialField.data[i]);
            });
        }
    });

    // reduction
    var cachedStore = {};
    var cloneProvider = function cloneProvider() {
        return dataModel.detachedRoot();
    };
    data.forEach(function (row) {
        var tuple = row;
        measureArr.forEach(function (_) {
            tuple[_] = reducerObj[_](row[_], cloneProvider, cachedStore);
        });
    });
    if (existingDataModel) {
        existingDataModel.__calculateFieldspace();
        newDataModel = existingDataModel;
    } else {
        newDataModel = new _export__WEBPACK_IMPORTED_MODULE_2__["default"](data, schema, { name: dbName });
    }
    return newDataModel;
}



/***/ }),

/***/ "./src/operator/hexbin.js":
/*!********************************!*\
  !*** ./src/operator/hexbin.js ***!
  \********************************/
/*! exports provided: hexbin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexbin", function() { return hexbin; });
/* harmony import */ var _utils_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/geo */ "./src/utils/geo.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();



/**
 * Creates hexagon
 *
 * @private
 * @param {Array<number>} center of the hexagon
 * @param {number} rx half hexagon width
 * @param {number} ry half hexagon height
 * @param {Object} properties passed to each hexagon
 * @param {Array<number>} cosines precomputed
 * @param {Array<number>} sines precomputed
 * @returns {Feature<Polygon>} hexagon
 */
var hexagon = function hexagon(center, rx, ry, cosines, sines) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
    }
    var radius = Object(_utils_geo__WEBPACK_IMPORTED_MODULE_0__["distance"])(center, vertices[0], 'kilometers');
    // first and last vertex must be the same
    vertices.push(vertices[0].slice());
    return {
        coordinates: [vertices],
        center: center,
        radius: radius
    };
};

/**
 * Takes a bounding box and the diameter of the cell and returns an array of flat-topped
 * hexagons or triangles aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids]
 *
 * @name hexbin
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSide length of the side of the the hexagons or triangles, in units.
 * It will also coincide with the radius of the circumcircle of the hexagons.
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] used in calculating cell size, can be degrees, radians, miles,
 * or kilometers
 * @param {Object} [options.properties={}] passed to each hexagon or triangle of the grid
 * @param {Feature<Polygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created
 * only inside it.
 * @param {boolean} [options.triangles=false] whether to return as triangles instead of hexagons
 * @returns {FeatureCollection<Polygon>} a hexagonal grid
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellSide = 50;
 * var options = {units: 'miles'};
 *
 * var bins = hexbin(bbox, cellSide, options);
 */
var hexbin = function hexbin(bbox, cellSide, options) {
    var _bbox$flat = bbox.flat(),
        _bbox$flat2 = _slicedToArray(_bbox$flat, 4),
        west = _bbox$flat2[0],
        south = _bbox$flat2[1],
        east = _bbox$flat2[2],
        north = _bbox$flat2[3];

    var centerY = (south + north) / 2;
    var centerX = (west + east) / 2;
    var xFraction = cellSide * 2 / Object(_utils_geo__WEBPACK_IMPORTED_MODULE_0__["distance"])([west, centerY], [east, centerY], options.units);
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSide * 2 / Object(_utils_geo__WEBPACK_IMPORTED_MODULE_0__["distance"])([centerX, south], [centerX, north], options.units);
    var cellHeight = yFraction * (north - south);
    var radius = cellWidth / 2;

    var hexWidth = radius * 2;
    var hexHeight = Math.sqrt(3) / 2 * cellHeight;

    var boxWidth = east - west;
    var boxHeight = north - south;

    var xInterval = 3 / 4 * hexWidth;
    var yInterval = hexHeight;

    // adjust boxWidth so all hexagons will be inside the bbox
    var xSpan = (boxWidth - hexWidth) / (hexWidth - radius / 2);
    var xCount = Math.floor(xSpan);

    var xAdjust = (xCount * xInterval - radius / 2 - boxWidth) / 2 - radius / 2 + xInterval / 2;

    // adjust boxHeight so all hexagons will be inside the bbox
    var yCount = Math.floor((boxHeight - hexHeight) / hexHeight);

    var yAdjust = (boxHeight - yCount * hexHeight) / 2;

    var hasOffsetY = yCount * hexHeight - boxHeight > hexHeight / 2;
    if (hasOffsetY) {
        yAdjust -= hexHeight / 4;
    }

    var cosines = [];
    var sines = [];
    for (var i = 0; i < 6; i++) {
        var angle = 2 * Math.PI / 6 * i;
        cosines.push(Math.cos(angle));
        sines.push(Math.sin(angle));
    }

    var results = [];
    for (var x = 0; x <= xCount; x++) {
        for (var y = 0; y <= yCount; y++) {
            var isOdd = x % 2 === 1;
            if (y === 0 && isOdd) continue;
            if (y === 0 && hasOffsetY) continue;

            var xCenter = x * xInterval + west - xAdjust;
            var yCenter = y * yInterval + south + yAdjust;

            if (isOdd) {
                yCenter -= hexHeight / 2;
            }

            var hex = hexagon([xCenter, yCenter], cellWidth / 2, cellHeight / 2, cosines, sines);

            results.push(hex);
        }
    }

    return results;
};

/***/ }),

/***/ "./src/operator/index.js":
/*!*******************************!*\
  !*** ./src/operator/index.js ***!
  \*******************************/
/*! exports provided: createBinnedFieldData, compose, bin, select, project, groupby, calculateVariable, sort, crossProduct, dataBuilder, difference, getCommonSchema, defReducer, fnList, groupBy, getFieldArr, getReducerObj, mergeSort, naturalJoinFilter, naturalJoin, leftOuterJoin, rightOuterJoin, fullOuterJoin, rowDiffsetIterator, union, hexbin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bucket_creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bucket-creator */ "./src/operator/bucket-creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createBinnedFieldData", function() { return _bucket_creator__WEBPACK_IMPORTED_MODULE_0__["createBinnedFieldData"]; });

/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose */ "./src/operator/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose__WEBPACK_IMPORTED_MODULE_1__["compose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bin", function() { return _compose__WEBPACK_IMPORTED_MODULE_1__["bin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _compose__WEBPACK_IMPORTED_MODULE_1__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _compose__WEBPACK_IMPORTED_MODULE_1__["project"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupby", function() { return _compose__WEBPACK_IMPORTED_MODULE_1__["groupBy"]; });

/* harmony import */ var _pure_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pure-operators */ "./src/operator/pure-operators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "calculateVariable", function() { return _pure_operators__WEBPACK_IMPORTED_MODULE_2__["calculateVariable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return _pure_operators__WEBPACK_IMPORTED_MODULE_2__["sort"]; });

/* harmony import */ var _cross_product__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross-product */ "./src/operator/cross-product.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "crossProduct", function() { return _cross_product__WEBPACK_IMPORTED_MODULE_3__["crossProduct"]; });

/* harmony import */ var _data_builder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-builder */ "./src/operator/data-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dataBuilder", function() { return _data_builder__WEBPACK_IMPORTED_MODULE_4__["dataBuilder"]; });

/* harmony import */ var _difference__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./difference */ "./src/operator/difference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _difference__WEBPACK_IMPORTED_MODULE_5__["difference"]; });

/* harmony import */ var _get_common_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./get-common-schema */ "./src/operator/get-common-schema.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCommonSchema", function() { return _get_common_schema__WEBPACK_IMPORTED_MODULE_6__["getCommonSchema"]; });

/* harmony import */ var _group_by_function__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./group-by-function */ "./src/operator/group-by-function.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defReducer", function() { return _group_by_function__WEBPACK_IMPORTED_MODULE_7__["defReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fnList", function() { return _group_by_function__WEBPACK_IMPORTED_MODULE_7__["fnList"]; });

/* harmony import */ var _group_by__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./group-by */ "./src/operator/group-by.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _group_by__WEBPACK_IMPORTED_MODULE_8__["groupBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFieldArr", function() { return _group_by__WEBPACK_IMPORTED_MODULE_8__["getFieldArr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getReducerObj", function() { return _group_by__WEBPACK_IMPORTED_MODULE_8__["getReducerObj"]; });

/* harmony import */ var _merge_sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge-sort */ "./src/operator/merge-sort.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return _merge_sort__WEBPACK_IMPORTED_MODULE_9__["mergeSort"]; });

/* harmony import */ var _natural_join_filter_function__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./natural-join-filter-function */ "./src/operator/natural-join-filter-function.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "naturalJoinFilter", function() { return _natural_join_filter_function__WEBPACK_IMPORTED_MODULE_10__["naturalJoinFilter"]; });

/* harmony import */ var _natural_join__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./natural-join */ "./src/operator/natural-join.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "naturalJoin", function() { return _natural_join__WEBPACK_IMPORTED_MODULE_11__["naturalJoin"]; });

/* harmony import */ var _outer_join__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./outer-join */ "./src/operator/outer-join.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leftOuterJoin", function() { return _outer_join__WEBPACK_IMPORTED_MODULE_12__["leftOuterJoin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rightOuterJoin", function() { return _outer_join__WEBPACK_IMPORTED_MODULE_12__["rightOuterJoin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fullOuterJoin", function() { return _outer_join__WEBPACK_IMPORTED_MODULE_12__["fullOuterJoin"]; });

/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rowDiffsetIterator", function() { return _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_13__["rowDiffsetIterator"]; });

/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./union */ "./src/operator/union.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _union__WEBPACK_IMPORTED_MODULE_14__["union"]; });

/* harmony import */ var _hexbin__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hexbin */ "./src/operator/hexbin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexbin", function() { return _hexbin__WEBPACK_IMPORTED_MODULE_15__["hexbin"]; });


















/***/ }),

/***/ "./src/operator/merge-sort.js":
/*!************************************!*\
  !*** ./src/operator/merge-sort.js ***!
  \************************************/
/*! exports provided: mergeSort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return mergeSort; });
/**
 * The default sort function.
 *
 * @param {*} a - The first value.
 * @param {*} b - The second value.
 * @return {number} Returns the comparison result e.g. 1 or 0 or -1.
 */
function defSortFn(a, b) {
    var a1 = "" + a;
    var b1 = "" + b;
    if (a1 < b1) {
        return -1;
    }
    if (a1 > b1) {
        return 1;
    }
    return 0;
}

/**
 * The helper function for merge sort which creates the sorted array
 * from the two halves of the input array.
 *
 * @param {Array} arr - The target array which needs to be merged.
 * @param {number} lo - The starting index of the first array half.
 * @param {number} mid - The ending index of the first array half.
 * @param {number} hi - The ending index of the second array half.
 * @param {Function} sortFn - The sort function.
 */
function merge(arr, lo, mid, hi, sortFn) {
    var mainArr = arr;
    var auxArr = [];
    for (var i = lo; i <= hi; i += 1) {
        auxArr[i] = mainArr[i];
    }
    var a = lo;
    var b = mid + 1;

    for (var _i = lo; _i <= hi; _i += 1) {
        if (a > mid) {
            mainArr[_i] = auxArr[b];
            b += 1;
        } else if (b > hi) {
            mainArr[_i] = auxArr[a];
            a += 1;
        } else if (sortFn(auxArr[a], auxArr[b]) <= 0) {
            mainArr[_i] = auxArr[a];
            a += 1;
        } else {
            mainArr[_i] = auxArr[b];
            b += 1;
        }
    }
}

/**
 * The helper function for merge sort which would be called
 * recursively for sorting the array halves.
 *
 * @param {Array} arr - The target array which needs to be sorted.
 * @param {number} lo - The starting index of the array half.
 * @param {number} hi - The ending index of the array half.
 * @param {Function} sortFn - The sort function.
 * @return {Array} Returns the target array itself.
 */
function sort(arr, lo, hi, sortFn) {
    if (hi === lo) {
        return arr;
    }

    var mid = lo + Math.floor((hi - lo) / 2);
    sort(arr, lo, mid, sortFn);
    sort(arr, mid + 1, hi, sortFn);
    merge(arr, lo, mid, hi, sortFn);

    return arr;
}

/**
 * The implementation of merge sort.
 * It is used in DataModel for stable sorting as it is not sure
 * what the sorting algorithm used by browsers is stable or not.
 *
 * @param {Array} arr - The target array which needs to be sorted.
 * @param {Function} [sortFn=defSortFn] - The sort function.
 * @return {Array} Returns the input array itself in sorted order.
 */
function mergeSort(arr) {
    var sortFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defSortFn;

    if (arr.length > 1) {
        sort(arr, 0, arr.length - 1, sortFn);
    }
    return arr;
}

/***/ }),

/***/ "./src/operator/natural-join-filter-function.js":
/*!******************************************************!*\
  !*** ./src/operator/natural-join-filter-function.js ***!
  \******************************************************/
/*! exports provided: naturalJoinFilter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalJoinFilter", function() { return naturalJoinFilter; });
/* harmony import */ var _get_common_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-common-schema */ "./src/operator/get-common-schema.js");


/**
 * The filter function used in natural join.
 * It generates a function that will have the logic to join two
 * DataModel instances by the process of natural join.
 *
 * @param {DataModel} dm1 - The left DataModel instance.
 * @param {DataModel} dm2 - The right DataModel instance.
 * @return {Function} Returns a function that is used in cross-product operation.
 */
function naturalJoinFilter(dm1, dm2) {
    var dm1FieldStore = dm1.getFieldspace();
    var dm2FieldStore = dm2.getFieldspace();
    // const dm1FieldStoreName = dm1FieldStore.name;
    // const dm2FieldStoreName = dm2FieldStore.name;
    var commonSchemaArr = Object(_get_common_schema__WEBPACK_IMPORTED_MODULE_0__["getCommonSchema"])(dm1FieldStore, dm2FieldStore);

    return function (dm1Fields, dm2Fields) {
        var retainTuple = true;
        commonSchemaArr.forEach(function (fieldName) {
            if (dm1Fields[fieldName].internalValue === dm2Fields[fieldName].internalValue && retainTuple) {
                retainTuple = true;
            } else {
                retainTuple = false;
            }
        });
        return retainTuple;
    };
}

/***/ }),

/***/ "./src/operator/natural-join.js":
/*!**************************************!*\
  !*** ./src/operator/natural-join.js ***!
  \**************************************/
/*! exports provided: naturalJoin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalJoin", function() { return naturalJoin; });
/* harmony import */ var _cross_product__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cross-product */ "./src/operator/cross-product.js");
/* harmony import */ var _natural_join_filter_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./natural-join-filter-function */ "./src/operator/natural-join-filter-function.js");



function naturalJoin(dataModel1, dataModel2) {
    return Object(_cross_product__WEBPACK_IMPORTED_MODULE_0__["crossProduct"])(dataModel1, dataModel2, Object(_natural_join_filter_function__WEBPACK_IMPORTED_MODULE_1__["naturalJoinFilter"])(dataModel1, dataModel2), true);
}

/***/ }),

/***/ "./src/operator/outer-join.js":
/*!************************************!*\
  !*** ./src/operator/outer-join.js ***!
  \************************************/
/*! exports provided: leftOuterJoin, rightOuterJoin, fullOuterJoin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftOuterJoin", function() { return leftOuterJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightOuterJoin", function() { return rightOuterJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fullOuterJoin", function() { return fullOuterJoin; });
/* harmony import */ var _cross_product__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cross-product */ "./src/operator/cross-product.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./src/constants/index.js");
/* harmony import */ var _union__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./union */ "./src/operator/union.js");




function leftOuterJoin(dataModel1, dataModel2, filterFn) {
    return Object(_cross_product__WEBPACK_IMPORTED_MODULE_0__["crossProduct"])(dataModel1, dataModel2, filterFn, false, _constants__WEBPACK_IMPORTED_MODULE_1__["JOINS"].LEFTOUTER);
}

function rightOuterJoin(dataModel1, dataModel2, filterFn) {
    return Object(_cross_product__WEBPACK_IMPORTED_MODULE_0__["crossProduct"])(dataModel2, dataModel1, filterFn, false, _constants__WEBPACK_IMPORTED_MODULE_1__["JOINS"].RIGHTOUTER);
}

function fullOuterJoin(dataModel1, dataModel2, filterFn) {
    return Object(_union__WEBPACK_IMPORTED_MODULE_2__["union"])(leftOuterJoin(dataModel1, dataModel2, filterFn), rightOuterJoin(dataModel1, dataModel2, filterFn));
}

/***/ }),

/***/ "./src/operator/pure-operators.js":
/*!****************************************!*\
  !*** ./src/operator/pure-operators.js ***!
  \****************************************/
/*! exports provided: calculateVariable, sort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateVariable", function() { return calculateVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return sort; });
/**
 * Wrapper on calculateVariable() method of DataModel to behave
 * the pure-function functionality.
 *
 * @param {Array} args - The argument list.
 * @return {any} Returns the returned value of calling function.
 */
var calculateVariable = function calculateVariable() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return function (dm) {
    return dm.calculateVariable.apply(dm, args);
  };
};

/**
 * Wrapper on sort() method of DataModel to behave
 * the pure-function functionality.
 *
 * @param {Array} args - The argument list.
 * @return {any} Returns the returned value of calling function.
 */
var sort = function sort() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return function (dm) {
    return dm.sort.apply(dm, args);
  };
};

/***/ }),

/***/ "./src/operator/row-diffset-iterator.js":
/*!**********************************************!*\
  !*** ./src/operator/row-diffset-iterator.js ***!
  \**********************************************/
/*! exports provided: rowDiffsetIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rowDiffsetIterator", function() { return rowDiffsetIterator; });
/**
 * Iterates through the diffSet array and call the callback with the current
 * index.
 *
 * @param {string} rowDiffset - The row diffset string e.g. '0-4,6,10-13'.
 * @param {Function} callback - The callback function to be called with every index.
 */
function rowDiffsetIterator(rowDiffset, callback) {
    if (rowDiffset.length > 0) {
        var rowDiffArr = rowDiffset.split(',');
        rowDiffArr.forEach(function (diffStr) {
            var diffStsArr = diffStr.split('-');
            var start = +diffStsArr[0];
            var end = +(diffStsArr[1] || diffStsArr[0]);
            if (end >= start) {
                for (var i = start; i <= end; i += 1) {
                    callback(i);
                }
            }
        });
    }
}

/***/ }),

/***/ "./src/operator/sort.js":
/*!******************************!*\
  !*** ./src/operator/sort.js ***!
  \******************************/
/*! exports provided: sortData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortData", function() { return sortData; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony import */ var _merge_sort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merge-sort */ "./src/operator/merge-sort.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper */ "./src/helper.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }






/**
 * Generates the sorting functions to sort the data of a DataModel instance
 * according to the input data type.
 *
 * @param {string} dataType - The data type e.g. 'measure', 'datetime' etc.
 * @param {string} sortType - The sorting order i.e. 'asc' or 'desc'.
 * @return {Function} Returns the the sorting function.
 */
function getSortFn(dataType, sortType) {
    var retFunc = void 0;

    switch (dataType) {
        case _enums__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS:
        case _enums__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL:
            if (sortType === 'asc') {
                retFunc = function retFunc(a, b) {
                    return a - b;
                };
            } else {
                retFunc = function retFunc(a, b) {
                    return b - a;
                };
            }
            break;
        default:
            if (sortType === 'asc') {
                retFunc = function retFunc(a, b) {
                    a = '' + a;
                    b = '' + b;
                    if (a === b) {
                        return 0;
                    }
                    return a > b ? 1 : -1;
                };
            } else {
                retFunc = function retFunc(a, b) {
                    a = '' + a;
                    b = '' + b;
                    if (a === b) {
                        return 0;
                    }
                    return a > b ? -1 : 1;
                };
            }
    }

    return retFunc;
}

/**
 * Resolves the actual sorting function based on sorting string value.
 *
 * @param {Object} fDetails - The target field info.
 * @param {string} strSortOrder - The sort order value.
 * @return {Function} Returns the sorting function.
 */
function resolveStrSortOrder(fDetails, strSortOrder) {
    var sortOrder = String(strSortOrder).toLowerCase() === 'desc' ? 'desc' : 'asc';
    return getSortFn(fDetails.type, sortOrder);
}

/**
 * Groups the data according to the specified target field.
 *
 * @param {Array} data - The input data array.
 * @param {number} fieldIndex - The target field index within schema array.
 * @return {Array} Returns an array containing the grouped data.
 */
function groupData(data, fieldIndex) {
    var hashMap = new Map();
    var groupedData = [];

    data.forEach(function (datum) {
        var fieldVal = datum[fieldIndex];
        if (hashMap.has(fieldVal)) {
            groupedData[hashMap.get(fieldVal)][1].push(datum);
        } else {
            groupedData.push([fieldVal, [datum]]);
            hashMap.set(fieldVal, groupedData.length - 1);
        }
    });

    return groupedData;
}

/**
 * Creates the argument value used for sorting function when sort is done
 * with another fields.
 *
 * @param {Array} groupedDatum - The grouped datum for a single dimension field value.
 * @param {Array} targetFields - An array of the sorting fields.
 * @param {Array} targetFieldDetails - An array of the sorting field details in schema.
 * @return {Object} Returns an object containing the value of sorting fields and the target field name.
 */
function createSortingFnArg(groupedDatum, targetFields, targetFieldDetails) {
    var arg = {
        label: groupedDatum[0]
    };

    targetFields.reduce(function (acc, next, idx) {
        acc[next] = groupedDatum[1].map(function (datum) {
            return datum[targetFieldDetails[idx].index];
        });
        return acc;
    }, arg);

    return arg;
}

/**
 * Sorts the data by applying the standard sorting mechanism.
 *
 * @param {Array} data - The input data array.
 * @param {Array} schema - The data schema.
 * @param {Array} sortingDetails - An array containing the sorting configs.
 */
function applyStandardSort(data, schema, sortingDetails) {
    var fieldName = void 0;
    var sortMeta = void 0;
    var fDetails = void 0;
    var i = sortingDetails.length - 1;

    for (; i >= 0; i--) {
        fieldName = sortingDetails[i][0];
        sortMeta = sortingDetails[i][1];
        fDetails = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["fieldInSchema"])(schema, fieldName);

        if (!fDetails) {
            // eslint-disable-next-line no-continue
            continue;
        }

        if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isCallable"])(sortMeta)) {
            // eslint-disable-next-line no-loop-func
            Object(_merge_sort__WEBPACK_IMPORTED_MODULE_1__["mergeSort"])(data, function (a, b) {
                return sortMeta(a[fDetails.index], b[fDetails.index]);
            });
        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_3__["isArray"])(sortMeta)) {
            (function () {
                var groupedData = groupData(data, fDetails.index);
                var sortingFn = sortMeta[sortMeta.length - 1];
                var targetFields = sortMeta.slice(0, sortMeta.length - 1);
                var targetFieldDetails = targetFields.map(function (f) {
                    return Object(_helper__WEBPACK_IMPORTED_MODULE_2__["fieldInSchema"])(schema, f);
                });

                groupedData.forEach(function (groupedDatum) {
                    groupedDatum.push(createSortingFnArg(groupedDatum, targetFields, targetFieldDetails));
                });

                Object(_merge_sort__WEBPACK_IMPORTED_MODULE_1__["mergeSort"])(groupedData, function (a, b) {
                    var m = a[2];
                    var n = b[2];
                    return sortingFn(m, n);
                });

                // Empty the array
                data.length = 0;
                groupedData.forEach(function (datum) {
                    data.push.apply(data, _toConsumableArray(datum[1]));
                });
            })();
        } else {
            (function () {
                var sortFn = resolveStrSortOrder(fDetails, sortMeta);
                // eslint-disable-next-line no-loop-func
                Object(_merge_sort__WEBPACK_IMPORTED_MODULE_1__["mergeSort"])(data, function (a, b) {
                    return sortFn(a[fDetails.index], b[fDetails.index]);
                });
            })();
        }
    }
}

/**
 * Creates a map based on grouping.
 *
 * @param {Array} depColumns - The dependency columns' info.
 * @param {Array} data - The input data.
 * @param {Array} schema - The data schema.
 * @param {Array} sortingDetails - The sorting details for standard sorting.
 * @return {Map} Returns a map.
 */
var makeGroupMapAndSort = function makeGroupMapAndSort(depColumns, data, schema, sortingDetails) {
    if (depColumns.length === 0) {
        return data;
    }

    var targetCol = depColumns[0];
    var map = new Map();

    data.reduce(function (acc, currRow) {
        var fVal = currRow[targetCol.index];
        if (acc.has(fVal)) {
            acc.get(fVal).push(currRow);
        } else {
            acc.set(fVal, [currRow]);
        }
        return acc;
    }, map);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ref = _step.value;

            var _ref2 = _slicedToArray(_ref, 2);

            var key = _ref2[0];
            var val = _ref2[1];

            var nMap = makeGroupMapAndSort(depColumns.slice(1), val, schema, sortingDetails);
            map.set(key, nMap);
            if (Array.isArray(nMap)) {
                applyStandardSort(nMap, schema, sortingDetails);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return map;
};

/**
 * Sorts the data by retaining the position/order of a particular field.
 *
 * @param {Array} data - The input data array.
 * @param {Array} schema - The data schema.
 * @param {Array} sortingDetails - An array containing the sorting configs.
 * @param {Array} depColumns - The dependency column list.
 * @return {Array} Returns the sorted data.
 */
function applyGroupSort(data, schema, sortingDetails, depColumns) {
    sortingDetails = sortingDetails.filter(function (detail) {
        if (detail[1] === null) {
            depColumns.push(detail[0]);
            return false;
        }
        return true;
    });
    if (sortingDetails.length === 0) {
        return data;
    }

    depColumns = depColumns.map(function (c) {
        return Object(_helper__WEBPACK_IMPORTED_MODULE_2__["fieldInSchema"])(schema, c);
    });

    var sortedGroupMap = makeGroupMapAndSort(depColumns, data, schema, sortingDetails);
    return data.map(function (row) {
        var i = 0;
        var nextMap = sortedGroupMap;

        while (!Array.isArray(nextMap)) {
            nextMap = nextMap.get(row[depColumns[i++].index]);
        }

        return nextMap.shift();
    });
}

/**
 * Sorts the data.
 *
 * @param {Object} dataObj - An object containing the data and schema.
 * @param {Array} sortingDetails - An array containing the sorting configs.
 */
function sortData(dataObj, sortingDetails) {
    var schema = dataObj.schema,
        data = dataObj.data;


    sortingDetails = sortingDetails.filter(function (sDetial) {
        return !!Object(_helper__WEBPACK_IMPORTED_MODULE_2__["fieldInSchema"])(schema, sDetial[0]);
    });
    if (sortingDetails.length === 0) {
        return;
    }

    var groupSortingIdx = sortingDetails.findIndex(function (sDetial) {
        return sDetial[1] === null;
    });
    groupSortingIdx = groupSortingIdx !== -1 ? groupSortingIdx : sortingDetails.length;

    var standardSortingDetails = sortingDetails.slice(0, groupSortingIdx);
    var groupSortingDetails = sortingDetails.slice(groupSortingIdx);

    applyStandardSort(data, schema, standardSortingDetails);
    data = applyGroupSort(data, schema, groupSortingDetails, standardSortingDetails.map(function (detail) {
        return detail[0];
    }));

    dataObj.uids = data.map(function (row) {
        return row.pop();
    });
    dataObj.data = data;
}

/***/ }),

/***/ "./src/operator/union.js":
/*!*******************************!*\
  !*** ./src/operator/union.js ***!
  \*******************************/
/*! exports provided: union */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "union", function() { return union; });
/* harmony import */ var _export__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../export */ "./src/export.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* harmony import */ var _row_diffset_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./row-diffset-iterator */ "./src/operator/row-diffset-iterator.js");
/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/helper */ "./src/utils/helper.js");




/**
 * Performs the union operation between two dm instances.
 *
 * @param {dm} dm1 - The first dm instance.
 * @param {dm} dm2 - The second dm instance.
 * @return {dm} Returns the newly created dm after union operation.
 */
function union(dm1, dm2) {
    var hashTable = {};
    var schema = [];
    var schemaNameArr = [];
    var data = [];
    var dm1FieldStore = dm1.getFieldspace();
    var dm2FieldStore = dm2.getFieldspace();
    var dm1FieldStoreFieldObj = dm1FieldStore.fieldsObj();
    var dm2FieldStoreFieldObj = dm2FieldStore.fieldsObj();
    var name = dm1FieldStore.name + ' union ' + dm2FieldStore.name;

    // For union the columns should match otherwise return a clone of the dm1
    if (!Object(_utils_helper__WEBPACK_IMPORTED_MODULE_3__["isArrEqual"])(dm1._colIdentifier.split(',').sort(), dm2._colIdentifier.split(',').sort())) {
        return null;
    }

    // Prepare the schema
    dm1._colIdentifier.split(',').forEach(function (fieldName) {
        var field = dm1FieldStoreFieldObj[fieldName];
        schema.push(Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extend2"])({}, field.schema()));
        schemaNameArr.push(field.schema().name);
    });

    /**
     * The helper function to create the data.
     *
     * @param {dm} dm - The dm instance for which the data is inserted.
     * @param {Object} fieldsObj - The fieldStore object format.
     */
    function prepareDataHelper(dm, fieldsObj) {
        Object(_row_diffset_iterator__WEBPACK_IMPORTED_MODULE_2__["rowDiffsetIterator"])(dm._rowDiffset, function (i) {
            var tuple = {};
            var hashData = '';
            schemaNameArr.forEach(function (schemaName) {
                var value = fieldsObj[schemaName].partialField.data[i];
                hashData += '-' + value;
                tuple[schemaName] = value;
            });
            if (!hashTable[hashData]) {
                data.push(tuple);
                hashTable[hashData] = true;
            }
        });
    }

    // Prepare the data
    prepareDataHelper(dm1, dm1FieldStoreFieldObj);
    prepareDataHelper(dm2, dm2FieldStoreFieldObj);

    return new _export__WEBPACK_IMPORTED_MODULE_0__["default"](data, schema, { name: name });
}

/***/ }),

/***/ "./src/relation.js":
/*!*************************!*\
  !*** ./src/relation.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/enums/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./src/helper.js");
/* harmony import */ var _operator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./operator */ "./src/operator/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }






/**
 * Relation provides the definitions of basic operators of relational algebra like *selection*, *projection*, *union*,
 * *difference* etc.
 *
 * It is extended by {@link DataModel} to inherit the functionalities of relational algebra concept.
 *
 * @class
 * @public
 * @module Relation
 * @namespace DataModel
 */

var Relation = function () {

    /**
     * Creates a new Relation instance by providing underlying data and schema.
     *
     * @private
     *
     * @param {Object | string | Relation} data - The input tabular data in dsv or json format or
     * an existing Relation instance object.
     * @param {Array} schema - An array of data schema.
     * @param {Object} [options] - The optional options.
     */
    function Relation() {
        _classCallCheck(this, Relation);

        var source = void 0;

        this._parent = null;
        this._derivation = [];
        this._ancestorDerivation = [];
        this._children = [];

        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
        }

        if (params.length === 1 && (source = params[0]) instanceof Relation) {
            // parent datamodel was passed as part of source
            this._colIdentifier = source._colIdentifier;
            this._rowDiffset = source._rowDiffset;
            this._dataFormat = source._dataFormat;
            this._parent = source;
            this._partialFieldspace = this._parent._partialFieldspace;
            this._fieldStoreName = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getUniqueId"])();
            this.__calculateFieldspace().calculateFieldsConfig();
        } else {
            _helper__WEBPACK_IMPORTED_MODULE_2__["updateData"].apply(undefined, [this].concat(params));
            this._fieldStoreName = this._partialFieldspace.name;
            this.__calculateFieldspace().calculateFieldsConfig();
            this._propagationNameSpace = {
                mutableActions: {},
                immutableActions: {}
            };
        }
    }

    /**
     * Retrieves the {@link Schema | schema} details for every {@link Field | field} as an array.
     *
     * @public
     *
     * @return {Array.<Schema>} Array of fields schema.
     *      ```
     *      [
     *          { name: 'Name', type: 'dimension' },
     *          { name: 'Miles_per_Gallon', type: 'measure', numberFormat: (val) => `${val} miles / gallon` },
     *          { name: 'Cylinder', type: 'dimension' },
     *          { name: 'Displacement', type: 'measure', defAggFn: 'max' },
     *          { name: 'HorsePower', type: 'measure', defAggFn: 'max' },
     *          { name: 'Weight_in_lbs', type: 'measure', defAggFn: 'avg',  },
     *          { name: 'Acceleration', type: 'measure', defAggFn: 'avg' },
     *          { name: 'Year', type: 'dimension', subtype: 'datetime', format: '%Y' },
     *          { name: 'Origin' }
     *      ]
     *      ```
     */


    _createClass(Relation, [{
        key: 'getSchema',
        value: function getSchema() {
            return this.getFieldspace().fields.map(function (d) {
                return d.schema();
            });
        }

        /**
         * Returns the name of the {@link DataModel} instance. If no name was specified during {@link DataModel}
         * initialization, then it returns a auto-generated name.
         *
         * @public
         *
         * @return {string} Name of the DataModel instance.
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this._fieldStoreName;
        }
    }, {
        key: 'getFieldspace',
        value: function getFieldspace() {
            return this._fieldspace;
        }
    }, {
        key: '__calculateFieldspace',
        value: function __calculateFieldspace() {
            this._fieldspace = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["updateFields"])([this._rowDiffset, this._colIdentifier], this.getPartialFieldspace(), this._fieldStoreName);
            return this;
        }
    }, {
        key: 'getPartialFieldspace',
        value: function getPartialFieldspace() {
            return this._partialFieldspace;
        }

        /**
         * Performs {@link link_of_cross_product | cross-product} between two {@link DataModel} instances and returns a
         * new {@link DataModel} instance containing the results. This operation is also called theta join.
         *
         * Cross product takes two set and create one set where each value of one set is paired with each value of another
         * set.
         *
         * This method takes an optional predicate which filters the generated result rows. If the predicate returns true
         * the combined row is included in the resulatant table.
         *
         * @example
         *  let originDM = dm.project(['Origin','Origin_Formal_Name']);
         *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])
         *
         *  console.log(carsDM.join(originDM)));
         *
         *  console.log(carsDM.join(originDM,
         *      obj => obj.[originDM.getName()].Origin === obj.[carsDM.getName()].Origin));
         *
         * @text
         * This is chained version of `join` operator. `join` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {DataModel} joinWith - The DataModel to be joined with the current instance DataModel.
         * @param {SelectionPredicate} filterFn - The predicate function that will filter the result of the crossProduct.
         *
         * @return {DataModel} New DataModel instance created after joining.
         */

    }, {
        key: 'join',
        value: function join(joinWith, filterFn) {
            return Object(_operator__WEBPACK_IMPORTED_MODULE_3__["crossProduct"])(this, joinWith, filterFn);
        }

        /**
         * {@link natural_join | Natural join} is a special kind of cross-product join where filtering of rows are performed
         * internally by resolving common fields are from both table and the rows with common value are included.
         *
         * @example
         *  let originDM = dm.project(['Origin','Origin_Formal_Name']);
         *  let carsDM = dm.project(['Name','Miles_per_Gallon','Origin'])
         *
         *  console.log(carsDM.naturalJoin(originDM));
         *
         * @text
         * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {DataModel} joinWith - The DataModel with which the current instance of DataModel on which the method is
         *      called will be joined.
         * @return {DataModel} New DataModel instance created after joining.
         */

    }, {
        key: 'naturalJoin',
        value: function naturalJoin(joinWith) {
            return Object(_operator__WEBPACK_IMPORTED_MODULE_3__["crossProduct"])(this, joinWith, Object(_operator__WEBPACK_IMPORTED_MODULE_3__["naturalJoinFilter"])(this, joinWith), true);
        }

        /**
         * {@link link_to_union | Union} operation can be termed as vertical stacking of all rows from both the DataModel
         * instances, provided that both of the {@link DataModel} instances should have same column names.
         *
         * @example
         * console.log(EuropeanMakerDM.union(USAMakerDM));
         *
         * @text
         * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {DataModel} unionWith - DataModel instance for which union has to be applied with the instance on which
         *      the method is called
         *
         * @return {DataModel} New DataModel instance with the result of the operation
         */

    }, {
        key: 'union',
        value: function union(unionWith) {
            return Object(_operator__WEBPACK_IMPORTED_MODULE_3__["union"])(this, unionWith);
        }

        /**
         * {@link link_to_difference | Difference } operation only include rows which are present in the datamodel on which
         * it was called but not on the one passed as argument.
         *
         * @example
         * console.log(highPowerDM.difference(highExpensiveDM));
         *
         * @text
         * This is chained version of `naturalJoin` operator. `naturalJoin` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {DataModel} differenceWith - DataModel instance for which difference has to be applied with the instance
         *      on which the method is called
         * @return {DataModel} New DataModel instance with the result of the operation
         */

    }, {
        key: 'difference',
        value: function difference(differenceWith) {
            return Object(_operator__WEBPACK_IMPORTED_MODULE_3__["difference"])(this, differenceWith);
        }

        /**
         * {@link link_to_selection | Selection} is a row filtering operation. It expects a predicate and an optional mode
         * which control which all rows should be included in the resultant DataModel instance.
         *
         * {@link SelectionPredicate} is a function which returns a boolean value. For selection operation the selection
         * function is called for each row of DataModel instance with the current row passed as argument.
         *
         * After executing {@link SelectionPredicate} the rows are labeled as either an entry of selection set or an entry
         * of rejection set.
         *
         * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the
         * resultant datamodel.
         *
         * @warning
         * Selection and rejection set is only a logical idea for concept explanation purpose.
         *
         * @example
         *  // with selection mode NORMAL:
         *  const normDt = dt.select(fields => fields.Origin.value === "USA")
         *  console.log(normDt));
         *
         * // with selection mode INVERSE:
         * const inverDt = dt.select(fields => fields.Origin.value === "USA", { mode: DataModel.FilteringMode.INVERSE })
         * console.log(inverDt);
         *
         * // with selection mode ALL:
         * const dtArr = dt.select(fields => fields.Origin.value === "USA", { mode: DataModel.FilteringMode.ALL })
         * // print the selected parts
         * console.log(dtArr[0]);
         * // print the inverted parts
         * console.log(dtArr[1]);
         *
         * @text
         * This is chained version of `select` operator. `select` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {Function} selectFn - The predicate function which is called for each row with the current row.
         * ```
         *  function (row, i, cloneProvider, store)  { ... }
         * ```
         * @param {Object} config - The configuration object to control the inclusion exclusion of a row in resultant
         * DataModel instance.
         * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - The mode of the selection.
         * @return {DataModel} Returns the new DataModel instance(s) after operation.
         */

    }, {
        key: 'select',
        value: function select(selectFn, config) {
            var defConfig = {
                mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL,
                saveChild: true
            };
            config = Object.assign({}, defConfig, config);
            config.mode = config.mode || defConfig.mode;

            var cloneConfig = { saveChild: config.saveChild };
            return Object(_helper__WEBPACK_IMPORTED_MODULE_2__["cloneWithSelect"])(this, selectFn, config, cloneConfig);
        }

        /**
         * Retrieves a boolean value if the current {@link DataModel} instance has data.
         *
         * @example
         * const schema = [
         *    { name: 'CarName', type: 'dimension' },
         *    { name: 'HorsePower', type: 'measure' },
         *    { name: "Origin", type: 'dimension' }
         * ];
         * const data = [];
         *
         * const dt = new DataModel(data, schema);
         * console.log(dt.isEmpty());
         *
         * @public
         *
         * @return {Boolean} True if the datamodel has no data, otherwise false.
         */

    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return !this._rowDiffset.length || !this._colIdentifier.length;
        }

        /**
         * Creates a clone from the current DataModel instance with child parent relationship.
         *
         * @private
         * @param {boolean} [saveChild=true] - Whether the cloned instance would be recorded in the parent instance.
         * @return {DataModel} - Returns the newly cloned DataModel instance.
         */

    }, {
        key: 'clone',
        value: function clone() {
            var saveChild = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var clonedDm = new this.constructor(this);
            if (saveChild) {
                clonedDm.setParent(this);
            } else {
                clonedDm.setParent(null);
            }
            return clonedDm;
        }

        /**
         * {@link Projection} is filter column (field) operation. It expects list of fields' name and either include those
         * or exclude those based on {@link FilteringMode} on the resultant variable.
         *
         * Projection expects array of fields name based on which it creates the selection and rejection set. All the field
         * whose name is present in array goes in selection set and rest of the fields goes in rejection set.
         *
         * {@link FilteringMode} operates on the selection and rejection set to determine which one would reflect in the
         * resulatant datamodel.
         *
         * @warning
         * Selection and rejection set is only a logical idea for concept explanation purpose.
         *
         * @example
         *  const dm = new DataModel(data, schema);
         *
         *  // with projection mode NORMAL:
         *  const normDt = dt.project(["Name", "HorsePower"]);
         *  console.log(normDt.getData());
         *
         *  // with projection mode INVERSE:
         *  const inverDt = dt.project(["Name", "HorsePower"], { mode: DataModel.FilteringMode.INVERSE })
         *  console.log(inverDt.getData());
         *
         *  // with selection mode ALL:
         *  const dtArr = dt.project(["Name", "HorsePower"], { mode: DataModel.FilteringMode.ALL })
         *  // print the normal parts
         *  console.log(dtArr[0].getData());
         *  // print the inverted parts
         *  console.log(dtArr[1].getData());
         *
         * @text
         * This is chained version of `select` operator. `select` can also be used as
         * {@link link_to_join_op | functional operator}.
         *
         * @public
         *
         * @param {Array.<string | Regexp>} projField - An array of column names in string or regular expression.
         * @param {Object} [config] - An optional config to control the creation of new DataModel
         * @param {FilteringMode} [config.mode=FilteringMode.NORMAL] - Mode of the projection
         *
         * @return {DataModel} Returns the new DataModel instance after operation.
         */

    }, {
        key: 'project',
        value: function project(projField, config) {
            var defConfig = {
                mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL,
                saveChild: true
            };
            config = Object.assign({}, defConfig, config);
            var fieldConfig = this.getFieldsConfig();
            var allFields = Object.keys(fieldConfig);
            var _config = config,
                mode = _config.mode;

            var normalizedProjField = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["getNormalizedProFields"])(projField, allFields, fieldConfig);

            var dataModel = void 0;

            if (mode === _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].ALL) {
                var projectionClone = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["cloneWithProject"])(this, normalizedProjField, {
                    mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].NORMAL,
                    saveChild: config.saveChild
                }, allFields);
                var rejectionClone = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["cloneWithProject"])(this, normalizedProjField, {
                    mode: _enums__WEBPACK_IMPORTED_MODULE_0__["FilteringMode"].INVERSE,
                    saveChild: config.saveChild
                }, allFields);
                dataModel = [projectionClone, rejectionClone];
            } else {
                var _projectionClone = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["cloneWithProject"])(this, normalizedProjField, config, allFields);
                dataModel = _projectionClone;
            }

            return dataModel;
        }
    }, {
        key: 'getFieldsConfig',
        value: function getFieldsConfig() {
            return this._fieldConfig;
        }
    }, {
        key: 'calculateFieldsConfig',
        value: function calculateFieldsConfig() {
            this._fieldConfig = this._fieldspace.fields.reduce(function (acc, fieldObj, i) {
                acc[fieldObj.name()] = {
                    index: i,
                    def: fieldObj.schema()
                };
                return acc;
            }, {});
            return this;
        }

        /**
         * Frees up the resources associated with the current DataModel instance and breaks all the links instance has in
         * the DAG.
         *
         * @public
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this._parent && this._parent.removeChild(this);
            this._parent = null;
            this._children.forEach(function (child) {
                child._parent = null;
            });
            this._children = [];
        }

        /**
         * Removes the specified child {@link DataModel} from the child list of the current {@link DataModel} instance.
         *
         * @example
         * const schema = [
         *    { name: 'Name', type: 'dimension' },
         *    { name: 'HorsePower', type: 'measure' },
         *    { name: "Origin", type: 'dimension' }
         * ];
         *
         * const data = [
         *    { Name: "chevrolet chevelle malibu", Horsepower: 130, Origin: "USA" },
         *    { Name: "citroen ds-21 pallas", Horsepower: 115, Origin: "Europe" },
         *    { Name: "datsun pl510", Horsepower: 88, Origin: "Japan" },
         *    { Name: "amc rebel sst", Horsepower: 150, Origin: "USA"},
         * ]
         *
         * const dt = new DataModel(data, schema);
         *
         * const dt2 = dt.select(fields => fields.Origin.value === "USA")
         * dt.removeChild(dt2);
         *
         * @private
         *
         * @param {DataModel} child - Delegates the parent to remove this child.
         */

    }, {
        key: 'removeChild',
        value: function removeChild(child) {
            var idx = this._children.findIndex(function (sibling) {
                return sibling === child;
            });
            idx !== -1 ? this._children.splice(idx, 1) : true;
        }

        /**
         * Sets the specified {@link DataModel} as a parent for the current {@link DataModel} instance.
         *
         * @param {DataModel} parent - The datamodel instance which will act as parent.
         */

    }, {
        key: 'setParent',
        value: function setParent(parent) {
            this._parent && this._parent.removeChild(this);
            this._parent = parent;
            parent && parent._children.push(this);
        }

        /**
         * Returns the parent {@link DataModel} instance.
         *
         * @example
         * const schema = [
         *    { name: 'Name', type: 'dimension' },
         *    { name: 'HorsePower', type: 'measure' },
         *    { name: "Origin", type: 'dimension' }
         * ];
         *
         * const data = [
         *    { Name: "chevrolet chevelle malibu", Horsepower: 130, Origin: "USA" },
         *    { Name: "citroen ds-21 pallas", Horsepower: 115, Origin: "Europe" },
         *    { Name: "datsun pl510", Horsepower: 88, Origin: "Japan" },
         *    { Name: "amc rebel sst", Horsepower: 150, Origin: "USA"},
         * ]
         *
         * const dt = new DataModel(data, schema);
         *
         * const dt2 = dt.select(fields => fields.Origin.value === "USA");
         * const parentDm = dt2.getParent();
         *
         * @return {DataModel} Returns the parent DataModel instance.
         */

    }, {
        key: 'getParent',
        value: function getParent() {
            return this._parent;
        }

        /**
         * Returns the immediate child {@link DataModel} instances.
         *
         * @example
         * const schema = [
         *    { name: 'Name', type: 'dimension' },
         *    { name: 'HorsePower', type: 'measure' },
         *    { name: "Origin", type: 'dimension' }
         * ];
         *
         * const data = [
         *    { Name: "chevrolet chevelle malibu", Horsepower: 130, Origin: "USA" },
         *    { Name: "citroen ds-21 pallas", Horsepower: 115, Origin: "Europe" },
         *    { Name: "datsun pl510", Horsepower: 88, Origin: "Japan" },
         *    { Name: "amc rebel sst", Horsepower: 150, Origin: "USA"},
         * ]
         *
         * const dt = new DataModel(data, schema);
         *
         * const childDm1 = dt.select(fields => fields.Origin.value === "USA");
         * const childDm2 = dt.select(fields => fields.Origin.value === "Japan");
         * const childDm3 = dt.groupBy(["Origin"]);
         *
         * @return {DataModel[]} Returns the immediate child DataModel instances.
         */

    }, {
        key: 'getChildren',
        value: function getChildren() {
            return this._children;
        }

        /**
         * Returns the in-between operation meta data while creating the current {@link DataModel} instance.
         *
         * @example
         * const schema = [
         *   { name: 'Name', type: 'dimension' },
         *   { name: 'HorsePower', type: 'measure' },
         *   { name: "Origin", type: 'dimension' }
         * ];
         *
         * const data = [
         *   { Name: "chevrolet chevelle malibu", Horsepower: 130, Origin: "USA" },
         *   { Name: "citroen ds-21 pallas", Horsepower: 115, Origin: "Europe" },
         *   { Name: "datsun pl510", Horsepower: 88, Origin: "Japan" },
         *   { Name: "amc rebel sst", Horsepower: 150, Origin: "USA"},
         * ]
         *
         * const dt = new DataModel(data, schema);
         * const dt2 = dt.select(fields => fields.Origin.value === "USA");
         * const dt3 = dt2.groupBy(["Origin"]);
         * const derivations = dt3.getDerivations();
         *
         * @return {Any[]} Returns the derivation meta data.
         */

    }, {
        key: 'getDerivations',
        value: function getDerivations() {
            return this._derivation;
        }

        /**
         * Returns the in-between operation meta data happened from root {@link DataModel} to current instance.
         *
         * @example
         * const schema = [
         *   { name: 'Name', type: 'dimension' },
         *   { name: 'HorsePower', type: 'measure' },
         *   { name: "Origin", type: 'dimension' }
         * ];
         *
         * const data = [
         *   { Name: "chevrolet chevelle malibu", Horsepower: 130, Origin: "USA" },
         *   { Name: "citroen ds-21 pallas", Horsepower: 115, Origin: "Europe" },
         *   { Name: "datsun pl510", Horsepower: 88, Origin: "Japan" },
         *   { Name: "amc rebel sst", Horsepower: 150, Origin: "USA"},
         * ]
         *
         * const dt = new DataModel(data, schema);
         * const dt2 = dt.select(fields => fields.Origin.value === "USA");
         * const dt3 = dt2.groupBy(["Origin"]);
         * const ancDerivations = dt3.getAncestorDerivations();
         *
         * @return {Any[]} Returns the previous derivation meta data.
         */

    }, {
        key: 'getAncestorDerivations',
        value: function getAncestorDerivations() {
            return this._ancestorDerivation;
        }
    }]);

    return Relation;
}();

/* harmony default export */ __webpack_exports__["default"] = (Relation);

/***/ }),

/***/ "./src/stats/index.js":
/*!****************************!*\
  !*** ./src/stats/index.js ***!
  \****************************/
/*! exports provided: sum, avg, min, max, first, last, count, sd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avg", function() { return avg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "first", function() { return first; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "count", function() { return count; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sd", function() { return sd; });
/* harmony import */ var _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operator/group-by-function */ "./src/operator/group-by-function.js");


var sum = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].sum,
    avg = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].avg,
    min = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].min,
    max = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].max,
    first = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].first,
    last = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].last,
    count = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].count,
    sd = _operator_group_by_function__WEBPACK_IMPORTED_MODULE_0__["fnList"].std;


/***/ }),

/***/ "./src/utils/column-major.js":
/*!***********************************!*\
  !*** ./src/utils/column-major.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * The utility function to calculate major column.
 *
 * @param {Object} store - The store object.
 * @return {Function} Returns the push function.
 */
/* harmony default export */ __webpack_exports__["default"] = (function (store) {
    var i = 0;
    return function () {
        for (var _len = arguments.length, fields = Array(_len), _key = 0; _key < _len; _key++) {
            fields[_key] = arguments[_key];
        }

        fields.forEach(function (val, fieldIndex) {
            if (!(store[fieldIndex] instanceof Array)) {
                store[fieldIndex] = Array.from({ length: i });
            }
            store[fieldIndex].push(val);
        });
        i++;
    };
});

/***/ }),

/***/ "./src/utils/date-time-formatter.js":
/*!******************************************!*\
  !*** ./src/utils/date-time-formatter.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DateTimeFormatter; });
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Creates a JS native date object from input
 *
 * @param {string | number | Date} date Input using which date object to be created
 * @return {Date} : JS native date object
 */
function convertToNativeDate(date) {
    if (date instanceof Date) {
        return date;
    }

    return new Date(date);
}
/**
 * Apply padding before a number if its less than 1o. This is used when constant digit's number to be returned
 * between 0 - 99
 *
 * @param {number} n Input to be padded
 * @return {string} Padded number
 */
function pad(n) {
    return n < 10 ? '0' + n : n;
}
/*
 * DateFormatter utility to convert any date format to any other date format
 * DateFormatter parse a date time stamp specified by a user abiding by rules which are defined
 * by user in terms of token. It creates JS native date object from the user specified format.
 * That native date can also be displayed
 * in any specified format.
 * This utility class only takes care of format conversion only
 */

/*
 * Escapes all the special character that are used in regular expression.
 * Like
 * RegExp.escape('sgfd-$') // Output: sgfd\-\$
 *
 * @param text {String} : text which is to be escaped
 */
RegExp.escape = function (text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

/**
 * DateTimeFormatter class to convert any user format of date time stamp to any other format
 * of date time stamp.
 *
 * @param {string} format Format of the date given. For the above date,
 * 'year: %Y, month: %b, day: %d'.
 * @class
 */
/* istanbul ignore next */function DateTimeFormatter(format) {
    this.format = format;
    this.dtParams = undefined;
    this.nativeDate = undefined;
}

// The identifier of the tokens
DateTimeFormatter.TOKEN_PREFIX = '%';

// JS native Date constructor takes the date params (year, month, etc) in a certail sequence.
// This defines the sequence of the date parameters in the constructor.
DateTimeFormatter.DATETIME_PARAM_SEQUENCE = {
    YEAR: 0,
    MONTH: 1,
    DAY: 2,
    HOUR: 3,
    MINUTE: 4,
    SECOND: 5,
    MILLISECOND: 6
};

/*
 * This is a default number parsing utility. It tries to parse a number in integer, if parsing is unsuccessful, it
 * gives back a default value.
 *
 * @param: defVal {Number} : Default no if the parsing to integer is not successful
 * @return {Function} : An closure function which is to be called by passing an the value which needs to be parsed.
 */
DateTimeFormatter.defaultNumberParser = function (defVal) {
    return function (val) {
        var parsedVal = void 0;
        if (isFinite(parsedVal = parseInt(val, 10))) {
            return parsedVal;
        }

        return defVal;
    };
};

/*
 * This is a default number range utility. It tries to find an element in the range. If not found it returns a
 * default no as an index.
 *
 * @param: range {Array} : The list which is to be serached
 * @param: defVal {Number} : Default no if the serach and find does not return anything
 * @return {Function} : An closure function which is to be called by passing an the value which needs to be found
 */
DateTimeFormatter.defaultRangeParser = function (range, defVal) {
    return function (val) {
        var i = void 0;
        var l = void 0;

        if (!val) {
            return defVal;
        }

        var nVal = val.toLowerCase();

        for (i = 0, l = range.length; i < l; i++) {
            if (range[i].toLowerCase() === nVal) {
                return i;
            }
        }

        if (i === undefined) {
            return defVal;
        }
        return null;
    };
};

/*
 * Defines the tokens which are supporter by the dateformatter. Using this definitation a value gets extracted from
 * the user specifed date string. This also formats the value for display purpose from native JS date.
 * The definition of each token contains the following named properties
 * {
 *     %token_name% : {
 *         name: name of the token, this is used in reverse lookup,
 *         extract: a function that returns the regular expression to extract that piece of information. All the
 *                  regex should be gouped by using ()
 *         parser: a function which receives value extracted by the above regex and parse it to get the date params
 *         formatter: a formatter function that takes milliseconds or JS Date object and format the param
 *                  represented by the token only.
 *     }
 * }
 *
 * @return {Object} : Definition of the all the supported tokens.
 */
DateTimeFormatter.getTokenDefinitions = function () {
    var daysDef = {
        short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var monthsDef = {
        short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };

    var definitions = {
        H: {
            // 24 hours format
            name: 'H',
            index: 3,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);

                return d.getHours().toString();
            }
        },
        l: {
            // 12 hours format
            name: 'l',
            index: 3,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var hours = d.getHours() % 12;

                return (hours === 0 ? 12 : hours).toString();
            }
        },
        p: {
            // AM or PM
            name: 'p',
            index: 3,
            extract: function extract() {
                return '(AM|PM)';
            },

            parser: function parser(val) {
                if (val) {
                    return val.toLowerCase();
                }
                return null;
            },
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var hours = d.getHours();

                return hours < 12 ? 'AM' : 'PM';
            }
        },
        P: {
            // am or pm
            name: 'P',
            index: 3,
            extract: function extract() {
                return '(am|pm)';
            },

            parser: function parser(val) {
                if (val) {
                    return val.toLowerCase();
                }
                return null;
            },
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var hours = d.getHours();

                return hours < 12 ? 'am' : 'pm';
            }
        },
        M: {
            // Two digit minutes 00 - 59
            name: 'M',
            index: 4,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var mins = d.getMinutes();

                return pad(mins);
            }
        },
        S: {
            // Two digit seconds 00 - 59
            name: 'S',
            index: 5,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var seconds = d.getSeconds();

                return pad(seconds);
            }
        },
        K: {
            // Milliseconds
            name: 'K',
            index: 6,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var ms = d.getMilliseconds();

                return ms.toString();
            }
        },
        a: {
            // Short name of day, like Mon
            name: 'a',
            index: 2,
            extract: function extract() {
                return '(' + daysDef.short.join('|') + ')';
            },

            parser: DateTimeFormatter.defaultRangeParser(daysDef.short),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var day = d.getDay();

                return daysDef.short[day].toString();
            }
        },
        A: {
            // Long name of day, like Monday
            name: 'A',
            index: 2,
            extract: function extract() {
                return '(' + daysDef.long.join('|') + ')';
            },

            parser: DateTimeFormatter.defaultRangeParser(daysDef.long),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var day = d.getDay();

                return daysDef.long[day].toString();
            }
        },
        e: {
            // 8 of March, 11 of November
            name: 'e',
            index: 2,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var day = d.getDate();

                return day.toString();
            }
        },
        d: {
            // 08 of March, 11 of November
            name: 'd',
            index: 2,
            extract: function extract() {
                return '(\\d+)';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var day = d.getDate();

                return pad(day);
            }
        },
        b: {
            // Short month, like Jan
            name: 'b',
            index: 1,
            extract: function extract() {
                return '(' + monthsDef.short.join('|') + ')';
            },

            parser: DateTimeFormatter.defaultRangeParser(monthsDef.short),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var month = d.getMonth();

                return monthsDef.short[month].toString();
            }
        },
        B: {
            // Long month, like January
            name: 'B',
            index: 1,
            extract: function extract() {
                return '(' + monthsDef.long.join('|') + ')';
            },

            parser: DateTimeFormatter.defaultRangeParser(monthsDef.long),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var month = d.getMonth();

                return monthsDef.long[month].toString();
            }
        },
        m: {
            // Two digit month of year like 01 for January
            name: 'm',
            index: 1,
            extract: function extract() {
                return '(\\d+)';
            },
            parser: function parser(val) {
                return DateTimeFormatter.defaultNumberParser()(val) - 1;
            },
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var month = d.getMonth();

                return pad(month + 1);
            }
        },
        y: {
            // Short year like 90 for 1990
            name: 'y',
            index: 0,
            extract: function extract() {
                return '(\\d{2})';
            },
            parser: function parser(val) {
                var result = void 0;
                if (val) {
                    var l = val.length;
                    val = val.substring(l - 2, l);
                }
                var parsedVal = DateTimeFormatter.defaultNumberParser()(val);
                var presentDate = new Date();
                var presentYear = Math.trunc(presentDate.getFullYear() / 100);

                result = '' + presentYear + parsedVal;

                if (convertToNativeDate(result).getFullYear() > presentDate.getFullYear()) {
                    result = '' + (presentYear - 1) + parsedVal;
                }
                return convertToNativeDate(result).getFullYear();
            },
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var year = d.getFullYear().toString();
                var l = void 0;

                if (year) {
                    l = year.length;
                    year = year.substring(l - 2, l);
                }

                return year;
            }
        },
        Y: {
            // Long year like 1990
            name: 'Y',
            index: 0,
            extract: function extract() {
                return '(\\d{4})';
            },

            parser: DateTimeFormatter.defaultNumberParser(),
            formatter: function formatter(val) {
                var d = convertToNativeDate(val);
                var year = d.getFullYear().toString();

                return year;
            }
        }
    };

    return definitions;
};

/*
 * The tokens which works internally is not user friendly in terms of memorizing the names. This gives a formal
 * definition to the informal notations.
 *
 * @return {Object} : Formal definition of the tokens
 */
DateTimeFormatter.getTokenFormalNames = function () {
    var definitions = DateTimeFormatter.getTokenDefinitions();

    return {
        HOUR: definitions.H,
        HOUR_12: definitions.l,
        AMPM_UPPERCASE: definitions.p,
        AMPM_LOWERCASE: definitions.P,
        MINUTE: definitions.M,
        SECOND: definitions.S,
        SHORT_DAY: definitions.a,
        LONG_DAY: definitions.A,
        DAY_OF_MONTH: definitions.e,
        DAY_OF_MONTH_CONSTANT_WIDTH: definitions.d,
        SHORT_MONTH: definitions.b,
        LONG_MONTH: definitions.B,
        MONTH_OF_YEAR: definitions.m,
        SHORT_YEAR: definitions.y,
        LONG_YEAR: definitions.Y
    };
};

/*
 * This defines the rules and declares dependencies that resolves a date parameter (year, month etc) from
 * the date time parameter array.
 *
 * @return {Object} : An object that contains dependencies and a resolver function. The dependencies values are fed
 *                  to the resolver function in that particular sequence only.
 */
DateTimeFormatter.tokenResolver = function () {
    var definitions = DateTimeFormatter.getTokenDefinitions();
    var defaultResolver = function defaultResolver() {
        // eslint-disable-line require-jsdoc
        var i = 0;
        var arg = void 0;
        var targetParam = void 0;
        var l = arguments.length;

        for (; i < l; i++) {
            arg = arguments.length <= i ? undefined : arguments[i];
            if (arguments.length <= i ? undefined : arguments[i]) {
                targetParam = arg;
            }
        }

        if (!targetParam) {
            return null;
        }

        return targetParam[0].parser(targetParam[1]);
    };

    return {
        YEAR: [definitions.y, definitions.Y, defaultResolver],
        MONTH: [definitions.b, definitions.B, definitions.m, defaultResolver],
        DAY: [definitions.a, definitions.A, definitions.e, definitions.d, defaultResolver],
        HOUR: [definitions.H, definitions.l, definitions.p, definitions.P, function (hourFormat24, hourFormat12, ampmLower, ampmUpper) {
            var targetParam = void 0;
            var amOrpm = void 0;
            var isPM = void 0;
            var val = void 0;

            if (hourFormat12 && (amOrpm = ampmLower || ampmUpper)) {
                if (amOrpm[0].parser(amOrpm[1]) === 'pm') {
                    isPM = true;
                }

                targetParam = hourFormat12;
            } else if (hourFormat12) {
                targetParam = hourFormat12;
            } else {
                targetParam = hourFormat24;
            }

            if (!targetParam) {
                return null;
            }

            val = targetParam[0].parser(targetParam[1]);
            if (isPM) {
                val += 12;
            }
            return val;
        }],
        MINUTE: [definitions.M, defaultResolver],
        SECOND: [definitions.S, defaultResolver]
    };
};

/*
 * Finds token from the format rule specified by a user.
 * @param format {String} : The format of the input date specified by the user
 * @return {Array} : An array of objects which contains the available token and their occurence index in the format
 */
DateTimeFormatter.findTokens = function (format) {
    var tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;
    var definitions = DateTimeFormatter.getTokenDefinitions();
    var tokenLiterals = Object.keys(definitions);
    var occurrence = [];
    var i = void 0;
    var forwardChar = void 0;

    while ((i = format.indexOf(tokenPrefix, i + 1)) >= 0) {
        forwardChar = format[i + 1];
        if (tokenLiterals.indexOf(forwardChar) === -1) {
            continue;
        }

        occurrence.push({
            index: i,
            token: forwardChar
        });
    }

    return occurrence;
};

/*
 * Format any JS date to a specified date given by user.
 *
 * @param date {Number | Date} : The date object which is to be formatted
 * @param format {String} : The format using which the date will be formatted for display
 */
DateTimeFormatter.formatAs = function (date, format) {
    var nDate = convertToNativeDate(date);
    var occurrence = DateTimeFormatter.findTokens(format);
    var definitions = DateTimeFormatter.getTokenDefinitions();
    var formattedStr = String(format);
    var tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;
    var token = void 0;
    var formattedVal = void 0;
    var i = void 0;
    var l = void 0;

    for (i = 0, l = occurrence.length; i < l; i++) {
        token = occurrence[i].token;
        formattedVal = definitions[token].formatter(nDate);
        formattedStr = formattedStr.replace(new RegExp(tokenPrefix + token, 'g'), formattedVal);
    }

    return formattedStr;
};

/*
 * Parses the user specified date string to extract the date time params.
 *
 * @return {Array} : Value of date time params in an array [year, month, day, hour, minutes, seconds, milli]
 */
DateTimeFormatter.prototype.parse = function (dateTimeStamp, options) {
    var tokenResolver = DateTimeFormatter.tokenResolver();
    var dtParams = this.extractTokenValue(dateTimeStamp);
    var dtParamSeq = DateTimeFormatter.DATETIME_PARAM_SEQUENCE;
    var noBreak = options && options.noBreak;
    var dtParamArr = [];
    var args = [];
    var resolverKey = void 0;
    var resolverParams = void 0;
    var resolverFn = void 0;
    var val = void 0;
    var i = void 0;
    var param = void 0;
    var resolvedVal = void 0;
    var l = void 0;
    var result = [];

    for (resolverKey in tokenResolver) {
        if (!{}.hasOwnProperty.call(tokenResolver, resolverKey)) {
            continue;
        }

        args.length = 0;
        resolverParams = tokenResolver[resolverKey];
        resolverFn = resolverParams.splice(resolverParams.length - 1, 1)[0];

        for (i = 0, l = resolverParams.length; i < l; i++) {
            param = resolverParams[i];
            val = dtParams[param.name];

            if (val === undefined) {
                args.push(null);
            } else {
                args.push([param, val]);
            }
        }

        resolvedVal = resolverFn.apply(this, args);

        if ((resolvedVal === undefined || resolvedVal === null) && !noBreak) {
            break;
        }

        dtParamArr[dtParamSeq[resolverKey]] = resolvedVal;
    }

    if (dtParamArr.length && this.checkIfOnlyYear(dtParamArr.length)) {
        result.unshift(dtParamArr[0], 0, 1);
    } else {
        result.unshift.apply(result, dtParamArr);
    }

    return result;
};

/*
 * Extract the value of the token from user specified date time string.
 *
 * @return {Object} : An key value pair which contains the tokens as key and value as pair
 */
DateTimeFormatter.prototype.extractTokenValue = function (dateTimeStamp) {
    var format = this.format;
    var definitions = DateTimeFormatter.getTokenDefinitions();
    var tokenPrefix = DateTimeFormatter.TOKEN_PREFIX;
    var occurrence = DateTimeFormatter.findTokens(format);
    var tokenObj = {};

    var lastOccurrenceIndex = void 0;
    var occObj = void 0;
    var occIndex = void 0;
    var targetText = void 0;
    var regexFormat = void 0;

    var l = void 0;
    var i = void 0;

    regexFormat = String(format);

    var tokenArr = occurrence.map(function (obj) {
        return obj.token;
    });
    var occurrenceLength = occurrence.length;
    for (i = occurrenceLength - 1; i >= 0; i--) {
        occIndex = occurrence[i].index;

        if (occIndex + 1 === regexFormat.length - 1) {
            lastOccurrenceIndex = occIndex;
            continue;
        }

        if (lastOccurrenceIndex === undefined) {
            lastOccurrenceIndex = regexFormat.length;
        }

        targetText = regexFormat.substring(occIndex + 2, lastOccurrenceIndex);
        regexFormat = regexFormat.substring(0, occIndex + 2) + RegExp.escape(targetText) + regexFormat.substring(lastOccurrenceIndex, regexFormat.length);

        lastOccurrenceIndex = occIndex;
    }

    for (i = 0; i < occurrenceLength; i++) {
        occObj = occurrence[i];
        regexFormat = regexFormat.replace(tokenPrefix + occObj.token, definitions[occObj.token].extract());
    }

    var extractValues = dateTimeStamp.match(new RegExp(regexFormat)) || [];
    extractValues.shift();

    for (i = 0, l = tokenArr.length; i < l; i++) {
        tokenObj[tokenArr[i]] = extractValues[i];
    }
    return tokenObj;
};

/*
 * Give back the JS native date formed from  user specified date string
 *
 * @return {Date} : Native JS Date
 */
DateTimeFormatter.prototype.getNativeDate = function (dateTimeStamp) {
    var date = null;
    if (Number.isFinite(dateTimeStamp)) {
        date = new Date(dateTimeStamp);
    } else if (!this.format && Date.parse(dateTimeStamp)) {
        date = new Date(dateTimeStamp);
    } else {
        var dtParams = this.dtParams = this.parse(dateTimeStamp);
        if (dtParams.length) {
            this.nativeDate = new (Function.prototype.bind.apply(Date, [null].concat(_toConsumableArray(dtParams))))();
            date = this.nativeDate;
        }
    }
    return date;
};

DateTimeFormatter.prototype.checkIfOnlyYear = function (len) {
    return len === 1 && this.format.match(/y|Y/g).length;
};

/*
 * Represents JS native date to a user specified format.
 *
 * @param format {String} : The format according to which the date is to be represented
 * @return {String} : The formatted date string
 */
DateTimeFormatter.prototype.formatAs = function (format, dateTimeStamp) {
    var nativeDate = void 0;

    if (dateTimeStamp) {
        nativeDate = this.nativeDate = this.getNativeDate(dateTimeStamp);
    } else if (!(nativeDate = this.nativeDate)) {
        nativeDate = this.getNativeDate(dateTimeStamp);
    }

    return DateTimeFormatter.formatAs(nativeDate, format);
};



/***/ }),

/***/ "./src/utils/domain-generator.js":
/*!***************************************!*\
  !*** ./src/utils/domain-generator.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Generates domain for measure field.
 *
 * @param {Array} data - The array of data.
 * @return {Array} Returns the measure domain.
 */
/* harmony default export */ __webpack_exports__["default"] = (function (data) {
    var min = Number.POSITIVE_INFINITY;
    var max = Number.NEGATIVE_INFINITY;

    data.forEach(function (d) {
        if (d < min) {
            min = d;
        }
        if (d > max) {
            max = d;
        }
    });

    return [min, max];
});

/***/ }),

/***/ "./src/utils/extend2.js":
/*!******************************!*\
  !*** ./src/utils/extend2.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extend2; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable */
var OBJECTSTRING = 'object';
var objectToStrFn = Object.prototype.toString;
var objectToStr = '[object Object]';
var arrayToStr = '[object Array]';

function checkCyclicRef(obj, parentArr) {
    var i = parentArr.length;
    var bIndex = -1;

    while (i) {
        if (obj === parentArr[i]) {
            bIndex = i;
            return bIndex;
        }
        i -= 1;
    }

    return bIndex;
}

function merge(obj1, obj2, skipUndef, tgtArr, srcArr) {
    var item, srcVal, tgtVal, str, cRef;
    // check whether obj2 is an array
    // if array then iterate through it's index
    // **** MOOTOOLS precution

    if (!srcArr) {
        tgtArr = [obj1];
        srcArr = [obj2];
    } else {
        tgtArr.push(obj1);
        srcArr.push(obj2);
    }

    if (obj2 instanceof Array) {
        for (item = 0; item < obj2.length; item += 1) {
            try {
                srcVal = obj1[item];
                tgtVal = obj2[item];
            } catch (e) {
                continue;
            }

            if ((typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) !== OBJECTSTRING) {
                if (!(skipUndef && tgtVal === undefined)) {
                    obj1[item] = tgtVal;
                }
            } else {
                if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== OBJECTSTRING) {
                    srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                }
                cRef = checkCyclicRef(tgtVal, srcArr);
                if (cRef !== -1) {
                    srcVal = obj1[item] = tgtArr[cRef];
                } else {
                    merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                }
            }
        }
    } else {
        for (item in obj2) {
            try {
                srcVal = obj1[item];
                tgtVal = obj2[item];
            } catch (e) {
                continue;
            }

            if (tgtVal !== null && (typeof tgtVal === 'undefined' ? 'undefined' : _typeof(tgtVal)) === OBJECTSTRING) {
                // Fix for issue BUG: FWXT-602
                // IE < 9 Object.prototype.toString.call(null) gives
                // '[object Object]' instead of '[object Null]'
                // that's why null value becomes Object in IE < 9
                str = objectToStrFn.call(tgtVal);
                if (str === objectToStr) {
                    if (srcVal === null || (typeof srcVal === 'undefined' ? 'undefined' : _typeof(srcVal)) !== OBJECTSTRING) {
                        srcVal = obj1[item] = {};
                    }
                    cRef = checkCyclicRef(tgtVal, srcArr);
                    if (cRef !== -1) {
                        srcVal = obj1[item] = tgtArr[cRef];
                    } else {
                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                    }
                } else if (str === arrayToStr) {
                    if (srcVal === null || !(srcVal instanceof Array)) {
                        srcVal = obj1[item] = [];
                    }
                    cRef = checkCyclicRef(tgtVal, srcArr);
                    if (cRef !== -1) {
                        srcVal = obj1[item] = tgtArr[cRef];
                    } else {
                        merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                    }
                } else {
                    obj1[item] = tgtVal;
                }
            } else {
                if (skipUndef && tgtVal === undefined) {
                    continue;
                }
                obj1[item] = tgtVal;
            }
        }
    }
    return obj1;
}

function extend2(obj1, obj2, skipUndef) {
    //if none of the arguments are object then return back
    if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== OBJECTSTRING && (typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== OBJECTSTRING) {
        return null;
    }

    if ((typeof obj2 === 'undefined' ? 'undefined' : _typeof(obj2)) !== OBJECTSTRING || obj2 === null) {
        return obj1;
    }

    if ((typeof obj1 === 'undefined' ? 'undefined' : _typeof(obj1)) !== OBJECTSTRING) {
        obj1 = obj2 instanceof Array ? [] : {};
    }
    merge(obj1, obj2, skipUndef);
    return obj1;
}



/***/ }),

/***/ "./src/utils/geo.js":
/*!**************************!*\
  !*** ./src/utils/geo.js ***!
  \**************************/
/*! exports provided: bounds, centroid, center, area, isValidLatitude, isValidLongitude, latLongPredicates, isSame, geoUnion, distance, nearestPoint, perimeter, isInBounds, includes, within */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounds", function() { return bounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centroid", function() { return centroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "center", function() { return center; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "area", function() { return area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidLatitude", function() { return isValidLatitude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidLongitude", function() { return isValidLongitude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "latLongPredicates", function() { return latLongPredicates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSame", function() { return isSame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geoUnion", function() { return geoUnion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestPoint", function() { return nearestPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perimeter", function() { return perimeter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInBounds", function() { return isInBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "within", function() { return within; });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./src/utils/helper.js");
/* harmony import */ var _geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geo */ "./src/geo/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }





/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @return {boolean} inRing
 */
var inRing = function inRing(pt, ring, ignoreBoundary) {
    try {
        var isInside = false;
        if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
            ring = ring.slice(0, ring.length - 1);
        }
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var xi = ring[i][0];
            var yi = ring[i][1];
            var xj = ring[j][0];
            var yj = ring[j][1];
            var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
            if (onBoundary) {
                return !ignoreBoundary;
            }
            var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
            if (intersect) {
                isInside = !isInside;
            }
        }
        return isInside;
    } catch (err) {
        throw new Error('Wrong input for polygon');
    }
};

/**
 * Takes a set of coordinates, returns the geographical boundaries from all the coordinates in the data.
 *
 * @name bounds
 * @param {Array} coordinates any GeoJSON type array
 * @return {Array} [
 [lon, lat], // Represents the longitude and latitude of the southwest point.
 [lon, lat] // Represents the longitude and latitude of the northeast point.
]
*/
var bounds = function bounds(coordinates) {
    var boundArray = [[Infinity, Infinity], [-Infinity, -Infinity]];
    Array.isArray(coordinates) && coordinates.forEach(function (coordinate) {
        if (boundArray[0][0] > coordinate[0]) {
            boundArray[0][0] = coordinate[0];
        }
        if (boundArray[0][1] > coordinate[1]) {
            boundArray[0][1] = coordinate[1];
        }
        if (boundArray[1][0] < coordinate[0]) {
            boundArray[1][0] = coordinate[0];
        }
        if (boundArray[1][1] < coordinate[1]) {
            boundArray[1][1] = coordinate[1];
        }
    });
    return boundArray;
};

/**
 * Takes an array of points and returns the centroid
 *
 * @name centroid
 * @param {Array} points an array of points
 * @return {Array} the centroid
 */
var centroid = function centroid(points) {
    var sumX = 0;
    var sumY = 0;
    var count = points.length;
    for (var i in points) {
        sumX = +points[i][0];
        sumY = +points[i][1];
    }
    return count ? [Math.round(sumX / count * 100) / 100, Math.round(sumY / count * 100) / 100] : [0, 0];
};

/**
 * Takes an array of points and returns the center
 *
 * @name center
 * @param {Array} points an array of points
 * @return {Array} the center
 */
var center = function center(points) {
    var centerPoint = [0, 0];
    if (points[0] && points[0].length === 2) {
        var boundsData = bounds(points);
        var x = (boundsData[0][0] + boundsData[1][0]) / 2;
        var y = (boundsData[0][1] + boundsData[1][1]) / 2;
        centerPoint = [x, y];
    }
    return centerPoint;
};

/**
 * Get area of the Polygon.
 *
 * @param {Array} vertices the coordinates of the area
 * @return {number} the are of the polygon with the given coordinates
 */
var area = function area(vertices) {
    var total = 0;
    var addX = void 0;
    var addY = void 0;
    var subX = void 0;
    var subY = void 0;
    for (var i = 0, l = vertices.length; i < l; i++) {
        addX = vertices[i][0];
        addY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];
        subX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];
        subY = vertices[i][1];

        total += addX * addY * 0.5;
        total -= subX * subY * 0.5;
    }
    return Math.round(Math.abs(total) * 100) / 100;
};

var isValidLatitude = function isValidLatitude(val) {
    return val >= -90 && val <= 90;
};
var isValidLongitude = function isValidLongitude(val) {
    return val >= -180 && val <= 180;
};

var latLongPredicates = {
    0: isValidLongitude,
    1: isValidLatitude
};

/**
 * Compares two geoShapes for equality
 * First bounds of both shapes and checked, if they match, coordinates are matched.
 * @param {Object} geoField1 Instance of first geoField
 * @param {Object} geoField2 Instance of second geoField
 * @return {boolean} Returns true if both shapes are same, false otherwise.
 */
var compare = function compare(geoField1, geoField2) {
    var geoField1Coords = void 0;
    var geoField2Coords = void 0;
    var geoField1Bounds = geoField1.bounds();
    var geoField2Bounds = geoField2.bounds();
    var isBoundsEqual = geoField1Bounds.every(function (g, index) {
        return Object(_helper__WEBPACK_IMPORTED_MODULE_0__["isArrEqual"])(g, geoField2Bounds[index]);
    });

    if (!isBoundsEqual) return false;
    // Flatten coordinates only if bounds are equal
    geoField1Coords = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["flattenArrayToSingleLevel"])(geoField1.getCoordinates());
    geoField2Coords = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["flattenArrayToSingleLevel"])(geoField2.getCoordinates());

    switch (geoField1.type) {
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Point:
            return isBoundsEqual;
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiPoint:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].LineString:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiLineString:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Polygon:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiPolygon:
            return isBoundsEqual ? geoField1Coords.every(function (g, i) {
                return Object(_helper__WEBPACK_IMPORTED_MODULE_0__["isArrEqual"])(g, geoField2Coords[i]);
            }) : false;
        default:
            return false;
    }
};

/**
 * Checks if two geoShapes are equal
 * @param {Object} geoField1 first geo shape
 * @param {Object} geoField2 second geo shape
 * @return {boolean} true if shapes are equal, false otherwise
 */
var isSame = function isSame(geoField1, geoField2) {
    if (!geoField1 || !geoField2) return false;

    var type1 = geoField1.type;
    var type2 = geoField2.type;

    if (type1 !== type2) return false;
    return compare(geoField1, geoField2);
};

/**
 * Merges two coordinates of same geometry type
 * @param {Array} coordsArr Coordinates of shapes
 * @param {string} type Geometry type
 * @return {Array} Returns the combined coordinates
 */
var getMergedCoords = function getMergedCoords(coordsArr, type) {
    var _ref;

    switch (type) {
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Point:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].LineString:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Polygon:
            return [].concat(coordsArr);
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiPoint:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiLineString:
        case _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].MultiPolygon:
            return (_ref = []).concat.apply(_ref, _toConsumableArray(coordsArr));
        default:
            throw new Error('Invalid Geometry Type');
    }
};

/**
 * Combines two geometries of the same type
 * @param {Object} geoField1 first geo shape
 * @param {Object} geoField2 second geo shape
 * @return {Object} Returns the new combined geometry shape instance
 */
var geoUnion = function geoUnion() {
    for (var _len = arguments.length, geometry = Array(_len), _key = 0; _key < _len; _key++) {
        geometry[_key] = arguments[_key];
    }

    if (geometry.some(function (geom) {
        return !geom;
    }) || geometry.length < 2) {
        throw new Error('One or more geometry fields missing');
    }
    if (geometry.some(function (geom) {
        return geom.type !== geometry[0].type;
    })) {
        throw new Error('All geometries must be of the same type');
    }
    var geomType = geometry[0].type;
    var newGeoType = geomType;

    // If geomType is point/lineString/polygon, we need to return a multiPoint/multiLineString/multiPolygon
    if ([_enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Point, _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].LineString, _enums__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"].Polygon].includes(geomType)) {
        newGeoType = 'Multi' + geomType;
    }
    // Prepare data for combined geometry
    var data = {
        type: newGeoType,
        coordinates: getMergedCoords(geometry.map(function (geom) {
            return geom.getCoordinates();
        }), geomType)
    };

    // Prepare and return the geometry
    return new _geo__WEBPACK_IMPORTED_MODULE_1__["geometryMap"][newGeoType](data);
};

/**
 * Calculates the distance between two points in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Array.<Number>} from origin point
 * @param {Array.<Number>} to destination point
 * @param {string} units can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * const from = [-75.343, 39.984];
 * const to = [-75.534, 39.123];
 * const unit = 'miles';
 *
 */
var distance = function distance(from, to, unit) {
    var dLat = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(to[1] - from[1]);
    var dLon = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(to[0] - from[0]);
    var lat1 = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(from[1]);
    var lat2 = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(to[1]);

    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return Object(_helper__WEBPACK_IMPORTED_MODULE_0__["radiansToLength"])(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), unit);
};

/**
 * Finds out the nearest point to a given coordinate
 * @param {Object} geoFieldsCoordinates Array of coordinates
 * @param {Array} referencePoint Coordinate Array for which nearestPoint has to be found in [lon, lat]
 * @return {Array} nearestPoint - Returns the nearestPoint in [lon, lat]
 */
var nearestPoint = function nearestPoint(geoFieldsCoordinates, referencePoint) {
    var pointNearest = void 0;
    // Initially take the first point as the nearestPoint
    var minDistance = distance(geoFieldsCoordinates[0], referencePoint, _enums__WEBPACK_IMPORTED_MODULE_2__["DistanceUnits"].DEGREES);
    pointNearest = geoFieldsCoordinates[0];

    for (var i = 1, len = geoFieldsCoordinates.length; i < len; i++) {
        // Iterate through other points and find the nearest point
        var distanceFromCurrentPoint = distance(geoFieldsCoordinates[i], referencePoint, _enums__WEBPACK_IMPORTED_MODULE_2__["DistanceUnits"].DEGREES);

        if (distanceFromCurrentPoint < minDistance) {
            minDistance = distanceFromCurrentPoint;
            pointNearest = geoFieldsCoordinates[i];
        }
    }
    return pointNearest;
};

/**
 * Calculates perimeter of a given shape from the coordinates
 * @param {Array} coordinates Array of coordinates
 * @param {string} distanceUnit - Unit to be used to calculate perimeter
 * @return {number} Returns the perimeter of the shape rounded to 2 decimal places
 */
var perimeter = function perimeter(coordinates, distanceUnit) {
    var noOfLines = coordinates.length;
    var totalPerimeter = 0;

    // Calculate distance between each coordinates
    for (var i = 0, totLines = noOfLines - 1; i < totLines; i++) {
        var lineLength = distance(coordinates[i], coordinates[i + 1], distanceUnit);
        totalPerimeter += lineLength;
    }
    return totalPerimeter;
};

/**
 * inBounds
 *
 * @private
 * @param {Array.<number>} pt point [x,y]
 * @param {Array.<number>} bound bound coordinates [[left coords], [right coords]
 * @return {boolean} true/false if point is inside bounds
 */
var isInBounds = function isInBounds(pt, bound) {
    return bound[0][0] <= pt[0] && bound[0][1] <= pt[1] && bound[1][0] >= pt[0] && bound[1][1] >= pt[1];
};

/**
 * Takes whether a coordinates lies in the coordinates of a polygon
 *
 * @name has
 * @param {Array.<number>} coord1 input polygon
 * @param {Array.<number>} coord2 input point
 * @param {boolean} excludeBoundary True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @return {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var coord2 = [-77, 44];
 * var coord1 = [
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ];
 *
 * returns true;
 */
var includes = function includes(coord1, coord2, excludeBoundary) {
    if (!(Array.isArray(coord1) && Array.isArray(coord2))) {
        throw new Error('Wrong input for polygon');
    }
    var boundCoordinates = bounds(coord1);
    var insidePoly = false;

    // Quick elimination if point is not inside bounds
    if (boundCoordinates && isInBounds(coord2, boundCoordinates) && inRing(coord2, coord1, !!excludeBoundary)) {
        insidePoly = true;
    }
    return insidePoly;
};

/**
 * Takes which of a set of coordinates fall in the coordinates of a polygon
 *
 * @name within
 * @param {Array.<number>} points input point
 * @param {Array.<number>} polygon input polygon
 * @returns {Array.<number>} points that land within at least one polygon
 * @example
 * points = [
 *     [-46.6318, -23.5523],
 *     [-46.6246, -23.5325],
 *     [-46.6062, -23.5513],
 *     [-46.663, -23.554],
 *     [-46.643, -23.557]
 * ];
 *
 * polygon = [
 *     [-46.653,-23.543],
 *     [-46.634,-23.5346],
 *     [-46.613,-23.543],
 *     [-46.614,-23.559],
 *     [-46.631,-23.567],
 *     [-46.653,-23.560],
 *     [-46.653,-23.543]
 * ];
 */
var within = function within(points, polygon) {
    if (!Array.isArray(points) || !Array.isArray(polygon)) {
        throw new Error('Wrong input');
    }

    var result = [];

    points.map(function (point) {
        if (includes(polygon, point, false)) {
            result.push(point);
        }
        return point;
    });
    return result;
};

/***/ }),

/***/ "./src/utils/helper.js":
/*!*****************************!*\
  !*** ./src/utils/helper.js ***!
  \*****************************/
/*! exports provided: isArray, isObject, isString, isCallable, uniqueValues, getUniqueId, isArrEqual, isArrayOfNums, flattenArrayToSingleLevel, formatNumber, detectDataFormat, radiansToLength, degreesToRadians, lengthToRadians */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCallable", function() { return isCallable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueValues", function() { return uniqueValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniqueId", function() { return getUniqueId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrEqual", function() { return isArrEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayOfNums", function() { return isArrayOfNums; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenArrayToSingleLevel", function() { return flattenArrayToSingleLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatNumber", function() { return formatNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectDataFormat", function() { return detectDataFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radiansToLength", function() { return radiansToLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToRadians", function() { return degreesToRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lengthToRadians", function() { return lengthToRadians; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ "./src/enums/index.js");
/* harmony import */ var _enums_geo_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/geo-props */ "./src/enums/geo-props.js");
/* harmony import */ var _enums_geom_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/geom-types */ "./src/enums/geom-types.js");
/* harmony import */ var _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/distance-factors */ "./src/enums/distance-factors.js");
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }






/**
 * Checks whether the value is an array.
 *
 * @param  {*} val - The value to be checked.
 * @return {boolean} Returns true if the value is an array otherwise returns false.
 */
function isArray(val) {
    return Array.isArray(val);
}

/**
 * Checks whether the value is an object.
 *
 * @param  {*} val - The value to be checked.
 * @return {boolean} Returns true if the value is an object otherwise returns false.
 */
function isObject(val) {
    return val === Object(val);
}

/**
 * Checks whether the value is a string value.
 *
 * @param  {*} val - The value to be checked.
 * @return {boolean} Returns true if the value is a string value otherwise returns false.
 */
function isString(val) {
    return typeof val === 'string';
}

/**
 * Checks whether the value is callable.
 *
 * @param {*} val - The value to be checked.
 * @return {boolean} Returns true if the value is callable otherwise returns false.
 */
function isCallable(val) {
    return typeof val === 'function';
}

/**
 * Returns the unique values from the input array.
 *
 * @param {Array} data - The input array.
 * @return {Array} Returns a new array of unique values.
 */
function uniqueValues(data) {
    return [].concat(_toConsumableArray(new Set(data)));
}

var getUniqueId = function getUniqueId() {
    return 'id-' + new Date().getTime() + Math.round(Math.random() * 10000);
};

/**
 * Checks Whether two arrays have same content.
 *
 * @param {Array} arr1 - The first array.
 * @param {Array} arr2 - The 2nd array.
 * @return {boolean} Returns whether two array have same content.
 */
function isArrEqual(arr1, arr2) {
    if (!isArray(arr1) || !isArray(arr2)) {
        return arr1 === arr2;
    }

    if (arr1.length !== arr2.length) {
        return false;
    }

    for (var i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }

    return true;
}

/**
 * Checks whether all the elements of an array are numbers.
 * @param {Array} arr - Input Array
 *
 * @return {boolean} Returns true if all the values are numbers, false otherwise.
 */
function isArrayOfNums(arr) {
    return arr.every(function (val) {
        return typeof val === 'number';
    });
}

/**
 * Recursive function to flatten a nested array till all the elements are array of numbers.
 * @param {Array} arr - Input Array.
 * @param {Array} result - Resultant flat array.
 *
 * @return {Array} Returns an array with each element being an array of numbers.
 * @input For the following array
 * [
 *  [
 *      [
 *          [100, 12],
 *          [110, 11]
 *      ],
 *      [
 *          [120, 13],
 *          [130, 10]
 *      ]
 *  ]
 * ]
 * @output The following will be returned
 * [[100, 12], [110, 11], [120, 13], [130, 10]]
 */
var flattenArrayToSingleLevel = function flattenArrayToSingleLevel(arr) {
    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    for (var i = 0, length = arr.length; i < length; i++) {
        var value = arr[i];
        if (isArray(value) && !isArrayOfNums(value)) {
            flattenArrayToSingleLevel(value, result);
        } else {
            result.push(value);
        }
    }
    return result;
};

/**
 * It is the default number format function for the measure field type.
 *
 * @param {any} val - The input value.
 * @return {number} Returns a number value.
 */
function formatNumber(val) {
    return val;
}

var geoTypes = [].concat(_toConsumableArray(Object.values(_enums_geo_props__WEBPACK_IMPORTED_MODULE_1__["GeoProps"])), _toConsumableArray(Object.values(_enums_geom_types__WEBPACK_IMPORTED_MODULE_2__["GeomTypes"])));

/**
 * Returns if an object is a geojson object or not.
 *
 * @param {Object} data Data object.
 *
 * @return {boolean} Whether the object is geojson or not.
 */
var isGeoJSON = function isGeoJSON(data) {
    if (data instanceof Object) {
        var type = data.type;

        return geoTypes.some(function (geoType) {
            return type === geoType;
        });
    }
    return false;
};

/**
 * Returns the detected data format.
 *
 * @param {any} data - The input data to be tested.
 * @return {string} Returns the data format name.
 */
var detectDataFormat = function detectDataFormat(data) {
    if (isString(data)) {
        return _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].DSV_STR;
    } else if (isArray(data) && isArray(data[0])) {
        return _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].DSV_ARR;
    } else if (isArray(data) && (data.length === 0 || isObject(data[0]))) {
        return _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].FLAT_JSON;
    } else if (isGeoJSON(data)) {
        return _enums__WEBPACK_IMPORTED_MODULE_0__["DataFormat"].GEO_JSON;
    }

    return null;
};

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometers.
 * @return {number} distance
 */
var radiansToLength = function radiansToLength(radians, units) {
    var factor = _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["factors"][units];
    if (!factor) {
        throw new Error(units + ' units is invalid');
    }
    return Math.round(radians * factor * 100) / 100;
};

/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @return {number} angle in radians
 */
var degreesToRadians = function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
};

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} units="kilometers" can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
var lengthToRadians = function lengthToRadians(distance, units) {
    var factor = _enums_distance_factors__WEBPACK_IMPORTED_MODULE_3__["factors"][units];
    if (!factor) {
        throw new Error(units + ' units is invalid');
    }
    return distance / factor;
};

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! exports provided: DateTimeFormatter, columnMajor, generateMeasureDomain, extend2, isSame, geoUnion, perimeter, nearestPoint, bounds, centroid, center, area, distance, isInBounds, includes, within, isArray, isObject, isString, isCallable, uniqueValues, getUniqueId, isArrEqual, isArrayOfNums, flattenArrayToSingleLevel, formatNumber, detectDataFormat, radiansToLength, degreesToRadians, lengthToRadians */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _date_time_formatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date-time-formatter */ "./src/utils/date-time-formatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateTimeFormatter", function() { return _date_time_formatter__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _column_major__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column-major */ "./src/utils/column-major.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "columnMajor", function() { return _column_major__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _domain_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domain-generator */ "./src/utils/domain-generator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateMeasureDomain", function() { return _domain_generator__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _extend2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extend2 */ "./src/utils/extend2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend2", function() { return _extend2__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geo */ "./src/utils/geo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSame", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["isSame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoUnion", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["geoUnion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "perimeter", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["perimeter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nearestPoint", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["nearestPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bounds", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["bounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "centroid", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["centroid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "center", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["center"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "area", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["area"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["distance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isInBounds", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["isInBounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["includes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "within", function() { return _geo__WEBPACK_IMPORTED_MODULE_4__["within"]; });

/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper */ "./src/utils/helper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCallable", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isCallable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqueValues", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["uniqueValues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUniqueId", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["getUniqueId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrEqual", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isArrEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayOfNums", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["isArrayOfNums"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flattenArrayToSingleLevel", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["flattenArrayToSingleLevel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatNumber", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["formatNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectDataFormat", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["detectDataFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radiansToLength", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["radiansToLength"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "degreesToRadians", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["degreesToRadians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lengthToRadians", function() { return _helper__WEBPACK_IMPORTED_MODULE_5__["lengthToRadians"]; });








/***/ }),

/***/ "./src/utils/quick-select.js":
/*!***********************************!*\
  !*** ./src/utils/quick-select.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var swap = function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
};

var defaultCompare = function defaultCompare(a, b) {
    if (a > b) {
        return -1;
    }
    return a > b ? 1 : 0;
};

var quickselectStep = function quickselectStep(arr, k, left, right, compare) {
    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
                i++;
            }while (compare(arr[j], t) > 0) {
                j--;
            }
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
};

/**
 * Rearranges items so that all items in the [left, k] are the smallest. The k-th element will have the
 * (k - left + 1)-th smallest value in [left, right].
 * array: the array to partially sort (in place)
 * k: middle index for partial sorting (as defined above)
 * left: left index of the range to sort (0 by default)
 * right: right index (last index of the array by default)
 * compareFn: compare function
 *
 * Ref: https://github.com/mourner/quickselect
 * Example:
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * arr is [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 *                                         ^^ middle index
 * @param {Array} arr the array to partially sort (in place)
 * @param {Number} k middle index for partial sorting (as defined above)
 * @param {Number} left left index of the range to sort (0 by default)
 * @param {Number} right right index (last index of the array by default)
 * @param {Function} compare compare function
 */
var quickselect = function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
};

/* harmony default export */ __webpack_exports__["default"] = (quickselect);

/***/ }),

/***/ "./src/utils/r-tree.js":
/*!*****************************!*\
  !*** ./src/utils/r-tree.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _quick_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quick-select */ "./src/utils/quick-select.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }



var createNode = function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
};

var extend = function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
};

// min bounding rectangle of node children from k to p-1
var distBBox = function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k; i < p; i++) {
        var child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
};

// calculate node's bbox from bboxes of its children
var calcBBox = function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
};

var compareNodeMinX = function compareNodeMinX(a, b) {
    return a.minX - b.minX;
};
var compareNodeMinY = function compareNodeMinY(a, b) {
    return a.minY - b.minY;
};

var bboxArea = function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
};

var bboxMargin = function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
};

var enlargedArea = function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
};

var intersectionArea = function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX);
    var minY = Math.max(a.minY, b.minY);
    var maxX = Math.min(a.maxX, b.maxX);
    var maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
};

var contains = function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
};

var intersects = function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
};

var findItem = function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
};

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

var multiSelect = function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right];

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        var mid = left + Math.ceil((right - left) / n / 2) * n;
        Object(_quick_select__WEBPACK_IMPORTED_MODULE_0__["default"])(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
};

var _all = function _all(node, result) {
    var nodesToSearch = [];
    while (node) {
        if (node.leaf) result.push.apply(result, _toConsumableArray(node.children));else nodesToSearch.push.apply(nodesToSearch, _toConsumableArray(node.children));

        node = nodesToSearch.pop();
    }
    return result;
};

var RTree = function () {
    function RTree() {
        var maxEntries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;

        _classCallCheck(this, RTree);

        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
    }

    _createClass(RTree, [{
        key: 'all',
        value: function all() {
            return _all(this.data, []);
        }
    }, {
        key: 'search',
        value: function search(bbox) {
            var node = this.data;
            var result = [];

            if (!intersects(bbox, node)) return result;

            var toBBox = this.toBBox;
            var nodesToSearch = [];

            while (node) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = node.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var child = _step.value;

                        var childBBox = node.leaf ? toBBox(child) : child;

                        if (intersects(bbox, childBBox)) {
                            if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) _all(child, result);else nodesToSearch.push(child);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                node = nodesToSearch.pop();
            }

            return result;
        }
    }, {
        key: 'load',
        value: function load(data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
                for (var i = 0; i < data.length; i++) {
                    this.insert(data[i]);
                }
                return this;
            }

            // recursively build the tree with the given data from scratch using OMT algorithm
            var node = this.build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;
            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this.splitRoot(this.data, node);
            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }

                // insert the small tree into the large tree at appropriate level
                this.insertSingleItem(node, this.data.height - node.height - 1, true);
            }

            return this;
        }
    }, {
        key: 'insert',
        value: function insert(item) {
            if (item) this.insertSingleItem(item, this.data.height - 1);
            return this;
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.data = createNode([]);
            return this;
        }
    }, {
        key: 'remove',
        value: function remove(item, equalsFn) {
            if (!item) return this;

            var i = void 0;
            var parent = void 0;
            var goingUp = void 0;
            var node = this.data;
            var bbox = this.toBBox(item);
            var path = [];
            var indexes = [];

            // depth-first iterative tree traversal
            while (node || path.length) {
                if (!node) {
                    // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }

                if (node.leaf) {
                    // check current node
                    var index = findItem(item, node.children, equalsFn);

                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this.condense(path);
                        return this;
                    }
                }

                if (!goingUp && !node.leaf && contains(node, bbox)) {
                    // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];
                } else if (parent) {
                    // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;
                } else node = null; // nothing found
            }

            return this;
        }
    }, {
        key: 'toJSON',
        value: function toJSON() {
            return this.data;
        }
    }, {
        key: 'fromJSON',
        value: function fromJSON(data) {
            this.data = data;
            return this;
        }
    }, {
        key: 'toBBox',
        value: function toBBox(item) {
            return item;
        }
    }, {
        key: 'compareMinX',
        value: function compareMinX(a, b) {
            return a.minX - b.minX;
        }
    }, {
        key: 'compareMinY',
        value: function compareMinY(a, b) {
            return a.minY - b.minY;
        }
    }, {
        key: 'build',
        value: function build(items, left, right, height) {
            var N = right - left + 1;
            var M = this._maxEntries;
            var node = void 0;

            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }

            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));

                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M);
            var N1 = N2 * Math.ceil(Math.sqrt(M));

            multiSelect(items, left, right, N1, this.compareMinX);

            for (var i = left; i <= right; i += N1) {
                var right2 = Math.min(i + N1 - 1, right);

                multiSelect(items, i, right2, N2, this.compareMinY);

                for (var j = i; j <= right2; j += N2) {
                    var right3 = Math.min(j + N2 - 1, right2);

                    // pack each entry recursively
                    node.children.push(this.build(items, j, right3, height - 1));
                }
            }

            calcBBox(node, this.toBBox);

            return node;
        }
    }, {
        key: 'chooseSubtree',
        value: function chooseSubtree(bbox, node, level, path) {
            while (true) {
                path.push(node);

                if (node.leaf || path.length - 1 === level) break;

                var minArea = Infinity;
                var minEnlargement = Infinity;
                var targetNode = void 0;

                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var child = _step2.value;

                        var area = bboxArea(child);
                        var enlargement = enlargedArea(bbox, child) - area;

                        // choose entry with the least area enlargement
                        if (enlargement < minEnlargement) {
                            minEnlargement = enlargement;
                            minArea = area < minArea ? area : minArea;
                            targetNode = child;
                        } else if (enlargement === minEnlargement) {
                            // otherwise choose one with the smallest area
                            if (area < minArea) {
                                minArea = area;
                                targetNode = child;
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                node = targetNode || node.children[0];
            }

            return node;
        }
    }, {
        key: 'insertSingleItem',
        value: function insertSingleItem(item, level, isNode) {
            var bbox = isNode ? item : this.toBBox(item);
            var insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this.chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this.split(insertPath, level);
                    level--;
                } else break;
            }

            // adjust bboxes along the insertion path
            this.adjustParentBoxes(bbox, insertPath, level);
        }

        // split overflowed node into two

    }, {
        key: 'split',
        value: function split(insertPath, level) {
            var node = insertPath[level];
            var M = node.children.length;
            var m = this._minEntries;

            this.chooseSplitAxis(node, m, M);

            var splitIndex = this.chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);else this.splitRoot(node, newNode);
        }
    }, {
        key: 'splitRoot',
        value: function splitRoot(node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        }
    }, {
        key: 'chooseSplitIndex',
        value: function chooseSplitIndex(node, m, M) {
            var index = void 0;
            var minOverlap = Infinity;
            var minArea = Infinity;

            for (var i = m; i <= M - m; i++) {
                var bbox1 = distBBox(node, 0, i, this.toBBox);
                var bbox2 = distBBox(node, i, M, this.toBBox);

                var overlap = intersectionArea(bbox1, bbox2);
                var area = bboxArea(bbox1) + bboxArea(bbox2);

                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;

                    minArea = area < minArea ? area : minArea;
                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }

            return index || M - m;
        }

        // sorts node children by the best axis for split

    }, {
        key: 'chooseSplitAxis',
        value: function chooseSplitAxis(node, m, M) {
            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
            var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
            var xMargin = this.allDistMargin(node, m, M, compareMinX);
            var yMargin = this.allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        }

        // total margin of all possible split distributions where each node is at least m full

    }, {
        key: 'allDistMargin',
        value: function allDistMargin(node, m, M, compare) {
            node.children.sort(compare);

            var toBBox = this.toBBox;
            var leftBBox = distBBox(node, 0, m, toBBox);
            var rightBBox = distBBox(node, M - m, M, toBBox);
            var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

            for (var i = m; i < M - m; i++) {
                var child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }

            for (var _i = M - m - 1; _i >= m; _i--) {
                var _child = node.children[_i];
                extend(rightBBox, node.leaf ? toBBox(_child) : _child);
                margin += bboxMargin(rightBBox);
            }

            return margin;
        }
    }, {
        key: 'adjustParentBoxes',
        value: function adjustParentBoxes(bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        }
    }, {
        key: 'condense',
        value: function condense(path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);
                    } else this.clear();
                } else calcBBox(path[i], this.toBBox);
            }
        }
    }]);

    return RTree;
}();

/* harmony default export */ __webpack_exports__["default"] = (RTree);

/***/ }),

/***/ "./src/utils/reducer-store.js":
/*!************************************!*\
  !*** ./src/utils/reducer-store.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _operator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operator */ "./src/operator/index.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



/**
 * A page level storage which stores, registers, unregisters reducers for all the datamodel instances. There is only one
 * reducer store available in a page. All the datamodel instances receive same instance of reducer store. DataModel
 * out of the box provides handful of {@link reducer | reducers} which can be used as reducer funciton.
 *
 * @public
 * @namespace DataModel
 */

var ReducerStore = function () {
    function ReducerStore() {
        var _this = this;

        _classCallCheck(this, ReducerStore);

        this.store = new Map();
        this.store.set('defReducer', _operator__WEBPACK_IMPORTED_MODULE_0__["defReducer"]);

        Object.entries(_operator__WEBPACK_IMPORTED_MODULE_0__["fnList"]).forEach(function (key) {
            _this.store.set(key[0], key[1]);
        });
    }

    /**
     * Changes the `defaultReducer` globally. For all the fields which does not have `defAggFn` mentioned in schema, the
     * value of `defaultReducer` is used for aggregation.
     *
     * @public
     * @param {string} [reducer='sum'] - The name of the default reducer. It picks up the definition from store by doing
     * name lookup. If no name is found then it takes `sum` as the default reducer.
     * @return {ReducerStore} Returns instance of the singleton store in page.
     */


    _createClass(ReducerStore, [{
        key: 'defaultReducer',
        value: function defaultReducer() {
            if (!arguments.length) {
                return this.store.get('defReducer');
            }

            var reducer = arguments.length <= 0 ? undefined : arguments[0];

            if (typeof reducer === 'function') {
                this.store.set('defReducer', reducer);
            } else {
                reducer = String(reducer);
                if (Object.keys(_operator__WEBPACK_IMPORTED_MODULE_0__["fnList"]).indexOf(reducer) !== -1) {
                    this.store.set('defReducer', _operator__WEBPACK_IMPORTED_MODULE_0__["fnList"][reducer]);
                } else {
                    throw new Error('Reducer ' + reducer + ' not found in registry');
                }
            }
            return this;
        }

        /**
         *
         * Registers a {@link reducer | reducer}.
         * A {@link reducer | reducer} has to be registered before it is used.
         *
         * @example
         *  // find the mean squared value of a given set
         *  const reducerStore = DataModel.Reducers();
         *
         *  reducers.register('meanSquared', (arr) => {
         *      const squaredVal = arr.map(item => item * item);
         *      let sum = 0;
         *      for (let i = 0, l = squaredVal.length; i < l; i++) {
         *          sum += squaredVal[i++];
         *      }
         *
         *      return sum;
         *  })
         *
         *  // datamodel (dm) is already prepared with cars.json
         *  const dm1 = dm.groupBy(['origin'], {
         *      accleration: 'meanSquared'
         *  });
         *
         * @public
         *
         * @param {string} name formal name for a reducer. If the given name already exists in store it is overridden by new
         *      definition.
         * @param {Function} reducer definition of {@link reducer} function.
         *
         * @return {Function} function for unregistering the reducer.
         */

    }, {
        key: 'register',
        value: function register(name, reducer) {
            var _this2 = this;

            if (typeof reducer !== 'function') {
                throw new Error('Reducer should be a function');
            }

            name = String(name);
            this.store.set(name, reducer);

            return function () {
                _this2.__unregister(name);
            };
        }
    }, {
        key: '__unregister',
        value: function __unregister(name) {
            if (this.store.has(name)) {
                this.store.delete(name);
            }
        }
    }, {
        key: 'resolve',
        value: function resolve(name) {
            if (name instanceof Function) {
                return name;
            }
            return this.store.get(name);
        }
    }]);

    return ReducerStore;
}();

var reducerStore = function () {
    var store = null;

    function getStore() {
        if (store === null) {
            store = new ReducerStore();
        }
        return store;
    }
    return getStore();
}();

/* harmony default export */ __webpack_exports__["default"] = (reducerStore);

/***/ }),

/***/ "./src/value.js":
/*!**********************!*\
  !*** ./src/value.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./src/helper.js");
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



/**
 * The wrapper class on top of the primitive value of a field.
 *
 * @todo Need to have support for StringValue, NumberValue, DateTimeValue
 * and GeoValue. These types should expose predicate API mostly.
 */

var Value = function () {

    /**
     * Creates new Value instance.
     *
     * @param {*} val - the primitive value from the field cell.
     * @param {string | Field} field - The field from which the value belongs.
     */
    function Value(value, rawValue, field) {
        _classCallCheck(this, Value);

        var formattedValue = Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getNumberFormattedVal"])(field, value);

        Object.defineProperties(this, {
            _value: {
                enumerable: false,
                configurable: false,
                writable: false,
                value: value
            },
            _formattedValue: {
                enumerable: false,
                configurable: false,
                writable: false,
                value: formattedValue
            },
            _internalValue: {
                enumerable: false,
                configurable: false,
                writable: false,
                value: rawValue
            }
        });

        this.field = field;
    }

    /**
     * Returns the field value.
     *
     * @return {*} Returns the current value.
     */


    _createClass(Value, [{
        key: 'toString',


        /**
         * Converts to human readable string.
         *
         * @override
         * @return {string} Returns a human readable string of the field value.
         *
         */
        value: function toString() {
            return String(this.value);
        }

        /**
         * Returns the value of the field.
         *
         * @override
         * @return {*} Returns the field value.
         */

    }, {
        key: 'valueOf',
        value: function valueOf() {
            return this.value;
        }
    }, {
        key: 'value',
        get: function get() {
            return this._value;
        }

        /**
         * Returns the parsed value of field
         */

    }, {
        key: 'formattedValue',
        get: function get() {
            return this._formattedValue;
        }

        /**
         * Returns the internal value of field
         */

    }, {
        key: 'internalValue',
        get: function get() {
            return this._internalValue;
        }
    }]);

    return Value;
}();

/* harmony default export */ __webpack_exports__["default"] = (Value);

/***/ })

/******/ });
});
//# sourceMappingURL=datamodel.js.map

/***/ }),

/***/ "./packages/layout/src/enums/constants.js":
/*!************************************************!*\
  !*** ./packages/layout/src/enums/constants.js ***!
  \************************************************/
/*! exports provided: VIEW_INDEX, ROW_MATRIX_INDEX, COLUMN_MATRIX_INDEX, GRID_WIDTH, GRID_HEIGHT, BORDER, ROW_POINTER, COLUMN_POINTER, ROW_SIZE_IS_EQUAL, COLUMN_SIZE_IS_EQUAL, COLUMN_WIDTHS, ROW_HEIGHTS, LEFT_MATRIX_WIDTH, RIGHT_MATRIX_WIDTH, TOP_MATRIX_HEIGHT, BOTTOM_MATRIX_HEIGHT, MOUNT_POINT, LEFT_TABLE_ID, RIGHT_TABLE_ID, TOP_TABLE_ID, BOTTOM_TABLE_ID, CENTER_TABLE_ID, TOP_DIV_ID, BOTTOM_DIV_ID, CENTER_DIV_ID, HAVE_ROWS_CHANGED, HAVE_COLUMNS_CHANGED, HAVE_VALUES_CHANGED, ROW_MATRIX_WIDTH, COLUMN_MATRIX_HEIGHT, UNIT_WIDTH, UNIT_HEIGHT, STYLE, COLOR, WIDTH, COLLAPSE, SPACING, DISTRIBUTION, GUTTERSPACE, BREAK_PAGE, SHOW_ROW_BORDERS, SHOW_COL_BORDERS, SHOW_VALUE_BORDERS, HEIGHT, COLUMN, ROW, TOP, LEFT, RIGHT, BOTTOM, CENTER, CLICK, ROW_LEFT, ROW_RIGHT, COLUMN_BOTTOM, COLUMN_TOP, AUTO, ROW_SPAN, COL_SPAN, ROW_ROOT, COLUMN_ROOT, PRIMARY, SECONDARY, VERTICAL, HORIZONTAL, GRID, BLANK_BORDERS, PAGINATION, BUFFER, HOLISTIC, SCROLL, MIDDLE, NO_BORDERS, MAX_WIDTH_AVAIL_FOR_COL_MATRIX, COLUMN_MATRIX, MAX_HEIGHT_AVAIL_FOR_ROW_MATRIX, ROW_MATRIX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VIEW_INDEX", function() { return VIEW_INDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_MATRIX_INDEX", function() { return ROW_MATRIX_INDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_MATRIX_INDEX", function() { return COLUMN_MATRIX_INDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_WIDTH", function() { return GRID_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_HEIGHT", function() { return GRID_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER", function() { return BORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_POINTER", function() { return ROW_POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_POINTER", function() { return COLUMN_POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_SIZE_IS_EQUAL", function() { return ROW_SIZE_IS_EQUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_SIZE_IS_EQUAL", function() { return COLUMN_SIZE_IS_EQUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_WIDTHS", function() { return COLUMN_WIDTHS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_HEIGHTS", function() { return ROW_HEIGHTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT_MATRIX_WIDTH", function() { return LEFT_MATRIX_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT_MATRIX_WIDTH", function() { return RIGHT_MATRIX_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP_MATRIX_HEIGHT", function() { return TOP_MATRIX_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM_MATRIX_HEIGHT", function() { return BOTTOM_MATRIX_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNT_POINT", function() { return MOUNT_POINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT_TABLE_ID", function() { return LEFT_TABLE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT_TABLE_ID", function() { return RIGHT_TABLE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP_TABLE_ID", function() { return TOP_TABLE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM_TABLE_ID", function() { return BOTTOM_TABLE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CENTER_TABLE_ID", function() { return CENTER_TABLE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP_DIV_ID", function() { return TOP_DIV_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM_DIV_ID", function() { return BOTTOM_DIV_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CENTER_DIV_ID", function() { return CENTER_DIV_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAVE_ROWS_CHANGED", function() { return HAVE_ROWS_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAVE_COLUMNS_CHANGED", function() { return HAVE_COLUMNS_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAVE_VALUES_CHANGED", function() { return HAVE_VALUES_CHANGED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_MATRIX_WIDTH", function() { return ROW_MATRIX_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_MATRIX_HEIGHT", function() { return COLUMN_MATRIX_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_WIDTH", function() { return UNIT_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_HEIGHT", function() { return UNIT_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STYLE", function() { return STYLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLLAPSE", function() { return COLLAPSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPACING", function() { return SPACING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DISTRIBUTION", function() { return DISTRIBUTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GUTTERSPACE", function() { return GUTTERSPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BREAK_PAGE", function() { return BREAK_PAGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW_ROW_BORDERS", function() { return SHOW_ROW_BORDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW_COL_BORDERS", function() { return SHOW_COL_BORDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW_VALUE_BORDERS", function() { return SHOW_VALUE_BORDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN", function() { return COLUMN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW", function() { return ROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CENTER", function() { return CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLICK", function() { return CLICK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_LEFT", function() { return ROW_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_RIGHT", function() { return ROW_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_BOTTOM", function() { return COLUMN_BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_TOP", function() { return COLUMN_TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTO", function() { return AUTO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_SPAN", function() { return ROW_SPAN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COL_SPAN", function() { return COL_SPAN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_ROOT", function() { return ROW_ROOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_ROOT", function() { return COLUMN_ROOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRIMARY", function() { return PRIMARY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDARY", function() { return SECONDARY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL", function() { return VERTICAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL", function() { return HORIZONTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID", function() { return GRID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLANK_BORDERS", function() { return BLANK_BORDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGINATION", function() { return PAGINATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUFFER", function() { return BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOLISTIC", function() { return HOLISTIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCROLL", function() { return SCROLL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIDDLE", function() { return MIDDLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_BORDERS", function() { return NO_BORDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_WIDTH_AVAIL_FOR_COL_MATRIX", function() { return MAX_WIDTH_AVAIL_FOR_COL_MATRIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN_MATRIX", function() { return COLUMN_MATRIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_HEIGHT_AVAIL_FOR_ROW_MATRIX", function() { return MAX_HEIGHT_AVAIL_FOR_ROW_MATRIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW_MATRIX", function() { return ROW_MATRIX; });
/**
 * This file exports constants that will be used to
 * create the state store of the table layout.
 */
/**
 * The index of top, bottom and center in the matrix
 */
const VIEW_INDEX = {
    top: 0,
    center: 1,
    bottom: 2
};

const ROW_MATRIX_INDEX = {
    0: 'top',
    1: 'center',
    2: 'bottom'
};

const COLUMN_MATRIX_INDEX = {
    0: 'left',
    1: 'middle',
    2: 'right'
};

/**
 * The width of the grid suppied by the user.
 */
const GRID_WIDTH = 'width';

/**
 * The height of the grid supplied by the user.
 */
const GRID_HEIGHT = 'height';

/**
  * The border for the grid
  */
const BORDER = 'border';

 /**
  *  The index of the first visible row in view matrix.
  */
const ROW_POINTER = 'rowPointer';

/**
 * The index of the first visible column in the view matrix.
 */
const COLUMN_POINTER = 'columnPointer';

/**
 * Flag to specify whether row sizes should be equal.
 */
const ROW_SIZE_IS_EQUAL = 'isRowSizeEqual';

/**
 * Flag to specify whether column sizes are equal.
 */
const COLUMN_SIZE_IS_EQUAL = 'isColumnSizeEqual';

/**
 * Field to store an array an of the widths of visible columns.
 * @computed
 */
const COLUMN_WIDTHS = 'visibleColumnWidths';

/**
 * Field to store an array of heights of visible rows.
 * @computed
 */
const ROW_HEIGHTS = 'visibleRowHeights';

/**
 * Field to store the width of the left matrix.
 * @computed
 */
const LEFT_MATRIX_WIDTH = 'leftMatrixWidth';

/**
 * Field to store the width of the right matrix.
 * @computed
 */
const RIGHT_MATRIX_WIDTH = 'rightMatrixWidth';

/**
 * Field to store the height of the top matrix.
 * @computed
 */
const TOP_MATRIX_HEIGHT = 'topMatrixHeight';

/**
 * Field to store the height of the bottom matrix.
 * @computed
 */
const BOTTOM_MATRIX_HEIGHT = 'bottomMatrixHeight';

/**
 * The dom element to render the layout inside.
 */
const MOUNT_POINT = 'mount';

/**
 * The id attribute of the left table element.
 */
const LEFT_TABLE_ID = 'grid-left';

/**
 * The id attribute of the right table element.
 */
const RIGHT_TABLE_ID = 'grid-right';

/**
 * The id attribute of the top table.
 */
const TOP_TABLE_ID = 'grid-top';

/**
 * The id attribute of the bottom table.
 */
const BOTTOM_TABLE_ID = 'grid-bottom';

/**
 * The id attribute of the center table.
 */
const CENTER_TABLE_ID = 'grid-center';

/**
 * The id attribute of the top div.
 */
const TOP_DIV_ID = 'muze-div-top';

/**
 * The id attribute of the bottom div.
 */
const BOTTOM_DIV_ID = 'muze-div-bottom';

/**
 * The id attribute of the center div.
 */
const CENTER_DIV_ID = 'muze-div-center';

/**
 * Field that indicates if the row configuration has changed
 */
const HAVE_ROWS_CHANGED = 'haveRowsChanged';

/**
 * Field that indicates if the column configuration has changed
 */
const HAVE_COLUMNS_CHANGED = 'haveColumnsChanged';

/**
 * Field that indicates if the values configuration for the center matrix has changed
 */
const HAVE_VALUES_CHANGED = 'haveValuesChanged';

/**
 * Field that indicates the width of row matrix
 */
const ROW_MATRIX_WIDTH = 'rowMatrixWidth';

/**
 * Field that indicates the height of row matrix
 */
const COLUMN_MATRIX_HEIGHT = 'columnMatrixHeight';

/**
 * Field that indicates the unit width of layout
 */
const UNIT_WIDTH = 'unitWidth';

/**
 * Field that indicates the unit height of layout
 */
const UNIT_HEIGHT = 'unitHeight';

/**
 * Field that indicates the style object
 */
const STYLE = 'style';

/**
 * Field that indicates the color configuration
 */
const COLOR = 'color';

/**
 * Field that indicates width
 */
const WIDTH = 'width';

/**
 * Field that indicates collpase property for border
 */
const COLLAPSE = 'collapse';

/**
 * Field that indicates spacing property for border
 */
const SPACING = 'spacing';

/**
 * Field that indicates spacing property for border
 */
const DISTRIBUTION = 'distribution';

/**
 * Field that indicates spacing property for border
 */
const GUTTERSPACE = 'gutterSpace';

/**
 * Field that indicates spacing property for border
 */
const BREAK_PAGE = 'breakPage';

/**
 * Field that indicates spacing property for border
 */
const SHOW_ROW_BORDERS = 'showRowBorders';

/**
 * Field that indicates spacing property for border
 */
const SHOW_COL_BORDERS = 'showColBorders';

/**
 * Field that indicates spacing property for border
 */
const SHOW_VALUE_BORDERS = 'showValueBorders';

const HEIGHT = 'height';
const COLUMN = 'column';
const ROW = 'row';
const TOP = 'top';
const LEFT = 'left';
const RIGHT = 'right';
const BOTTOM = 'bottom';
const CENTER = 'center';
const CLICK = 'click';
const ROW_LEFT = 'rowLeft';
const ROW_RIGHT = 'rowRight';
const COLUMN_BOTTOM = 'colBottom';
const COLUMN_TOP = 'colTop';
const AUTO = 'auto';
const ROW_SPAN = 'rowSpan';
const COL_SPAN = 'colSpan';
const ROW_ROOT = 'rowRoot';
const COLUMN_ROOT = 'columnRoot';
const PRIMARY = 'primary';
const SECONDARY = 'secondary';
const VERTICAL = 'vertical';
const HORIZONTAL = 'horizontal';
const GRID = 'grid';

const BLANK_BORDERS = 'rgba(0,0,0,0)';

const PAGINATION = 'pagination';
const BUFFER = 'buffer';
const HOLISTIC = 'holistic';
const SCROLL = 'scroll';
const MIDDLE = 'middle';
const NO_BORDERS = null;

const MAX_WIDTH_AVAIL_FOR_COL_MATRIX = 'maxWidthAvailableForColumnMatrix';
const COLUMN_MATRIX = 'columnMatrix';
const MAX_HEIGHT_AVAIL_FOR_ROW_MATRIX = 'maxHeightAvailableForRowMatrix';
const ROW_MATRIX = 'rowMatrix';


/***/ }),

/***/ "./packages/layout/src/generic-layout/index.js":
/*!*****************************************************!*\
  !*** ./packages/layout/src/generic-layout/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GenericLayout; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");



/*
 * This is the abstract implementation of the root layout. This takes care of common work which all the layouts
 * has to handle. The common work includes sanitizaion of inputs, update, rerender, dispose etc. This class can't be
 * used directly (as ofcourse this is an abstract implementaiton), the class which is implementing it has to implement
 * the necessary methods and gives its on visual.
 */

/**
 * This class is used to create a generic layout. It can be extended to create layouts
 * of different types
 * @class GenericLayout
 */
class GenericLayout {

    /**
     * Creates an instance of TableLayout.
     * @param {HTMLElement} mountPoint DOM element/d3 selection where the layout is to be mounted
     * @param {Object} measurement The dimensions of the layout
     * @param {Object} config configuration to be given for the layout
     * @param {Object} dependencies external dependencies.
     *
     * @memberof GenericLayout
     *
     */
    constructor (mountPoint, measurement, config, dependencies) {
        this._config = {};
        this._measurement = {};
        this._matrices = [];
        // External dependencies to be included for the layout. This includes the ext global dependencies like
        // smartlabel which has one single implementation of throughout the page or per isntance
        this._dependencies = dependencies;

        this.measurement(measurement);
        this.mountPoint(mountPoint);
        this.config(config);
    }

    /**
     * Returns an object which is used to recreate the layout.
     * @return {Object} the serialized components
     */
    serialize () {
        return {
            measurement: this.measurement(),
            config: this.config(),
            matrices: this.matrices()
        };
    }

     /**
     * Sets/Gets the config for the layout
     * @param {Object} config configuration for the layout
     * @return {Layout|Object} Gets the Config/ Returns this instance when set
     */
    config (config) {
        if (config) {
            this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._config || {}, config);
            this._config.border.width = Math.max(0, this._config.border.width);
            return this;
        }
        return this._config;
    }

    /**
     * Sets/Gets the measurement for the layout
     * @param {Object} measurement measurement for the layout
     * @return {Layout|Object} Gets the measurement/ Returns this instance when set
     */
    measurement (measurement) {
        if (measurement) {
            this._measurement = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._measurement || {}, measurement);

            return this;
        }
        return this._measurement;
    }

    /**
     * Sets/Gets the matrices for the layout
     * @param {Object} matrices matrices for the layout
     * @return {Layout|Object} Gets the matrices/ Returns this instance when set
     */
    matrices (matrices) {
        if (matrices) {
            this._matrices = muze_utils__WEBPACK_IMPORTED_MODULE_0__["sanitizeIP"].typeObj([_enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]], matrices);

            return this;
        }
        return this._matrices;
    }

    /**
     * Sets/Gets the matrix for row
     * @param {Object} matrix matrices for the layout
     * @return {Layout|Object} Gets the matrix/ Returns this instance when set
     */
    rowMatrix (matrix) {
        if (matrix) {
            this._rowMatrix = matrix;
            return this;
        }
        return this._rowMatrix;
    }

    /**
     * Sets/Gets the matrix for columns
     * @param {Object} matrix matrices for the layout
     * @return {Layout|Object} Gets the matrix/ Returns this instance when set
     */
    columnMatrix (matrix) {
        if (matrix) {
            this._columnMatrix = matrix;
            return this;
        }
        return this._columnMatrix;
    }

   /**
     * Sets/Gets the matrix for value
     * @param {Object} matrix matrices for the layout
     * @return {Layout|Object} Gets the matrix/ Returns this instance when set
     */
    centerMatrix (matrix) {
        if (matrix) {
            this._centerMatrix = matrix;
            return this;
        }
        return this._centerMatrix;
    }

    /**
     * Sets/Gets the mountPoint for the layout
     * @param {Object} mountPoint mountPoint for the layout
     * @return {Layout|Object} Gets the mountPoint/ Returns this instance when set
     */
    mountPoint (mountPoint) {
        if (mountPoint) {
            this._mountPoint = mountPoint;

            return this;
        }
        return this._mountPoint;
    }
}


/***/ }),

/***/ "./packages/layout/src/grid-layout/border-helper.js":
/*!**********************************************************!*\
  !*** ./packages/layout/src/grid-layout/border-helper.js ***!
  \**********************************************************/
/*! exports provided: applyBorders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyBorders", function() { return applyBorders; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");


const borderMap = {
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["NO_BORDERS"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["MIDDLE"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["NO_BORDERS"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["MIDDLE"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["NO_BORDERS"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["MIDDLE"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN"],
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]}`]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["NO_BORDERS"]
};

const applySpecificBorder = (cells, color, type, style) => {
    cells.style(`border-${type}`, `${style} ${color}`);
};

const specificBorderApplier = (borderTypes, showBorders, cells, borderInfo) => {
    const {
        color,
        width,
        style
    } = borderInfo;
    const borderStyle = `${width}px ${style}`;

    borderTypes.forEach((borderType) => {
        applySpecificBorder(cells, showBorders[borderType] ? color : _enums_constants__WEBPACK_IMPORTED_MODULE_0__["BLANK_BORDERS"], borderType, borderStyle);
    });
};

const borderApplier = (cells, borderInfo) => {
    const {
       showRowBorders,
      showColBorders,
      showValueBorders
  } = borderInfo;
    return {
        row: () => specificBorderApplier([_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]], showRowBorders, cells, borderInfo),
        column: () => specificBorderApplier([_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]], showColBorders, cells, borderInfo),
        center: () => specificBorderApplier([_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]], showValueBorders, cells, borderInfo)
    };
};

const applyBorders = (cells, border, row, column) => {
    const borderApplierFn = borderApplier(cells, border);
    const borderMapVal = borderMap[`${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW_MATRIX_INDEX"][_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VIEW_INDEX"][row]]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN_MATRIX_INDEX"][column]}`];
    if (borderMapVal) {
        borderApplierFn[borderMapVal]();
    }
};


/***/ }),

/***/ "./packages/layout/src/grid-layout/computations.js":
/*!*********************************************************!*\
  !*** ./packages/layout/src/grid-layout/computations.js ***!
  \*********************************************************/
/*! exports provided: getMatrixMeasurement, setMatrixMeasurement, computeLayoutMeasurements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatrixMeasurement", function() { return getMatrixMeasurement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixMeasurement", function() { return setMatrixMeasurement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLayoutMeasurements", function() { return computeLayoutMeasurements; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");


/**
 * Gets measurement for an instance of visual matrix
 *
 * @param {Array} matrix instance of visual matrix
 * @param {string} type height/width
 * @return {Object} Logical height/width of the matrix
 */
function getMatrixMeasurement (matrix, type) {
    if (matrix) {
        return matrix.getLogicalSpace()[type];
    }
    return 0;
}

/**
 * Sets available space for an instance of visual matrix
 *
 * @param {Array} matrix instance of visual matrix
 * @param {string} type height/width
 * @param {number} value Value of measurement
 */
function setMatrixMeasurement (matrix, type, value) {
    if (matrix) {
        const spaces = matrix.getLogicalSpace();
        if (value && spaces[type] !== value) {
            type === _enums_constants__WEBPACK_IMPORTED_MODULE_0__["HEIGHT"] ? matrix.setAvailableSpace(spaces.width, value) :
                matrix.setAvailableSpace(value, spaces.height);
        }
    }
}

const setAvailableSpace = (matrix, widths, heights) => {
    matrix.forEach((row, rIdx) => {
        row.forEach((placeholder, cIdx) => {
            placeholder.setAvailableSpace(widths[cIdx], heights[rIdx]);
        });
    });
};

const setViewSpaces = (layout, pointerType, viewSpaces) => {
    let pointer = layout.config()[`${pointerType}Pointer`];
    if (viewSpaces.length - 1 < pointer) {
        pointer = 0;
        layout.config({ [`${pointerType}Pointer`]: pointer });
    }
    return pointer;
};

const paginationDetailsMap = {
    column: {
        maxMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["MAX_WIDTH_AVAIL_FOR_COL_MATRIX"],
        matrix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN_MATRIX"],
        measureType: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["WIDTH"],
        scrollType: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"]
    },
    row: {
        maxMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["MAX_HEIGHT_AVAIL_FOR_ROW_MATRIX"],
        matrix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW_MATRIX"],
        measureType: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["HEIGHT"],
        scrollType: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"]
    }
};

/**
 * This method provides the required width/height in the different pagination stages.
 * If the pagination is holistic, then only the max width/height will be provided for layouting
 * If scroll is enabled, then the entire width/height shall be provided for layouting
 * Note: width is required for scrolling the columns while height is required for scrolling rows
 *
 *
 * @param {Layout} layout Layout instance required for configuration details
 * @param {Object} measureDetails different measure details for row/column
 * @param {number} maxMeasure maximum width/height present for column/row respectively
 * @return {number} Provides the width/height based on which further calculation can occur
 */
const getMatrixMeasureForPagination = (layout, measureDetails, maxMeasure, buffer) => {
    const {
        pagination
    } = layout.config();
    const {
        matrix,
        measureType,
        scrollType
    } = measureDetails;

    switch (pagination) {
    case _enums_constants__WEBPACK_IMPORTED_MODULE_0__["HOLISTIC"]:
        return maxMeasure;
    default: {
        const actualMeasure = getMatrixMeasurement(layout[matrix](), measureType) + buffer;

        if (actualMeasure > maxMeasure) {
            layout.scrollInfo({ [scrollType]: true });
        }
        return Math.max(maxMeasure, actualMeasure);
    }
    }
};

/**
 * This method uses the getMatrixMeasureForPagination function to calculate maximum measure
 * depending on the layouting algorithm used
 *
 *
 * @param {Layout} layout Layout instance required for configuration details
 * @param {string} matrixType row/column
 * @param {number} relatedMaxMeasure maximum width/height present for column/row respectively
 * @return {number} Provides the width/height based on which further calculation can occur
 */
const paginationMeasureGetter = (layout, matrixType, relatedMaxMeasure, buffer) =>
    getMatrixMeasureForPagination(layout, paginationDetailsMap[matrixType], relatedMaxMeasure, buffer);

const getMatrixWidthDetails = (layout) => {
    const rowMatrix = layout.rowMatrix();
    const {
        width
    } = layout.measurement();
    const {
        border,
        buffer
    } = layout.config();

    // Border adjustment for each cell in the central matrix
    const borderWidth = border.width;

    // Get width of row matrix
    const rowMatrixWidth = getMatrixMeasurement(rowMatrix, _enums_constants__WEBPACK_IMPORTED_MODULE_0__["WIDTH"]);

    // Get maximum width allowed for the row matrix
    const maxRowMatrixWidth = Math.min(rowMatrixWidth + buffer, width / 2);

    // Get maximum width available for the column matrix
    const maxWidthAvailableForColumnMatrix = width - maxRowMatrixWidth - borderWidth;

    // Set width for column matrix
    const columnMatrixWidth = paginationMeasureGetter(layout, _enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN"], maxWidthAvailableForColumnMatrix, 0);

    return {
        rowMatrixWidth,
        maxRowMatrixWidth,
        columnMatrixWidth,
        maxWidthAvailableForColumnMatrix
    };
};

const getHeightRequiredByColMatrix = (layout, columnMatrixWidth) => {
    const {
        height
    } = layout.measurement();
    const columnMatrix = layout.columnMatrix();

    // Get maximum allowed height for colum matrix
    const maxColumnMatrixHeight = Math.min(columnMatrix.getLogicalSpace().height, height / 2);

    // Set the computed width and max height to column matrix to determine the actual height
    // that will be taken by the column matrix
    columnMatrix.setAvailableSpace(columnMatrixWidth, maxColumnMatrixHeight);

    // Get the set of pages column view
    const columnViewPages = columnMatrix.getViewableSpaces();

    // Figuring out total space needed by current view space
    const columnViewSpace = columnViewPages[layout.config().columnPointer];

    // Getting height of column matrix
    const columnMatrixHeight = columnViewSpace.height.primary + columnViewSpace.height.secondary;

    return {
        columnMatrixHeight,
        maxColumnMatrixHeight
    };
};

const getMatrixHeightDetails = (layout, columnMatrixWidth) => {
    const {
        height
    } = layout.measurement();
    const {
        buffer
    } = layout.config();

    // Get actual height required by column matrix
    const { columnMatrixHeight, maxColumnMatrixHeight } = getHeightRequiredByColMatrix(layout, columnMatrixWidth);

    // Based on column height, compute max height available for row matrix
    const maxHeightAvailableForRowMatrix = height - Math.min(maxColumnMatrixHeight, columnMatrixHeight);

    // Get height for row matrix
    const rowMatrixHeight = paginationMeasureGetter(layout, _enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW"], maxHeightAvailableForRowMatrix, buffer);

    return {
        columnMatrixHeight,
        maxColumnMatrixHeight,
        rowMatrixHeight,
        maxHeightAvailableForRowMatrix
    };
};

const setValueMatrixMeasurements = (layout, rowViewableSpaces, columnViewableSpaces) => {
    const centerMatrix = layout.centerMatrix();

    const {
        border
    } = layout.config();
    const matrices = layout.matrices();
    const {
        top,
        bottom
    } = matrices;

    // Border adjustment for each cell in the central matrix
    const borderWidth = border.width;

    // Get the heights for each cell in the row matrix
    const rowHeights = [].concat(...rowViewableSpaces.map(e => e.rowHeights.primary));

    // Get the widths for each of the row matrix cells(primary and secondary)
    const rowWidthsPrimary = [].concat(...rowViewableSpaces.map(e => e.columnWidths.primary));
    const rowWidthsSecondary = [].concat(...rowViewableSpaces.map(e => e.columnWidths.secondary));

    // Get the widths for each cell in the column matrix
    const columnWidths = [].concat(...columnViewableSpaces.map(e => e.columnWidths.primary));

    // Get the widths for each of the column matrix cells(primary and secondary)
    const columnHeightsPrimary = columnViewableSpaces[0].rowHeights.primary;
    const columnHeightsSecondary = [].concat(...columnViewableSpaces.map(e => e.rowHeights.secondary));

    // Setting the available space for each cell in the centre matrix computed throught the row and
    // column matrices
    centerMatrix.forEach((matrix, rIdx) => {
        matrix.forEach((placeholder, cIdx) => {
            placeholder.setAvailableSpace(columnWidths[cIdx] - borderWidth, rowHeights[rIdx] - borderWidth);
        });
    });

    // Set the heights and widths for the corner matrices namely:
    // TOP_LEFT
    setAvailableSpace(top[0], rowWidthsPrimary, columnHeightsPrimary);
    // TOP_RIGHT
    setAvailableSpace(top[2], rowWidthsSecondary, columnHeightsPrimary);
    // BOTTOM_LEFT
    setAvailableSpace(bottom[0], rowWidthsPrimary, columnHeightsSecondary);
     // BOTTOM_RIGHT
    setAvailableSpace(bottom[2], rowWidthsSecondary, columnHeightsSecondary);
};

const bufferCondition = {
    isScroll: true,
    pagination: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["SCROLL"]
};

const getBufferFromCondition = (layout, type) => {
    const scrollInfo = layout.scrollInfo();
    const {
        pagination
    } = layout.config();

    const currentBufferType = {
        pagination,
        isScroll: scrollInfo[type]
    };

    return Object.keys(bufferCondition).every(e => bufferCondition[e] === currentBufferType[e]);
};

const getActualBufferFromConfig = (layout) => {
    const {
        buffer
    } = layout.config();
    const [horizontalBuffer, verticalBuffer] = [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"]].map((type) => {
        if (getBufferFromCondition(layout, type)) {
            return buffer;
        }
        return 0;
    });

    return {
        horizontalBuffer,
        verticalBuffer
    };
};
/**
 * Computes the measurements of space for all matrices in the
 * layout
 *
 * @param {Object} layout Instance of grid layout
 * @return {Object} set of measurements for the layout
 */
const computeLayoutMeasurements = (layout) => {
    const rowMatrix = layout.rowMatrix();
    const columnMatrix = layout.columnMatrix();

    // Compute the widths of the row and column matrices
    const {
        rowMatrixWidth,
        maxRowMatrixWidth,
        maxWidthAvailableForColumnMatrix,
        columnMatrixWidth
    } = getMatrixWidthDetails(layout);

    // Compute the heights of the row and column matrices
    const {
        columnMatrixHeight,
        rowMatrixHeight,
        maxHeightAvailableForRowMatrix
    } = getMatrixHeightDetails(layout, columnMatrixWidth);

    const {
        horizontalBuffer,
        verticalBuffer
    } = getActualBufferFromConfig(layout);
    rowMatrix.setAvailableSpace(maxRowMatrixWidth - verticalBuffer, rowMatrixHeight - horizontalBuffer);

    // Get row and columns viewable spaces
    const rowViewableSpaces = rowMatrix.getViewableSpaces();
    const columnViewableSpaces = columnMatrix.getViewableSpaces();

    // Set view spaces for row and columns
    setViewSpaces(layout, _enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW"], rowViewableSpaces);
    setViewSpaces(layout, _enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN"], columnViewableSpaces);

    // Set measures for each cell of the value matrix
    setValueMatrixMeasurements(layout, rowViewableSpaces, columnViewableSpaces);

    return {
        rowMatrixHeight: rowMatrixHeight - horizontalBuffer,
        rowMatrixWidth: rowMatrixWidth - verticalBuffer,
        maxHeightAvailableForRowMatrix: maxHeightAvailableForRowMatrix - horizontalBuffer,

        columnMatrixHeight,
        columnMatrixWidth,
        maxWidthAvailableForColumnMatrix
    };
};


/***/ }),

/***/ "./packages/layout/src/grid-layout/defaults.js":
/*!*****************************************************!*\
  !*** ./packages/layout/src/grid-layout/defaults.js ***!
  \*****************************************************/
/*! exports provided: DEFAULT_CONFIGURATION, DEFAULT_MEASUREMENTS, BLANK_BORDERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIGURATION", function() { return DEFAULT_CONFIGURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MEASUREMENTS", function() { return DEFAULT_MEASUREMENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLANK_BORDERS", function() { return BLANK_BORDERS; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");


/**
 * Default configuration of the layout
 * @return {Object} returns the default configuration
 */
const DEFAULT_CONFIGURATION = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BORDER"]]: {
        [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["STYLE"]]: 'solid',
        [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLOR"]]: '#d6d6d6',
        [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["WIDTH"]]: 2,
        [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLLAPSE"]]: true,
        [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SPACING"]]: 0
    },
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["PAGINATION"]]: 'scroll',
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BUFFER"]]: 20,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["GUTTERSPACE"]]: { rows: [], columns: [] },
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["DISTRIBUTION"]]: { rows: [], columns: [] },
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BREAK_PAGE"]]: { rows: [], columns: [] },
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW_SIZE_IS_EQUAL"]]: false,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN_SIZE_IS_EQUAL"]]: false,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMN_POINTER"]]: 0,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROW_POINTER"]]: 0
};

/**
 * Default measurements for the layout
 * @return {Object} returns the default measurements
 */
const DEFAULT_MEASUREMENTS = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["GRID_WIDTH"]]: 100,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["GRID_HEIGHT"]]: 100,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["UNIT_WIDTH"]]: 100,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["UNIT_HEIGHT"]]: 100
};

const BLANK_BORDERS = 'rgba(0,0,0,0)';


/***/ }),

/***/ "./packages/layout/src/grid-layout/index.js":
/*!**************************************************!*\
  !*** ./packages/layout/src/grid-layout/index.js ***!
  \**************************************************/
/*! exports provided: GridLayout, applyBorders, cellSpanMaker, applySpans */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./packages/layout/src/grid-layout/layout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridLayout", function() { return _layout__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _border_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./border-helper */ "./packages/layout/src/grid-layout/border-helper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyBorders", function() { return _border_helper__WEBPACK_IMPORTED_MODULE_1__["applyBorders"]; });

/* harmony import */ var _span_maker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./span-maker */ "./packages/layout/src/grid-layout/span-maker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cellSpanMaker", function() { return _span_maker__WEBPACK_IMPORTED_MODULE_2__["cellSpanMaker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applySpans", function() { return _span_maker__WEBPACK_IMPORTED_MODULE_2__["applySpans"]; });








/***/ }),

/***/ "./packages/layout/src/grid-layout/layout-helper.js":
/*!**********************************************************!*\
  !*** ./packages/layout/src/grid-layout/layout-helper.js ***!
  \**********************************************************/
/*! exports provided: generateVisualMatrices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateVisualMatrices", function() { return generateVisualMatrices; });
/* harmony import */ var _visual_matrix_row_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../visual-matrix/row-matrix */ "./packages/layout/src/visual-matrix/row-matrix.js");
/* harmony import */ var _visual_matrix_column_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../visual-matrix/column-matrix */ "./packages/layout/src/visual-matrix/column-matrix.js");



const generateVisualMatrices = (context, matrices) => {
    // Set of matrices for layout is generated starting with the left matrix
    let leftMatrix = [];
    let rightMatrix = [];
    let topMatrix = [];
    let bottomMatrix = [];
    let begColCells;
    let endColCells;
    const {
        isRowSizeEqual,
        isColumnSizeEqual,
        gutterSpace,
        distribution,
        border,
        breakPage,
        priority
    } = context.config();
    const {
        minUnitHeight,
        minUnitWidth
    } = context.measurement();
    const { top, center, bottom } = matrices;
    const [topLeft, topColumns, topRight] = top;
    const [leftRows, valueMatrix, rightRows] = center;
    const [bottomLeft, bottomColumns, bottomRight] = bottom;

    if (leftRows.length > 0) {
        // If no left matrix is present, context will be empty
        leftMatrix = [...topLeft, ...leftRows, ...bottomLeft];
    }
    if (rightRows.length > 0) {
        // If no right matrix is present, context will be empty
        rightMatrix = [...topRight, ...rightRows, ...bottomRight];
    }
    if (topColumns.length > 0 && topColumns[0].length > 0) {
        // If no top matrix is present, context will be empty
        topMatrix = topColumns.map((d, i) => [...topLeft[i], ...d, ...topRight[i]]);
    }
    if (bottomColumns.length > 0 && bottomColumns[0].length > 0) {
        // If no bottom matrix is present, context will be empty
        bottomMatrix = bottomColumns.map((d, i) => [...bottomLeft[i], ...d, ...bottomRight[i]]);
    }

    context.rowMatrix(new _visual_matrix_row_matrix__WEBPACK_IMPORTED_MODULE_0__["default"]([leftMatrix, rightMatrix], {
        isDistributionEqual: isRowSizeEqual,
        distribution: distribution.rows,
        gutter: gutterSpace.rows,
        unitMeasures: {
            width: minUnitWidth,
            height: minUnitHeight,
            border: border.width
        },
        priority: priority.row,
        breakPage: breakPage.rows.map(e => e + Math.max(topLeft.length, topRight.length)),
        extraCellLengths: [topLeft.length, bottomLeft.length]
    }));

    if (topLeft.length > 0) {
        begColCells = topLeft[0].length;
    } else {
        begColCells = bottomLeft.length > 0 ? bottomLeft[0].length : 0;
    }

    if (topRight.length > 0) {
        endColCells = topRight[0].length;
    } else {
        endColCells = bottomRight.length > 0 ? bottomRight[0].length : 0;
    }

    context.columnMatrix(new _visual_matrix_column_matrix__WEBPACK_IMPORTED_MODULE_1__["default"]([topMatrix, bottomMatrix], {
        isDistributionEqual: isColumnSizeEqual,
        distribution: distribution.columns,
        gutter: gutterSpace.columns,
        isTransposed: true,
        unitMeasures: {
            width: minUnitWidth,
            height: minUnitHeight,
            border: border.width
        },
        priority: priority.col,
        breakPage: breakPage.columns,
        extraCellLengths: [begColCells, endColCells]
    }));
    context.centerMatrix(valueMatrix);

    return matrices;
};


/***/ }),

/***/ "./packages/layout/src/grid-layout/layout.js":
/*!***************************************************!*\
  !*** ./packages/layout/src/grid-layout/layout.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridLayout; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _generic_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../generic-layout */ "./packages/layout/src/generic-layout/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/layout/src/grid-layout/defaults.js");
/* harmony import */ var _layout_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layout-helper */ "./packages/layout/src/grid-layout/layout-helper.js");
/* harmony import */ var _computations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./computations */ "./packages/layout/src/grid-layout/computations.js");
/* harmony import */ var _view_info_getter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./view-info-getter */ "./packages/layout/src/grid-layout/view-info-getter.js");
/**
 * This file declares a table that can be extended to create a Datagrid, crosstab
 * and man other visualzations that require a tabular structure.
 */







/**
 * This class is used to create a tabular structure that
 * can house charts and values.
 *
 * @class GridLayout
 */
class GridLayout extends _generic_layout__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Creates an instance of TableLayout.
     * @param {HTMLElement} matrices Set of upto 9 matrices containing the cells to be rendered
     * @param {HTMLElement} mountPoint DOM element/d3 selection where the layout is to be mounted
     * @param {Object} measurement The dimensions of the layout
     * @param {Object} config external configurations.
     * @memberof GenericLayout
     */
    constructor (matrices, mountPoint, measurement, config) {
        super(mountPoint, measurement, config);
        this.matrices(matrices);
        this.config(this.constructor.defaultConfig());
        this._layoutId = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._scrollInfo = { horizontal: false, vertical: false };
    }

    static defaultViewInfo () {
        return Object.assign({}, {
            layoutDimensions: {
                border: this.defaultConfig().border,
                viewHeight: [0, 0, 0],
                viewWidth: [0, 0, 0]
            },
            viewMatricesInfo: {
                columnPages: 0,
                rowPages: 0,
                matrices: { top: [], center: [], bottom: [] }
            }
        });
    }

    /**
     * Returns initial set of measurements for the grid layout
     *
     * @static
     * @return {Object} Returns initial set of measurements
     * @memberof GridLayout
     */
    static defaultMeasurement () {
        return _defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_MEASUREMENTS"];
    }

    /**
     * Returns initialconfiguration for grid layout
     *
     * @static
     * @return {Object} Returns initial configuration for grid layout
     * @memberof GridLayout
     */
    static defaultConfig () {
        return _defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIGURATION"];
    }

    /**
     * This function is used to return an instance of GridLayout
     *
     * @return {GridLayout} Instance of grid layout.
     * @static
     * @memberof GridLayout
     */
    static create () {
        return new GridLayout(null, null, this.defaultMeasurement(), this.defaultConfig());
    }

    /**
     * Sets/Gets the matrices for the layout
     *
     * @param {Array} matrices Set of matrices
     * @return {Object} Getter/Setter
     * @memberof GridLayout
     */
    matrices (matrices) {
        if (matrices) {
            this._matrices = Object(_layout_helper__WEBPACK_IMPORTED_MODULE_3__["generateVisualMatrices"])(this, matrices);
            return this;
        }
        return super.matrices(matrices);
    }

    /**
     * Triggers the computations for the layout based on the matrices available
     * This causes a reflow in the entire layout system.
     *
     * @return {Object} Layout instance
     * @memberof GridLayout
     */
    triggerReflow () {
        this.scrollInfo({ horizontal: false, vertical: false });
        const {
            maxHeightAvailableForRowMatrix,
            maxWidthAvailableForColumnMatrix
        } = Object(_computations__WEBPACK_IMPORTED_MODULE_4__["computeLayoutMeasurements"])(this);

        this.setViewInformation(maxHeightAvailableForRowMatrix, maxWidthAvailableForColumnMatrix);
        return this;
    }

    gotoPage (type, pageNumber) {
        const pageType = type.toLowerCase();
        const { viewMatricesInfo } = this.viewInfo();
        const totalPages = viewMatricesInfo[`${pageType}Pages`];
        const pointer = Math.min(Math.max(1, pageNumber), totalPages);
        this.config({
            [`${pageType}Pointer`]: pointer - 1
        });
        this.setViewInformation();
        this.renderGrid();
        return this;
    }

    pages (type) {
        const { viewMatricesInfo } = this.viewInfo();
        const pageType = type.toLowerCase();
        return {
            totalPages: viewMatricesInfo[`${pageType}Pages`],
            currentPage: this.config()[`${pageType}Pointer`] + 1
        };
    }

    viewInfo (...viewInfo) {
        if (viewInfo.length) {
            this._viewInfo = viewInfo[0];
            return this;
        }
        return this._viewInfo;
    }

    scrollInfo (...scrollInfo) {
        if (scrollInfo.length) {
            this._scrollInfo = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._scrollInfo, scrollInfo[0]);
            return this;
        }
        return this._scrollInfo;
    }

    /**
     *
     *
     * @returns
     * @memberof GridLayout
     */
    setViewInformation (maxRowHeight, maxColWidth) {
        const {
            rowPointer,
            columnPointer,
            border
        } = this.config();
        const viewMatricesInfo = Object(_view_info_getter__WEBPACK_IMPORTED_MODULE_5__["getViewMatrices"])(this, rowPointer, columnPointer);
        const layoutDimensions = Object(_view_info_getter__WEBPACK_IMPORTED_MODULE_5__["getViewMeasurements"])(this, maxRowHeight, maxColWidth);
        layoutDimensions.border = border;
        this.viewInfo({
            viewMatricesInfo,
            layoutDimensions
        });
        return this;
    }
}


/***/ }),

/***/ "./packages/layout/src/grid-layout/span-maker.js":
/*!*******************************************************!*\
  !*** ./packages/layout/src/grid-layout/span-maker.js ***!
  \*******************************************************/
/*! exports provided: cellSpanMaker, applySpans */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cellSpanMaker", function() { return cellSpanMaker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applySpans", function() { return applySpans; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");



const orderMaker = arr => Array.from(Array(arr.length).keys());

const nestByStack = (stack, updateArr, optionalParams = {}) => {
    let {
        order,
        keyFn
    } = optionalParams;
    const arr = updateArr.slice();
    const currStack = stack.slice();
    const prevStack = currStack.slice();
    // Order in which element are to be checked for nesting, default normal looping
    // Order is always in the order of nest, i.e., left to right
    order = order || Array.from(Array(arr.length).keys());

    // Key function, if array of objects
    keyFn = keyFn || (v => v);

    // Return same array if stack is empty
    if (currStack.length === 0) {
        const newArr = [];
        order.forEach((e) => {
            newArr.push(arr[e]);
        });
        return { prevStack, currStack: arr, arr: newArr };
    }

    let arrVal = '';
    let stackVal = '';
    const newArr = [];

    // Loop in order
    for (let i = order.length - 1; i >= 0; i--) {
        // Get current element index from the order given
        const currElemIndex = order[i];

        // Crete a hashmap for the hierarchy by joining strings of the array for both stack and input array
        arrVal += keyFn(arr[currElemIndex]);
        stackVal += keyFn(currStack[currElemIndex]);

        // If the current value and value in stack is same, convert it to null
        if (arrVal === stackVal) {
            newArr[currElemIndex] = null;
        } else {
            stackVal = '';
            // Loop from the current index in order to the last element in order to change the
            // whole hierarchy
            for (let j = i; j < order.length; j++) {
                const newElem = order[j];
                const arrElem = arr[newElem];

                newArr[newElem] = arrElem;

                // Reset stack to new stack
                currStack[newElem] = arrElem;
                stackVal = arrVal;
            }
        }
    }
    const returnArr = [];
    order.forEach((e) => {
        returnArr.push(newArr[e]);
    });
    return { prevStack, currStack, arr: returnArr };
};

const spanCalculator = (colData, colIdx, matrix, rIdx) => {
    // if data is not header cell then rowspan
    // has to be 1
    if (!colData) {
        return () => null;
    }

    const conditions = {
        row: count => matrix[rIdx + count] && matrix[rIdx + count][colIdx],
        column: count => matrix[rIdx][colIdx + count]
    };

    return (type) => {
        let count = 1;
        let isNull = false;

        while (!isNull) {
            if (conditions[type](count) === null) {
                count += 1;
            } else {
                isNull = true;
            }
        }
        return count;
    };
};

const maskCreator = (matrix, order) => ({
    row: () => {
        let stack = [];
        return matrix.map((e) => {
            const {
                    currStack,
                    arr
                } = nestByStack(stack, e, { keyFn: val => val.valueOf(), order });

            stack = currStack;
            return arr;
        });
    },
    column: () => {
        let stack = [];
        const viewMatrix = [];
        matrix.length && matrix[0].forEach((cell, colIndex) => {
            const hierarchy = [];
            matrix.forEach((row) => {
                hierarchy.push(row[colIndex]);
            });
            const {
                    currStack,
                    arr
                } = nestByStack(stack, hierarchy, { keyFn: val => val.valueOf(), order });
            stack = currStack;

            matrix.forEach((row, rowIndex) => {
                viewMatrix[rowIndex] = viewMatrix[rowIndex] || [];
                viewMatrix[rowIndex][colIndex] = arr[rowIndex];
            });
        });
        return viewMatrix;
    }
});

const spanGenerator = viewMatrix => ({
    row: () => {
        const spans = [];
        viewMatrix.forEach((row, ridx) => {
            spans[ridx] = spans[ridx] || [];
            row.forEach((col, i) => {
                if (viewMatrix[ridx][i]) {
                    const currSpan = spanCalculator(col, i, viewMatrix, ridx)('row');
                    currSpan && spans[ridx].push(currSpan);
                }
            });
        });
        return spans;
    },
    column: () => viewMatrix.map((row, ridx) => row.map((col, i) => spanCalculator(col, i, viewMatrix, ridx)('column'))
                    .filter(col => col !== null))
});

const getOrder = () => ({
    row: matrix => orderMaker(matrix[0]),
    column: matrix => orderMaker(matrix)
});

const matrixSpanGeneratorMap = {
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"]}-1`]: {
        orderGetter: getOrder()[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]],
        viewMatrixMaker: (...params) => maskCreator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]],
        spanMaker: (...params) => spanGenerator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]]
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]}-1`]: {
        orderGetter: getOrder()[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]],
        viewMatrixMaker: (...params) => maskCreator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]],
        spanMaker: (...params) => spanGenerator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMN"]]
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"]}-0`]: {
        orderGetter: getOrder()[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]],
        viewMatrixMaker: (...params) => maskCreator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]],
        spanMaker: (...params) => spanGenerator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]]
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"]}-2`]: {
        orderGetter: getOrder()[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]],
        viewMatrixMaker: (...params) => maskCreator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]],
        spanMaker: (...params) => spanGenerator(...params)[_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW"]]
    }
};

const matrixSpanGenerator = (type) => {
    const generator = matrixSpanGeneratorMap[type];
    if (generator) {
        return generator;
    }
    return {
        orderGetter: () => null,
        viewMatrixMaker: matrix => () => matrix,
        spanMaker: () => () => null
    };
};

/**
 * This function is used to set the col and row spans
 * for the matrices based on repeated/hierarchichal data
 *
 * @export
 * @param {Array} matrix The 2d array for which filtering is to be done
 * @param {string} type Type of array (center, top, bottom)
 * @param {number} index Index of array in the row
 * @return {Object} containing the view matrix and their spans
 */
function cellSpanMaker (matrix, type, index) {
    let spans = null;
    let viewMatrix = matrix;
    const {
        orderGetter,
        viewMatrixMaker,
        spanMaker
    } = matrixSpanGenerator(`${type}-${index}`);

    if (matrix.length) {
        const order = orderGetter(matrix);
        viewMatrix = viewMatrixMaker(matrix, order)();
        spans = spanMaker(viewMatrix)();
    }
    return { viewMatrix, spans };
}

const spaceAllocationDueToSpan = (span = 1, placeholder, config, index) => {
    const height = placeholder.availHeight();
    const width = placeholder.availWidth();
    const borderWidth = config.border.width;
    const { unitWidths } = config.dimensions;
    const { col } = index;

    return {
        [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW_SPAN"]] () {
            placeholder.setAvailableSpace(width, height * span);
            if (span === 1) {
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).style('height', `${height * span + borderWidth}px`);
            }
        },
        [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COL_SPAN"]] () {
            const primaryUnitWidth = unitWidths.primary[col];
            if (span > 1) {
                let cumulativeWidth = 0;
                for (let i = col; i < col + span; i++) {
                    cumulativeWidth += unitWidths.primary[i] - borderWidth;
                }
                placeholder.setAvailableSpace(cumulativeWidth + borderWidth, height);
            } else if (primaryUnitWidth) {
                placeholder.setAvailableSpace(primaryUnitWidth - borderWidth, height);
            }
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).style('height', `${height}px`);
        }
    };
};

const spanApplier = (cells, spans, config, type) => {
    let cellCounter = 0;
    cells.attr(type, function (cell, colIndex) {
        if (colIndex === 0) {
            cellCounter = 0;
        }
        const span = spans[cell.rowIndex][colIndex];
        const placeholder = cell.placeholder;
        const index = {
            row: cell.rowIndex,
            col: cellCounter
        };

        spaceAllocationDueToSpan(span, placeholder, config, index)[type].bind(this)();
        cellCounter += span;
        return span;
    });
};

const spanApplierMap = {
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"]}-0`]: null,
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"]}-1`]: (...params) => spanApplier(...params, _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COL_SPAN"]),
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"]}-2`]: null,
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"]}-0`]: (...params) => spanApplier(...params, _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW_SPAN"]),
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"]}-1`]: null,
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"]}-2`]: (...params) => spanApplier(...params, _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROW_SPAN"]),
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]}-0`]: null,
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]}-1`]: (...params) => spanApplier(...params, _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COL_SPAN"]),
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]}-2`]: null
};

const applySpans = (cells, spans, config, type) => {
    const applier = spanApplierMap[type];
    if (applier) {
        applier(cells, spans, config);
    }
};


/***/ }),

/***/ "./packages/layout/src/grid-layout/view-info-getter.js":
/*!*************************************************************!*\
  !*** ./packages/layout/src/grid-layout/view-info-getter.js ***!
  \*************************************************************/
/*! exports provided: getViewMatrices, getViewMeasurements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getViewMatrices", function() { return getViewMatrices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getViewMeasurements", function() { return getViewMeasurements; });
/**
 * Gets view matrices based on current pointers for row and column
 *
 * @param {Object} layout instance of layout
 * @param {number} rowPointer current row pointer
 * @param {number} columnPointer current column pointer
 * @return {Object} returns the view matrix and its relevant information
 */
const getViewMatrices = (layout, rowPointer, columnPointer) => {
    const rowMatrix = layout.rowMatrix();
    const columnMatrix = layout.columnMatrix();
    const centerMatrix = layout.centerMatrix();
    const matrices = layout.matrices();
    const rowMatrices = rowMatrix.getViewableMatrices();
    const columnMatrices = columnMatrix.getViewableMatrices();
    const centralMatrixPointer = {
        row: 0,
        column: 0
    };

    for (let i = rowPointer - 1; i >= 0; i--) {
        const length = Math.max(rowMatrices[i].primaryMatrix.length,
            rowMatrices[i].secondaryMatrix.length);
        centralMatrixPointer.row += length;
    }
     /* istanbul ignore next */
    for (let i = columnPointer - 1; i >= 0; i--) {
        const matrix = columnMatrices[i];
        const { primaryMatrix, secondaryMatrix } = matrix;
        const length = Math.max(primaryMatrix[0] ? primaryMatrix[0].length : 0,
            secondaryMatrix[0] ? secondaryMatrix[0].length : 0);
        centralMatrixPointer.column += length;
    }

    matrices.top[1] = columnMatrices[columnPointer].primaryMatrix;
    matrices.bottom[1] = columnMatrices[columnPointer].secondaryMatrix;

    matrices.center[0] = rowMatrices[rowPointer].primaryMatrix;
    matrices.center[2] = rowMatrices[rowPointer].secondaryMatrix;

    const rowMatrixLen = Math.max(matrices.center[0].length, matrices.center[2].length);
     /* istanbul ignore next */
    const columnMatrixLen = Math.max(matrices.top[1][0] ? matrices.top[1][0].length : 0, matrices.bottom[1][0] ?
            matrices.bottom[1][0].length : 0);
    matrices.center[1] = centerMatrix.slice(centralMatrixPointer.row, centralMatrixPointer.row + rowMatrixLen)
        .map(matrix => matrix.slice(centralMatrixPointer.column, centralMatrixPointer.column + columnMatrixLen));

    return {
        matrices,
        rowPages: rowMatrices.length,
        columnPages: columnMatrices.length
    };
};

const measureSum = measureArr => measureArr.reduce((total, measure) => total + measure, 0);
/**
 * Returns measurements of the cells of the current matrix
 *
 * @param {Object} layout instance of layout
 * @return {Object} returns the measurements for current view matrix
 */
const getViewMeasurements = (layout, maxRowHeight, maxColWidth) => {
    const rowMatrix = layout.rowMatrix();
    const columnMatrix = layout.columnMatrix();
    const {
        columnPointer,
        rowPointer
    } = layout.config();

    const rowSpaces = rowMatrix.getViewableSpaces()[rowPointer];
    const colSpaces = columnMatrix.getViewableSpaces()[columnPointer];

    const {
        rowHeights,
        width: rowMatrixWidth
    } = rowSpaces;
    const {
        columnWidths,
        height: columnMatrixHeight
    } = colSpaces;

    const { primary: leftWidth, secondary: rightWidth } = rowMatrixWidth;
    const { primary: topHeight, secondary: bottomHeight } = columnMatrixHeight;

    const centerHeight = measureSum(rowHeights.primary);
    const centerWidth = measureSum(columnWidths.primary);
    const viewWidth = [leftWidth, Math.min(centerWidth, maxColWidth), rightWidth];
    const viewHeight = [topHeight, Math.min(centerHeight, maxRowHeight), bottomHeight];

    return {
        viewWidth,
        viewHeight,
        actualCenterMeasures: {
            height: centerHeight,
            width: centerWidth
        },
        totalMeasures: {
            width: measureSum(viewWidth),
            height: measureSum(viewHeight)
        },
        unitHeights: rowHeights,
        unitWidths: columnWidths
    };
};


/***/ }),

/***/ "./packages/layout/src/index.js":
/*!**************************************!*\
  !*** ./packages/layout/src/index.js ***!
  \**************************************/
/*! exports provided: GridLayout, cellSpanMaker, applySpans, applyBorders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _grid_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid-layout */ "./packages/layout/src/grid-layout/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridLayout", function() { return _grid_layout__WEBPACK_IMPORTED_MODULE_0__["GridLayout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cellSpanMaker", function() { return _grid_layout__WEBPACK_IMPORTED_MODULE_0__["cellSpanMaker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applySpans", function() { return _grid_layout__WEBPACK_IMPORTED_MODULE_0__["applySpans"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyBorders", function() { return _grid_layout__WEBPACK_IMPORTED_MODULE_0__["applyBorders"]; });

/**
 * This file is used to export all the public classes in this module.
 * @module Layout
 */




/***/ }),

/***/ "./packages/layout/src/tree-layout/constants/defaults.js":
/*!***************************************************************!*\
  !*** ./packages/layout/src/tree-layout/constants/defaults.js ***!
  \***************************************************************/
/*! exports provided: DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_CLASS_NAME, NODE_PREFIX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_WIDTH", function() { return DEFAULT_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_HEIGHT", function() { return DEFAULT_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CLASS_NAME", function() { return DEFAULT_CLASS_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NODE_PREFIX", function() { return NODE_PREFIX; });
/* harmony import */ var _muze_src_defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../muze/src/defaults */ "./packages/muze/src/defaults.js");


const DEFAULT_WIDTH = 600;
const DEFAULT_HEIGHT = 400;
const DEFAULT_CLASS_NAME = `${_muze_src_defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_CONFIG"].classPrefix}-layout-container-component`;
const NODE_PREFIX = `${_muze_src_defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_CONFIG"].classPrefix}-layout-container`;




/***/ }),

/***/ "./packages/layout/src/tree-layout/data-adapters/data-parser.js":
/*!**********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/data-adapters/data-parser.js ***!
  \**********************************************************************/
/*! exports provided: DataParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataParser", function() { return DataParser; });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./packages/layout/src/tree-layout/data-adapters/helper.js");


class DataParser {
    constructor (data) {
        this._data = data;
    }

    defaultDataPointLogic () {
        const nodepoints = [];
        Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getnodePoints"])(this._data, nodepoints);
        return nodepoints;
    }

}


/***/ }),

/***/ "./packages/layout/src/tree-layout/data-adapters/data-point.js":
/*!*********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/data-adapters/data-point.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataPoint; });
/* harmony import */ var _constants_defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/defaults */ "./packages/layout/src/tree-layout/constants/defaults.js");
/* harmony import */ var _layout_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout-component */ "./packages/layout/src/tree-layout/layout-component/index.js");



class DataPoint {
    constructor (node) {
        this._node = node;
        this._className = node.model().host() instanceof _layout_component__WEBPACK_IMPORTED_MODULE_1__["LayoutComponent"] ?
                            node.model().host().className() : _constants_defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_CLASS_NAME"];
    }

    node () {
        return this._node;
    }

    hasHost () {
        return this._node.model().host() instanceof _layout_component__WEBPACK_IMPORTED_MODULE_1__["LayoutComponent"];
    }

    className () {
        return this._className || _constants_defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_CLASS_NAME"];
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/data-adapters/helper.js":
/*!*****************************************************************!*\
  !*** ./packages/layout/src/tree-layout/data-adapters/helper.js ***!
  \*****************************************************************/
/*! exports provided: getnodePoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getnodePoints", function() { return getnodePoints; });
/* harmony import */ var _data_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-point */ "./packages/layout/src/tree-layout/data-adapters/data-point.js");


const getnodePoints = (node, nodepoints) => {
    const datapoint = new _data_point__WEBPACK_IMPORTED_MODULE_0__["default"](node);
    nodepoints.push(datapoint);
    node.children().forEach((child) => {
        getnodePoints(child, nodepoints);
    });
};


/***/ }),

/***/ "./packages/layout/src/tree-layout/data-adapters/html-data.js":
/*!********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/data-adapters/html-data.js ***!
  \********************************************************************/
/*! exports provided: HTMLDataAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLDataAdapter", function() { return HTMLDataAdapter; });
/* harmony import */ var _data_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-parser */ "./packages/layout/src/tree-layout/data-adapters/data-parser.js");


class HTMLDataAdapter extends _data_parser__WEBPACK_IMPORTED_MODULE_0__["DataParser"] {
    getCoordinates () {
        return super.defaultDataPointLogic();
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/drawing-manager/helper.js":
/*!*******************************************************************!*\
  !*** ./packages/layout/src/tree-layout/drawing-manager/helper.js ***!
  \*******************************************************************/
/*! exports provided: getChildNode, findNode, renderHTML, drawLayout, drawComponent, removeElement, resolveAligment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildNode", function() { return getChildNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNode", function() { return findNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderHTML", function() { return renderHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLayout", function() { return drawLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawComponent", function() { return drawComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeElement", function() { return removeElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveAligment", function() { return resolveAligment; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _renderers_html_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/html-renderer */ "./packages/layout/src/tree-layout/renderers/html-renderer.js");
/* harmony import */ var _layout_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout-component */ "./packages/layout/src/tree-layout/layout-component/index.js");




const getChildNode = (context, config) =>
    context.renderer().createAndPositionDiv(config);

const findNode = (context, nodeID) =>
    context.renderer().coordinates().find(point => point.node().id() === nodeID);

const renderHTML = (context) => {
    context.renderer(new _renderers_html_renderer__WEBPACK_IMPORTED_MODULE_1__["HTMLRenderer"](context.data()));
    context.renderer().createhtml(context.mount(), context.className());
};

const drawLayout = context => renderHTML(context);

const drawComponent = (componentData) => {
    componentData.children().forEach((node) => {
        const host = node.model().host();
        if (host instanceof _layout_component__WEBPACK_IMPORTED_MODULE_2__["LayoutComponent"]) {
            host.draw();
        }
        drawComponent(node);
    });
};

const removeElement = (elemID) => {
    if (elemID) {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(`#${elemID}`).remove();
    }
};

const setAlignConfig = (alignment, params) => {
    let newNodeConfig = {};
    const { node, refNode } = params;
    switch (alignment) {
    case 'left':
        newNodeConfig = {
            top: node.top,
            left: refNode.left,
            height: node.height,
            width: Math.abs(node.width - Math.abs(refNode.left - node.left))
        };
        break;

    case 'right':
        newNodeConfig = {
            top: node.top,
            left: node.left,
            height: node.height,
            width: Math.abs(node.width - Math.abs(node.left + node.width - (refNode.left + refNode.width)))
        };
        break;

    case 'top':
        newNodeConfig = {
            top: refNode.top,
            left: node.left,
            height: Math.abs(node.height - Math.abs(refNode.top - node.top)),
            width: node.width
        };
        break;

    case 'bottom':
        newNodeConfig = {
            top: node.top,
            left: node.left,
            height: Math.abs(node.top - refNode.top + refNode.height),
            width: node.width
        };
        break;

    case 'h-center':
        newNodeConfig = {
            top: node.top,
            left: refNode.left,
            height: node.height,
            width: refNode.width
        };
        break;

    case 'v-center':
        newNodeConfig = {
            top: refNode.top,
            left: node.left,
            height: refNode.top,
            width: node.width
        };
        break;
    default:
        break;
    }
    return newNodeConfig;
};

const resolveAligment = (context, componentData) => {
    componentData.children().forEach((component) => {
        const host = component.model().host();

        if (host instanceof _layout_component__WEBPACK_IMPORTED_MODULE_2__["LayoutComponent"] && host.alignWith()) {
            const componentToAlign = context.componentMap().get(host.alignWith());

            if (componentToAlign) {
                const point = findNode(context, component.id()).node();
                const node = point.boundBox();
                const refNode = findNode(context, componentToAlign.renderAt())
                    .node()
                    .boundBox();
                const newNodeConfig = setAlignConfig(host.alignment(), { node, refNode });

                // check if model in parent component
                Object.assign(newNodeConfig, { id: point.id(), className: host.className() });
                context.renderer().createAndPositionDiv(newNodeConfig);
                context.componentMap().get(host.name()).setSpatialConfig({
                    x: newNodeConfig.left,
                    y: newNodeConfig.top,
                    height: newNodeConfig.height,
                    width: newNodeConfig.width

                });
            }
        }

        resolveAligment(context, component);
    });
};


/***/ }),

/***/ "./packages/layout/src/tree-layout/drawing-manager/index.js":
/*!******************************************************************!*\
  !*** ./packages/layout/src/tree-layout/drawing-manager/index.js ***!
  \******************************************************************/
/*! exports provided: DrawingManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawingManager", function() { return DrawingManager; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/tree-layout/utils/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/layout/src/tree-layout/drawing-manager/helper.js");



class DrawingManager {
    constructor (data, renderer, container) {
        this._data = data.tree;
        this._componentMap = data.componentMap;
        this._layoutClassName = data.layoutClassName;
        this._renderer = renderer;
        this._mount = _utils__WEBPACK_IMPORTED_MODULE_0__["Utils"].isDOMElement(container) ? container : _utils__WEBPACK_IMPORTED_MODULE_0__["Utils"].getElement(container);
    }

    draw () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["drawLayout"])(this);
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["resolveAligment"])(this, this._data);
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["drawComponent"])(this._data);
        return this;
    }

    data (data) {
        if (data) {
            this._data = data;
        }
        return this._data;
    }

    componentMap (param) {
        if (param) {
            this._componentMap = param;
        }
        return this._componentMap;
    }

    className (param) {
        if (param) {
            this._layoutClassName = param;
        }
        return this._layoutClassName;
    }

    renderer (param) {
        if (param) {
            this._renderer = param;
        }
        return this._renderer;
    }

    mount (param) {
        if (param) {
            this._mount = param;
        }
        return this._mount;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/index.js":
/*!**************************************************!*\
  !*** ./packages/layout/src/tree-layout/index.js ***!
  \**************************************************/
/*! exports provided: LayoutManager, DummyComponent, LayoutComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout-component */ "./packages/layout/src/tree-layout/layout-component/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DummyComponent", function() { return _layout_component__WEBPACK_IMPORTED_MODULE_0__["DummyComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutComponent", function() { return _layout_component__WEBPACK_IMPORTED_MODULE_0__["LayoutComponent"]; });

/* harmony import */ var _layout_manager___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout-manager/ */ "./packages/layout/src/tree-layout/layout-manager/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutManager", function() { return _layout_manager___WEBPACK_IMPORTED_MODULE_1__["default"]; });







/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-component/dummy-component.js":
/*!*****************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-component/dummy-component.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layoutComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layoutComponent */ "./packages/layout/src/tree-layout/layout-component/layoutComponent.js");


class DummyComponent extends _layoutComponent__WEBPACK_IMPORTED_MODULE_0__["default"] {
    getLogicalSpace () {
        return {
            width: this.boundBox().width,
            height: this.boundBox().height
        };
    }

    setSpatialConfig (conf) {
        this.boundBox({ top: conf.y, left: conf.x });
        this.newDimensions = {
            width: conf.width,
            height: conf.height
        };
        this.renderAt(conf.renderAt);
        return this;
    }

    draw () {
        if (!this.component) {
            throw new Error(`Component not set for ${this.componentName}`);
        }
        this.component.mount(document.getElementById(this.renderAt)); // Change the draw method to component draw
        return this;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (DummyComponent);


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-component/index.js":
/*!*******************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-component/index.js ***!
  \*******************************************************************/
/*! exports provided: DummyComponent, LayoutComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dummy_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dummy-component */ "./packages/layout/src/tree-layout/layout-component/dummy-component.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DummyComponent", function() { return _dummy_component__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _layoutComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layoutComponent */ "./packages/layout/src/tree-layout/layout-component/layoutComponent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutComponent", function() { return _layoutComponent__WEBPACK_IMPORTED_MODULE_1__["default"]; });







/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-component/layoutComponent.js":
/*!*****************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-component/layoutComponent.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayoutComponent; });
class LayoutComponent {
    constructor (name, dimensions, seed) {
        this._seed = seed;
        this._boundBox = {
            height: dimensions.height,
            width: dimensions.width,
            top: null,
            left: null
        };
        this._renderAt = null;
        this._alignWith = null;
        this._alignment = null;
        this._target = null;
        this._position = null;
        this._componentName = name;
        this._className = null;
    }

    getLogicalSpace () {
        throw new Error('getLogicalSpace is not defined');
    }

    setSpatialConfig () {
        throw new Error('setSpatialSpace is not defined');
    }

    name (param) {
        if (param) {
            this._componentName = param;
        }
        return this._componentName;
    }

    target (param) {
        if (param) {
            this._target = param;
        }
        return this._target;
    }

    position (param) {
        if (param) {
            this._position = param;
        }
        return this._position;
    }

    alignment (param) {
        if (param) {
            this._alignment = param;
        }
        return this._alignment;
    }

    alignWith (param) {
        if (param) {
            this._alignWith = param;
        }
        return this._alignWith;
    }

    renderAt (param) {
        if (param) {
            this._renderAt = param;
        }
        return this._renderAt;
    }

    boundBox (param) {
        if (param) {
            Object.assign(this._boundBox, param);
        }
        return this._boundBox;
    }

    className (param) {
        if (param) {
            this._className = param;
        }
        return this._className;
    }

    draw () {
        throw new Error('draw is not defined');
    }

    attachListener () {
        return this;
    }
  }



/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/definition-manager/definitionModel.js":
/*!*************************************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/definition-manager/definitionModel.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DefinitionModel; });
class DefinitionModel {
    constructor (config) {
        this._host = config.host || null;
        this._cut = config.cut || null;
        this._ratioWeight = config.ratioWeight === 0 ? 0 : config.ratioWeight || 1;
        this._preferred = config.preferred || false;
        this._lanes = config.lanes || [];
        this._remainingHeight = 0;
        this._remainingWidth = 0;
    }

    host (host) {
        if (host) {
            this._host = host;
        }
        return this._host;
    }

    preferred (preferred) {
        if (preferred) {
            this._preferred = preferred;
        }
        return this._preferred;
    }

    cut (cut) {
        if (cut) {
            this._cut = cut;
        }
        return this._cut;
    }

    ratioWeight (ratioWeight) {
        if (ratioWeight) {
            this._ratioWeight = ratioWeight;
        }
        return this._ratioWeight;
    }

    lanes (lanes) {
        if (lanes) {
            this._lanes = lanes;
        }
        return this._lanes;
    }

    remainingHeight (remainingHeight) {
        if (remainingHeight) {
            this._remainingHeight = remainingHeight;
        }
        return this._remainingHeight;
    }

    remainingWidth (remainingWidth) {
        if (remainingWidth) {
            this._remainingWidth = remainingWidth;
        }
        return this._remainingWidth;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/definition-manager/index.js":
/*!***************************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/definition-manager/index.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DefinitionManager; });
/* harmony import */ var _definitionModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./definitionModel */ "./packages/layout/src/tree-layout/layout-definition/definition-manager/definitionModel.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper */ "./packages/layout/src/tree-layout/layout-definition/helper/index.js");



class DefinitionManager {
    constructor (componentMap, sequence, totalHeight, totalWidth) {
        this._componentMap = componentMap;
        this._prioritySequence = sequence;
        this._totalHeight = totalHeight;
        this._totalWidth = totalWidth;
        this._targetComponentMap = null;
    }

    // create the config model
    generateConfigModel () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["prepareTargetComponentMap"])(this);
        const canvasComponent = this._targetComponentMap.get('canvas');
        const definitionModel = new _definitionModel__WEBPACK_IMPORTED_MODULE_0__["default"]({});
        let tempDefModel = definitionModel;
        definitionModel.remainingHeight(this._totalHeight);
        definitionModel.remainingWidth(this._totalWidth);

        let componentRef = null;

        this._prioritySequence.forEach((name) => {
            componentRef = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getComponent"])(canvasComponent, name);
            if (name !== 'grid') {
                tempDefModel = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["placeComponent"])(tempDefModel, componentRef).second;
            } else {
                tempDefModel = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["placeGridComponent"])(tempDefModel, componentRef.component);
            }
        });
        return definitionModel;
    }

    componentMap (param) {
        if (param) {
            this._componentMap = param;
        }
        return this._componentMap;
    }

    targetComponentMap (param) {
        if (param) {
            this._targetComponentMap = param;
        }
        return this._targetComponentMap;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/helper/index.js":
/*!***************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/helper/index.js ***!
  \***************************************************************************/
/*! exports provided: isEqual, getNodeId, yExtraSpace, smallestExtraHeightHorizontally, xExtraSpace, smallestExtraWidthVertically, determineBoundBox, prepareTargetComponentMap, getComponent, createPlaceHolderComponent, placeComponent, placeGridComponent, negotiateDimension, computePosition, allocateBoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeId", function() { return getNodeId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yExtraSpace", function() { return yExtraSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallestExtraHeightHorizontally", function() { return smallestExtraHeightHorizontally; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xExtraSpace", function() { return xExtraSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallestExtraWidthVertically", function() { return smallestExtraWidthVertically; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determineBoundBox", function() { return determineBoundBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareTargetComponentMap", function() { return prepareTargetComponentMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponent", function() { return getComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPlaceHolderComponent", function() { return createPlaceHolderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placeComponent", function() { return placeComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placeGridComponent", function() { return placeGridComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negotiateDimension", function() { return negotiateDimension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computePosition", function() { return computePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allocateBoundingBox", function() { return allocateBoundingBox; });
/* harmony import */ var _constants_defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants/defaults */ "./packages/layout/src/tree-layout/constants/defaults.js");
/* harmony import */ var _definition_manager_definitionModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../definition-manager/definitionModel */ "./packages/layout/src/tree-layout/layout-definition/definition-manager/definitionModel.js");
/* harmony import */ var _layout_component_dummy_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../layout-component/dummy-component */ "./packages/layout/src/tree-layout/layout-component/dummy-component.js");



/**
 * Compares two strings in lowercase
 *
 * @export
 * @param {string} value the value to be compared
 * @param {string} compareTo whom the value would be compared
 * @return {boolean} true if values are equal
 */
function isEqual (value, compareTo) {
    if (typeof value !== 'string' || typeof compareTo !== 'string') {
        throw new TypeError('value and compareTo must be string');
    }
    return value.toLowerCase() === compareTo.toLowerCase();
}

const getNodeId = (() => {
    let _uid = 0;
    return () => `${_constants_defaults__WEBPACK_IMPORTED_MODULE_0__["NODE_PREFIX"]}-${++_uid}`;
})();

function yExtraSpace (node) {
    let smallestHeight = 0;
    if (node.getCutType() === 'v') {
        smallestHeight = smallestExtraHeightHorizontally(node); // eslint-disable-line no-use-before-define
    } else if (node.getCutType() === 'h') {
        node.children().forEach((child) => {
            smallestHeight += yExtraSpace(child);
        });
    } else if (node.model().host() && node.model().host().getLogicalSpace) {
        const containerHeight = node.boundBox().height;
        const hostHeight = node.model().host().getLogicalSpace().height;

        smallestHeight = containerHeight - hostHeight;
        if (smallestHeight < 0) {
            smallestHeight = 0;
        }
    } else {
        smallestHeight = 0;
    }
    return smallestHeight;
}

function smallestExtraHeightHorizontally (node) {
    let smallestHeight = Number.MAX_SAFE_INTEGER;
    node.children().forEach((child) => {
        const h = yExtraSpace(child);
        if (h < smallestHeight) {
            smallestHeight = h;
        }
    });
    return smallestHeight;
}

function xExtraSpace (node) {
    let smallestWidth = 0;
    if (node.getCutType() === 'h') {
        smallestWidth = smallestExtraWidthVertically(node); // eslint-disable-line no-use-before-define
    } else if (node.getCutType() === 'v') {
        node.children().forEach((child) => {
            smallestWidth += xExtraSpace(child);
        });
    } else if (node.model().host() && node.model().host().getLogicalSpace) {
        const containerWidth = node.boundBox().width;
        const hostWidth = node.model().host().getLogicalSpace().width;
        smallestWidth = containerWidth - hostWidth;
        if (smallestWidth < 0) {
            smallestWidth = 0;
        }
    } else {
        smallestWidth = 0;
    }
    return smallestWidth;
}

function smallestExtraWidthVertically (node) {
    let smallestWidth = Number.MAX_SAFE_INTEGER;
    node.children().forEach((child) => {
        const w = xExtraSpace(child);
        if (w < smallestWidth) {
            smallestWidth = w;
        }
    });
    return smallestWidth;
}

function determineBoundBox (bb, i, arr, instance) {
    if (i) {
    // if not first sibling, take boundbox from previous sibling
        const lastSibling = arr[i - 1];
        const { top: _top, left: _left, height: _height, width: _width } = lastSibling.boundBox();
        return {
            width: bb.width,
            height: bb.height,

            top: instance.parentCut() === 'h'
        ? _top + _height : _top,

            left: instance.parentCut() === 'h'
        ? _left : _left + _width
        };
    }
  // if first sibling, take boundbox from parent
    const { top: _top, left: _left } = instance.parent().boundBox();
    return {
        width: bb.width,
        height: bb.height,
        top: _top,
        left: _left
    };
}

// prepares the targetComponent Map for target Mapping ie. where a component should lie
function prepareTargetComponentMap (context) {
    context.targetComponentMap(new Map());
    context.componentMap().forEach((value) => {
        if (context.targetComponentMap().has(value.target())) {
            context.targetComponentMap().get(value.target()).push(value);
        } else {
            const temp = [];
            temp.push(value);
            context.targetComponentMap().set(value.target(), temp);
        }
    });
}

function getComponent (canvasComponent, componentName) {
    const comp = canvasComponent.find(component => component.name() === componentName);
    return (comp && comp !== -1) ? comp : null;
}
function createPlaceHolderComponent (height, width, position) {
    const comp = new _layout_component_dummy_component__WEBPACK_IMPORTED_MODULE_2__["default"](0, { height, width });
    comp.name('placeHolder');
    comp.position(position);
    return comp;
}

function placeComponent (definitionModel, component, isPreferred = false, isGridComponent = false) {
    let cut = '';
    let componentRatioWidth = 1;
    let leftOvercomponentRationWidth = 1;
    let leftHeight = 0;
    let leftWidth = 0;

    if (!component) {
        return { first: definitionModel, second: definitionModel };
    }

    const { height: componentHeight, width: componentWidth } = component.getLogicalSpace();
    const position = component.position();
    if (position === 'top' || position === 'bottom') {
        cut = 'h';
        componentRatioWidth = componentHeight / definitionModel.remainingHeight();
        leftHeight = definitionModel.remainingHeight() - componentHeight;
        leftWidth = definitionModel.remainingWidth();
    } else {
        cut = 'v';
        componentRatioWidth = componentWidth / definitionModel.remainingWidth();
        leftWidth = definitionModel.remainingWidth() - componentWidth;
        leftHeight = definitionModel.remainingHeight();
    }
    leftOvercomponentRationWidth = 1 - componentRatioWidth;

// update parentModel
    definitionModel.cut(cut);
    const firstLaneConfig = {
        host: component.name(),
        cut: null,
        ratioWeight: componentRatioWidth,
        preferred: isGridComponent ? false : isPreferred,
        lanes: []
    };
    const firstLane = new _definition_manager_definitionModel__WEBPACK_IMPORTED_MODULE_1__["default"](firstLaneConfig);
    firstLane.remainingHeight(componentHeight);
    firstLane.remainingWidth(componentWidth);

    const secondLaneConfig = {
        host: null,
        cut: null,
        ratioWeight: leftOvercomponentRationWidth,
        preferred: isGridComponent ? false : !isPreferred,
        lanes: []
    };
    const secondLane = new _definition_manager_definitionModel__WEBPACK_IMPORTED_MODULE_1__["default"](secondLaneConfig);
    secondLane.remainingHeight(leftHeight);
    secondLane.remainingWidth(leftWidth);
    if (isPreferred) {
        definitionModel.lanes([firstLane]);
    } else if (position === 'top' || position === 'left') {
        definitionModel.lanes([firstLane, secondLane]);
    } else {
        definitionModel.lanes([secondLane, firstLane]);
    }
    return { first: firstLane, second: secondLane };
}

function placeGridComponent (definitionModel, gridComponents) {
    let tempDefModel = definitionModel;
    const rows = gridComponents.length;
    const column = rows ? gridComponents[0].length : 0;
    const height = gridComponents.reduce((acc, val) => (acc + val[0].getLogicalSpace().height), 0);

    for (let i = 0; i < column; i++) {
        const iscolumnPreffered = i === column - 1;
        const columnPlaceHolderComponent = createPlaceHolderComponent(height,
                                                    gridComponents[0][i].getLogicalSpace().width, 'left');
        const { first, second } = placeComponent(tempDefModel, columnPlaceHolderComponent, iscolumnPreffered);
        tempDefModel = first;
        for (let j = 0; j < rows; j++) {
            const rowpreffred = j === (rows - 1);
            tempDefModel = placeComponent(tempDefModel, gridComponents[j][i], rowpreffred, true).second;
        }
        tempDefModel = second;
    }
    return tempDefModel;
}

function negotiateDimension (node) {
    let preferred;
    let cumultiveExtraSpaceAmt = 0;
    let alteredDim;
    let nonAlteredDim;

    const childrenLength = node.children().length;

    for (let index = 0; index < childrenLength; index++) {
        let fn;
        let extraSpaceAmt;
        const child = node.children()[index];

        if (child.parentCut() === 'h') {
            fn = yExtraSpace;
            alteredDim = 'height';
            nonAlteredDim = 'width';
        } else {
            fn = xExtraSpace;
            alteredDim = 'width';
            nonAlteredDim = 'height';
        }
  // if vertical then get extra height from other node and push it to the preferred node.
  // for horizontal cut the same thing is to be done with width
        if (child.isPreferred()) {
    // push extra space in sink. Execute it when all non preferred space are computed.
            preferred = child;

            continue; // eslint-disable-line no-continue
        }
  // reduce own height and save it in a var
        cumultiveExtraSpaceAmt += (extraSpaceAmt = fn(child));
        child.boundBox()[alteredDim] -= extraSpaceAmt;
  // update nonaltered dim from parent for any change which happened during negotiation
        child.boundBox()[nonAlteredDim] = child.parent().boundBox()[nonAlteredDim];

        negotiateDimension(child);
    }

    if (preferred) {
        preferred.boundBox()[alteredDim] += cumultiveExtraSpaceAmt;
        preferred.boundBox()[nonAlteredDim] = preferred.parent().boundBox()[nonAlteredDim];
        negotiateDimension(preferred);
    }
}

function computePosition (node) {
    node.children().forEach((child, i, children) => {
        const boundBox = determineBoundBox(child.boundBox(), i, children, child);
        child.boundBox(boundBox);
        computePosition(child);
    });
}

function allocateBoundingBox (node) {
    const totalWeight = node.children()
                            .map(child => child.model().ratioWeight())
                            .reduce((carry, val) => carry + val, 0);

    node.children().forEach((child, i, children) => {
        const lastSibling = children[i - 1];
        const ratio = child.model().ratioWeight() / totalWeight;

        if (child.parentCut() === 'h') {
            child.boundBox({
                top: i ? lastSibling.boundBox().top + lastSibling.boundBox().height : 0,
                left: child.parent().boundBox().left,
                height: child.parent().boundBox().height * ratio,
                width: child.parent().boundBox().width
            });
        } else {
            child.boundBox({
                top: child.parent().boundBox().top,
                left: i ? lastSibling.boundBox().left + lastSibling.boundBox().width : 0,
                height: child.parent().boundBox().height,
                width: child.parent().boundBox().width * ratio
            });
        }
        allocateBoundingBox(child);
    });
}



/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/index.js":
/*!********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/index.js ***!
  \********************************************************************/
/*! exports provided: LayoutModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout-model */ "./packages/layout/src/tree-layout/layout-definition/layout-model/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutModel", function() { return _layout_model__WEBPACK_IMPORTED_MODULE_0__["default"]; });






/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/layout-model/index.js":
/*!*********************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/layout-model/index.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayoutModel; });
/* harmony import */ var _tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree */ "./packages/layout/src/tree-layout/layout-definition/tree/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper */ "./packages/layout/src/tree-layout/layout-definition/helper/index.js");



class LayoutModel {
    constructor (measurements, config) {
        this._measurements = measurements;
        this._config = config;
        this._root = this.createTree(this._config, null);
        this.setBoundBox();
    }

    createTree (config, parent) {
        const node = new _tree__WEBPACK_IMPORTED_MODULE_0__["default"](config);
        if (parent) {
            node.parentCut(parent.getCutType());
            parent.addChildren([node]);
        } else {
            this._root = node;
        }
        for (const lane of config.lanes()) {
            this.createTree(lane, node);
        }

        return this._root;
    }

    setBoundBox () {
        this._root.boundBox({
            top: 0,
            left: 0,
            width: this._measurements.width,
            height: this._measurements.height
        });
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["allocateBoundingBox"])(this._root);
    }

    setHostPosition (node) {
        node.children().forEach((child) => {
            LayoutModel.setHostSpatialConfig(child);
            this.setHostPosition(child);
        });
    }

    static setHostSpatialConfig (node) {
        const bb = node.boundBox();
        const host = node.model().host();
        if (host && host.setSpatialConfig) {
            const conf = {
                x: bb.left,
                y: bb.top,
                width: bb.width,
                height: bb.height,
                renderAt: node.id()
            };
            host.setSpatialConfig(conf);
        }
    }

    negotiate () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["negotiateDimension"])(this._root);
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["computePosition"])(this._root);
        return this;
    }

    broadcast () {
        this.setHostPosition(this._root);
        return this;
    }

    tree () {
        return this._root;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-definition/tree/index.js":
/*!*************************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-definition/tree/index.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helper */ "./packages/layout/src/tree-layout/layout-definition/helper/index.js");
/* harmony import */ var _layout_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout-component */ "./packages/layout/src/tree-layout/layout-component/index.js");



class Node {
    constructor (data) {
        this._model = data;
        this._parent = null;
        this._children = [];
        this._parentCut = null;
        this._boundBox = {
            top: null,
            left: null,
            height: null,
            width: null
        };

        this._id = this._model.host() instanceof _layout_component__WEBPACK_IMPORTED_MODULE_1__["LayoutComponent"] && this._model.host().renderAt() ?
                    this._model.host().renderAt() :
                    Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getNodeId"])();
    }

    addChildren (entries) {
        this._children.push(...entries);
        entries.forEach((e) => { e.parent(this); });
    }

    isRoot () {
        return this._parent === null;
    }

    isLeaf () {
        return !this._children.length;
    }

    getCutType () {
        return this._model.cut();
    }

    isPreferred () {
        return !!this._model.preferred();
    }

    children (children) {
        if (children) {
            this._children = children;
        }
        return this._children;
    }

    parent (parent) {
        if (parent) {
            this._parent = parent;
        }
        return this._parent;
    }

    parentCut (parentCut) {
        if (parentCut) {
            this._parentCut = parentCut;
        }
        return this._parentCut;
    }

    id (id) {
        if (id) {
            this._id = id;
        }
        return this._id;
    }

    model (model) {
        if (model) {
            this._model = model;
        }
        return this._model;
    }

    boundBox (bound) {
        if (bound) {
            this._boundBox = {
                top: bound.top,
                left: bound.left,
                height: bound.height,
                width: bound.width
            };
        }
        return this._boundBox;
    }
  /**
     * function to search a node and update it with the config provided.
     * @param  {Object} nodeconfig
     */
    updateNode (nodeconfig) {
        if (this._id === nodeconfig._id) {
            this._model.cut(nodeconfig.cut);
            this._model.ratioWeight(nodeconfig.ratioWeight);
        } else {
            this._children.forEach((node) => {
                if (node._id === nodeconfig._id) {
                    node.model.cut(nodeconfig.cut);
                    node.model.ratioWeight(nodeconfig.ratioWeight);
                    return;
                }
                this.searchNode(node, nodeconfig);
            });
        }
    }

  // Recursive function to search a node
    searchNode (node, nodeconfig) {
        node.children().forEach((childNode) => {
            if (childNode.id() === nodeconfig._id) {
                childNode.model().cut(nodeconfig.cut);
                childNode.model().ratioWeight(nodeconfig.ratioWeight);
            } else {
                this.searchNode(childNode, nodeconfig);
            }
        });
    }

  /**
     * function to delete a node from tree Structure.
     * @param  {String} nodeId - node Id of the Node
     */
    delete (nodeId) {
        this._children.forEach((node) => {
            if (node.id() === nodeId) {
                const index = this._children.indexOf(node);
                this._model.lanes().splice(index, 1);
            }
            this.deleteSearchNode(node, nodeId);
        });
    }

  // Recursive function to search a node
    deleteSearchNode (node, nodeId) {
        node.children().forEach((childNode) => {
            if (childNode.id() === nodeId) {
                const index = node.children().indexOf(childNode);
                node.model().lanes().splice(index, 1);
            } else {
                this.deleteSearchNode(childNode, nodeId);
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Node);


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-manager/helper.js":
/*!******************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-manager/helper.js ***!
  \******************************************************************/
/*! exports provided: sanitizeConfig, calLayOutDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeConfig", function() { return sanitizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calLayOutDef", function() { return calLayOutDef; });
/* harmony import */ var _layout_definition_definition_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../layout-definition/definition-manager */ "./packages/layout/src/tree-layout/layout-definition/definition-manager/index.js");


function sanitizeConfig (context, hostObj) {
    const hostID = hostObj.host();
    if (hostObj.lanes() && hostObj.lanes().length) {
        hostObj.lanes().forEach(childHost => sanitizeConfig(context, childHost));
    }
    if (hostID != null && typeof (hostID) === 'string') {
        if (context.componentMap().get(hostID) !== undefined) {
            hostObj.host(context.componentMap().get(hostID));
        }
    }
}

function calLayOutDef (context) {
    const { height, width } = context.dimension();
    const defManager = new _layout_definition_definition_manager__WEBPACK_IMPORTED_MODULE_0__["default"](context.layoutDef().componentMap(),
                                              context.prioritySequence(),
                                              height,
                                              width);
    const genLayoutdef = defManager.generateConfigModel();
    return genLayoutdef;
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-manager/index.js":
/*!*****************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-manager/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayoutManager; });
/* harmony import */ var _layout_definition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../layout-definition */ "./packages/layout/src/tree-layout/layout-definition/index.js");
/* harmony import */ var _constants_defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/defaults */ "./packages/layout/src/tree-layout/constants/defaults.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _drawing_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing-manager */ "./packages/layout/src/tree-layout/drawing-manager/index.js");
/* harmony import */ var _drawing_manager_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing-manager/helper */ "./packages/layout/src/tree-layout/drawing-manager/helper.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/tree-layout/utils/index.js");
/* harmony import */ var _layout_def__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./layout-def */ "./packages/layout/src/tree-layout/layout-manager/layout-def.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helper */ "./packages/layout/src/tree-layout/layout-manager/helper.js");












class LayoutManager {
    constructor (conf) {
        this._renderAt = conf.renderAt;
        this._layoutClassName = conf.className;
        this._dimension = {
            width: conf.width || _constants_defaults__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_WIDTH"],
            height: conf.height || _constants_defaults__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_HEIGHT"]
        };

        this._skeletonType = conf.skeletonType || 'html';
        this._layoutDefinition = null;
        this._layoutDef = new _layout_def__WEBPACK_IMPORTED_MODULE_6__["LayoutDef"]();
        this._drawingManager = null;
        this._prioritySequence = [];
        this.tree = null;
        this._rootNodeID = null;
    }

    layoutDef (param) {
        if (param) {
            this._layoutDef = param;
        }
        return this._layoutDef;
    }

    prioritySequence (param) {
        if (param) {
            this._prioritySequence = param;
        }
        return this._prioritySequence;
    }

    dimension (param) {
        if (param) {
            Object.assign(this._dimension, param);
        }
        return this._dimension;
    }

    addComponent (component) {
        this._layoutDef.addComponent(component);
    }

    addMultipleComponent (componentArray) {
        this._layoutDef.addMultipleComponent(componentArray);
    }

    resetNode (node) {
        if (this.con) {
            this.con.resetNode(node);
        }
    }

  /**
   * function to update the node and rerender the layout.
   * @param  {} config - node configuration to change.
   */
    updateNode (config) {
        this.tree.updateNode(config);
        this._layoutDefinition = this.tree.model;
        this.compute();
    }

    compute () {
        //----
        if (_utils__WEBPACK_IMPORTED_MODULE_5__["Utils"].isDOMElement(this._renderAt)) {
            this._renderAt._layout = this;
        } else {
            document.getElementById(this._renderAt)._layout = this;
        }
        //-----
        this._layoutDefinition = Object(_helper__WEBPACK_IMPORTED_MODULE_7__["calLayOutDef"])(this);
        this._layoutDef.layoutDefinition(this._layoutDefinition);
        this._layoutDefinition = this._layoutDef.sanitizedDefinition();
        this._layout = new _layout_definition__WEBPACK_IMPORTED_MODULE_0__["LayoutModel"]({
            width: this._dimension.width,
            height: this._dimension.height
        },
            this._layoutDefinition);
        this.tree = this._layout.negotiate().tree();
        this._layout.broadcast();
        this._drawingManager = new _drawing_manager__WEBPACK_IMPORTED_MODULE_3__["DrawingManager"]({
            tree: this.tree,
            componentMap: this._layoutDef.componentMap(),
            layoutClassName: this._layoutClassName
        }, this._skeletonType, this._renderAt);

        if (this._rootNodeID) {
            this.tree.id(this._rootNodeID);
        } else {
            this._rootNodeID = this.tree.id();
        }
    // this will draw all the components by calling their draw method
        this._drawingManager.draw();
    }

    getRootNodeId () {
        return this._rootNodeID;
    }

  /**
  * This function takes the LayoutComponents and Register them in component store
  * @param {Array<LayoutComponent>} layoutComponents
  */
    registerComponents (layoutComponents) {
        this._prioritySequence.length = 0;
        this._layoutDef.resetComponentMap();
        layoutComponents.forEach((container) => {
            if (container) {
                this._prioritySequence.push(container.name());
                this.addComponent(container);
                if (container.name() === 'grid') {
                    container.component.forEach((componentArr) => {
                        componentArr.forEach((compo) => {
                            this.addComponent(compo);
                        });
                    });
                }
            }
        });
        return this;
    }

    getComponent (componentName) {
        return this._layoutDef.componentMap().get(componentName);
    }

    deleteElement (component, elementName) {
        this._layoutDef.componentMap().delete(elementName);
        const deleteElementId = component.renderAt();
        return Object(_drawing_manager_helper__WEBPACK_IMPORTED_MODULE_4__["removeElement"])(deleteElementId);
    }

    removeComponent (name) {
        const component = this.getComponent(name);
        if (component) {
            if (name === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["GRID"]) {
                return component.component.map(comp => comp.map(
                    co => this.deleteElement(co, co.name())
                ));
            }
            return this.deleteElement(component, name);
        }
        return this;
    }

    renderAt (mount) {
        if (mount) {
            this._renderAt = mount;
        }
        return this._renderAt;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/layout-manager/layout-def.js":
/*!**********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/layout-manager/layout-def.js ***!
  \**********************************************************************/
/*! exports provided: LayoutDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutDef", function() { return LayoutDef; });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./packages/layout/src/tree-layout/layout-manager/helper.js");


class LayoutDef {
    constructor () {
        this._componentMap = new Map();
        this._layoutDefinition = null;
    }

    addComponent (component) {
        this._componentMap.set(component.name(), component);
    }

    layoutDefinition (def) {
        if (def) {
            this._layoutDefinition = def;
        }
        return this._layoutDefinition;
    }

    addMultipleComponent (componentArray) {
        componentArray.forEach((comp) => {
            this.addComponent(comp);
        });
    }

    sanitizedDefinition () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_0__["sanitizeConfig"])(this, this._layoutDefinition);
        return this.layoutDefinition();
    }

    componentMap () {
        return this._componentMap;
    }
    resetComponentMap () {
        this._componentMap.clear();
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/renderers/html-renderer.js":
/*!********************************************************************!*\
  !*** ./packages/layout/src/tree-layout/renderers/html-renderer.js ***!
  \********************************************************************/
/*! exports provided: HTMLRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLRenderer", function() { return HTMLRenderer; });
/* harmony import */ var _data_adapters_html_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data-adapters/html-data */ "./packages/layout/src/tree-layout/data-adapters/html-data.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/tree-layout/utils/index.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./packages/layout/src/tree-layout/renderers/renderer.js");




class HTMLRenderer extends _renderer__WEBPACK_IMPORTED_MODULE_2__["Renderer"] {
    constructor (data) {
        super();
        this._data = data;
        this._coordinates = new _data_adapters_html_data__WEBPACK_IMPORTED_MODULE_0__["HTMLDataAdapter"](this._data).getCoordinates();
    }

    createhtml (mount, className) {
        const mainDiv = mount;
        super.initRenderer(mainDiv, this._data); // Initialise node with layout id
        this.parentDiv = this.createAndCustomiseParent(className);
        this._coordinates.forEach((node) => {
            if (node.hasHost()) {
                const host = node.node();
                this.parentDiv.appendChild(this.createAndPositionDiv({ ...host.boundBox(),
                    id: host.id(),
                    className: node.className() }));
            }
        });
        mainDiv.appendChild(this.parentDiv);
    }

    createAndPositionDiv (config) {
        const { top, left, height, width, className, id } = config;
        const existingDiv = document.getElementById(id);
        const div = existingDiv || document.createElement('div');
        div.style.position = 'absolute';
        div.style.left = `${left}px`;
        div.style.top = `${top}px`;
        div.style.height = `${height}px`;
        div.style.width = `${width}px`;
        div.id = id;
        div.className = className;
        return div;
    }

    createAndCustomiseParent (className) {
        const container = _utils__WEBPACK_IMPORTED_MODULE_1__["Utils"].findContainer(this._coordinates);
        const host = container.node();
        const parentDiv = this.createAndPositionDiv({ ...host.boundBox(),
            id: host.id(),
            className: container.className() });
        parentDiv.className = className;
        parentDiv.style.position = 'relative';
        return parentDiv;
    }

    coordinates () {
        return this._coordinates;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/renderers/renderer.js":
/*!***************************************************************!*\
  !*** ./packages/layout/src/tree-layout/renderers/renderer.js ***!
  \***************************************************************/
/*! exports provided: Renderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer", function() { return Renderer; });
class Renderer {

    initRenderer (node, tree) {
        node.__logicalTree = tree;
    }
}


/***/ }),

/***/ "./packages/layout/src/tree-layout/utils/index.js":
/*!********************************************************!*\
  !*** ./packages/layout/src/tree-layout/utils/index.js ***!
  \********************************************************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utils", function() { return Utils; });
/* eslint no-undef: "off" */
/* eslint default-case: "off" */
class Utils {
    static isDOMElement (element) {
        return element instanceof Element;
    }

    static getID (element) {
        return element.id;
    }

    static getElement (id) {
        return document.getElementById(id);
    }

    static findContainer (data) {
        return data.filter(coordinate => coordinate.parent == null)[0];
    }
  /**
   * static method to remove the div
   * @param  {} divId - div ID to be removed.
   */
    static removeDiv (divId) {
        if (document.getElementById(divId) !== null) { document.getElementById(divId).remove(); }
    }
}


/***/ }),

/***/ "./packages/layout/src/utils/index.js":
/*!********************************************!*\
  !*** ./packages/layout/src/utils/index.js ***!
  \********************************************/
/*! exports provided: combineMatrices, createTree, getMinMeasures, getLogicalSpace, computeLogicalSpace, spaceTakenByRow, spaceTakenByColumn, createMatrixEachLevel, breakMatrix, getDistributedWidth, getDistributedHeight, extraCellsRemover, createMatrixInstances */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineMatrices", function() { return combineMatrices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTree", function() { return createTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMinMeasures", function() { return getMinMeasures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLogicalSpace", function() { return getLogicalSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLogicalSpace", function() { return computeLogicalSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceTakenByRow", function() { return spaceTakenByRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceTakenByColumn", function() { return spaceTakenByColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMatrixEachLevel", function() { return createMatrixEachLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "breakMatrix", function() { return breakMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistributedWidth", function() { return getDistributedWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistributedHeight", function() { return getDistributedHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extraCellsRemover", function() { return extraCellsRemover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMatrixInstances", function() { return createMatrixInstances; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");
/**
 * This file exports utility functions that are used across the layout module
 */



const nest = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].nest;
/**
 *
 *
 * @param {*} isTransposed
 *
 */
const getMeasureInfo = (isTransposed) => {
    if (isTransposed) {
        return {
            firstMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"],
            secondMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"]
        };
    }
    return {
        firstMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"],
        secondMeasure: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"]
    };
};

/**
 *
 *
 * @param {*} i
 * @param {*} page
 *
 */
const findInPage = (i, page) => {
    let count = 0;
    for (const x in page) {
        if (i < page[x]) {
            count = x;
            break;
        }
    }
    return count;
};

/**
 * Creates a single matrix from two matrices
 *
 * @param {Array<Array>} matrix Input matrix
 * @return {Array<Array>} Joined matrix
 * @memberof VisualMatrix
 */
const combineMatrices = (matrix, config) => {
    const { isTransposed } = config;
    let joinedMatrix = matrix[0].length > 0 ? matrix[0] : matrix[1];
    if (isTransposed) {
        joinedMatrix = matrix[0].length > 0 ? [...matrix[0]] : [];
        joinedMatrix = matrix[1].length > 0 ? [...joinedMatrix, ...matrix[1]] : joinedMatrix;
    } else {
        joinedMatrix = joinedMatrix.map((row, rowIndex) => {
            let rowData = [];
            if (matrix[0].length > 0) {
                rowData = [...matrix[0][rowIndex]];
            }
            if (matrix[1].length > 0) {
                rowData = [...rowData, ...matrix[1][rowIndex]];
            }
            return rowData;
        });
    }
    return joinedMatrix;
};

/**
 * Creates a hirachical tree from the context
 *
 * @param {Object} context context for creating tree
 * @return {Object} nested tree
 */
const createTree = (context) => {
    let matrixTree = {};
    let lastLevelKey = 0;
    let facet = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"];
    const nestFn = nest();
    const keys = [];
    const layoutMatrix = context._layoutMatrix;
    const primaryMatrix = context.primaryMatrix();
    const secondaryMatrix = context.secondaryMatrix();
    const { isTransposed, breakPage } = context.config();

    if (!isTransposed) {
        if (primaryMatrix.length === 0) {
            facet = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"];
        } else if (secondaryMatrix.length === 0) {
            facet = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"];
        } else {
            facet = primaryMatrix.length >= secondaryMatrix.length ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"];
        }
        if (primaryMatrix.length > 0) {
            for (let i = 0; i < primaryMatrix[0].length - 1; i++) {
                keys.push(i);
            }
            keys.push(primaryMatrix[0].length - 1);
            if (facet === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"] || secondaryMatrix.length === 0) {
                lastLevelKey = primaryMatrix[0].length - 1;
            }
        }
        if (secondaryMatrix.length > 0) {
            const keyLength = primaryMatrix.length > 0 ? primaryMatrix[0].length : 0;
            for (let i = secondaryMatrix[0].length - 1; i > 0; i--) {
                keys.push(i + keyLength);
            }
            keys.push(keyLength);

            if (facet === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"]) {
                lastLevelKey = keyLength;
            }
        } else {
            lastLevelKey = primaryMatrix.length > 0 ? primaryMatrix[0].length - 1 : 0;
        }
        keys.forEach((key) => {
            let counter = -1;
            return nestFn.key((d) => {
                counter++;
                return `${d[key].valueOf()}-${findInPage(counter, breakPage)}`;
            });
        });
        matrixTree = nestFn.entries(layoutMatrix);
    } else {
        if (primaryMatrix.length === 0) {
            facet = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"];
        } else if (secondaryMatrix.length === 0) {
            facet = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"];
        } else {
            facet = primaryMatrix.length >= secondaryMatrix.length ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"];
        }
        if (primaryMatrix.length > 0) {
            for (let i = 0; i < primaryMatrix.length - 1; i++) {
                keys.push(i);
            }
            // if (facet === PRIMARY) {
            keys.push(primaryMatrix.length - 1);
            // } else {
            if (facet === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SECONDARY"]) {
                lastLevelKey = primaryMatrix.length - 1;
            }
        }
        if (secondaryMatrix.length > 0) {
            const primaryMatrixLength = primaryMatrix.length;
            for (let i = secondaryMatrix.length - 1; i > 0; i--) {
                keys.push(i + primaryMatrixLength);
            }
            // if (facet === SECONDARY) {
            keys.push(primaryMatrixLength);
            // }
            if (facet === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["PRIMARY"]) {
                lastLevelKey = primaryMatrixLength;
            }
        }
        keys.forEach((key) => {
            let counter = -1;
            return nestFn.key((d) => {
                counter++;
                return `${d[key].valueOf()}-${findInPage(counter, breakPage)}`;
            });
        });
        let newMatrix = [];
        newMatrix = layoutMatrix[0].map((col, colIndex) => layoutMatrix.map(row => row[colIndex]));
        matrixTree = nestFn.entries(newMatrix);
    }
    return { tree: matrixTree, lastLevelKey };
};

/**
 * Gives the min measues
 *
 * @param {boolean} isTransposed is column matrix
 * @param {Object} unitMeasures min measures to be given to cells
 * @return {Object} dimension min cell
 */
const getMinMeasures = (isTransposed, unitMeasures) => {
    if (!isTransposed) {
        return {
            height: unitMeasures.height,
            width: 0
        };
    }
    return {
        height: 0,
        width: unitMeasures.width
    };
};

/**
 * Get the logical space from the tree
 *
 * @param {Node} item tree to be calculated
 * @param {number} measures width and height
 * @param {Array} minMeasures min measures for a cell
 * @param {Array} maxMeasure max measures for a col/row
 * @return {Object} dimension
 */
const getLogicalSpace = (item, measures, minMeasures, maxMeasure = []) => {
    const { firstMeasure, secondMeasure } = measures;
    let firstMeasureValue = 0;
    let secondMeasureValue = 0;
    item.values.forEach((valueArray) => {
        let fMeasure = 0;
        let sMeasure = 0;
        valueArray.forEach((placeholder, colIndex) => {
            placeholder.setAvailableSpace();
            const space = placeholder.getLogicalSpace();
            const minSecondMeasure = placeholder.getMinMeasures(minMeasures[secondMeasure]);

            sMeasure = Math.max(sMeasure, +space[secondMeasure], minSecondMeasure);
            maxMeasure[colIndex] = Math.max(maxMeasure[colIndex] || 0, space[firstMeasure]);
            fMeasure += +maxMeasure[colIndex];
        });
        secondMeasureValue += sMeasure;
        firstMeasureValue = Math.max(firstMeasureValue, fMeasure);
        item.space = {
            [secondMeasure]: Math.ceil(secondMeasureValue),
            [firstMeasure]: Math.ceil(firstMeasureValue)
        };
    });
    return {
        [secondMeasure]: secondMeasureValue,
        [firstMeasure]: firstMeasureValue
    };
};

/**
 * Computes the logical spcae taken by the matrix tree
 *
 * @param {*} [item={}] tree to be viewed
 * @param {boolean} [isTransposed=false] is column matrix
 * @param {*} unitMeasures min measues for a cell
 * @param {Array} maxMeasure max measures for a col/row
 * @return {Object} logical space taken
 */
const computeLogicalSpace = (item = {}, config, maxMeasures) => {
    const { isTransposed = false, unitMeasures } = config;
    const { firstMeasure, secondMeasure } = getMeasureInfo(isTransposed);
    const { values } = item;
    const minMeasures = getMinMeasures(isTransposed, unitMeasures);

    if (values[0].key) {
        const logicalSpace = { [firstMeasure]: 0, [secondMeasure]: 0 };

        values.forEach((valueItem) => {
            // Compute logical space for lowest level
            const space = computeLogicalSpace(valueItem, config, maxMeasures);
            // Set logical space for first measure
            logicalSpace[firstMeasure] = Math.max(logicalSpace[firstMeasure], space[firstMeasure],
                minMeasures[firstMeasure]);

            // Set logical space for second measure
            logicalSpace[secondMeasure] += +space[secondMeasure];
        });
        item.space = logicalSpace;
        return logicalSpace;
    }

    return getLogicalSpace(item, { firstMeasure, secondMeasure }, minMeasures, maxMeasures);
};

/**
 * Gives the space taken by a row
 *
 * @param {Array} row matrix array of rows
 * @return {Object} dimension of the row
 */
const spaceTakenByRow = (row) => {
    let height = 0;
    let width = 0;
    row.forEach((col) => {
        const spaces = col.getLogicalSpace();
        height = Math.max(height, spaces.height);
        width += spaces.width;
    });
    return {
        width,
        height
    };
};

/**
 * Gives the space taken by a column
 *
 * @param {Array<Array>} matrix column matrix
 * @param {number} colIndex column index
 * @return {Object} dimension of the column
 */
const spaceTakenByColumn = (matrix, colIndex) => {
    let height = 0;
    let width = 0;
    matrix.forEach((row) => {
        const col = row[colIndex];
        const spaces = col.getLogicalSpace();
        width = Math.max(width, spaces.width);
        height += spaces.height;
    });
    return {
        width,
        height
    };
};

/**
 * Creates different level matrices
 *
 * @param {Object} item matrix tree
 * @param {boolean} isTransposed is column matrix
 * @return {Object} matrix of each level
 */
const createMatrixEachLevel = (item, isTransposed) => {
    if (item.values[0].key) {
        const arr = [];
        item.values.forEach((child) => {
            if (!isTransposed) {
                arr.push(...createMatrixEachLevel(child, isTransposed));
            } else {
                const eachLevel = createMatrixEachLevel(child, isTransposed);
                eachLevel.forEach((e, i) => {
                    arr[i] = arr[i] || [];
                    arr[i].push(...e);
                });
            }
        });
        item.matrix = arr;
        return arr;
    }
    if (!isTransposed) {
        item.matrix = item.values;
    } else {
        item.matrix = item.values[0].map((col, colIndex) => item.values.map(row => row[colIndex]));
    }
    return item.matrix;
};

/**
 * Breaks the matrix into two part
 *
 * @param {Array<Array>} matrix input matrix
 * @param {boolean} isTransposed is column matrix
 * @param {number} breakPointer point in matrix where it is to be broken
 * @return {Array} two broken matrix
 */
const breakMatrix = (matrix, isTransposed, breakPointer) => {
    const primaryMatrix = [];
    const secondaryMatrix = [];
    if (isTransposed) {
        matrix.forEach((row, rowIndex) => {
            if (rowIndex >= breakPointer) {
                secondaryMatrix.push(row);
            } else {
                primaryMatrix.push(row);
            }
        });
    } else {
        matrix.forEach((row, rowIndex) => {
            row.forEach((column, columnIndex) => {
                if (columnIndex >= breakPointer) {
                    secondaryMatrix[rowIndex] = secondaryMatrix[rowIndex] || [];
                    secondaryMatrix[rowIndex].push(column);
                } else {
                    primaryMatrix[rowIndex] = primaryMatrix[rowIndex] || [];
                    primaryMatrix[rowIndex].push(column);
                }
            });
        });
    }
    return [primaryMatrix, secondaryMatrix];
};

/**
 * Distributed width returned
 *
 * @param {Object} context context for the width distibution
 * @return {number} distributed widths
 */
const getDistributedWidth = (context, layoutConfig) => {
    const {
        availableWidth,
        width,
        row
    } = context;
    const {
        isDistributionEqual,
        isTransposed,
        distribution
    } = layoutConfig;
    let distSum = 0;
    if (distribution && distribution[0]) {
        distSum = distribution.reduce((t, n) => {
            t += n;
            return t;
        });
    }
    return row.map((col, colIndex) => {
        const space = col.getLogicalSpace().width;
        let distWidth = (space + (availableWidth - width) * (space / width));
        if (isTransposed) {
            if (distribution.length > 0) {
                distWidth = (availableWidth * distribution[colIndex] / distSum);
            } else if (isDistributionEqual || width === 0) {
                const rowLen = row.length;
                distWidth = (availableWidth / rowLen);
            }
        }
        return Math.floor(distWidth);
    });
};

/**
 * Distributeed heights returned
 *
 * @param {Object} context input for the height distribution
 * @return {Object} distribured heights
 */
const getDistributedHeight = (context) => {
    let distSum = 0;
    let gutterSum = 0;
    let heightWithoutGutter = 0;
    const {
        isTransposed,
        distribution,
        availableHeight,
        height,
        isDistributionEqual,
        gutter,
        matrix,
        cIdx
    } = context;

    if (distribution && distribution[0] !== undefined) {
        distSum = distribution.reduce((t, n) => {
            t += n;
            return t;
        });
    }
    if (gutter && gutter[0] !== undefined) {
        gutterSum = gutter.reduce((t, n) => {
            t += n;
            return t;
        });
    }
    heightWithoutGutter = availableHeight - Math.floor(availableHeight * gutterSum);

    const colLen = matrix.length;
    return matrix.map((row, rIdx) => {
        const col = row[cIdx];
        const space = col.getLogicalSpace().height;
        let distHeight = (space + (heightWithoutGutter - height) * (space / height));

        if (!isTransposed) {
            if (distribution.length > 0 && colLen === distribution.length) {
                distHeight = (heightWithoutGutter * distribution[rIdx] / distSum);
            } else if (isDistributionEqual || context.height === 0) {
                distHeight = (heightWithoutGutter / colLen);
            }
        }
        return Math.floor(distHeight);
    });
};

/**
 *
 *
 * @param {*} arr
 * @param {*} beg
 * @param {*} end
 */
const extraCellsRemover = (arr, beg, end) => arr.slice(beg, -end);

/**
 * Creates matrix instancess
 *
 * @param {Array} [arr=[]] mutated arry
 * @param {number} depth depth of the tree
 * @param {Array} matrixInfo Details about the matrix(tree, etc) to be inserted
 * @param {boolean} layout Instance of layout
 */
const createMatrixInstances = (arr = [], depth, matrixInfo, layout) => {
    const breakPointer = layout._breakPointer;
    const config = layout.config();
    const {
        isTransposed
    } = config;
    const {
        tree,
        layoutMatrix
    } = matrixInfo;

    if (depth === 0) {
        const brokenMatrix = breakMatrix(tree.matrix, isTransposed, breakPointer);
        arr.push({
            matrix: tree.matrix,
            primaryMatrix: brokenMatrix[0],
            secondaryMatrix: brokenMatrix[1],
            space: tree.space
        });
        return arr;
    }
    const nextLevel = depth - 1;
    tree.values.forEach((e) => {
        createMatrixInstances(arr, nextLevel, {
            tree: e,
            layoutMatrix
        }, layout);
    });
    return arr;
};


/***/ }),

/***/ "./packages/layout/src/visual-matrix/column-matrix.js":
/*!************************************************************!*\
  !*** ./packages/layout/src/visual-matrix/column-matrix.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnVisualMatrix; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/utils/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _visual_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visual-matrix */ "./packages/layout/src/visual-matrix/visual-matrix.js");





/**
 * This class used to create column / row matrix for GridLayout
 *
 * @class VisualMatrix
 */
class ColumnVisualMatrix extends _visual_matrix__WEBPACK_IMPORTED_MODULE_3__["default"] {

    /**
     *Creates an instance of VisualMatrix.
     * @param {any} matrix Two set of matrices
     * @param {any} [config={}] Configuration for VisualMatrix
     * @memberof VisualMatrix
     */
    constructor (matrix, config = {}) {
        super(matrix, config);

        this._breakPointer = matrix[0].length;

        // Create Tree
        this._tree = {
            key: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["COLUMN_ROOT"],
            values: this.createTree()
        };
        this._logicalSpace = this.computeLogicalSpace();
    }

    /**
     * Computes the logical space taken by the entire matrixTree
     *
     * @return {Object} Logical space taken
     * @memberof VisualMatrix
     */
    computeLogicalSpace () {
        const matrixTree = this.tree();
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["createMatrixEachLevel"])(matrixTree, true);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["computeLogicalSpace"])(matrixTree, this.config(), this.maxMeasures());
    }

    computeViewableSpaces (measures) {
        const {
            maxHeights,
            maxWidths,
            height,
            width
        } = measures;

        return this.viewableMatrix.map((matrixInst, i) => {
            const cellDimOptions = { matrixInst, maxWidths, maxHeights, matrixIndex: i, height };
            const {
                heights,
                rowHeights,
                columnWidths
            } = this.getCellDimensions(cellDimOptions);
            const heightMeasures = heights;
            const columnMeasures = [width, width];

            return {
                rowHeights: {
                    primary: rowHeights[0],
                    secondary: rowHeights[1]
                },
                columnWidths: {
                    primary: columnWidths[0],
                    secondary: columnWidths[1]
                },
                height: {
                    primary: heightMeasures[0],
                    secondary: heightMeasures[1]
                },
                width: {
                    primary: columnMeasures[0],
                    secondary: columnMeasures[1]
                }
            };
        });
    }

    /**
     *
     *
     * @return
     * @memberof VisualMatrix
     */
    removeExtraCells () {
        const {
            isTransposed,
            extraCellLengths
        } = this.config();
        const matrix = this._layoutMatrix;
        const tree = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.tree());
        const begCellLen = extraCellLengths[0];
        const endCellLen = extraCellLengths[1] || Number.NEGATIVE_INFINITY;
        const layoutMatrix = !isTransposed ? Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(matrix, begCellLen, endCellLen) :
        matrix.slice(0).map(e => Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(e, begCellLen, endCellLen));

        tree.values = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(tree.values, begCellLen, endCellLen);

        tree.matrix = tree.matrix.map(e => Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(e, begCellLen, endCellLen));

        return {
            tree,
            layoutMatrix
        };
    }

    getPriorityDistribution (measures) {
        const {
            height,
            maxHeights
        } = measures;
        let remainingHeight = height;
        let heightDist = [];
        let conditions = [];
        let divider = 2;
        const priority = this.config().priority;
        const primaryMatrixLength = this.primaryMatrix().length;

        if (priority === 2) {
            conditions = [primaryMatrixLength - 1, primaryMatrixLength];
            divider = 2;
        } else {
            conditions = priority === 0 ? [primaryMatrixLength - 1] : [primaryMatrixLength];
            divider = 1;
        }
        maxHeights.forEach((heights, index) => {
            if (conditions.indexOf(index) === -1) {
                heightDist[index] = heights;
                remainingHeight -= heights;
            }
        });
        if (remainingHeight < 0) {
            heightDist = heightDist.map(() => 0);
        } else {
            conditions.forEach((condition) => {
                heightDist[condition] = Math.min(maxHeights[condition], (remainingHeight) / divider);
            });
        }
        return heightDist;
    }

    /**
     * Calculates the depth of the tree that can be viewed
     *
     * @param {Array} widthMeasures array of widths
     * @param {Array} heightMeasures array of heights
     * @return {number} depth of the tree
     * @memberof VisualMatrix
     */
    calculateDepth (widthMeasures) {
        let j;
        const { width } = this.availableSpace();

        for (j = 0; j < widthMeasures.length; j++) {
            if (widthMeasures[j] <= width) break;
        }
        return Math.min(widthMeasures.length - 1, j);
    }

     /**
     * Redistributes the provied space to all cells
     *
     * @param {*} viewableMatrix current viewport matrix
     * @param {*} width provied width
     * @param {*} height provied height
     * @return {Object} current viewports matrixes with measures
     * @memberof VisualMatrix
     */
    redistributeSpaces (width, height) {
        let maxHeights = [];
        let maxWidths = [];

        this.viewableMatrix.forEach((matrixInst) => {
            const matrix = matrixInst.matrix;
            const mWidth = 0;
            const mHeight = 0;
            const options = { mWidth, mHeight, matrix, width, height, maxHeights, maxWidths };
            const maxMeasures = this.redistributeViewSpaces(options);
            maxWidths = maxMeasures.maxWidths;
            maxHeights = maxMeasures.maxHeights;
        });

        return this.computeViewableSpaces({ height, width, maxHeights, maxWidths });
    }

    /**
     * Distibutes the given space column wisely
     *
     * @param {Object} measures Redistribution information
     * @memberof VisualMatrix
     */
    redistributeViewSpaces (measures) {
        let rHeights = [];
        const {
            matrix,
            width,
            maxHeights,
            maxWidths
        } = measures;
        const borderWidth = this.config().unitMeasures.border;

        const mWidth = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["spaceTakenByRow"])(matrix[this._lastLevelKey]).width;
        const cWidths = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getDistributedWidth"])({
            row: matrix[this._lastLevelKey],
            width: mWidth,
            availableWidth: width
        }, this.config());

        matrix.forEach((row, rIdx) => row.forEach((col, cIdx) => {
            const oldLogicalSpace = col.getLogicalSpace();

            col.setAvailableSpace(cWidths[cIdx] - borderWidth, oldLogicalSpace.height);

            rHeights[rIdx] = Math.max(rHeights[rIdx] || 0, Math.floor(col.getLogicalSpace().height));
        }));
        if (maxHeights.length > 0) {
            rHeights = rHeights.map((e, i) => Math.max(e, maxHeights[0][i]));
        }
        maxHeights.push(rHeights);
        for (let x = 0; x < maxHeights.length; x++) {
            maxHeights[x] = rHeights;
        }
        maxWidths.push(cWidths);
        return { maxHeights, maxWidths };
    }

    /**
     * Dispatch the calculated cell dimensions to all the cells
     *
     * @param {Object} measures cell dimension information
     * @return {Object} row and column heights / widths
     * @memberof VisualMatrix
     */
    getCellDimensions (measures) {
        const {
            unitMeasures
        } = this.config();
        const borderWidth = unitMeasures.border;
        const { matrixInst, height, maxWidths, maxHeights, matrixIndex } = measures;
        const matrix = matrixInst.matrix;
        const rowHeights = [[0], [0]];
        const columnWidths = [[0], [0]];
        const heights = [0, 0];
        const widths = [0, 0];
        const breakPointer = this._breakPointer;

        const heightDistribution = this.getPriorityDistribution({ height, maxHeights: maxHeights[0] || [] });

        matrix.forEach((row, rIdx) => {
            row.forEach((cell, cIdx) => {
                const colHeight = heightDistribution[rIdx] || 0;
                const colWidth = maxWidths[matrixIndex][cIdx];

                cell.setAvailableSpace(colWidth - borderWidth, colHeight);

                if (cIdx === 0 && rIdx < breakPointer) {
                    rowHeights[0][rIdx] = colHeight;
                    heights[0] = (heights[0] || 0) + colHeight;
                } else if (cIdx === 0 && rIdx >= breakPointer) {
                    rowHeights[1][rIdx - breakPointer] = colHeight;
                    heights[1] = (heights[1] || 0) + colHeight;
                }
                if (rIdx === this._lastLevelKey) {
                    columnWidths[0][cIdx] = colWidth;
                    columnWidths[1][cIdx] = colWidth;
                }
            });
        });
        return {
            heights,
            widths,
            rowHeights,
            columnWidths
        };
    }
}



/***/ }),

/***/ "./packages/layout/src/visual-matrix/default-config.js":
/*!*************************************************************!*\
  !*** ./packages/layout/src/visual-matrix/default-config.js ***!
  \*************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");

/**
 *
 *
 */
const defaultConfig = {
    distribution: [],
    classPrefix: 'muze',
    isDistributionEqual: true,
    unitMeasures: {
        height: 100,
        width: 100,
        border: 1
    },
    isTransposed: false,
    facet: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["PRIMARY"],
    extraCellLengths: []
};


/***/ }),

/***/ "./packages/layout/src/visual-matrix/props.js":
/*!****************************************************!*\
  !*** ./packages/layout/src/visual-matrix/props.js ***!
  \****************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const PROPS = {
    config: {
        sanitization: (context, value) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._config || {}, value)
    },
    maxMeasures: {},
    availableSpace: {},
    logicalSpace: {}
};


/***/ }),

/***/ "./packages/layout/src/visual-matrix/row-matrix.js":
/*!*********************************************************!*\
  !*** ./packages/layout/src/visual-matrix/row-matrix.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RowVisualMatrix; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/utils/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _visual_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visual-matrix */ "./packages/layout/src/visual-matrix/visual-matrix.js");





/**
 * This class used to create column / row matrix for GridLayout
 *
 * @class VisualMatrix
 */
class RowVisualMatrix extends _visual_matrix__WEBPACK_IMPORTED_MODULE_3__["default"] {

    /**
     *Creates an instance of VisualMatrix.
     * @param {any} matrix Two set of matrices
     * @param {any} [config={}] Configuration for VisualMatrix
     * @memberof VisualMatrix
     */
    constructor (matrix, config = {}) {
        super(matrix, config);

        this._breakPointer = (matrix[0].length > 0 ? matrix[0][0].length : 0);
        this._layoutMatrix = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["combineMatrices"])([matrix[0] || [], matrix[1] || []], this.config());

        // Create Tree
        this._tree = {
            key: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["ROW_ROOT"],
            values: this.createTree()
        };
        this._logicalSpace = this.computeLogicalSpace();
    }

    /**
     * Computes the logical space taken by the entire matrixTree
     *
     * @return {Object} Logical space taken
     * @memberof VisualMatrix
     */
    computeLogicalSpace () {
        const matrixTree = this.tree();
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["createMatrixEachLevel"])(matrixTree, false);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["computeLogicalSpace"])(matrixTree, this.config(), this.maxMeasures());
    }

    computeViewableSpaces (measures) {
        const {
            maxHeights,
            maxWidths,
            height
        } = measures;
        return this.viewableMatrix.map((matrixInst, i) => {
            const cellDimOptions = { matrixInst, maxWidths, maxHeights, matrixIndex: i };
            const { widths, rowHeights, columnWidths } = this.getCellDimensions(cellDimOptions);
            const heightMeasures = [height, height];
            const columnMeasures = widths;

            return {
                rowHeights: {
                    primary: rowHeights[0],
                    secondary: rowHeights[1]
                },
                columnWidths: {
                    primary: columnWidths[0],
                    secondary: columnWidths[1]
                },
                height: {
                    primary: heightMeasures[0],
                    secondary: heightMeasures[1]
                },
                width: {
                    primary: columnMeasures[0],
                    secondary: columnMeasures[1]
                }
            };
        });
    }

    /**
     *
     *
     * @return
     * @memberof VisualMatrix
     */
    removeExtraCells () {
        const {
            isTransposed,
            extraCellLengths
        } = this.config();
        const matrix = this._layoutMatrix;
        const tree = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.tree());
        const begCellLen = extraCellLengths[0];
        const endCellLen = extraCellLengths[1] || Number.NEGATIVE_INFINITY;
        const layoutMatrix = !isTransposed ? Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(matrix, begCellLen, endCellLen) :
        matrix.slice(0).map(e => Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(e, begCellLen, endCellLen));

        tree.values = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(tree.values, begCellLen, endCellLen);
        tree.matrix = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["extraCellsRemover"])(tree.matrix, begCellLen, endCellLen);

        return {
            tree,
            layoutMatrix
        };
    }

    getPriorityDistribution (measures) {
        let remainingAvailWidth;
        let remainingWidth;
        let cWidths = [];
        let conditions = [];
        let maxPrioritySpace = 0;
        const {
            matrix,
            width: availableWidth,
            maxMeasures: maxWidths,
            maxWidth: currentWidth,
            height
        } = measures;
        const priority = this.config().priority;
        const primaryMatrixLength = this.primaryMatrix().length ? this.primaryMatrix()[0].length : 0;

        const dist = [];

        remainingAvailWidth = availableWidth;
        remainingWidth = currentWidth;

        if (priority === 2) {
            conditions = [primaryMatrixLength - 1, primaryMatrixLength];
            // divider = Math.min(2, matrixLen);
        } else {
            conditions = priority === 0 ? [primaryMatrixLength - 1] : [primaryMatrixLength];
            // divider = Math.min(1, matrixLen);
        }
        conditions.forEach((i) => {
            dist[i] = maxWidths[i];
            maxPrioritySpace += maxWidths[i];
            remainingAvailWidth -= dist[i];
            remainingWidth -= dist[i];
        });
        matrix[0].forEach((e, i) => {
            if (conditions.indexOf(i) === -1) {
                dist[i] = remainingAvailWidth * (maxWidths[i] / remainingWidth);
            }
        });
        matrix.forEach(row => row.forEach((col, cIdx) => {
            if (conditions.indexOf(cIdx) === -1) {
                col.setAvailableSpace(dist[cIdx], height);

                cWidths[cIdx] = Math.max(cWidths[cIdx] || 0, Math.floor(col.getLogicalSpace().width));
            } else {
                cWidths[cIdx] = 0;
            }
        }));

        const prioritySpace = availableWidth - cWidths.reduce((t, n) => t + n);
        if (prioritySpace < 0) {
            cWidths = cWidths.map(() => 0);
        } else {
            conditions.forEach((i) => {
                cWidths[i] = Math.floor(prioritySpace * (dist[i] / maxPrioritySpace || 1));
            });
        }
        return cWidths;
    }

    /**
     * Calculates the depth of the tree that can be viewed
     *
     * @param {Array} widthMeasures array of widths
     * @param {Array} heightMeasures array of heights
     * @return {number} depth of the tree
     * @memberof VisualMatrix
     */
    calculateDepth (widthMeasures, heightMeasures) {
        let i;
        const { height } = this.availableSpace();

        for (i = 0; i < heightMeasures.length; i++) {
            if (heightMeasures[i] <= height) break;
        }

        return Math.min(widthMeasures.length - 1, i);
    }

    /**
     * Redistributes the provied space to all cells
     *
     * @param {*} viewableMatrix current viewport matrix
     * @param {*} width provied width
     * @param {*} height provied height
     * @return {Object} current viewports matrixes with measures
     * @memberof VisualMatrix
     */
    redistributeSpaces (width, height) {
        let maxHeights = [];
        let maxWidths = [];
        const maxMeasures = this.maxMeasures();

        const maxWidth = maxMeasures.reduce((t, n) => {
            t += n;
            return t;
        });
        const logicalWidths = this.getPriorityDistribution({
            matrix: this._layoutMatrix,
            maxWidth,
            maxMeasures,
            width,
            height
        });

        this.viewableMatrix.forEach((matrixInst) => {
            const matrix = matrixInst.matrix;
            const mWidth = 0;
            const mHeight = 0;
            const options = { mWidth, mHeight, matrix, width, height, maxHeights, maxWidths, logicalWidths };
            const measures = this.redistributeViewSpaces(options);
            maxWidths = measures.maxWidths;
            maxHeights = measures.maxHeights;
        });
        return this.computeViewableSpaces({ height, width, maxHeights, maxWidths });
    }

    /**
     * Distibutes the given space row wisely
     *
     * @param {Object} measures Redistribution information
     * @memberof VisualMatrix
     */
    redistributeViewSpaces (measures) {
        let cWidths = [];
        let rHeights = [];
        let mHeight = 0;
        const maxMeasures = this.maxMeasures();

        const {
            isDistributionEqual,
            distribution,
            isTransposed,
            gutter
        } = this.config();
        const { matrix, height, maxHeights, maxWidths, logicalWidths } = measures;
        mHeight = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["spaceTakenByColumn"])(matrix, this._lastLevelKey).height;

        const maxWidth = maxMeasures.reduce((t, n) => {
            t += n;
            return t;
        });
        measures.maxMeasures = maxMeasures;
        measures.maxWidth = maxWidth;
        if (maxWidth > 0) {
            cWidths = logicalWidths;
        } else {
            cWidths = maxMeasures.map(() => 0);
        }
        rHeights = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getDistributedHeight"])({
            matrix,
            cIdx: this._lastLevelKey,
            height: mHeight,
            availableHeight: height,
            isDistributionEqual,
            distribution,
            isTransposed,
            gutter
        });
        if (maxWidths.length > 0) {
            cWidths = cWidths.map((e, i) => Math.max(e, maxWidths[0][i] || 0));
        }
        maxWidths.push(cWidths);
        for (let x = 0; x < maxWidths.length; x++) {
            maxWidths[x] = cWidths;
        }
        maxHeights.push(rHeights);
        return { maxWidths, maxHeights };
    }

    /**
     * Dispatch the calculated cell dimensions to all the cells
     *
     * @param {Object} measures cell dimension information
     * @return {Object} row and column heights / widths
     * @memberof VisualMatrix
     */
    getCellDimensions (measures) {
        const {
            unitMeasures
        } = this.config();
        const borderWidth = unitMeasures.border;
        const { matrixInst, maxWidths, maxHeights, matrixIndex } = measures;
        const matrix = matrixInst.matrix;
        const rowHeights = [[0], [0]];
        const columnWidths = [[0], [0]];
        const heights = [0, 0];
        const widths = [0, 0];
        const breakPointer = this._breakPointer;

        matrix.forEach((row, rIdx) => {
            row.forEach((cell, cIdx) => {
                const colHeight = maxHeights[matrixIndex][rIdx] || 0;
                const colWidth = maxWidths[matrixIndex][cIdx];

                cell.setAvailableSpace(colWidth, colHeight - borderWidth);

                if (rIdx === 0 && cIdx < breakPointer) {
                    columnWidths[0][cIdx] = colWidth;
                    widths[0] = (widths[0] || 0) + colWidth;
                } else if (rIdx === 0 && cIdx >= breakPointer) {
                    columnWidths[1][cIdx - breakPointer] = colWidth;
                    widths[1] = (widths[1] || 0) + colWidth;
                }
                if (cIdx === this._lastLevelKey) {
                    rowHeights[0][rIdx] = colHeight;
                    rowHeights[1][rIdx] = colHeight;
                }
            });
        });
        return {
            heights,
            widths,
            rowHeights,
            columnWidths
        };
    }
}



/***/ }),

/***/ "./packages/layout/src/visual-matrix/visual-matrix.js":
/*!************************************************************!*\
  !*** ./packages/layout/src/visual-matrix/visual-matrix.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VisualMatrix; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./packages/layout/src/utils/index.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./props */ "./packages/layout/src/visual-matrix/props.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./default-config */ "./packages/layout/src/visual-matrix/default-config.js");






/**
 * This class used to create column / row matrix for GridLayout
 *
 * @class VisualMatrix
 */
class VisualMatrix {

    /**
     *Creates an instance of VisualMatrix.
     * @param {any} matrix Two set of matrices
     * @param {any} [config={}] Configuration for VisualMatrix
     * @memberof VisualMatrix
     */
    constructor (matrix, config = {}) {
        // Prepare matrices
        this._lastLevelKey = 0;
        this._primaryMatrix = matrix[0] || [];
        this._secondaryMatrix = matrix[1] || [];
        this._maxMeasures = [];
        this._availableSpace = {};

        // Store the config
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_2__["PROPS"]);
        const defCon = Object.assign({}, this.constructor.defaultConfig());
        this.config(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defCon, config));

        this._layoutMatrix = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["combineMatrices"])([matrix[0] || [], matrix[1] || []], this.config());
    }

     /**
     * Computes the logical space taken by the entire matrixTree
     *
     * @return {Object} Logical space taken
     * @memberof VisualMatrix
     */
    computeLogicalSpace () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    computeViewableSpaces () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     *
     *
     * @return
     * @memberof VisualMatrix
     */
    removeExtraCells () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    getPriorityDistribution () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Calculates the depth of the tree that can be viewed
     *
     * @param {Array} widthMeasures array of widths
     * @param {Array} heightMeasures array of heights
     * @return {number} depth of the tree
     * @memberof VisualMatrix
     */
    calculateDepth () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Redistributes the provied space to all cells
     *
     * @param {*} viewableMatrix current viewport matrix
     * @param {*} width provied width
     * @param {*} height provied height
     * @return {Object} current viewports matrixes with measures
     * @memberof VisualMatrix
     */
    redistributeSpaces () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Distibutes the given space row wisely
     *
     * @param {Object} measures Redistribution information
     * @memberof VisualMatrix
     */
    redistributeViewSpaces () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Dispatch the calculated cell dimensions to all the cells
     *
     * @param {Object} measures cell dimension information
     * @return {Object} row and column heights / widths
     * @memberof VisualMatrix
     */
    getCellDimensions () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     *
     *
     * @param {*} params
     * @returns
     * @memberof VisualMatrix
     */
    primaryMatrix (...params) {
        if (params.length) {
            return this;
        }
        return this._primaryMatrix;
    }

    secondaryMatrix (...params) {
        if (params.length) {
            return this;
        }
        return this._secondaryMatrix;
    }

    tree (...params) {
        if (params.length) {
            return this;
        }
        return this._tree;
    }

    static defaultConfig () {
        return _default_config__WEBPACK_IMPORTED_MODULE_4__["defaultConfig"];
    }

    createTree () {
        const { tree, lastLevelKey } = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["createTree"])(this);
        this._lastLevelKey = lastLevelKey;
        return tree;
    }

    /**
     * Returns the space taken by visual matrix
     *
     * @return {Object} space taken by the matrix
     * @memberof VisualMatrix
     */
    getLogicalSpace () {
        return this.logicalSpace();
    }

    /**
     * Sets the provied space to the visual matrix
     *
     * @param {number} width width provided
     * @param {number} height height provided
     * @memberof VisualMatrix
     */
    setAvailableSpace (width, height) {
        this.availableSpace({ width, height });
        const tree = this.tree();
        const heightMeasures = this.populateMaxMeasures(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], tree);
        const widthMeasures = this.populateMaxMeasures(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], tree);
        const depth = this.calculateDepth(widthMeasures, heightMeasures);

        this.viewableMatrix = this.createViewPortMatrix(depth);
        this.viewableMeasures = this.redistributeSpaces(width, height);
        return this;
    }

    /**
     * Populate the max measures in the array
     *
     * @param {Array} measures array to be filled with max measures
     * @param {Object} matrixTree matrix tree of visual matrix
     * @param {number} measure width or height
     * @param {number} [depth=0] depth of the tree that to be calculated
     * @memberof VisualMatrix
     */
    populateMaxMeasures (type, matrixTree, depth = 0, measures = []) {
        measures[depth] = Math.max(measures[depth] || 0, matrixTree.space[type]);
        if (matrixTree.values) {
            const childDepth = depth + 1;
            matrixTree.values.forEach((child) => {
                if (child.space) {
                    measures = this.populateMaxMeasures(type, child, childDepth, measures);
                }
            });
        }
        return measures;
    }

    /**
     * Gets the viewable measures for the current viewable matrix
     *
     * @return {Object} Set of viewable measures
     * @memberof VisualMatrix
     */
    getViewableSpaces () {
        return this.viewableMeasures;
    }

    /**
     * Returns the matrix that can be viewed in the current viewport
     *
     * @return {Array} Set of matrices that can be viewed
     * @memberof VisualMatrix
     */
    getViewableMatrices () {
        return this.viewableMatrix;
    }

    /**
     * Creates the viewport that can be viewed together
     *
     * @param {number} depth maxDepth that can be viewed in the viewport
     * @return {Array<Object>} Set of matrices that can be viewed
     * @memberof VisualMatrix
     */
    createViewPortMatrix (depth) {
        const arr = [];
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["createMatrixInstances"])(arr, depth, this.removeExtraCells(), this);
        return arr;
    }
}



/***/ }),

/***/ "./packages/muze-axis/src/axis-renderer.js":
/*!*************************************************!*\
  !*** ./packages/muze-axis/src/axis-renderer.js ***!
  \*************************************************/
/*! exports provided: renderAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderAxis", function() { return renderAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/**
 * This file exports functionality that is used to render axis.
 */




/**
 *
 *
 * @param {*} instance
 * @param {*} container
 * @param {*} labelManager
 * @param {*} config
 */
const rotateAxis = (instance, tickText, labelManager) => {
    let rotation;
    const axis = instance.axis();
    const config = instance.config();
    const renderConfig = instance.renderConfig();
    const smartTicks = instance.smartTicks();
    const scale = axis.scale();
    const labelFunc = scale.ticks || scale.quantile || scale.domain;
    const ticks = labelFunc();
    const {
        orientation,
        fixedBaseline,
        type
    } = config;
    const {
        labels
    } = renderConfig;

    rotation = labels.rotation;

    const tickSize = instance.getTickSize();
    tickText.each(function (d, index) {
        let yShift;
        let xShift;
        let datum = smartTicks[index] ? smartTicks[index].text : d;

        datum = datum.toString();

        const tickLabelDim = labelManager.getOriSize(datum);

        const width = tickLabelDim.width * 0.5;
        const height = tickLabelDim.height * 0.5;

        if (rotation < 0) {
            rotation = 360 + rotation;
        }

        const quadrant = 4 - Math.floor(rotation / 90);
        const rotationNormalizer = ((quadrant % 2 === 0) ? rotation : 180 * Math.ceil(rotation / 180) - rotation) % 180;

        yShift = Math.sqrt(height ** 2 + width ** 2) * Math.sin(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["angleToRadian"])(rotationNormalizer));

        if ((quadrant === 3 || quadrant === 2) && !(rotationNormalizer > 67.5 && rotationNormalizer <= 90)) {
            yShift += height * 2;
        }
        xShift = width;

        if (rotation === 90) {
            xShift = height;
        } else if (rotation === 270) {
            xShift = -height;
        } else {
            xShift = 0;
        }

        if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"]) {
            xShift = (fixedBaseline && ticks[0] === d && type === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["LINEAR"]) ? xShift + xShift / 2 : xShift;
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this)
                            .attr('transform', `translate(${-xShift + tickSize}
                                ${-yShift - tickSize}) rotate(${rotation})`);
        } else {
            xShift = (fixedBaseline && ticks[0] === d && type === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["LINEAR"]) ? xShift - xShift / 2 : xShift;

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this)
                            .attr('transform', `translate(${xShift - tickSize}
                                ${yShift + tickSize}) rotate(${rotation})`);
        }
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).transition()
                        .duration(1000).text(datum);
    });
    return tickText;
};

/**
 *
 *
 * @param {*} tickText
 * @param {*} axisInstance
 */
const changeTickOrientation = (selectContainer, axisInstance, tickSize) => {
    const {
        _smartTicks
    } = axisInstance;
    const config = axisInstance.config();
    const renderConfig = axisInstance.renderConfig();
    const labelManager = axisInstance.dependencies().labelManager;
    const {
        orientation,
        classPrefix
    } = config;
    const {
        labels
    } = renderConfig;
    const {
        rotation,
        smartTicks: isSmartTicks
    } = labels;

    const tickText = selectContainer.selectAll('.tick text');
    tickText.selectAll('tspan').remove();

    // rotate labels if not enough space is available
    if (rotation && (orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["TOP"] || orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"])) {
        rotateAxis(axisInstance, tickText, labelManager);
    } else if (!rotation && !isSmartTicks) {
        tickText.attr('transform', '');
    } else {
        tickText.text('');
        if (orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["TOP"] || orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"]) {
            tickText.attr('y', 0)
                            .attr('x', 0)
                            .attr('transform', '')
                            .text('');
            const tspan = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(tickText, 'tspan', (d, i) => {
                if (_smartTicks[i]) {
                    return _smartTicks[i].lines;
                } return [];
            }, `${classPrefix}-smart-text`);

            tspan.attr('dy', '0')
                            .style('opacity', '0')

                            .transition()
                            .duration(1000)
                            .on('end', axisInstance.registerAnimationDoneHook())
                            .attr('dy', (d, i) => {
                                if (orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"] || i !== 0) {
                                    return _smartTicks[0].oriTextHeight;
                                }
                                return -_smartTicks[0].oriTextHeight * (_smartTicks[0].lines.length - 1) - tickSize;
                            })
                            .style('opacity', 1)
                            .text(e => e)
                            .attr('x', 0);
        } else {
            const tspan = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(tickText, 'tspan', (d, i) => _smartTicks[i].lines, `${classPrefix}-smart-text`);
            tspan.text(e => e);
        }
    }

    return tickText;
};

const setFixedBaseline = (axisInstance) => {
    const {
        fixedBaseline
    } = axisInstance.config();
    const {
        showInnerTicks
    } = axisInstance.renderConfig();
    const domain = axisInstance.domain();
    if (fixedBaseline && domain.length && showInnerTicks) {
        axisInstance.setFixedBaseline();
    }
};

/**
 *
 *
 * @param {*} textNode
 * @param {*} orientation
 * @param {*} measures
 */
const setAxisNamePos = (textNode, orientation, measures) => {
    const {
        axisNameHeight,
        availableSpace
    } = measures;

    switch (orientation) {
    case _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["LEFT"]:
        textNode.attr('transform',
            `translate(${-(availableSpace.width - axisNameHeight)},${availableSpace.height / 2})rotate(-90)`);
        break;
    case _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["RIGHT"]:
        textNode.attr('transform',
             `translate(${(availableSpace.width - axisNameHeight)},${availableSpace.height / 2})rotate(90)`);
        break;
    case _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"]:
        textNode.attr('transform',
             `translate(${availableSpace.width / 2},${-availableSpace.height + axisNameHeight})`);
        break;
    case _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]:
        textNode.attr('transform',
             `translate(${availableSpace.width / 2},${availableSpace.height - axisNameHeight / 2})`);
        break;
    default:
    }
    return textNode;
};

/**
 * This method is used to render the axis inside an
 * svg container.
 *
 * @export
 * @param {Object} axisInstance the nput object required to render axis
 * @param {string} axisInstance.orientation the orientation of axis
 * @param {Object} axisInstance.scale instance of d3 scale
 * @param {SVGElement} axisInstance.container the container in which to render
 */
function renderAxis (axisInstance) {
    const config = axisInstance.config();
    const renderConfig = axisInstance.renderConfig();
    const labelManager = axisInstance.dependencies().labelManager;
    const mount = axisInstance.mount();
    const range = axisInstance.range();
    const axis = axisInstance.axis();
    const scale = axisInstance.scale();
    const {
        _tickLabelStyle: tickLabelStyle,
        _tickFormatter: axisTickFormatter
     } = axisInstance;
    const {
        orientation,
        axisNamePadding,
        className,
        id,
        classPrefix
     } = config;
    const {
        show,
        xOffset,
        yOffset,
        showAxisName,
        labels,
        smartAxisName
    } = renderConfig;

    if (!show) {
        return;
    }

    const tickSize = axisInstance.getTickSize();

    const selectContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount), 'g', [axisInstance], `${className}`, {},
        key => key.config().id);

    // Set style for tick labels
    labelManager.setStyle(tickLabelStyle);

    const labelFunc = scale.ticks || scale.quantile || scale.domain;

    const ticks = axis.tickValues() || labelFunc();

    axis.tickFormat(axisTickFormatter(ticks));

    // Get range(length of range)
    const availableSpace = Math.abs(range[0] - range[1]);

    // Get width and height taken by axis labels
    const labelProps = axisInstance.axisComponentDimensions().largestTickDimensions;

    // Draw axis ticks
    selectContainer.attr('transform', `translate(${xOffset},${yOffset})`);
    setFixedBaseline(axisInstance);
    if (labels.smartTicks === false || tickSize === 0) {
        selectContainer.transition()
                        .duration(1000)
                        .on('end', axisInstance.registerAnimationDoneHook())
                        .call(axis);
    } else {
        selectContainer.call(axis);
    }
    selectContainer.selectAll('.tick').classed(`${classPrefix}-ticks`, true);
    selectContainer.selectAll('.tick line').classed(`${classPrefix}-tick-lines`, true);

    // Set classes for ticks
    const tickText = selectContainer.selectAll('.tick text');
    tickText.classed(`${classPrefix}-ticks`, true)
                    .classed(`${classPrefix}-ticks-${id}`, true);

    changeTickOrientation(selectContainer, axisInstance, tickSize);

    // Create axis name
    const textNode = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(selectContainer, 'text', [smartAxisName], `${classPrefix}-axis-name`)
                    .attr('text-anchor', 'middle')
                    .classed(`${classPrefix}-axis-name-${id}`, true)
                    .text(d => d.text);

    // Hide axis name if show is off
    textNode.classed(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["HIDDEN"], !showAxisName);

    // render labels based on orientation of axis
    const labelOffset = availableSpace / 2;

    const measures = {
        labelProps,
        tickSize,
        axisNamePadding,
        axisNameHeight: smartAxisName.height,
        yOffset,
        xOffset,
        labelOffset,
        availableSpace: axisInstance.availableSpace()
    };
    // Set position for axis name
    setAxisNamePos(textNode, orientation, measures);
}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/band-axis.js":
/*!************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/band-axis.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BandAxis; });
/* harmony import */ var _simple_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-axis */ "./packages/muze-axis/src/cartesian-axis/simple-axis.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/cartesian-axis/helper.js");




class BandAxis extends _simple_axis__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     *
     *
     * @static
     *
     * @memberof BandAxis
     */
    static type () {
        return _enums_scale_type__WEBPACK_IMPORTED_MODULE_1__["BAND"];
    }

    /**
     *
     *
     *
     * @memberof BandAxis
     */
    setTickConfig () {
        let smartTicks = '';
        let smartlabel;
        const domain = this.domain();
        const { labelManager } = this._dependencies;
        const { padding } = this.config();
        const { labels, tickValues } = this.renderConfig();
        const { height: availHeight, width: availWidth, noWrap } = this.maxTickSpaces();
        const { width, height } = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["getRotatedSpaces"])(labels.rotation, availWidth, availHeight);

        tickValues && this.axis().tickValues(tickValues);
        smartTicks = tickValues || domain;

        // set the style on the shared label manager instance
        labelManager.setStyle(this._tickLabelStyle);

        // Update padding between plots
        if (typeof padding === 'number') {
            const paddingNormalized = Math.min(1, Math.max(0, padding));
            this.scale().padding(paddingNormalized);
        }

        if (domain && domain.length) {
            const values = tickValues || domain;
            const tickFormatter = this._tickFormatter(values);
            smartTicks = values.map((d, i) => {
                labelManager.useEllipsesOnOverflow(true);

                smartlabel = labelManager.getSmartText(tickFormatter(d, i), width, height, noWrap);
                return labelManager.constructor.textToLines(smartlabel);
            });
        }
        this.smartTicks(smartTicks);
        return this;
    }

    /**
     * Gets the space occupied by the axis
     *
     * @return {Object} object with details about size of the axis.
     * @memberof SimpleAxis
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(Object(_helper__WEBPACK_IMPORTED_MODULE_2__["calculateBandSpace"])(this));
        }
        Object(_helper__WEBPACK_IMPORTED_MODULE_2__["setOffset"])(this);

        return this.logicalSpace();
    }

    /**
     *
     *
     * @memberof BandAxis
     */
    getTickValues () {
        return this.axis().scale().domain();
    }

    formatTickValue (val) {
        return this.valueParser()(val);
    }

    sanitizeTickFormatter (value) {
        const { tickFormat } = value;

        if (tickFormat) {
            return ticks => (val, i) => tickFormat(this.formatTickValue(val), val, i, ticks);
        }
        return () => val => this.formatTickValue(val);
    }

    /**
     *
     *
     *
     * @memberof BandAxis
     */
    getUnitWidth () {
        return this.scale().bandwidth();
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getTickSize () {
        const {
            showInnerTicks,
            showOuterTicks
        } = this.renderConfig();
        const axis = this.axis();

        axis.tickSizeInner(showInnerTicks ? 6 : 0);
        axis.tickSizeOuter(showOuterTicks ? 6 : 0);
        return axis.tickSize();
    }

    invertExtent (v1, v2) {
        return this.scale().invertExtent(v1, v2);
    }

    /**
     * Gets the nearest range value from the given range values.
     * @param {number} v1 Start range value
     * @param {number} v2 End range value
     * @return {Array} range values
     */
    getNearestRange (v1, v2) {
        const scale = this.scale();
        const range = scale.range();
        const reverse = range[0] > range[1];

        const extent = this.invertExtent(v1, v2);
        const p1 = scale(reverse ? extent[extent.length - 1] : extent[0]);
        const p2 = scale(reverse ? extent[0] : extent[extent.length - 1]) + scale.bandwidth();
        return [p1, p2];
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/continous-axis.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/continous-axis.js ***!
  \*****************************************************************/
/*! exports provided: interpolatorMap, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatorMap", function() { return interpolatorMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContinousAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-axis */ "./packages/muze-axis/src/cartesian-axis/simple-axis.js");
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony import */ var _interpolators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolators */ "./packages/muze-axis/src/cartesian-axis/interpolators/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/cartesian-axis/helper.js");







const interpolatorMap = {
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_3__["LOG"]]: _interpolators__WEBPACK_IMPORTED_MODULE_4__["LogInterpolator"],
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_3__["POW"]]: _interpolators__WEBPACK_IMPORTED_MODULE_4__["PowInterpolator"],
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_3__["LINEAR"]]: _interpolators__WEBPACK_IMPORTED_MODULE_4__["LinearInterpolator"]
};

class ContinousAxis extends _simple_axis__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor (config, dependencies) {
        config.tickFormat = config.tickFormat || (val => val);
        super(config, dependencies);
    }
    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    createScale (config) {
        const {
            base,
            padding,
            interpolator,
            exponent
        } = config;
        const range = this.range();
        const InterpolatorCls = interpolatorMap[interpolator];

        this._interpolator = new InterpolatorCls();
        let scale = this._interpolator.createScale({
            padding,
            exponent,
            base,
            range
        });

        scale = scale.nice();
        return scale;
    }

    /**
     *
     *
     * @static
     *
     * @memberof ContinousAxis
     */
    static type () {
        return _enums_scale_type__WEBPACK_IMPORTED_MODULE_3__["LINEAR"];
    }

    getScaleValue (domainVal) {
        if (domainVal === null || domainVal === undefined) {
            return undefined;
        }
        return this._interpolator.getScaleValue(domainVal);
    }
 /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getTickSize () {
        const {
            showInnerTicks,
            showOuterTicks
        } = this.renderConfig();
        const axis = this.axis();
        axis.tickSizeInner(showInnerTicks === false ? 0 : 6);
        axis.tickSizeOuter(showOuterTicks === false ? 0 : 6);

        return axis.tickSize();
    }

    /**
     *
     *
     * @param {*} d
     *
     * @memberof SimpleAxis
     */
    domain (...domain) {
        if (domain.length) {
            const domainVal = this._interpolator.sanitizeDomain(Object(_helper__WEBPACK_IMPORTED_MODULE_5__["getValidDomain"])(this, domain[0]));
            Object(_helper__WEBPACK_IMPORTED_MODULE_5__["setContinousAxisDomain"])(this, domainVal);
            this.setAxisComponentDimensions();
            this.logicalSpace(null);
            return this;
        }
        return this._domain;
    }

    /**
     * This method is used to set the space availiable to render
     * the SimpleCell.
     *
     * @param {number} width The width of SimpleCell.
     * @param {number} height The height of SimpleCell.
     * @memberof AxisCell
     */
    setAvailableSpace (...params) {
        super.setAvailableSpace(...params);
        this.getTickSize();
        return this;
    }

    /**
     *
     *
     * @param {*} tickValues
     *
     * @memberof SimpleAxis
     */
    setTickConfig () {
        const {
            tickValues,
            showInnerTicks
        } = this.renderConfig();
        const axis = this.axis();

        if (!showInnerTicks) {
            axis.tickValues([]);
            return this;
        }

        if (tickValues) {
            tickValues instanceof Array && this.axis().tickValues(tickValues);
        }
        const newTickValues = this.getTickValues();

        axis.tickValues(newTickValues);
        const smartLabel = this.dependencies().labelManager;
        smartLabel.setStyle(this._tickLabelStyle);
        const formatter = this._tickFormatter(newTickValues);
        const smartTicks = newTickValues.map((val, i) => {
            const text = formatter(val, i);
            const tickSpace = smartLabel.getOriSize(text);

            tickSpace.text = text;
            return tickSpace;
        });

        this.smartTicks(smartTicks);
        return this;
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getTickValues () {
        let labelDim = 0;
        const {
            orientation

        } = this.config();
        const {
            tickValues
        } = this.renderConfig();
        const range = this.range();
        const axis = this.axis();

        const availableSpace = Math.abs(range[0] - range[1]);

        const labelProps = this.axisComponentDimensions().largestTickDimensions;

        if (tickValues) {
            return tickValues;
        }
        labelDim = labelProps[orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["TOP"] ? 'width' : 'height'];

        return Object(_helper__WEBPACK_IMPORTED_MODULE_5__["getNumberOfTicks"])(availableSpace, labelDim, axis, this);
    }

    getMinTickDifference () {
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmallestDiff"])(this.renderConfig().tickValues);
    }

    /**
     * Sets a fixed baseline for the first ticks so that they can render effectively within
     * the given area
     *
     * @param {*} tickText
     * @param {*} config
     * @param {*} labelManager
     */
    setFixedBaseline (tickText) {
        const {
            orientation
        } = this.config();
        const {
            labels
        } = this.renderConfig();

        const {
            rotation
        } = labels;
        const axis = this.axis();
        const ticks = axis.tickValues();
        const smartTicks = this.smartTicks();

        if (smartTicks && smartTicks.length) {
            const { width, height } = this.smartTicks()[0];

            axis.tickTransform((d) => {
                if (d === ticks[0]) {
                    if ((orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["LEFT"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["RIGHT"])) {
                        return `translate(0, -${(height) / 3}px)`;
                    }

                    if ((orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"]) && !rotation) {
                        return `translate(${width / 2}px,  ${0}px)`;
                    }
                } return '';
            });
        }
        return tickText;
    }

}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/default-config.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/default-config.js ***!
  \*****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");



/**
 *
 *
 */
const defaultConfig = {
    id: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])(),
    adjustRange: false,
    axisName: {
        defClassName: 'axis-name'
    },
    axisNamePadding: 12,
    base: 10,
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"],
    className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-axis`,
    exponent: 1,
    interpolator: 'linear',
    fixedBaseline: true,
    labels: {
        rotation: null,
        smartTicks: null
    },
    orientation: 'left',
    numberFormat: val => val,
    padding: 0.3,
    nice: true,
    numberOfTicks: null,
    rotate: false,
    show: true,
    showAxisName: true,
    showInnerTicks: true,
    showOuterTicks: true,
    style: {},
    type: 'linear',
    tickFormat: null,
    tickValues: null,
    xOffset: 0,
    yOffset: 0
};



/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/helper.js":
/*!*********************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/helper.js ***!
  \*********************************************************/
/*! exports provided: getRotatedSpaces, setOffset, getNumberOfTicks, getAxisComponentDimensions, computeAxisDimensions, getHorizontalAxisSpace, getVerticalAxisSpace, calculateBandSpace, calculateContinousSpace, getValidDomain, setContinousAxisDomain, hasAxesConfigChanged, resetTickInterval, getSmartAxisName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotatedSpaces", function() { return getRotatedSpaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOffset", function() { return setOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNumberOfTicks", function() { return getNumberOfTicks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisComponentDimensions", function() { return getAxisComponentDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAxisDimensions", function() { return computeAxisDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHorizontalAxisSpace", function() { return getHorizontalAxisSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVerticalAxisSpace", function() { return getVerticalAxisSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateBandSpace", function() { return calculateBandSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateContinousSpace", function() { return calculateContinousSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValidDomain", function() { return getValidDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setContinousAxisDomain", function() { return setContinousAxisDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasAxesConfigChanged", function() { return hasAxesConfigChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTickInterval", function() { return resetTickInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSmartAxisName", function() { return getSmartAxisName; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _space_setter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./space-setter */ "./packages/muze-axis/src/cartesian-axis/space-setter.js");





const getRotatedSpaces = (rotation = 0, width, height) => {
    let rotatedHeight = height;
    let rotatedWidth = width;
    if (rotation) {
        const angle = ((rotation || 0) * Math.PI) / 180;
        rotatedWidth = Math.abs(height * Math.sin(angle)) + Math.abs(width * Math.cos(angle));
        rotatedHeight = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));
    }
    return { width: rotatedWidth, height: rotatedHeight };
};

const setOffset = (context) => {
    let x = 0;
    let y = 0;
    const logicalSpace = context.logicalSpace();
    const config = context.config();
    const {
        orientation,
        xOffset,
        yOffset
    } = config;
    if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["LEFT"]) {
        x = xOffset === undefined ? logicalSpace.width : xOffset;
    }
    if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"]) {
        y = yOffset === undefined ? logicalSpace.height : yOffset;
    }
    context.renderConfig({ xOffset: x, yOffset: y });
};

const getNumberOfTicks = (availableSpace, labelDim, axis, axisInstance) => {
    let numberOfValues = 0;
    let tickValues = [];
    let { numberOfTicks } = axisInstance.config();
    const ticks = axis.scale().ticks();
    const tickLength = ticks.length;
    const minTickDistance = axisInstance._minTickDistance.width;

    numberOfValues = tickLength;

    if (tickLength * (labelDim + minTickDistance) > availableSpace) {
        numberOfValues = Math.floor(availableSpace / (labelDim + minTickDistance));
    }

    numberOfTicks = numberOfTicks || numberOfValues;
    numberOfValues = Math.min(numberOfTicks, Math.max(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["MIN_NO_OF_TICKS"], numberOfValues));

    tickValues = axis.scale().ticks(numberOfValues);

    if (tickValues.length > numberOfValues) {
        tickValues = tickValues.filter((e, i) => i % 2 === 0);
    }

    if (numberOfValues === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["MIN_NO_OF_TICKS"]) {
        tickValues = axis.scale().ticks(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_NO_OF_TICKS"]);
        tickValues = [tickValues[0], tickValues[tickValues.length - 1]];
    }
    return tickValues;
};

const getAxisComponentDimensions = (context) => {
    let largestTick = '';
    let largestTickDimensions = { width: 0, height: 0 };
    let smartTick = {};
    let axisTicks;
    const allTickDimensions = [];
    const scale = context.scale();
    const { tickValues, showAxisName } = context.renderConfig();
    const { name } = context.config();
    const { labelManager } = context.dependencies();
    const labelFunc = scale.ticks || scale.quantile || scale.domain;

    // set the style on the shared label manager instance
    labelManager.setStyle(context._tickLabelStyle);

    // get the values along the domain
    axisTicks = tickValues || labelFunc();

    // Get the tick labels
    axisTicks = axisTicks.map((originalLabel, i) => {
        const label = context.getFormattedText(originalLabel, i, axisTicks);

    // convert to string for quant values
        const tickDimensions = labelManager.getOriSize(label);

    // Get spaces for all labels
        allTickDimensions.push(tickDimensions);

    // Getting largest label
        if (tickDimensions.width > largestTickDimensions.width) {
            largestTick = label;
            smartTick = context.smartTicks() ? context.smartTicks()[i] : {};

            largestTickDimensions = tickDimensions;
            smartTick = smartTick || tickDimensions;
        }
        return label;
    });

    labelManager.setStyle(context._axisNameStyle);
    const axisNameDimensions = showAxisName ? labelManager.getOriSize(name) : { width: 0, height: 0 };

    return {
        axisNameDimensions,
        largestTick,
        largestTickDimensions,
        allTickDimensions,
        axisTicks,
        smartTick,
        tickSize: context.getTickSize()
    };
};

const computeAxisDimensions = (context) => {
    let tickDimensions = {};
    const { labels } = context.renderConfig();
    const { smartTicks, rotation } = labels;
    const {
        largestTickDimensions,
        axisTicks,
        smartTick,
        axisNameDimensions,
        allTickDimensions,
        tickSize
    } = getAxisComponentDimensions(context);
    const { height: labelHeight, width: labelWidth } = largestTickDimensions;

    // get the domain of axis
    const domain = context.domain();
    // const angle = ((rotation || 0) * Math.PI) / 180;

    if (domain.length === 0) {
        return null;
    }

    if (smartTicks) {
        tickDimensions = smartTick;
    } else {
        tickDimensions = { width: labelWidth, height: labelHeight };
    }
    tickDimensions = getRotatedSpaces(rotation, tickDimensions.width, tickDimensions.height);

    if (tickSize === 0) {
        tickDimensions = { width: 0, height: 0 };
    }
    return {
        allTickDimensions,
        tickSize,
        tickDimensions,
        axisNameDimensions,
        largestTickDimensions,
        axisTicks
    };
};

/**
 *
 *
 * @param {*} axisDimensions
 * @param {*} config
 * @param {*} range
 *
 */
const getHorizontalAxisSpace = (context, axisDimensions, range) => {
    let width;
    let height;
    const domain = context.domain();
    const minTickDistance = context._minTickDistance.width;
    const { tickSize, tickDimensions, axisNameDimensions } = axisDimensions;
    const { axisNamePadding, tickValues } = context.config();
    const { showAxisName } = context.renderConfig();
    const { height: axisDimHeight } = axisNameDimensions;
    const { height: tickDimHeight, width: tickDimWidth } = tickDimensions;

    width = range && range.length ? range[1] - range[0] : ((tickDimWidth + minTickDistance) * 3);

    height = 0;
    if (tickValues) {
        const minTickDiff = context.getMinTickDifference();
        const [min, max] = [
            Math.min(...tickValues, ...domain),
            Math.max(...tickValues, ...domain)
        ];

        width = ((max - min) / Math.abs(minTickDiff)) * (tickDimWidth + context._minTickDistance.width);
    }
    if (!range || !range.length) {
        height = Math.max(tickDimWidth, tickDimHeight);
    } else {
        height = tickDimHeight;
    }

    height += (showAxisName ? axisDimHeight + axisNamePadding : 0) + tickSize;

    return {
        width,
        height
    };
};

/**
 *
 *
 * @param {*} axisDimensions
 * @param {*} config
 * @param {*} range
 *
 */
const getVerticalAxisSpace = (context, axisDimensions) => {
    let height;
    let width;
    const domain = context.domain();
    const { tickSize, tickDimensions, axisNameDimensions } = axisDimensions;
    const { axisNamePadding, tickValues } = context.config();
    const { showAxisName } = context.renderConfig();
    const { height: axisDimHeight } = axisNameDimensions;
    const { height: tickDimHeight, width: tickDimWidth } = tickDimensions;

    height = 0;
    width = tickDimWidth;
    if (tickValues) {
        const minTickDiff = context.getMinTickDifference();
        const [min, max] = [
            Math.min(...tickValues, ...domain),
            Math.max(...tickValues, ...domain)
        ];

        height = ((max - min) / Math.abs(minTickDiff)) * tickDimHeight;
    }
    width += (showAxisName ? axisDimHeight : 0) + tickSize + axisNamePadding;

    return {
        height,
        width
    };
};

/**
 * Calculates the logical space of the axis
 * @return {Object} Width and height occupied by the axis.
 */
const calculateBandSpace = (context) => {
    const range = context.range();
    const axisDimensions = context.getAxisDimensions();

    const { orientation } = context.config();
    const { show } = context.renderConfig();
    const { largestTickDimensions, axisTicks, allTickDimensions } = axisDimensions;
    const { height: largestDimHeight } = largestTickDimensions;
    const minTickWidth = context._minTickDistance.width;
    if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) {
        let {
            width,
            height
        } = getHorizontalAxisSpace(context, axisDimensions, range);

        if (!range || !range.length) {
            width = allTickDimensions.reduce((t, n) =>
                t + Math.min(n.width, n.height) + minTickWidth, 0);
        }

        if (show === false) {
            height = 0;
            width = 0;
        }
        return {
            width,
            height
        };
    }

    let {
        width,
        height
    } = getVerticalAxisSpace(context, axisDimensions, range);

    if (!height || height === 0) {
        height = axisTicks.length * (largestDimHeight + context._minTickDistance.height);
    }
    if (show === false) {
        width = 0;
    }
    return {
        width,
        height
    };
};

/**
 * Calculates the logical space of the axis
 * @return {Object} Width and height occupied by the axis.
 */
const calculateContinousSpace = (context) => {
    const range = context.range();
    const axisDimensions = context.getAxisDimensions();
    const { orientation } = context.config();
    const { show, showAxisName } = context.renderConfig();
    const { axisNameDimensions } = axisDimensions;

    if (show === false) {
        return {
            width: 0,
            height: 0
        };
    }

    const { width: axisNameWidth } = axisNameDimensions;

    if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) {
        const {
            width,
            height
        } = getHorizontalAxisSpace(context, axisDimensions, range);
        const axisWidth = Math.max(width, axisNameWidth);

        return {
            width: axisWidth,
            height
        };
    }
    const {
        width,
        height
    } = getVerticalAxisSpace(context, axisDimensions, range);

    const effHeight = Math.max(height, showAxisName ? axisNameWidth : 0);

    return {
        width,
        height: effHeight
    };
};

/**
 * Overwrites domain with user defined domain (if present)
 * @param {Object} context reference to current axes
 * @param {Array} domain default domain
 *
 * @return {Array} domain
 */
const getValidDomain = (context, domain) => {
    const { domain: userDom } = context.config();

    if (userDom) {
        domain = userDom;
    }

    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(domain, []);
};

const setContinousAxisDomain = (context, domain) => {
    const { nice } = context.config();
    const scale = context.scale.bind(context);

    scale().domain(domain);
    nice && scale().nice();
    context._domain = scale().domain();
};

/**
 * Checks if any of the properties have changed between two objects
 * @param {Object} obj first object
 * @param {Object} obj1 second object
 * @param {Array} properties properties to be compared between two objects
 *
 * @return {Boolean} boolean value
 */
const hasAxesConfigChanged = (obj = {}, obj1 = {}, properties) => {
    if (!Object.keys(obj).length || !Object.keys(obj1).length) {
        return false;
    }
    return properties.some(key => obj[key] !== obj1[key]);
};

const resetTickInterval = (context, domain) => {
    const {
        orientation,
        isOffset
    } = context.config();

    const minDiff = context._minDiff;
     // Set available space on interaction
    if (context.range().length && (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"])) {
        context.applyTickSkipping();
        const {
            largestTickDimensions
        } = context.getAxisDimensions();

        const noOfTicks = context.getTickValues().length;

        const { width, height, padding } = context.availableSpace();
        const {
            left,
            right
        } = padding;
        // Get the Tick Interval
        const tickInterval = Math.min(largestTickDimensions.width,
            ((width - (noOfTicks - 1) * (context._minTickDistance.width)) / noOfTicks));

        context.maxTickSpaces({
            width: tickInterval
        });

        const adjustedRange = Object(_space_setter__WEBPACK_IMPORTED_MODULE_3__["getAdjustedRange"])(minDiff, [tickInterval / 2,
            width - left - right - tickInterval / 2], domain, context.config());

         // set range for axis
        Object(_space_setter__WEBPACK_IMPORTED_MODULE_3__["setAxisRange"])(context, 'y', adjustedRange, isOffset ? height : null);

        context.setTickConfig();
    }
};

const getSmartAxisName = (name, width, labelManager) => {
    const oriSize = labelManager.getOriSize(name);

    labelManager.useEllipsesOnOverflow(true);

    return labelManager.getSmartText(name, width, oriSize.height, true);
};


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/index.js":
/*!********************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/index.js ***!
  \********************************************************/
/*! exports provided: ContinousAxis, BandAxis, TimeAxis, SimpleAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _continous_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continous-axis */ "./packages/muze-axis/src/cartesian-axis/continous-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContinousAxis", function() { return _continous_axis__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _band_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./band-axis */ "./packages/muze-axis/src/cartesian-axis/band-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BandAxis", function() { return _band_axis__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _time_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./time-axis */ "./packages/muze-axis/src/cartesian-axis/time-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeAxis", function() { return _time_axis__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _simple_axis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./simple-axis */ "./packages/muze-axis/src/cartesian-axis/simple-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleAxis", function() { return _simple_axis__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/interpolators/index.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/interpolators/index.js ***!
  \**********************************************************************/
/*! exports provided: LinearInterpolator, LogInterpolator, PowInterpolator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./packages/muze-axis/src/cartesian-axis/interpolators/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolator", function() { return _linear__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log */ "./packages/muze-axis/src/cartesian-axis/interpolators/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogInterpolator", function() { return _log__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pow */ "./packages/muze-axis/src/cartesian-axis/interpolators/pow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PowInterpolator", function() { return _pow__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/interpolators/linear.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/interpolators/linear.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LinearInterpolator; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../scale-creator */ "./packages/muze-axis/src/scale-creator.js");



class LinearInterpolator {

    createScale (config) {
        const {
            range
        } = config;
        const scaleFactory = _scale_creator__WEBPACK_IMPORTED_MODULE_1__["scaleMap"].linear;
        this._scale = scaleFactory().range(range);
        return this._scale;
    }

    getScaleValue (domainVal) {
        return this._scale(domainVal) + 0.5;
    }

    sanitizeDomain (domain) {
        if (domain.length) {
            domain = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["sanitizeDomainWhenEqual"])(domain);
        }
        return domain;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/interpolators/log.js":
/*!********************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/interpolators/log.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LogInterpolator; });
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scale-creator */ "./packages/muze-axis/src/scale-creator.js");


class LogInterpolator {

    createScale (config) {
        const {
            range,
            base
        } = config;
        const scaleFactory = _scale_creator__WEBPACK_IMPORTED_MODULE_0__["scaleMap"].log;
        this._scale = scaleFactory().range(range).base(base);
        return this._scale;
    }

    getScaleValue (domainVal) {
        const scale = this._scale;
        if (domainVal <= 0) {
            return scale(scale.domain()[0]);
        }

        return scale(domainVal) + 0.5;
    }

    sanitizeDomain (domain) {
        if (domain[0] <= 0) {
            domain[0] = Math.max(1, domain[0]);
        }
        if (domain[1] <= 0) {
            domain[1] = Math.max(1, domain[1]);
        }
        return domain;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/interpolators/pow.js":
/*!********************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/interpolators/pow.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PowInterpolator; });
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scale-creator */ "./packages/muze-axis/src/scale-creator.js");


class PowInterpolator {

    createScale (config) {
        const {
            range,
            exponent
        } = config;
        const scaleFactory = _scale_creator__WEBPACK_IMPORTED_MODULE_0__["scaleMap"].pow;
        this._scale = scaleFactory().range(range).exponent(exponent);
        return this._scale;
    }

    getScaleValue (domainVal) {
        return this._scale(domainVal) + 0.5;
    }

    sanitizeDomain (domain) {
        return domain;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/props.js":
/*!********************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/props.js ***!
  \********************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/cartesian-axis/helper.js");



const PROPS = {
    availableSpace: {},
    axisDimensions: {},
    axisComponentDimensions: {},
    config: {
        sanitization: (context, value) => {
            const oldConfig = Object.assign({}, context._config || {});
            const mockedOldConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, oldConfig);
            value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(mockedOldConfig, value);

            value.axisNamePadding = Math.max(value.axisNamePadding, 0);
            const shouldAxesScaleUpdate = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["hasAxesConfigChanged"])(
                value, oldConfig, ['interpolator', 'exponent', 'base', 'orientation']
            );
            const tickFormatter = context.sanitizeTickFormatter(value);

            if (shouldAxesScaleUpdate) {
                context._scale = context.createScale(value);
                context._axis = context.createAxis(value);
            }

            context._tickFormatter = ticks => tickFormatter(ticks);

            context.resetRenderConfig(value);
            return value;
        }
    },
    renderConfig: {
        sanitization: (context, value) => {
            const oldConfig = Object.assign({}, context._renderConfig || {});
            value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(oldConfig, value);
            return value;
        }
    },
    logicalSpace: {},
    mount: {
    },
    range: {
        sanitization: (context, value) => {
            context.scale().range(value);
            context.logicalSpace(null);
            return value;
        }
    },

    smartTicks: {},
    tickSize: {},
    maxTickSpaces: {
        sanitization: (context, value) => {
            const oldConfig = Object.assign({}, context._maxTickSpaces || {});
            value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(oldConfig, value);
            return value;
        }
    },
    valueParser: {
        defaultValue: val => val
    }
};


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/simple-axis.js":
/*!**************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/simple-axis.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SimpleAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-config */ "./packages/muze-axis/src/cartesian-axis/default-config.js");
/* harmony import */ var _axis_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../axis-renderer */ "./packages/muze-axis/src/axis-renderer.js");
/* harmony import */ var _space_setter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./space-setter */ "./packages/muze-axis/src/cartesian-axis/space-setter.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/cartesian-axis/helper.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/cartesian-axis/props.js");









class SimpleAxis {

    /**
     * Creates an instance of SimpleAxis.
     * @memberof SimpleAxis
     */
    constructor (config, dependencies) {
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();

        this._dependencies = dependencies;
        this._mount = null;
        this._range = [];
        this._domain = [];
        this._domainLock = false;
        this._axisDimensions = {};
        this._smartTicks = [];

        const defCon = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());
        const simpleConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defCon, config);

        const bodyElem = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])('body');
        const classPrefix = simpleConfig.classPrefix;
        this._tickLabelStyle = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(bodyElem, `${classPrefix}-ticks`);
        this._axisNameStyle = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(bodyElem, `${classPrefix}-axis-name`);

        dependencies.labelManager.setStyle(this._tickLabelStyle);
        const dist = dependencies.labelManager.getOriSize('w');

        this._minTickDistance = { width: dist.width * 3 / 4, height: dist.height / 2 };
        this._minTickSpace = dependencies.labelManager.getOriSize('www...');

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_7__["PROPS"]);
        this.config(simpleConfig);

        this._scale = this.createScale(this._config);
        this._axis = this.createAxis(this._config);
        this._animationDonePromises = [];
    }

    /**
     * Returns the default configuration of simple axis
     *  @return {Object} default configurations
     */
    static defaultConfig () {
        return _default_config__WEBPACK_IMPORTED_MODULE_3__["defaultConfig"];
    }

    /**
     * Sets a fixed baseline for the first ticks so that they can render effectively within
     * the given area
     *
     * @param {*} tickText
     * @param {*} config
     * @param {*} labelManager
     */
    setFixedBaseline () {
        return this;
    }

    /**
     *
     *
     * @readonly
     * @memberof SimpleAxis
     */
    scale (...params) {
        if (params.length) {
            this._scale = params[0];
            return this;
        }
        return this._scale;
    }

    resetDomain () {
        this._domain = [];
        return this;
    }

    /**
     *
     *
     * @readonly
     * @memberof SimpleAxis
     */
    axis (...params) {
        if (params.length) {
            this._axis = params[0];
            return this;
        }
        return this._axis;
    }

    /**
     *
     *
     * @param {*} d
     *
     * @memberof SimpleAxis
     */
    domain (...domain) {
        if (domain.length) {
            const domainValue = Object(_helper__WEBPACK_IMPORTED_MODULE_6__["getValidDomain"])(this, domain[0]);
            this.scale().domain(domainValue);
            this._domain = this.scale().domain();
            this.setAxisComponentDimensions();
            this.logicalSpace(null);
            return this;
        }
        return this._domain;
    }

    setAxisComponentDimensions () {
        this.axisComponentDimensions(Object(_helper__WEBPACK_IMPORTED_MODULE_6__["getAxisComponentDimensions"])(this));
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    dependencies () {
        return this._dependencies;
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    createScale (config) {
        const {
            base,
            padding,
            interpolator,
            exponent
        } = config;
        const range = this.range();
        const scale = Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            padding,
            interpolator,
            exponent,
            base,
            range,
            type: this.constructor.type()
        });

        return scale;
    }

    sanitizeTickFormatter (value) {
        const { tickFormat, numberFormat } = value;

        if (tickFormat) {
            return ticks => (val, i) => tickFormat(numberFormat(val), val, i, ticks);
        }

        return () => val => numberFormat(val);
    }

    resetRenderConfig (config) {
        const {
            labels,
            show,
            showInnerTicks,
            showOuterTicks,
            showAxisName,
            xOffset,
            yOffset,
            tickValues,
            smartAxisName
        } = config;
        this.renderConfig({
            labels,
            show,
            showInnerTicks,
            showOuterTicks,
            showAxisName,
            xOffset,
            yOffset,
            tickValues,
            smartAxisName
        });
        return this;
    }

    resetLogicalSpace () {
        this.logicalSpace(null);
        this.range([]);

        this.resetRenderConfig(this.config());
    }

    getFormattedText (text, index, axisTicks) {
        const formatter = this._tickFormatter;

        return formatter(axisTicks)(text, index);
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    createAxis (config) {
        const { orientation } = config;
        const axisClass = _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["axisOrientationMap"][orientation];

        if (axisClass) {
            const axis = axisClass(this.scale());
            return axis;
        }
        return null;
    }

    setTickValues (tickValues) {
        const renderConfig = this.renderConfig();
        this.config({ ...renderConfig, tickValues });
        this.tickValues = tickValues;
        this.axis().tickValues(tickValues);
    }

    /**
     * This method is used to set the space availiable to render
     * the SimpleCell.
     *
     * @param {number} width The width of SimpleCell.
     * @param {number} height The height of SimpleCell.
     * @memberof AxisCell
     */
    setAvailableSpace (width = 0, height, padding, isOffset) {
        let labelConfig = {};
        const {
           orientation
       } = this.config();

        this.availableSpace({ width, height, padding });
        const type = this.constructor.type();

        if (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"]) {
            labelConfig = Object(_space_setter__WEBPACK_IMPORTED_MODULE_5__["spaceSetter"])(this, { isOffset })[type].x();
        } else {
            labelConfig = Object(_space_setter__WEBPACK_IMPORTED_MODULE_5__["spaceSetter"])(this, { isOffset })[type].y();
        }

        // Set config
        this.renderConfig({
            labels: labelConfig
        });
        this.setTickConfig();
        this.setSmartAxisName();
        return this;
    }

    setSmartAxisName () {
        const { orientation, name } = this.config();
        const dimType = (orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["TOP"] || orientation === _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"]) ? 'width' : 'height';
        const widthDim = this.availableSpace()[dimType];
        const labelManager = this.dependencies().labelManager;
        labelManager.setStyle(this._axisNameStyle);
        this.renderConfig({
            smartAxisName: Object(_helper__WEBPACK_IMPORTED_MODULE_6__["getSmartAxisName"])(name, widthDim, labelManager)
        });
        return this;
    }

    /**
     *
     *
     * @memberof SimpleAxis
     */
    setTickConfig () {
        return this;
    }

    getScaleValue (domainVal) {
        if (domainVal === null || domainVal === undefined) {
            return undefined;
        }
        return this.scale()(domainVal);
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getTickSize () {
        return this.axis().tickSize();
    }

    /**
     * Gets the space occupied by the parts of an axis
     *
     * @return {Object} object with details about sizes of the axis.
     * @memberof SimpleAxis
     */
    getAxisDimensions (...params) {
        this.axisDimensions(Object(_helper__WEBPACK_IMPORTED_MODULE_6__["computeAxisDimensions"])(this, ...params));
        return this.axisDimensions();
    }

    /**
     * Gets the space occupied by the axis
     *
     * @return {Object} object with details about size of the axis.
     * @memberof SimpleAxis
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(Object(_helper__WEBPACK_IMPORTED_MODULE_6__["calculateContinousSpace"])(this));
        }
        Object(_helper__WEBPACK_IMPORTED_MODULE_6__["setOffset"])(this);

        return this.logicalSpace();
    }

    /**
     * Returns the value from the domain when given a value from the range.
     * @param {number} value Value from the range.
     * @return {number} Value
     */
    invert (value) {
        return this.scale().invert(value);
    }

    /**
     * Gets the nearest range value from the given range values.
     * @param {number} v1 Start range value
     * @param {number} v2 End range value
     *
     * @return {Array} range values
     */
    getNearestRange (v1, v2) {
        return [v1, v2];
    }

    invertExtent (v1, v2) {
        return [this.invert(v1), this.invert(v2)];
    }

    getMinTickDifference () {
        return this.domain();
    }

    getFormattedTickValues (tickValues) {
        return tickValues;
    }

    /**
     * This method returns the width in pixels for one
     * unit along the axis. It is only applicable to band scale
     * and returns undefined for other scale type.
     *
     * @return {number} the width of one band along band scale axis
     * @memberof SimpleAxis
     */
    getUnitWidth () {
        return 0;
    }

    /**
     * This method returns an object that can be used to
     * reconstruct this instance.
     *
     * @return {Object} the serializable props of axis
     * @memberof SimpleAxis
     */
    serialize () {
        return {
            name: this.name,
            type: this.type,
            range: this.range(),
            config: this.config()
        };
    }

    /**
     * Returns the id of the axis.
     * @return {string} Unique identifier of the axis.
     */
    get id () {
        return this._id;
    }

    /**
     * This method is used to render the axis inside
     * the supplied svg container.
     *
     * @param {SVGElement} svg the svg element in which to render the path
     * @memberof SimpleAxis
     */
    /* istanbul ignore next */render () {
        if (this.mount()) {
            this.setTickConfig();
            Object(_axis_renderer__WEBPACK_IMPORTED_MODULE_4__["renderAxis"])(this);
        }
        return this;
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    remove () {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this.mount()).remove();
        return this;
    }

    /**
     *
     *
     * @memberof SimpleAxis
     */
    unsubscribe () {
        return this;
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    isReverse () {
        const range = this.range();
        return range[0] > range[1];
    }

    /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getPixelToValueRatio () {
        const scale = this.scale();
        const range = scale.range();
        const domain = scale.domain();

        return Math.abs(range[1] - range[0]) / (domain[1] - domain[0]);
    }

     /**
     * Notifies when all animations/transitions of the axis are completed.
     *
     * @public
     * @return {Promise} Returns a promise to notify the animation completion.
     */
    animationDone () {
        return Promise.all(this._animationDonePromises);
    }

    registerAnimationDoneHook () {
        let resolveFn;
        const promise = new Promise((resolve) => {
            resolveFn = resolve;
        });
        this._animationDonePromises.push(promise);

        return () => {
            resolveFn();
        };
    }
}



/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/skip-ticks.js":
/*!*************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/skip-ticks.js ***!
  \*************************************************************/
/*! exports provided: getSkippedTicks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSkippedTicks", function() { return getSkippedTicks; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

// Longest Word for each level based on which tick skipping is decided
const longestWord = {
    month: 'September',
    quarter: 'October',
    halfYearly: 'July',
    year: 9999,
    day: 'September',
    hour: '24 AM',
    mintues: '60:60',
    seconds: ':60',
    week: 'Wed 31'
};

// These are the various levels of ticks that can be shown by Muze.
// Each level is described as how frequently the ticks appear
// The format is as follows:
// [Frequency, Milliseconds, Name of Seconds, Tick Generator, Level Type]
const tickIntervals = [
    [1, 1, 'milliseconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMillisecond"].every(1), 'seconds'],
    [1, durationSecond, 'seconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeSecond"].every(1), 'seconds'],
    [5, 5 * durationSecond, 'five seconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeSecond"].every(5), 'seconds'],
    [10, 10 * durationSecond, 'ten seconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeSecond"].every(10), 'seconds'],
    [15, 15 * durationSecond, 'fifteen seconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeSecond"].every(15), 'seconds'],
    [30, 30 * durationSecond, 'thirty seconds', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeSecond"].every(30), 'seconds'],
    [1, durationMinute, 'minute', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMinute"].every(1), 'minutes'],
    [5, 5 * durationMinute, 'five minutes', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMinute"].every(5), 'minutes'],
    [10, 10 * durationMinute, 'ten minutes', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMinute"].every(10), 'minutes'],
    [15, 15 * durationMinute, 'fifteen minutes', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMinute"].every(15), 'minutes'],
    [30, 30 * durationMinute, 'thirty minutes', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMinute"].every(30), 'minutes'],
    [1, durationHour, 'hour', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeHour"].every(1), 'hour'],
    [3, 3 * durationHour, 'three hours', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeHour"].every(3), 'hour'],
    [6, 6 * durationHour, 'six hours', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeHour"].every(6), 'hour'],
    [12, 12 * durationHour, 'twelve hours', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeHour"].every(12), 'hour'],
    [1, durationDay, 'daily', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeDay"].every(1), 'day'],
    [1, durationWeek, 'weekly', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeWeek"].every(1), 'week'],
    [1, durationMonth, 'monthly', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMonth"].every(1), 'week'],
    [3, 3 * durationMonth, 'quaterly', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMonth"].every(3), 'quarter'],
    [6, 6 * durationMonth, 'half yearly', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeMonth"].every(6), 'halfYearly'],
    [1, durationYear, 'yearly', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(1), 'year'],
    [2, 2 * durationYear, '2 year', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(2), 'year'],
    [3, 3 * durationYear, '3 year', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(3), 'year'],
    [5, 5 * durationYear, '5 year', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(5), 'year'],
    [10, 10 * durationYear, 'decade', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(10), 'year'],
    [100, 100 * durationYear, 'century', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(100), 'year'],
    [1000, 1000 * durationYear, 'millenium', muze_utils__WEBPACK_IMPORTED_MODULE_0__["timeYear"].every(1000), 'year']
];
/**
 * Get the actual tick interval based on the available width, number of ticks
 * and the distance between two ticks
 *
 * @param {Object} context Axis Context
 * @param {number} noOfTicks Number of Ticks based on which interval is calculated
 * @return {number} The width for the tick interval
 */
const getActualTickInterval = (context, noOfTicks) => {
    const minTickDistance = context._minTickDistance;
    const minWidthBetweenTicks = minTickDistance.width;

    const { width } = context.availableSpace();
    const actualTickInterval = Math.floor(((width - (noOfTicks - 1) * (minWidthBetweenTicks)) / noOfTicks));

    return actualTickInterval;
};

/**
 * Get the tick interval based on the current level of ticks. Levels are decided on
 * the number of ticks that are possible to show
 *
 * @param {Object} context Axis Context
 * @param {string} type Type of level (yearly, monthly, etc)
 * @return {number} The width for the tick interval
 */
const getTickIntervalBasedOnCurrentLevel = (context, type) => {
    const labelManager = context._dependencies.labelManager;
    const longestWordType = longestWord[type];
    const measure = labelManager.getOriSize(longestWordType);

    return measure.width;
};

const getTickIntervalFnBasedOnNumberOfTicks = (interval, count, context) => {
    let possibleTickLevelIndex = tickIntervals.length - 1;
    let maxPossibleTicks = 1;
    let tickIntervalLevelInfo = null;

    // Decide possible tick level based on min tick width (with ellipses)
    for (let i = tickIntervals.length - 1; i >= 0; i--) {
        const tickIntervalInfo = tickIntervals[i];
        const numOfPossibleTicks = Math.floor(interval / tickIntervalInfo[1]);
        if (numOfPossibleTicks <= count) {
            possibleTickLevelIndex = i;
            maxPossibleTicks = numOfPossibleTicks;
        }
    }

    tickIntervalLevelInfo = tickIntervals[possibleTickLevelIndex];

    // Get actual tick interval based on the level of ticks generated
    const actualTickInterval = getActualTickInterval(context, maxPossibleTicks);

    // Maximum Possible tick Interval for a particular level based on a pre decided set of values
    const maxTickInterval = getTickIntervalBasedOnCurrentLevel(context, tickIntervalLevelInfo[4]);

    // Display the next level involving tick skipping if current level does not meet the requirement
    // for displaying max tick
    if (actualTickInterval < maxTickInterval && possibleTickLevelIndex < tickIntervals.length - 1) {
        tickIntervalLevelInfo = tickIntervals[possibleTickLevelIndex + 1];
    }
    return tickIntervalLevelInfo[3];
};

const getSkippedTicks = (context, maxPossibleTicks) => {
    let actualNumberOfTicks = maxPossibleTicks;
    const domain = context.domain();
    const minDiff = context._minDiff;
    // Get the interval in ms from the domain
    const millisecondInterval = domain[1] - domain[0];
    // Get number of ticks based on the minimum difference in the data
    const numOfTicksAccordingToMinDiff = Math.floor(millisecondInterval / minDiff);

    // Show ticks according to min diff if possible
    if (maxPossibleTicks >= numOfTicksAccordingToMinDiff) {
        actualNumberOfTicks = numOfTicksAccordingToMinDiff;
    }

    return getTickIntervalFnBasedOnNumberOfTicks(millisecondInterval, actualNumberOfTicks, context);
};


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/space-setter.js":
/*!***************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/space-setter.js ***!
  \***************************************************************/
/*! exports provided: applyTickSkipping, setAxisRange, getAdjustedRange, spaceSetter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTickSkipping", function() { return applyTickSkipping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisRange", function() { return setAxisRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAdjustedRange", function() { return getAdjustedRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceSetter", function() { return spaceSetter; });
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony import */ var _skip_ticks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./skip-ticks */ "./packages/muze-axis/src/cartesian-axis/skip-ticks.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");




const applyTickSkipping = (context) => {
    const minTickDistance = context._minTickDistance;
    const minTickSpace = context._minTickSpace;
    const minWidthBetweenTicks = minTickDistance.width;
    const minTickWidth = minTickSpace.width;

    const { width } = context.availableSpace();

    const maxTicks = Math.floor((width + minWidthBetweenTicks) / (minTickWidth + minWidthBetweenTicks));

    const ticks = context.scale().ticks(Object(_skip_ticks__WEBPACK_IMPORTED_MODULE_1__["getSkippedTicks"])(context, maxTicks));

    context.renderConfig({
        tickValues: ticks
    });
};

const adjustHorizontalRange = (range, diff) => {
    range[0] += diff;
    range[1] -= diff;
    return range;
};

const adjustVerticalRange = (range, diff) => {
    range[0] -= diff;
    range[1] += diff;
    return range;
};

const rangeAdjustmentMap = {
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: adjustHorizontalRange,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: adjustHorizontalRange,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: adjustVerticalRange,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: adjustVerticalRange
};

const setAxisRange = (context, type, rangeBounds, offset) => {
    context.range(rangeBounds);
    offset && context.renderConfig({ [`${type}Offset`]: offset });
};

const getAxisOffset = (timeDiff, range, domain) => {
    const avWidth = Math.abs(range[1] - range[0]);
    const pvr = avWidth / (domain[1] - domain[0]);
    const width = (pvr * timeDiff);
    const bars = avWidth / width;
    const barWidth = avWidth / (bars + 1);
    const diff = avWidth - barWidth * bars;

    return diff / 2;
};

const getAdjustedRange = (minDiff, range, domain, config) => {
    const {
        orientation,
        adjustRange
    } = config;
    const diff = getAxisOffset(minDiff, range, domain);

    if (adjustRange) {
        return rangeAdjustmentMap[orientation](range, diff);
    }
    return range;
};

const spaceSetter = (context, spaceConfig) => {
    let tickInterval;
    let heightForTicks;
    const config = context.config();
    const {
        width: availWidth,
        height: availHeight,
        padding
    } = context.availableSpace();
    const {
        top,
        left,
        bottom,
        right
    } = padding;
    const {
        isOffset
    } = spaceConfig;
    const {
        showAxisName,
        labels
    } = context.renderConfig();
    const {
        rotation
    } = labels;
    const {
        fixedBaseline,
        axisNamePadding,
        tickValues
    } = config;
    const {
        tickDimensions,
        allTickDimensions,
        axisNameDimensions,
        tickSize
    } = context.getAxisDimensions();
    const {
        height: tickDimHeight,
        width: tickDimWidth
    } = tickDimensions;

    const namePadding = showAxisName ? axisNamePadding : 0;
    const labelConfig = { smartTicks: true, rotation: labels.rotation };
    const minTickDistance = context._minTickDistance;
    const minTickSpace = context._minTickSpace;
    const minDiff = context._minDiff;
    const domain = context.domain();
    const axisNameHeight = axisNameDimensions.height;
    const minWidthBetweenTicks = minTickDistance.width;
    const minTickWidth = Math.min(minTickSpace.width, tickDimWidth);
    const minTickHeight = Math.min(minTickSpace.height, tickDimHeight);

    return {
        [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["TIME"]]: {
            x: () => {
                !tickValues && context.applyTickSkipping();
                const noOfTicks = context.getTickValues().length;

                // Get the Tick Interval
                tickInterval = ((availWidth - (noOfTicks - 1) * (minWidthBetweenTicks)) / noOfTicks);

                // Get height for ticks
                heightForTicks = availHeight - axisNameHeight - tickSize - namePadding;

                if (tickInterval < minTickWidth && rotation !== 0) {
                    // set smart ticks and rotation config
                    labelConfig.rotation = rotation;
                    // Remove ticks if not enough height
                    if (tickInterval < minTickHeight) {
                        heightForTicks = availHeight;
                        tickInterval = minTickHeight;
                        context.renderConfig({ showInnerTicks: false, showOuterTicks: false });
                    }
                }
                if (availHeight < axisNameHeight) {
                    context.renderConfig({ show: false });
                }

                const tickShifter = Math.min(tickInterval, tickDimWidth);
                // set range for axis
                setAxisRange(context, 'y', getAdjustedRange(minDiff, [tickShifter / 2,
                    availWidth - left - right - tickShifter / 2], domain, config),
                        isOffset ? availHeight : null);

                context.maxTickSpaces({
                    width: tickInterval,
                    height: heightForTicks,
                    noWrap: rotation !== null
                });

                return labelConfig;
            },
            y: () => {
                let widthForTicks = availWidth;
                const tickShifter = tickDimHeight / 2;

                setAxisRange(context, 'x', getAdjustedRange(minDiff,
                    [availHeight - top - bottom - tickShifter, tickShifter], domain, config),
                        isOffset ? availWidth : null);

                if ((availWidth - axisNameHeight - namePadding) <= minWidthBetweenTicks) {
                    widthForTicks = 0;
                    context.renderConfig({ showInnerTicks: false, showOuterTicks: false });
                }

                context.maxTickSpaces({
                    width: widthForTicks,
                    height: availHeight,
                    noWrap: true
                });
                if (availWidth < axisNameHeight) {
                    context.renderConfig({ show: false });
                }
                return labelConfig;
            }
        },
        [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["BAND"]]: {
            x: () => {
                setAxisRange(context, 'y', [0, availWidth - left - right], isOffset ? availHeight : null);
                const range = context.range();

                // Get Tick Interval
                tickInterval = ((range[1] - range[0]) / (tickValues || domain).length) - minWidthBetweenTicks;

                // Get height available for ticks
                heightForTicks = availHeight - axisNameHeight - tickSize - namePadding;

                if (tickInterval < minTickWidth && rotation !== 0) {
                    // set smart ticks and rotation config
                    labelConfig.rotation = rotation === null ? -90 : rotation;
                    labelConfig.smartTicks = false;

                    tickInterval = Math.max(heightForTicks, minTickWidth);

                    if (heightForTicks < minTickWidth) {
                        context.renderConfig({ showAxisName: false });
                    }
                } else if (tickValues) {
                    const interval = (availWidth / domain.length) - minWidthBetweenTicks;
                    if (interval < minTickWidth) {
                        context.range([minTickHeight / 2, availWidth - minTickHeight / 2]);
                    }
                }
                if (availHeight < axisNameHeight) {
                    context.renderConfig({ show: false });
                }

                context.maxTickSpaces({
                    width: tickInterval,
                    height: heightForTicks,
                    noWrap: rotation !== null
                });
                return labelConfig;
            },
            y: () => {
                setAxisRange(context, 'x', [availHeight - bottom, top], isOffset ? availWidth : null);

                let widthForTicks = availWidth - axisNameHeight - tickSize - namePadding;
                if (widthForTicks <= minWidthBetweenTicks) {
                    widthForTicks = 0;
                    context.renderConfig({ showInnerTicks: false, showOuterTicks: false });
                }

                context.maxTickSpaces({
                    width: widthForTicks,
                    height: availHeight,
                    noWrap: true
                });
                if (availWidth < axisNameHeight) {
                    context.renderConfig({ show: false });
                }
                return labelConfig;
            }
        },
        [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LINEAR"]]: {
            x: () => {
                labelConfig.smartTicks = false;
                const tickShifter = tickDimWidth / 2;

                const baseline = fixedBaseline ? 0 : tickShifter;

                setAxisRange(context, 'y', [baseline + left, availWidth - right - tickShifter],
                    isOffset ? availHeight : null);

                const range = context.range();

                // Get Tick widths and available space
                const totalTickWidth = allTickDimensions.length * (tickDimWidth + minWidthBetweenTicks);
                const availableWidth = range[1] - range[0];

                 // Rotate labels if not enough width
                if (availableWidth < totalTickWidth && labels.rotation !== null) {
                    if (availHeight - tickDimWidth - namePadding - tickSize > axisNameHeight) {
                        labelConfig.rotation = null;
                        context.renderConfig({
                            showInnerTicks: true,
                            showAxisName: true
                        });
                    } else {
                        labelConfig.rotation = -90;
                        context.renderConfig({
                            showInnerTicks: true,
                            showAxisName: false

                        });
                    }
                }

                if (availHeight < axisNameHeight) {
                    context.renderConfig({ show: false });
                }
                return labelConfig;
            },
            y: () => {
                labelConfig.smartTicks = false;
                const tickShifter = tickDimensions.height / 2;
                const baseline = fixedBaseline ? 1 : tickShifter;

                setAxisRange(context, 'x', [availHeight - bottom - baseline, tickShifter + top],
                    isOffset ? availWidth : null);

                // Remove display of ticks if no space is left
                if (availWidth < tickDimWidth + axisNameHeight + namePadding) {
                    context.renderConfig({ showInnerTicks: false });
                    if (availWidth < axisNameHeight) {
                        context.renderConfig({ show: false });
                    }
                }
                return labelConfig;
            }
        }
    };
};


/***/ }),

/***/ "./packages/muze-axis/src/cartesian-axis/time-axis.js":
/*!************************************************************!*\
  !*** ./packages/muze-axis/src/cartesian-axis/time-axis.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-axis */ "./packages/muze-axis/src/cartesian-axis/simple-axis.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/cartesian-axis/helper.js");
/* harmony import */ var _space_setter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./space-setter */ "./packages/muze-axis/src/cartesian-axis/space-setter.js");






/**
 *
 *
 * @export
 * @class TimeAxis
 * @extends {SimpleAxis}
 */
class TimeAxis extends _simple_axis__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor (...params) {
        super(...params);
        this._minDiff = Infinity;
    }

    /**
     *
     *
     * @param {*} range
     *
     * @memberof TimeAxis
     */
    createScale (range) {
        let scale = super.createScale(range);

        scale = scale.nice();
        return scale;
    }

    /**
     *
     *
     * @static
     *
     * @memberof TimeAxis
     */
    static type () {
        return _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["TIME"];
    }

    formatTickValue (val) {
        return this.scale().tickFormat()(val);
    }

    sanitizeTickFormatter (value) {
        const { tickFormat } = value;

        if (tickFormat) {
            return (ticks) => {
                const rawTicks = ticks.map(t => t.getTime());
                return (val, i) => tickFormat(this.formatTickValue(val), val.getTime(), i, rawTicks);
            };
        }
        return () => val => this.formatTickValue(val);
    }

     /**
     *
     *
     *
     * @memberof SimpleAxis
     */
    getTickSize () {
        const {
            showInnerTicks,
            showOuterTicks
        } = this.renderConfig();
        const axis = this.axis();
        axis.tickSizeInner(showInnerTicks === false ? 0 : 6);
        axis.tickSizeOuter(showOuterTicks === false ? 0 : 6);
        return super.getTickSize();
    }

    /**
     *
     *
     *
     * @memberof TimeAxis
     */
    getTickValues () {
        return this.renderConfig().tickValues || this.scale().ticks();
    }

    /**
     *
     *
     * @param {*} diff
     *
     * @memberof TimeAxis
     */
    minDiff (diff) {
        this._minDiff = Math.min(this._minDiff, diff);
        return this;
    }

    applyTickSkipping () {
        Object(_space_setter__WEBPACK_IMPORTED_MODULE_4__["applyTickSkipping"])(this);
    }

    /**
     *
     *
     * @param {*} d
     *
     * @memberof SimpleAxis
     */
    domain (...domain) {
        if (domain.length) {
            const domainValue = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getValidDomain"])(this, domain[0]);
            Object(_helper__WEBPACK_IMPORTED_MODULE_3__["setContinousAxisDomain"])(this, domainValue);
            this.setAxisComponentDimensions();
            this.logicalSpace(null);

            Object(_helper__WEBPACK_IMPORTED_MODULE_3__["resetTickInterval"])(this, domainValue);
            return this;
        }
        return this._domain;
    }

    /**
     * Gets the space occupied by the axis
     *
     * @return {Object} object with details about size of the axis.
     * @memberof SimpleAxis
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(Object(_helper__WEBPACK_IMPORTED_MODULE_3__["calculateBandSpace"])(this));
        }
        Object(_helper__WEBPACK_IMPORTED_MODULE_3__["setOffset"])(this);

        return this.logicalSpace();
    }

    getMinTickDifference () {
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmallestDiff"])(this.config().tickValues);
    }

    /**
     * This method is used to set the space availiable to render
     * the SimpleCell.
     *
     * @param {number} width The width of SimpleCell.
     * @param {number} height The height of SimpleCell.
     * @memberof AxisCell
     */
    setAvailableSpace (...params) {
        super.setAvailableSpace(...params);
        this.getTickSize();
        return this;
    }

    /**
     *
     *
     * @returns
     * @memberof BandAxis
     */
    setTickConfig () {
        let smartTicks;
        let smartlabel;

        const { labels, tickValues } = this.renderConfig();
        const { height: availHeight, width: availWidth, noWrap } = this.maxTickSpaces();
        const { labelManager } = this._dependencies;
        const domain = this.getTickValues();

        tickValues && this.axis().tickValues(tickValues);

        const { width, height } = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getRotatedSpaces"])(labels.rotation, availWidth, availHeight);

        smartTicks = tickValues || domain;

        // set the style on the shared label manager instance
        labelManager.setStyle(this._tickLabelStyle);

        if (domain && domain.length) {
            const values = tickValues || domain;
            const tickFormatter = this._tickFormatter(values);
            smartTicks = values.map((d, i) => {
                labelManager.useEllipsesOnOverflow(true);

                smartlabel = labelManager.getSmartText(tickFormatter(d, i), width, height, noWrap);
                return labelManager.constructor.textToLines(smartlabel);
            });
        }

        this.smartTicks(smartTicks);
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/color-axis/color-axis.js":
/*!*********************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/color-axis.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _color_strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color-strategy */ "./packages/muze-axis/src/color-axis/color-strategy.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults */ "./packages/muze-axis/src/color-axis/defaults.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/color-axis/props.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */







/**
* This class is used to instantiate a SimpleAxis.
* @class SimpleAxis
*/
class ColorAxis {

    /**
    * Creates an instance of SimpleAxis.
    * @param {Object} config input parameters.
    * @param {Object | undefined} params.range Type of color range.
    * @param {string} params.name the label to show on axis.
    * @param {string} params.type The type of scale to handle.
    * @memberof ColorAxis
    */
    constructor (config) {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_5__["PROPS"]);
        this.config(config);

        this._domainType = this._config.type === 'linear' ? _enums_constants__WEBPACK_IMPORTED_MODULE_2__["CONTINOUS"] : _enums_constants__WEBPACK_IMPORTED_MODULE_2__["DISCRETE"];
        this._rangeType = (this._config.type === 'linear' && !this._config.step) ? _enums_constants__WEBPACK_IMPORTED_MODULE_2__["CONTINOUS"] : _enums_constants__WEBPACK_IMPORTED_MODULE_2__["DISCRETE"];

        this._schemeType = Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["getSchemeType"])(this._config.range);

        this._colorStrategy = this.setColorStrategy(this._domainType, this._rangeType, this._schemeType);
        this._scale = this.createScale(this._colorStrategy);

        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();

        this.updateDomain(config.domain);
    }

    /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static defaultConfig () {
        return _defaults__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_CONFIG"];
    }

    /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_2__["COLOR"];
    }

    /**
     *
     *
     * @param {*} colorStrategy
     *
     * @memberof ColorAxis
     */
    createScale (colorStrategy) {
        const { range } = this.config();
        if (range && typeof (range) === 'string') {
            return Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["getScheme"])(range);
        }
        return Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            type: colorStrategy.scale,
            range
        });
    }

    /**
     *
     *
     * @param {*} domainType
     * @param {*} rangeType
     * @param {*} schemeType
     *
     * @memberof ColorAxis
     */
    setColorStrategy (domainType, rangeType, schemeType) {
        return Object(_color_strategy__WEBPACK_IMPORTED_MODULE_3__["strategyGetter"])(domainType, rangeType, schemeType);
    }

    /**
     *
     *
     * @param {*} domainVal
     *
     * @memberof ColorAxis
     */
    getHslString (hslColorArray) {
        return Object(_props__WEBPACK_IMPORTED_MODULE_5__["getHslString"])(hslColorArray);
    }
    /**
     *
     *
     * @param {*} domainVal
     *
     * @memberof ColorAxis
     */
    getColor (domainVal) {
        return this.getHslString(this.getRawColor(domainVal));
    }
    /**
     *
     *
     * @param {*} domainVal
     *
     * @memberof ColorAxis
     */
    getRawColor (domainVal) {
        if (this.domain() && domainVal !== undefined) {
            const scale = this.scale();
            const range = scale.range ? scale.range() : null;
            const color = this._colorStrategy.value(range)(domainVal, scale, this.domain(), this.uniqueValues());
            if (color) {
                if (typeof color === 'string') {
                    const col = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(/,\s*/);
                    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["rgbToHsv"])(...col);
                }
                return [...color];
            }
        }
        return [...this.config().value];
    }

    /**
     *
     *
     * @param {*} [domain=[]]
     *
     * @memberof ColorAxis
     */
    updateDomain (domain = []) {
        if (domain.length) {
            const scale = this.scale();
            const range = scale.range ? scale.range() : null;
            const domainRangeFn = this._colorStrategy.domainRange();
            const scaleInfo = domainRangeFn(domain, this.config().stops, range);

            this.domain(scaleInfo.domain);
            scaleInfo.range && this.scale().range(scaleInfo.range);
            this.uniqueValues(scaleInfo.uniqueVals);
            this.scale().domain(scaleInfo.scaleDomain || this.domain());
        }
        return this;
    }

    /**
     * This method returns an object that can be used to
     * reconstruct this instance.
     *
     * @return {Object} the serializable props of axis
     * @memberof ShapeAxis
     */
    serialize () {
        return {
            type: this.constructor.type(),
            scale: this.scale(),
            domain: this.domain(),
            config: this.config()
        };
    }

    transformColor (color, transformationArr) {
        const h = color[0] * 360;
        const s = color[1] * 100;
        const l = color[2] * 100;
        const a = Math.min(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(color[3], 0), 1);
        const newH = h + transformationArr[0];
        const newS = s + transformationArr[1];
        const newL = l + transformationArr[2];
        const newA = Math.min(a + transformationArr[3] || 0, 1);

        return { color: `hsla(${newH},${newS}%,${newL}%,${newA})`, hsla: [newH / 360, newS / 100, newL / 100, newA] };
    }

    /**
     * Returns the id of the axis.
     * @return {string} Unique identifier of the axis.
     */
    id () {
        return this._id;
    }

    getHslArray (color) {
        return Object(_props__WEBPACK_IMPORTED_MODULE_5__["getActualHslColor"])(color);
    }

}


/***/ }),

/***/ "./packages/muze-axis/src/color-axis/color-maps.js":
/*!*********************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/color-maps.js ***!
  \*********************************************************/
/*! exports provided: x11Colors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x11Colors", function() { return x11Colors; });
const x11Colors = {
    Pink: { hex: 'ffc0cb', rgb: '255,192,203' },
    LightPink: { hex: 'ffb6c1', rgb: '255,182,193' },
    HotPink: { hex: 'ff69b4', rgb: '255,105,180' },
    DeepPink: { hex: 'ff1493', rgb: '255,20,147' },
    PaleVioletRed: { hex: 'db7093', rgb: '219,112,147' },
    MediumVioletRed: { hex: 'c71585', rgb: '199,21,133' },
    LightSalmon: { hex: 'ffa07a', rgb: '255,160,122' },
    Salmon: { hex: 'fa8072', rgb: '250,128,114' },
    DarkSalmon: { hex: 'e9967a', rgb: '233,150,122' },
    LightCoral: { hex: 'f08080', rgb: '240,128,128' },
    IndianRed: { hex: 'cd5c5c', rgb: '205,92,92' },
    Crimson: { hex: 'dc143c', rgb: '220,20,60' },
    FireBrick: { hex: 'b22222', rgb: '178,34,34' },
    DarkRed: { hex: '8b0000', rgb: '139,0,0' },
    Red: { hex: 'ff0000', rgb: '255,0,0' },
    OrangeRed: { hex: 'ff4500', rgb: '255,69,0' },
    Tomato: { hex: 'ff6347', rgb: '255,99,71' },
    Coral: { hex: 'ff7f50', rgb: '255,127,80' },
    DarkOrange: { hex: 'ff8c00', rgb: '255,140,0' },
    Orange: { hex: 'ffa500', rgb: '255,165,0' },
    Gold: { hex: 'ffd700', rgb: '255,215,0' },
    Yellow: { hex: 'ffff00', rgb: '255,255,0' },
    LightYellow: { hex: 'ffffe0', rgb: '255,255,224' },
    LemonChiffon: { hex: 'fffacd', rgb: '255,250,205' },
    LightGoldenrodYellow: { hex: 'fafad2', rgb: '250,250,210' },
    PapayaWhip: { hex: 'ffefd5', rgb: '255,239,213' },
    Moccasin: { hex: 'ffe4b5', rgb: '255,228,181' },
    PeachPuff: { hex: 'ffdab9', rgb: '255,218,185' },
    PaleGoldenrod: { hex: 'eee8aa', rgb: '238,232,170' },
    Khaki: { hex: 'f0e68c', rgb: '240,230,140' },
    DarkKhaki: { hex: 'bdb76b', rgb: '189,183,107' },
    Cornsilk: { hex: 'fff8dc', rgb: '255,248,220' },
    BlanchedAlmond: { hex: 'ffebcd', rgb: '255,235,205' },
    Bisque: { hex: 'ffe4c4', rgb: '255,228,196' },
    NavajoWhite: { hex: 'ffdead', rgb: '255,222,173' },
    Wheat: { hex: 'f5deb3', rgb: '245,222,179' },
    BurlyWood: { hex: 'deb887', rgb: '222,184,135' },
    Tan: { hex: 'd2b48c', rgb: '210,180,140' },
    RosyBrown: { hex: 'bc8f8f', rgb: '188,143,143' },
    SandyBrown: { hex: 'f4a460', rgb: '244,164,96' },
    Goldenrod: { hex: 'daa520', rgb: '218,165,32' },
    DarkGoldenrod: { hex: 'b8860b', rgb: '184,134,11' },
    Peru: { hex: 'cd853f', rgb: '205,133,63' },
    Chocolate: { hex: 'd2691e', rgb: '210,105,30' },
    SaddleBrown: { hex: '8b4513', rgb: '139,69,19' },
    Sienna: { hex: 'a0522d', rgb: '160,82,45' },
    Brown: { hex: 'a52a2a', rgb: '165,42,42' },
    Maroon: { hex: '800000', rgb: '128,0,0' },
    DarkOliveGreen: { hex: '556b2f', rgb: '85,107,47' },
    Olive: { hex: '808000', rgb: '128,128,0' },
    OliveDrab: { hex: '6b8e23', rgb: '107,142,35' },
    YellowGreen: { hex: '9acd32', rgb: '154,205,50' },
    LimeGreen: { hex: '32cd32', rgb: '50,205,50' },
    Lime: { hex: '00ff00', rgb: '0,255,0' },
    LawnGreen: { hex: '7cfc00', rgb: '124,252,0' },
    Chartreuse: { hex: '7fff00', rgb: '127,255,0' },
    GreenYellow: { hex: 'adff2f', rgb: '173,255,47' },
    SpringGreen: { hex: '00ff7f', rgb: '0,255,127' },
    MediumSpringGreen: { hex: '00fa9a', rgb: '0,250,154' },
    LightGreen: { hex: '90ee90', rgb: '144,238,144' },
    PaleGreen: { hex: '98fb98', rgb: '152,251,152' },
    DarkSeaGreen: { hex: '8fbc8f', rgb: '143,188,143' },
    MediumSeaGreen: { hex: '3cb371', rgb: '60,179,113' },
    SeaGreen: { hex: '2e8b57', rgb: '46,139,87' },
    ForestGreen: { hex: '228b22', rgb: '34,139,34' },
    Green: { hex: '008000', rgb: '0,128,0' },
    DarkGreen: { hex: '006400', rgb: '0,100,0' },
    MediumAquamarine: { hex: '66cdaa', rgb: '102,205,170' },
    Aqua: { hex: '00ffff', rgb: '0,255,255' },
    Cyan: { hex: '00ffff', rgb: '0,255,255' },
    LightCyan: { hex: 'e0ffff', rgb: '224,255,255' },
    PaleTurquoise: { hex: 'afeeee', rgb: '175,238,238' },
    Aquamarine: { hex: '7fffd4', rgb: '127,255,212' },
    Turquoise: { hex: '40e0d0', rgb: '64,224,208' },
    MediumTurquoise: { hex: '48d1cc', rgb: '72,209,204' },
    DarkTurquoise: { hex: '00ced1', rgb: '0,206,209' },
    LightSeaGreen: { hex: '20b2aa', rgb: '32,178,170' },
    CadetBlue: { hex: '5f9ea0', rgb: '95,158,160' },
    DarkCyan: { hex: '008b8b', rgb: '0,139,139' },
    Teal: { hex: '008080', rgb: '0,128,128' },
    LightSteelBlue: { hex: 'b0c4de', rgb: '176,196,222' },
    PowderBlue: { hex: 'b0e0e6', rgb: '176,224,230' },
    LightBlue: { hex: 'add8e6', rgb: '173,216,230' },
    SkyBlue: { hex: '87ceeb', rgb: '135,206,235' },
    LightSkyBlue: { hex: '87cefa', rgb: '135,206,250' },
    DeepSkyBlue: { hex: '00bfff', rgb: '0,191,255' },
    DodgerBlue: { hex: '1e90ff', rgb: '30,144,255' },
    CornflowerBlue: { hex: '6495ed', rgb: '100,149,237' },
    SteelBlue: { hex: '4682b4', rgb: '70,130,180' },
    RoyalBlue: { hex: '4169e1', rgb: '65,105,225' },
    Blue: { hex: '0000ff', rgb: '0,0,255' },
    MediumBlue: { hex: '0000cd', rgb: '0,0,205' },
    DarkBlue: { hex: '00008b', rgb: '0,0,139' },
    Navy: { hex: '000080', rgb: '0,0,128' },
    MidnightBlue: { hex: '191970', rgb: '25,25,112' },
    Lavender: { hex: 'e6e6fa', rgb: '230,230,250' },
    Thistle: { hex: 'd8bfd8', rgb: '216,191,216' },
    Plum: { hex: 'dda0dd', rgb: '221,160,221' },
    Violet: { hex: 'ee82ee', rgb: '238,130,238' },
    Orchid: { hex: 'da70d6', rgb: '218,112,214' },
    Fuchsia: { hex: 'ff00ff', rgb: '255,0,255' },
    Magenta: { hex: 'ff00ff', rgb: '255,0,255' },
    MediumOrchid: { hex: 'ba55d3', rgb: '186,85,211' },
    MediumPurple: { hex: '9370db', rgb: '147,112,219' },
    BlueViolet: { hex: '8a2be2', rgb: '138,43,226' },
    DarkViolet: { hex: '9400d3', rgb: '148,0,211' },
    DarkOrchid: { hex: '9932cc', rgb: '153,50,204' },
    DarkMagenta: { hex: '8b008b', rgb: '139,0,139' },
    Purple: { hex: '800080', rgb: '128,0,128' },
    Indigo: { hex: '4b0082', rgb: '75,0,130' },
    DarkSlateBlue: { hex: '483d8b', rgb: '72,61,139' },
    SlateBlue: { hex: '6a5acd', rgb: '106,90,205' },
    MediumSlateBlue: { hex: '7b68ee', rgb: '123,104,238' },
    White: { hex: 'ffffff', rgb: '255,255,255' },
    Snow: { hex: 'fffafa', rgb: '255,250,250' },
    Honeydew: { hex: 'f0fff0', rgb: '240,255,240' },
    MintCream: { hex: 'f5fffa', rgb: '245,255,250' },
    Azure: { hex: 'f0ffff', rgb: '240,255,255' },
    AliceBlue: { hex: 'f0f8ff', rgb: '240,248,255' },
    GhostWhite: { hex: 'f8f8ff', rgb: '248,248,255' },
    WhiteSmoke: { hex: 'f5f5f5', rgb: '245,245,245' },
    Seashell: { hex: 'fff5ee', rgb: '255,245,238' },
    Beige: { hex: 'f5f5dc', rgb: '245,245,220' },
    OldLace: { hex: 'fdf5e6', rgb: '253,245,230' },
    FloralWhite: { hex: 'fffaf0', rgb: '255,250,240' },
    Ivory: { hex: 'fffff0', rgb: '255,255,240' },
    AntiqueWhite: { hex: 'faebd7', rgb: '250,235,215' },
    Linen: { hex: 'faf0e6', rgb: '250,240,230' },
    LavenderBlush: { hex: 'fff0f5', rgb: '255,240,245' },
    MistyRose: { hex: 'ffe4e1', rgb: '255,228,225' },
    Gainsboro: { hex: 'dcdcdc', rgb: '220,220,220' },
    LightGray: { hex: 'd3d3d3', rgb: '211,211,211' },
    Silver: { hex: 'c0c0c0', rgb: '192,192,192' },
    DarkGrey: { hex: 'a9a9a9', rgb: '169,169,169' },
    Grey: { hex: '808080', rgb: '128,128,128' },
    DimGrey: { hex: '696969', rgb: '105,105,105' },
    LightSlateGrey: { hex: '778899', rgb: '119,136,153' },
    SlateGrey: { hex: '708090', rgb: '112,128,144' },
    DarkSlateGrey: { hex: '2f4f4f', rgb: '47,79,79' },
    Black: { hex: '000000', rgb: '0,0,0' }
};


/***/ }),

/***/ "./packages/muze-axis/src/color-axis/color-strategy.js":
/*!*************************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/color-strategy.js ***!
  \*************************************************************/
/*! exports provided: strategyGetter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strategyGetter", function() { return strategyGetter; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/color-axis/props.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper */ "./packages/muze-axis/src/helper.js");






const getStops = (domain, stops) => {
    let newStops = [];

    if (stops instanceof Array) {
        newStops = stops.slice().sort();
        newStops = [...new Set([domain[0], ...stops, domain[1]])].sort();
    } else {
        const interpolator = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["numberInterpolator"])()(...domain);
        for (let i = 0; i <= stops; i++) {
            newStops[i] = interpolator(i / stops);
        }
    }

    if (newStops[0] < domain[0]) {
        newStops.shift();
    }
    return { domain, newStops };
};

const rangeStops = (newStopsLength, range) => {
    let newRange = [];
    const maxRangeLength = Math.min(range.length, 18);

    if (newStopsLength > maxRangeLength) {
        const interpolator = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["piecewiseInterpolator"])()(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["hslInterpolator"])(), range.map(e => Object(_props__WEBPACK_IMPORTED_MODULE_3__["getHslString"])(e)));
        for (let i = 0; i < newStopsLength; i++) {
            newRange[i] = interpolator(i / (newStopsLength - 1));
        }
    } else {
        newRange = range.slice(0, newStopsLength);
    }
    return { newRange };
};

/**
*
*
* @param {*} domain
*
*/
const indexedDomain = (domain) => {
    const uniqueVals = domain;
    const retDomain = domain.map((d, i) => (i) / (domain.length - 1));
    return { domain: retDomain, uniqueVals, scaleDomain: [0, 1] };
};

/**
 *
 *
 * @param {*} domain
 *
 */
const indexedDomainMeasure = (domain, stops, range) => {
    const uniqueVals = domain;
    return { domain, uniqueVals, scaleDomain: [0, 1], range };
};

/**
 *
 *
 * @param {*} domain
 *
 */
const normalDomain = (domain, stops, range) => {
    const uniqueVals = domain;
    return { uniqueVals, domain, nice: true, range };
};

/**
 *
 *
 * @param {*} domain
 * @param {*} stops
 *
 */
const steppedDomain = (domain, stops, range) => {
    const { domain: uniqueVals, newStops } = getStops(domain, stops);
    const { newRange } = rangeStops(newStops.length - 1, range);

    return { uniqueVals, domain: newStops, nice: true, range: newRange };
};

const continousSteppedDomain = (domain, stops, range) => {
    const { domain: uniqueVals, newStops } = getStops(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["sanitizeDomainWhenEqual"])(domain), range.length - 1);
    const hslRange = range.map(e => Object(_props__WEBPACK_IMPORTED_MODULE_3__["getHslString"])(e));
    return { uniqueVals, domain: newStops, nice: true, range: hslRange };
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 * @param {*} domain
 * @param {*} uniqueVals
 *
 */
const uniqueRange = (domainValue, scale, domain, uniqueVals) => {
    const index = uniqueVals.indexOf(domainValue);
    const numVal = domain[index];
    return scale(numVal);
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 * @param {*} domain
 *
 */
const indexedRange = (domainValue, scale, domain) => {
    const numVal = (domainValue - domain[0]) / (domain[domain.length - 1] - domain[0]);

    return Object(_helper__WEBPACK_IMPORTED_MODULE_4__["treatNullMeasures"])(domainValue, scale(numVal), scale(0));
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 */
const normalRange = (domainValue, scale, domain) => Object(_helper__WEBPACK_IMPORTED_MODULE_4__["treatNullMeasures"])(domainValue, scale(domainValue),
    scale(domain[0]));

/**
 *
 *
 * @param {*} stops
 */
const strategies = () => ({
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"],
        domainRange: () => indexedDomainMeasure,
        value: () => indexedRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"],
        domainRange: () => indexedDomainMeasure,
        value: () => indexedRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"],
        domainRange: () => indexedDomain,
        value: () => uniqueRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["ORDINAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["ORDINAL"],
        domainRange: () => normalDomain,
        value: () => normalRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["ORDINAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LINEAR"],
        domainRange: () => continousSteppedDomain,
        value: () => normalRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["ORDINAL"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["QUANTILE"],
        domainRange: () => steppedDomain,
        value: () => normalRange

    }
});

/**
 *
 *
 * @param {*} domainType
 * @param {*} rangeType
 * @param {*} schemeType
 * @param {*} stops
 */
const strategyGetter = (domainType, rangeType, schemeType) =>
    strategies()[`${domainType}-${rangeType}-${schemeType || ''}`];


/***/ }),

/***/ "./packages/muze-axis/src/color-axis/defaults.js":
/*!*******************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/defaults.js ***!
  \*******************************************************/
/*! exports provided: palette, DEFAULT_GRADIENT_COLOR, DEFAULT_CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "palette", function() { return palette; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_GRADIENT_COLOR", function() { return DEFAULT_GRADIENT_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");

/**
 * Set of default colors
 */
const palette = [
    '#086bb6',
    '#f37d45',
    '#f5ce02',
    '#67bda0',
    '#c54e4e',
    '#ae70af'
];

const DEFAULT_GRADIENT_COLOR = '#eaeaea';

const DEFAULT_CONFIG = {
    range: palette,
    value: palette[0],
    step: false,
    stops: 5,
    type: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["LINEAR"]
};


/***/ }),

/***/ "./packages/muze-axis/src/color-axis/index.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/index.js ***!
  \****************************************************/
/*! exports provided: ColorAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color-axis */ "./packages/muze-axis/src/color-axis/color-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAxis", function() { return _color_axis__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-axis/src/color-axis/props.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/color-axis/props.js ***!
  \****************************************************/
/*! exports provided: getHslString, convertToXllString, getActualHslColor, PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHslString", function() { return getHslString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToXllString", function() { return convertToXllString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActualHslColor", function() { return getActualHslColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _color_maps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color-maps */ "./packages/muze-axis/src/color-axis/color-maps.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/muze-axis/src/color-axis/defaults.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");





const getHslString = hslArr => `hsla(${hslArr[0] * 360},${hslArr[1] * 100}%,${hslArr[2] * 100}%,\
${hslArr[3] || 1})`;

const convertToXllString = baseString => (baseString.split(' ') || [])
                .reduce((x, e) => `${x}${e.charAt(0).toUpperCase()}${e.slice(1)}`, '');

const getActualHslColor = (e, paletteColor) => {
    let color = '';
    if (typeof e === 'string') {
        e = e.replace(/ /g, '');
        e = e.toLowerCase();
        if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["detectColor"])(e) === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["HSL"] || Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["detectColor"])(e) === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["HSLA"]) {
            color = e.match(/(\d+(\.\d+)?)/g);
            color = [color[0] / 360, color[1] / 100, color[2] / 100, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(Number(color[3]), 1)];
        } else if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["detectColor"])(e) === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEX"]) {
            color = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["hexToHsv"])(e);
        } else if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["detectColor"])(e) === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RGB"]) {
            const col = e.substring(e.indexOf('(') + 1, e.lastIndexOf(')')).split(/,\s*/);
            color = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["rgbToHsv"])(...col);
        } else if (_color_maps__WEBPACK_IMPORTED_MODULE_1__["x11Colors"][convertToXllString(e)]) {
            color = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["rgbToHsv"])(..._color_maps__WEBPACK_IMPORTED_MODULE_1__["x11Colors"][convertToXllString(e)].rgb.split(','));
        }
    } else if (!(e instanceof Array)) {
        color = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["rgbToHsv"])(paletteColor);
    } else {
        color = e;
    }
    return color;
};

const PROPS = {
    config: {
        sanitization: (context, config) => {
            const defCon = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, context.constructor.defaultConfig());
            if (config.type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["LINEAR"]) {
                config.range = config.range || [defCon.range[0]];
                config.range = config.range.length > 1 ? config.range : [_defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_GRADIENT_COLOR"], ...config.range];
            }
            const oldConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defCon, context.config());
            const newConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(oldConfig, config);

            if (newConfig.range instanceof Array) {
                newConfig.range = newConfig.range.map((e, i) => getActualHslColor(e, _defaults__WEBPACK_IMPORTED_MODULE_2__["palette"][i]));
                newConfig.stops = config.stops || newConfig.range.length;
            }
            newConfig.value = getActualHslColor(newConfig.value, newConfig.value);
            return newConfig;
        }
    },
    domain: {},
    scale: {},
    uniqueValues: {}
};


/***/ }),

/***/ "./packages/muze-axis/src/data-type-scale-map.js":
/*!*******************************************************!*\
  !*** ./packages/muze-axis/src/data-type-scale-map.js ***!
  \*******************************************************/
/*! exports provided: dataTypeScaleMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataTypeScaleMap", function() { return dataTypeScaleMap; });
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");


const DATA_TYPES = {
    DIMENSION: 'dimension',
    CATEGORICAL: 'categorical',
    MEASURE: 'measure',
    TEMPORAL: 'temporal'
};

/**
 * Map of DataModel types to associated field types.
 */
const dataTypeScaleMap = {
    [DATA_TYPES.DIMENSION]: _enums_scale_type__WEBPACK_IMPORTED_MODULE_0__["BAND"],
    [DATA_TYPES.MEASURE]: _enums_scale_type__WEBPACK_IMPORTED_MODULE_0__["LINEAR"],
    [DATA_TYPES.TEMPORAL]: _enums_scale_type__WEBPACK_IMPORTED_MODULE_0__["TIME"]
};



/***/ }),

/***/ "./packages/muze-axis/src/enums/axis-orientation.js":
/*!**********************************************************!*\
  !*** ./packages/muze-axis/src/enums/axis-orientation.js ***!
  \**********************************************************/
/*! exports provided: BOTTOM, TOP, LEFT, RIGHT, axisOrientationMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisOrientationMap", function() { return axisOrientationMap; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */



/**
 * @module Axis
 * This file exports constants that are used to reference axis orientations
 * in a consistent manner.
 */
const BOTTOM = 'bottom';
const TOP = 'top';
const LEFT = 'left';
const RIGHT = 'right';

/**
  * This object is used to associate the axis orientation with the d3 class
  * used to represent that axis.
  */
const axisOrientationMap = {
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["LEFT"]]: muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].axisLeft,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]]: muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].axisBottom,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["RIGHT"]]: muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].axisRight,
    [_enums_axis_orientation__WEBPACK_IMPORTED_MODULE_1__["TOP"]]: muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].axisTop
};


/***/ }),

/***/ "./packages/muze-axis/src/enums/constants.js":
/*!***************************************************!*\
  !*** ./packages/muze-axis/src/enums/constants.js ***!
  \***************************************************/
/*! exports provided: CLASSPREFIX, CONTINOUS, DISCRETE, SEQUENTIAL, ORDINAL, LINEAR, BAND, THRESHOLD, QUANTIZE, QUANTILE, COLOR, SHAPE, SIZE, DOMAIN, HIDDEN, NUMBER, BOTTOM, TOP, RGB, HEX, HSLA, HSL, DEFAULT_ANGLE_DOMAIN, MIN_NO_OF_TICKS, DEFAULT_NO_OF_TICKS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONTINOUS", function() { return CONTINOUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DISCRETE", function() { return DISCRETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEQUENTIAL", function() { return SEQUENTIAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDINAL", function() { return ORDINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAND", function() { return BAND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THRESHOLD", function() { return THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUANTIZE", function() { return QUANTIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUANTILE", function() { return QUANTILE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPE", function() { return SHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIZE", function() { return SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMAIN", function() { return DOMAIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIDDEN", function() { return HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMBER", function() { return NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB", function() { return RGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEX", function() { return HEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSLA", function() { return HSLA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSL", function() { return HSL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ANGLE_DOMAIN", function() { return DEFAULT_ANGLE_DOMAIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_NO_OF_TICKS", function() { return MIN_NO_OF_TICKS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_NO_OF_TICKS", function() { return DEFAULT_NO_OF_TICKS; });
const CLASSPREFIX = 'muze';

const CONTINOUS = 'continous';
const DISCRETE = 'discrete';
const SEQUENTIAL = 'sequential';
const ORDINAL = 'ordinal';
const LINEAR = 'linear';
const BAND = 'band';
const THRESHOLD = 'threshold';
const QUANTIZE = 'quantize';
const QUANTILE = 'quantile';

const COLOR = 'color';
const SHAPE = 'shape';
const SIZE = 'size';

const DOMAIN = 'domain';
const HIDDEN = 'hidden';
const NUMBER = 'number';
const BOTTOM = 'bottom';
const TOP = 'top';

const RGB = 'rgb';
const HEX = 'hex';
const HSLA = 'hsla';
const HSL = 'hsl';

const DEFAULT_ANGLE_DOMAIN = [1];
const MIN_NO_OF_TICKS = 2;
const DEFAULT_NO_OF_TICKS = 10;



/***/ }),

/***/ "./packages/muze-axis/src/enums/scale-type.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/enums/scale-type.js ***!
  \****************************************************/
/*! exports provided: LINEAR, BAND, TIME, COLOR, ORDINAL, QUANTIZE, QUANTILE, LOG, POW, IDENTITY, SEQUENTIAL, THRESHOLD */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAND", function() { return BAND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TIME", function() { return TIME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDINAL", function() { return ORDINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUANTIZE", function() { return QUANTIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUANTILE", function() { return QUANTILE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOG", function() { return LOG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POW", function() { return POW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEQUENTIAL", function() { return SEQUENTIAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THRESHOLD", function() { return THRESHOLD; });
/**
 * @module axis
 * This file exports constants used to reference scale type
 * consistently throughout the project.
 */
const LINEAR = 'linear';
const BAND = 'band';
const TIME = 'temporal';
const COLOR = 'color';
const ORDINAL = 'ordinal';
const QUANTIZE = 'quantize';
const QUANTILE = 'quantile';
const LOG = 'log';
const POW = 'pow';
const IDENTITY = 'identity';
const SEQUENTIAL = 'sequential';
const THRESHOLD = 'threshold';


/***/ }),

/***/ "./packages/muze-axis/src/helper.js":
/*!******************************************!*\
  !*** ./packages/muze-axis/src/helper.js ***!
  \******************************************/
/*! exports provided: treatNullMeasures, resolveAxisConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "treatNullMeasures", function() { return treatNullMeasures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveAxisConfig", function() { return resolveAxisConfig; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const treatNullMeasures = (domainVal, scaledVal, minDomainScaledVal) => {
    if (domainVal instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"]) {
        return minDomainScaledVal;
    }
    return scaledVal;
};

const resolveAxisConfig = (propVal, defaultVal, context) => {
    const constructor = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(propVal, 'constructor');
    switch (constructor) {
    case Function:
        return propVal(defaultVal, context);
    case Array:
        return propVal;
    default:
        return defaultVal;
    }
};


/***/ }),

/***/ "./packages/muze-axis/src/index.js":
/*!*****************************************!*\
  !*** ./packages/muze-axis/src/index.js ***!
  \*****************************************/
/*! exports provided: SimpleAxis, ContinousAxis, BandAxis, TimeAxis, ColorAxis, SizeAxis, ShapeAxis, RadiusAxis, AngleAxis, dataTypeScaleMap, AxisOrientation, ScaleType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums/axis-orientation */ "./packages/muze-axis/src/enums/axis-orientation.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "AxisOrientation", function() { return _enums_axis_orientation__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ScaleType", function() { return _enums_scale_type__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-axis/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _cartesian_axis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cartesian-axis */ "./packages/muze-axis/src/cartesian-axis/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleAxis", function() { return _cartesian_axis__WEBPACK_IMPORTED_MODULE_3__["SimpleAxis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContinousAxis", function() { return _cartesian_axis__WEBPACK_IMPORTED_MODULE_3__["ContinousAxis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BandAxis", function() { return _cartesian_axis__WEBPACK_IMPORTED_MODULE_3__["BandAxis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeAxis", function() { return _cartesian_axis__WEBPACK_IMPORTED_MODULE_3__["TimeAxis"]; });

/* harmony import */ var _color_axis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./color-axis */ "./packages/muze-axis/src/color-axis/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAxis", function() { return _color_axis__WEBPACK_IMPORTED_MODULE_4__["ColorAxis"]; });

/* harmony import */ var _size_axis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./size-axis */ "./packages/muze-axis/src/size-axis/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SizeAxis", function() { return _size_axis__WEBPACK_IMPORTED_MODULE_5__["SizeAxis"]; });

/* harmony import */ var _shape_axis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shape-axis */ "./packages/muze-axis/src/shape-axis/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeAxis", function() { return _shape_axis__WEBPACK_IMPORTED_MODULE_6__["ShapeAxis"]; });

/* harmony import */ var _polar_axis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polar-axis */ "./packages/muze-axis/src/polar-axis/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadiusAxis", function() { return _polar_axis__WEBPACK_IMPORTED_MODULE_7__["RadiusAxis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AngleAxis", function() { return _polar_axis__WEBPACK_IMPORTED_MODULE_7__["AngleAxis"]; });

/* harmony import */ var _data_type_scale_map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-type-scale-map */ "./packages/muze-axis/src/data-type-scale-map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dataTypeScaleMap", function() { return _data_type_scale_map__WEBPACK_IMPORTED_MODULE_8__["dataTypeScaleMap"]; });

/**
 * @module Axis
 * This file exports all the public methods and classes in the axis module.
 */













/***/ }),

/***/ "./packages/muze-axis/src/polar-axis/angle-axis.js":
/*!*********************************************************!*\
  !*** ./packages/muze-axis/src/polar-axis/angle-axis.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/polar-axis/props.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper */ "./packages/muze-axis/src/helper.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */






const { pie } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"];

const createAngleValues = (context) => {
    const angleData = context._angleFn(context._domain);
    angleData.forEach((v) => {
        v.startAngle -= Math.PI / 2;
        v.endAngle -= Math.PI / 2;
    });
    context._angleValues = angleData.reduce((values, d) => {
        const key = d.data;
        !values[key] && (values[key] = []);
        values[key].push(d);
        return values;
    }, {});
};

/**
* This class is used to instantiate a AngleAxis.
* @class AngleAxis
*/
class AngleAxis {

    /**
     * Creates an instance of AngleAxis.
     * @param {Object} config input parameters.
     * @memberof AngleAxis
     */
    constructor (config = {}) {
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_3__["PROPS"]);
        this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());
        this.config(config);
        this._range = [0, 360];
        this._angleFn = pie()
                .value(d => (typeof d === 'string' ? 1 : d))
                .sortValues(null);
        this._angleValues = {};
    }

    static defaultConfig () {
        return {};
    }

    createScale (strategy) {
        const {
            range
        } = this.config();
        return Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            type: strategy.scale,
            range
        });
    }

    getScaleValue (domainVal) {
        return this._angleValues[domainVal];
    }

    padAngle (angle) {
        this._angleFn = this._angleFn.padAngle(angle);
    }

    domain (...domainVal) {
        if (domainVal.length) {
            const { domain: customDomain } = this.config();
            const domain = domainVal[0].length ? domainVal[0] : _enums_constants__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ANGLE_DOMAIN"];
            this._domain = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["resolveAxisConfig"])(customDomain, domain, this);
            createAngleValues(this);
            return this;
        }
        return this._domain;
    }

    range (...range) {
        if (range.length) {
            const { range: customRange } = this.config();
            this._range = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["resolveAxisConfig"])(customRange, range[0], this);
            const domain = this.domain();
            const [startAngle, endAngle] = this._range;
            this._angleFn
                    .startAngle((startAngle / 180) * Math.PI)
                    .endAngle(Math.PI * endAngle / 180);
            if (domain && domain.length) {
                createAngleValues(this);
            }
            return this;
        }
        return this._range;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/polar-axis/index.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/polar-axis/index.js ***!
  \****************************************************/
/*! exports provided: AngleAxis, RadiusAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _angle_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./angle-axis */ "./packages/muze-axis/src/polar-axis/angle-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AngleAxis", function() { return _angle_axis__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _radius_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./radius-axis */ "./packages/muze-axis/src/polar-axis/radius-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadiusAxis", function() { return _radius_axis__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./packages/muze-axis/src/polar-axis/props.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/polar-axis/props.js ***!
  \****************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const PROPS = {
    config: {
        sanitization: (context, config) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context.config(), config),
        preset: (context, config) => {
            const { range, domain } = config;
            range && context.range(range);
            domain && context.domain(domain);
        }
    },
    domain: {},
    range: {}
};


/***/ }),

/***/ "./packages/muze-axis/src/polar-axis/radius-axis.js":
/*!**********************************************************!*\
  !*** ./packages/muze-axis/src/polar-axis/radius-axis.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RadiusAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _visual_group_src_enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../visual-group/src/enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/polar-axis/props.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper */ "./packages/muze-axis/src/helper.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */






const adjustDomain = (context) => {
    const minOuterRadius = context.config().minOuterRadius;
    const domain = context._domain;
    if (context._range.length) {
        const scale = context._scale;
        const value = scale.invert(minOuterRadius) - scale.invert(0);
        context._domain = [domain[0] - value, domain[1]];
        scale.domain(context._domain);
    }
};

/**
* This class is used to instantiate a RadiusAxis.
* @class RadiusAxis
*/
class RadiusAxis {

    /**
     * Creates an instance of RadiusAxis.
     * @param {Object} config input parameters.
     * @memberof RadiusAxis
     */
    constructor (config = {}) {
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_3__["PROPS"]);
        this._range = [];
        this._radiusFactor = 1;
        this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());
        this.config(config);
        this._scale = this.createScale({
            scale: _visual_group_src_enums_constants__WEBPACK_IMPORTED_MODULE_2__["LINEAR"]
        });
    }

    static defaultConfig () {
        return {
            padding: [0, 1],
            minOuterRadius: 10
        };
    }

    config (...params) {
        if (params.length) {
            const config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this.config(), params[0]);
            this._config = config;
            return this;
        }
        return this._config;
    }

    createScale (strategy) {
        return Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            type: strategy.scale,
            range: this.range()
        });
    }

    domain (...domainVal) {
        if (domainVal.length) {
            const { domain: customDomain } = this.config();
            let domain = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["resolveAxisConfig"])(customDomain, domainVal[0], this);
            domain = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["sanitizeDomainWhenEqual"])(domain);
            this._scale.domain(domain);
            this._domain = domain;
            adjustDomain(this);
        }
        return this._domain;
    }

    getInnerRadius (domainVal) {
        if (domainVal === undefined) {
            return this.range()[0];
        }
        return this._scale(domainVal);
    }

    getOuterRadius (domainVal) {
        if (domainVal === undefined) {
            return this.range()[1];
        }
        const radius = this._scale(domainVal) * this._radiusFactor;
        return radius;
    }

    range (...range) {
        if (range.length) {
            const { padding, range: customRange } = this.config();
            const sanitizedRange = range[0].map((v, i) => v + (i ? -padding[i] : padding[i]));
            const rangeVal = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["resolveAxisConfig"])(customRange, sanitizedRange, this);
            this._range = rangeVal;
            this._scale.range(rangeVal);
            adjustDomain(this);
        }
        return this._range;
    }

    setRadiusFactor (val) {
        this._radiusFactor = val;
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/scale-creator.js":
/*!*************************************************!*\
  !*** ./packages/muze-axis/src/scale-creator.js ***!
  \*************************************************/
/*! exports provided: scaleMap, SCHEMES, getScheme, getSchemeType, createScale, updateScaleRange, getScaleType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMap", function() { return scaleMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEMES", function() { return SCHEMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScheme", function() { return getScheme; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSchemeType", function() { return getSchemeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createScale", function() { return createScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateScaleRange", function() { return updateScaleRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleType", function() { return getScaleType; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");






const {
    scaleLinear,
    scaleThreshold,
    scaleLog,
    scalePow,
    scaleIdentity,
    scaleOrdinal,
    scaleSequential,
    scaleQuantize,
    scaleQuantile,
    schemeCategory10,
    schemeCategory20,
    schemeCategory20b,
    scaleBand,
    scaleTime
} = muze_utils__WEBPACK_IMPORTED_MODULE_0__["scales"];
const scaleMap = {
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LINEAR"]]: scaleLinear,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["BAND"]]: scaleBand,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["QUANTIZE"]]: scaleQuantize,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["QUANTILE"]]: scaleQuantile,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["THRESHOLD"]]: scaleThreshold,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["SEQUENTIAL"]]: scaleSequential,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LOG"]]: scaleLog,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["POW"]]: scalePow,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["IDENTITY"]]: scaleIdentity,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["TIME"]]: scaleTime,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["COLOR"]]: scaleLinear,
    [_enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["ORDINAL"]]: scaleOrdinal
};
const SCHEMES = {
    SCHEME1: schemeCategory10,
    SCHEME2: schemeCategory20,
    SCHEME3: schemeCategory20b
};

/**
 * Accepts a scheme in a string format and returns the scale from d3-scale-chromatic
 *
 * @export
 * @param {string} scheme a string representing the kind of scheme for the color axis
 * @return {Object} The corresponding scale from a scheme type from d3 chromatic scale
 */
function getScheme (scheme) {
    if (scheme[0] === 'i') {
        return scaleSequential(muze_utils__WEBPACK_IMPORTED_MODULE_0__["colorSchemes"][scheme]);
    }
    return scaleOrdinal(muze_utils__WEBPACK_IMPORTED_MODULE_0__["colorSchemes"][scheme]);
}

/**
 *
 *
 * @export
 * @param {*} scheme
 *
 */
function getSchemeType (scheme) {
    let schemeType = '';
    if (scheme && typeof (scheme) === 'string') {
        schemeType = scheme[0] === 'i' ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SEQUENTIAL"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ORDINAL"];
    } else {
        schemeType = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ORDINAL"];
    }
    return schemeType;
}

/**
 * This function is used to create a scale that is assigned to
 * an instance of axis.
 *
 * @export
 * @param {Object} params the input parameters to create a Scale object
 * @param {string} params.type the type of scale
 * @param {Array} params.range the range of scale
 * @return {Object} instance of scale
 */
function createScale (params) {
    if (!params.type || !scaleMap[params.type]) {
        throw new Error(`${params.type} is not a valid scale type`);
    }
    if (!Array.isArray(params.range)) {
        throw new Error('range parameter must be an array');
    }
    let scaleFactory = null;
    const range = params.range;
    // @todo: do it using scale decorator
    if (params.type === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LINEAR"] && params.interpolator) {
        scaleFactory = scaleMap[params.interpolator];
        if (params.interpolator === _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["POW"]) {
            return scaleFactory().range(range).exponent(params.exponent);
        } else if (params.interpolator === _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LOG"]) {
            return scaleFactory().range(range).base([params.base]);
        }
    } else {
        scaleFactory = scaleMap[params.type];
    }

    if (params.type === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["QUANTIZE"]) {
        scaleFactory().nice();
    }
    return scaleFactory().range(range);
}

/**
 * This method is used to update the range of a scale
 * so that the core module can remain agnostic of the d3
 * scale api.
 *
 * @export
 * @param {Scale} scale Instance of d3 Scale.
 * @param {Array} range new range of the scale.
 * @return {Scale} Updated scale.
 */
function updateScaleRange (scale, range) {
    return scale.range(range);
}

/**
 *
 *
 * @export
 * @param {*} domainType
 * @param {*} rangeType
 * @param {*} steps
 *
 */
function getScaleType (domainType, rangeType, steps) {
    if (rangeType === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]) {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LINEAR"];
    }
    if (domainType === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]) {
        if (steps instanceof Array) {
            return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["THRESHOLD"];
        }
        return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["QUANTIZE"];
    }
    return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ORDINAL"];
}


/***/ }),

/***/ "./packages/muze-axis/src/shape-axis/defaults.js":
/*!*******************************************************!*\
  !*** ./packages/muze-axis/src/shape-axis/defaults.js ***!
  \*******************************************************/
/*! exports provided: DEFAULT_CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
const DEFAULT_CONFIG = {
    generator: null,
    value: 'circle',
    range: ['circle', 'diamond', 'star', 'cross', 'square', 'wye', 'triangle']
};


/***/ }),

/***/ "./packages/muze-axis/src/shape-axis/helper.js":
/*!*****************************************************!*\
  !*** ./packages/muze-axis/src/shape-axis/helper.js ***!
  \*****************************************************/
/*! exports provided: shapeGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shapeGenerator", function() { return shapeGenerator; });
/**
 *
 *
 * @param {*} domain
 * @param {*} generatorFn
 *
 */
const shapeGenerator = (domain, generatorFn) => {
    const generatedShapes = {};
    domain.forEach((value) => {
        generatedShapes[value] = generatorFn(value);
    });
    return generatedShapes;
};


/***/ }),

/***/ "./packages/muze-axis/src/shape-axis/index.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/shape-axis/index.js ***!
  \****************************************************/
/*! exports provided: ShapeAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shape_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape-axis */ "./packages/muze-axis/src/shape-axis/shape-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeAxis", function() { return _shape_axis__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-axis/src/shape-axis/props.js":
/*!****************************************************!*\
  !*** ./packages/muze-axis/src/shape-axis/props.js ***!
  \****************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
const PROPS = {
    config: {},
    domain: {},
    scale: {},
    uniqueValues: {},
    generator: {}
};



/***/ }),

/***/ "./packages/muze-axis/src/shape-axis/shape-axis.js":
/*!*********************************************************!*\
  !*** ./packages/muze-axis/src/shape-axis/shape-axis.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShapeAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/muze-axis/src/shape-axis/defaults.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper */ "./packages/muze-axis/src/shape-axis/helper.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/shape-axis/props.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */







/**
* This class is used to instantiate a SimpleAxis.
* @class SimpleAxis
*/
class ShapeAxis {
    /**
    * Creates an instance of SimpleAxis.
    * @param {Object} params input parameters.
    * @param {Object | undefined} params.range Type of color scheme.
    * @memberof ShapeAxis
    */
    constructor (config) {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_5__["PROPS"]);

        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._config = Object.assign({}, this.constructor.defaultConfig());
        this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._config, config);

        this._scale = Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            type: 'ordinal',
            range: this._config.range
        });
        this.updateDomain(config.domain);
    }

     /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static defaultConfig () {
        return _defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"];
    }

     /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"];
    }

    /**
     *
     *
     * @param {*} value
     *
     * @memberof ShapeAxis
     */
    getShape (value) {
        if (!this.scale() || !this.domain() || !value || value instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"]) {
            return this.config().value;
        }

        if (this._generatedShapes) {
            return this._generatedShapes[value];
        }

        const shapeType = this.scale()(value);
        if (shapeType === 'string') {
            return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSymbol"])(shapeType);
        }

        return shapeType;
    }

    /**
     * This method is used to assign a domain to the axis.
     *
     * @param {Array} domain the domain of the scale
     * @memberof ShapeAxis
     */
    updateDomain (domain = []) {
        if (domain.length) {
            this.uniqueValues(domain);
            this.domain(domain);
            this.scale().domain(domain);

            if (this.config().generator) {
                this._generatedShapes = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["shapeGenerator"])(domain, this.config().generator);
            }
        }
        return this;
    }

    /**
     * This method returns an object that can be used to
     * reconstruct this instance.
     *
     * @return {Object} the serializable props of axis
     * @memberof ShapeAxis
     */
    serialize () {
        return {
            type: this.constructor.type(),
            scale: this.scale(),
            domain: this.domain(),
            range: this.config().range,
            config: this.config()
        };
    }

    /**
     * Returns the id of the axis.
     * @return {string} Unique identifier of the axis.
     */
    id () {
        return this._id;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/size-axis/defaults.js":
/*!******************************************************!*\
  !*** ./packages/muze-axis/src/size-axis/defaults.js ***!
  \******************************************************/
/*! exports provided: DEFAULT_CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
const DEFAULT_CONFIG = {
    value: 36,
    range: [36, 1000]
};


/***/ }),

/***/ "./packages/muze-axis/src/size-axis/index.js":
/*!***************************************************!*\
  !*** ./packages/muze-axis/src/size-axis/index.js ***!
  \***************************************************/
/*! exports provided: SizeAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _size_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./size-axis */ "./packages/muze-axis/src/size-axis/size-axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SizeAxis", function() { return _size_axis__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-axis/src/size-axis/props.js":
/*!***************************************************!*\
  !*** ./packages/muze-axis/src/size-axis/props.js ***!
  \***************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
const PROPS = {
    config: {},
    domain: {
        sanitization: (context, value) => {
            context.scale().domain(value);
            return value;
        }
    },
    range: {},
    scale: {},
    uniqueValues: {}
};


/***/ }),

/***/ "./packages/muze-axis/src/size-axis/size-axis.js":
/*!*******************************************************!*\
  !*** ./packages/muze-axis/src/size-axis/size-axis.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SizeAxis; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scale_creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scale-creator */ "./packages/muze-axis/src/scale-creator.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/muze-axis/src/size-axis/defaults.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _size_strategy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./size-strategy */ "./packages/muze-axis/src/size-axis/size-strategy.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./props */ "./packages/muze-axis/src/size-axis/props.js");
/**
 * @module Axis
 * This file declares a class that is used to render an axis to add  meaning to
 * plots.
 */







/**
* This class is used to instantiate a SimpleAxis.
* @class SimpleAxis
*/
class SizeAxis {

    /**
     * Creates an instance of SimpleAxis.
     * @param {Object} config input parameters.
     * @memberof SizeAxis
     */
    constructor (config) {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_5__["PROPS"]);

        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._config = Object.assign({}, this.constructor.defaultConfig(), config);
        // @todo: Will use configuration override using scale decorator
        this._domainType = this._config.type === 'linear' ? _enums_constants__WEBPACK_IMPORTED_MODULE_3__["CONTINOUS"] : _enums_constants__WEBPACK_IMPORTED_MODULE_3__["DISCRETE"];
        this._rangeType = _enums_constants__WEBPACK_IMPORTED_MODULE_3__["CONTINOUS"];

        this._sizeStrategy = this.setStrategy(this._domainType, this._rangeType);
        this._scale = this.createScale(this._sizeStrategy);
        this._range = this._config.range;

        this.updateDomain(config.domain);
    }

     /**
     *
     *
     * @param {*} domainType
     * @param {*} rangeType
     * @param {*} schemeType
     *
     * @memberof ColorAxis
     */
    setStrategy (domainType, rangeType) {
        return Object(_size_strategy__WEBPACK_IMPORTED_MODULE_4__["strategyGetter"])(domainType, rangeType);
    }

    /**
     *
     *
     *
     * @memberof SizeAxis
     */
    createScale (strategy) {
        const {
            range
        } = this.config();
        return Object(_scale_creator__WEBPACK_IMPORTED_MODULE_1__["createScale"])({
            type: strategy.scale,
            range
        });
    }

    /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static defaultConfig () {
        return _defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"];
    }

     /**
     *
     *
     * @static
     *
     * @memberof ColorAxis
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"];
    }

    /**
     *
     *
     * @param {*} domainVal
     *
     * @memberof SizeAxis
     */
    getSize (domainVal = 0) {
        let sizeVal = 1;
        const {
            value
        } = this.config();
        const scale = this.scale();
        const domain = this.domain() || [1, 1];

        if (!scale || domain[0] === domain[1]) {
            sizeVal = value;
        } else {
            return this._sizeStrategy.range(domainVal, scale, this.domain(), this.uniqueValues());
        }
        return sizeVal;
    }

    /**
     * This method is used to assign a domain to the axis.
     *
     * @param {Array} domain the domain of the scale
     * @memberof SizeAxis
     */
    updateDomain (domain) {
        if (domain) {
            const domainFn = this._sizeStrategy.domain;

            const domainInfo = domainFn(domain, this.config().intervals);

            this.domain(domainInfo.domain);
            this.uniqueValues(domainInfo.uniqueVals);

            this.scale().domain(domainInfo.scaleDomain || this.domain());
        }
        return this;
    }

    /**
     * This method returns an object that can be used to
     * reconstruct this instance.
     *
     * @return {Object} the serializable props of axis
     * @memberof ShapeAxis
     */
    serialize () {
        return {
            type: this.constructor.type(),
            scale: this.scale(),
            domain: this.domain(),
            range: this.range(),
            config: this.config()
        };
    }

    /**
     * Returns the id of the axis.
     * @return {string} Unique identifier of the axis.
     */
    id () {
        return this._id;
    }
}


/***/ }),

/***/ "./packages/muze-axis/src/size-axis/size-strategy.js":
/*!***********************************************************!*\
  !*** ./packages/muze-axis/src/size-axis/size-strategy.js ***!
  \***********************************************************/
/*! exports provided: strategyGetter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strategyGetter", function() { return strategyGetter; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-axis/src/enums/constants.js");
/* harmony import */ var _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/scale-type */ "./packages/muze-axis/src/enums/scale-type.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helper */ "./packages/muze-axis/src/helper.js");





/**
 *
 *
 * @param {*} domain
 *
 */
const indexedDomain = (domain) => {
    const uniqueVals = domain;
    const retDomain = domain.map((d, i) => (i) / (domain.length - 1));
    return { domain: retDomain, uniqueVals, scaleDomain: [0, 1] };
};

/**
 *
 *
 * @param {*} domain
 *
 */
const normalDomain = (domain) => {
    const uniqueVals = domain;
    return { uniqueVals, domain };
};

/**
 *
 *
 * @param {*} domain
 * @param {*} intervals
 *
 */
const steppedDomain = (domain, intervals) => {
    let newIntervals = [];
    if (intervals instanceof Array) {
        newIntervals = intervals.slice().sort();
    } else {
        const interpolator = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["numberInterpolator"])()(...domain);
        for (let i = 0; i < intervals; i++) {
            newIntervals[i] = interpolator(i / (intervals - 1));
        }
    }
    if (newIntervals[0] < domain[0]) {
        newIntervals.shift();
    }
    const retDomain = newIntervals;
    return { uniqueVals: newIntervals, domain: retDomain, nice: true };
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 * @param {*} domain
 * @param {*} uniqueVals
 *
 */
const discreteRange = (domainValue, scale, domain) => {
    const numVal = (domainValue - domain[0]) / (domain[domain.length - 1] - domain[0]);
    const interpolator = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["numberInterpolator"])()(...scale.range());
    return Object(_helper__WEBPACK_IMPORTED_MODULE_3__["treatNullMeasures"])(domainValue, interpolator(numVal), interpolator(domain[0]));
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 * @param {*} domain
 *
 */
const pieceWiseRange = (domainValue, scale, domain, uniqueVals) => {
    const index = uniqueVals.indexOf(domainValue);
    const numVal = domain[index];
    const fn = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["piecewiseInterpolator"])()(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["numberInterpolator"])(), [...scale.range()]);
    return fn(numVal);
};

/**
 *
 *
 * @param {*} domainValue
 * @param {*} scale
 */
const normalRange = (domainValue, scale, domain) =>
    Object(_helper__WEBPACK_IMPORTED_MODULE_3__["treatNullMeasures"])(domainValue, scale(domainValue), scale(domain[0]));

/**
 *
 *
 * @param {*} intervals
 */
const strategies = {
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LINEAR"],
        domain: indexedDomain,
        range: pieceWiseRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["LINEAR"],
        domain: normalDomain,
        range: normalRange
    },
    [`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONTINOUS"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["DISCRETE"]}`]: {
        scale: _enums_scale_type__WEBPACK_IMPORTED_MODULE_2__["THRESHOLD"],
        domain: steppedDomain,
        range: discreteRange
    }
};

/**
 *
 *
 * @param {*} domainType
 * @param {*} rangeType
 * @param {*} schemeType
 * @param {*} intervals
 */
const strategyGetter = (domainType, rangeType) =>
     strategies[`${domainType}-${rangeType}`];


/***/ }),

/***/ "./packages/muze-axis/src/styles.scss":
/*!********************************************!*\
  !*** ./packages/muze-axis/src/styles.scss ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/brush.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/brush.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrushBehaviour; });
/* harmony import */ var _volatile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./volatile */ "./packages/muze-firebolt/src/actions/behavioural/volatile.js");
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");



/**
 * This is the behaviour for brushing a region on the chart. It accepts a payload
 * which contains the x and y range of the data and other configuration. It will then
 * create a selection box from the range and select the points which fall within the range.
 */
class BrushBehaviour extends _volatile__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__["BRUSH"];
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/filter.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/filter.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FilterBehaviour; });
/* harmony import */ var _volatile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./volatile */ "./packages/muze-firebolt/src/actions/behavioural/volatile.js");
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");



class FilterBehaviour extends _volatile__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__["FILTER"];
    }

    static mutates () {
        return true;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/generic.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/generic.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GenericBehaviour; });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helper */ "./packages/muze-firebolt/src/helper/index.js");


/**
 * This is the base class has all the common functionalities needed for all behavioural actions. Any other behavioural
 * action needs to extend this class.
 *
 * @public
 * @class GenericBehaviour
 * @module GenericBehaviour
 */
class GenericBehaviour {
    constructor (firebolt) {
        this.firebolt = firebolt;
        this._enabled = true;
    }

    /**
     * Returns entry and exit set information. This method is called by firebolt when ```dispatchBehaviour``` is called
     * dynamically or when any physical action is triggered on the chart.
     *
     * @param {Object} payload Payload information.
     * @param {Object|Array} payload.criteria Identifiers of data interacted with.
     *
     * @return {Array} Entry and exit set information.
     */
    dispatch (payload) {
        const criteria = payload.criteria;
        const firebolt = this.firebolt;
        const formalName = this.constructor.formalName();
        const selectionSets = firebolt.getSelectionSets(formalName);
        const {
            model: filteredDataModel,
            uids
        } = this.firebolt.getAddSetFromCriteria(criteria, this.firebolt.getPropagationInf());
        const entryExitSets = selectionSets.map((selectionSet) => {
            this.setSelectionSet(uids, selectionSet);
            return this.getEntryExitSet(selectionSet, filteredDataModel, payload);
        });

        return entryExitSets;
    }

    /**
     * Updates the selection set by adding uids to the instance of {@link SelectionSet} or removing them.
     * {@link SelectionSet} keeps the information of which rows are in the entry set and exit set.
     *
     * @public
     * @param {Array} addSet Array of row ids which got affected during interaction.
     * @param {SelectionSet} selectionSet Instance of selection set.
     *
     * @return {GenericBehaviour} Instance of behaviour.
     */
    setSelectionSet () {
        return this;
    }

    getEntryExitSet (selectionSet, filteredDataModel, payload) {
        const {
            entrySet,
            exitSet,
            completeSet
        } = selectionSet.getSets();
        const propagationInf = this.firebolt.getPropagationInf();
        const dataModel = this.firebolt.getFullData();
        const setConfig = {
            dataModel,
            filteredDataModel,
            propagationData: propagationInf.data,
            selectionSet
        };

        return {
            entrySet: [Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('oldEntry', entrySet[0], setConfig),
                Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('newEntry', entrySet[1], setConfig)],
            exitSet: [Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('oldEntry', exitSet[0], setConfig),
                Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('newExit', exitSet[1], setConfig)],
            mergedEnter: Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('mergedEnter', Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getMergedSet"])(entrySet), setConfig),
            mergedExit: Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('mergedExit', Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getMergedSet"])(exitSet), setConfig),
            completeSet: Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSetInfo"])('complete', completeSet, setConfig),
            fields: Object(_helper__WEBPACK_IMPORTED_MODULE_0__["getSourceFields"])(propagationInf, payload.criteria),
            sourceSelectionSet: selectionSet._volatile === true
        };
    }

    static mutates () {
        return false;
    }

    enable () {
        this._enabled = true;
    }

    disable () {
        this._enabled = false;
    }

    isEnabled () {
        return this._enabled;
    }
}



/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/highlight.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/highlight.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HighlightBehaviour; });
/* harmony import */ var _volatile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./volatile */ "./packages/muze-firebolt/src/actions/behavioural/volatile.js");
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");



class HighlightBehaviour extends _volatile__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__["HIGHLIGHT"];
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/index.js ***!
  \*****************************************************************/
/*! exports provided: HighlightBeahviour, BrushBehaviour, FilterBehaviour, SelectBehaviour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./highlight */ "./packages/muze-firebolt/src/actions/behavioural/highlight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HighlightBeahviour", function() { return _highlight__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brush */ "./packages/muze-firebolt/src/actions/behavioural/brush.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BrushBehaviour", function() { return _brush__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./packages/muze-firebolt/src/actions/behavioural/filter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FilterBehaviour", function() { return _filter__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./select */ "./packages/muze-firebolt/src/actions/behavioural/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectBehaviour", function() { return _select__WEBPACK_IMPORTED_MODULE_3__["default"]; });








/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/persistent.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/persistent.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PersistentBehaviour; });
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generic */ "./packages/muze-firebolt/src/actions/behavioural/generic.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helper */ "./packages/muze-firebolt/src/helper/index.js");
/* harmony import */ var _enums_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/selection */ "./packages/muze-firebolt/src/enums/selection.js");




class PersistentBehaviour extends _generic__WEBPACK_IMPORTED_MODULE_0__["default"] {
    setSelectionSet (addSet, selectionSet) {
        if (addSet === null) {
            selectionSet.reset();
        } else if (addSet.length) {
            const propagationInf = this.firebolt.getPropagationInf();
            // new add set
            const existingAddSet = addSet.filter(d => selectionSet._set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_2__["SELECTION_NEW_ENTRY"]
                || selectionSet._set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_2__["SELECTION_OLD_ENTRY"]);
            if (propagationInf.propagate === false) {
                selectionSet.updateExit();
                const { entrySet } = selectionSet.getSets();
                selectionSet.reset(Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getMergedSet"])(entrySet));
                selectionSet.add(addSet);
                selectionSet.update(existingAddSet);
            } else {
                // existing add set
                if (existingAddSet.length) {
                    selectionSet.updateExit();
                    selectionSet.remove(existingAddSet);
                } else {
                    selectionSet.updateEntry();
                    selectionSet.add(addSet);
                }
                const { exitSet } = selectionSet.getSets();
                const mergedExitSet = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getMergedSet"])(exitSet);
                const completeSetCount = selectionSet.getCompleteSet().length;
                if (mergedExitSet.length === completeSetCount) {
                    selectionSet.reset();
                }
            }
        } else {
            selectionSet.remove(selectionSet.getCompleteSet());
        }

        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/select.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/select.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SelectBehaviour; });
/* harmony import */ var _persistent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./persistent */ "./packages/muze-firebolt/src/actions/behavioural/persistent.js");
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");



class SelectBehaviour extends _persistent__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_behaviours__WEBPACK_IMPORTED_MODULE_1__["SELECT"];
    }
}



/***/ }),

/***/ "./packages/muze-firebolt/src/actions/behavioural/volatile.js":
/*!********************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/behavioural/volatile.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VolatileBehaviour; });
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generic */ "./packages/muze-firebolt/src/actions/behavioural/generic.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helper */ "./packages/muze-firebolt/src/helper/index.js");
/* harmony import */ var _enums_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/selection */ "./packages/muze-firebolt/src/enums/selection.js");




class VolatileBehaviour extends _generic__WEBPACK_IMPORTED_MODULE_0__["default"] {
    setSelectionSet (addSet, selectionSet) {
        if (addSet === null) {
            selectionSet.reset();
        } else if (addSet.length) {
                // new add set
            const existingAddSet = addSet.filter(d => selectionSet._set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_2__["SELECTION_NEW_ENTRY"]
                    || selectionSet._set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_2__["SELECTION_OLD_ENTRY"]);
            selectionSet.updateExit();
            const { entrySet } = selectionSet.getSets();
            selectionSet.reset(Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getMergedSet"])(entrySet));
            selectionSet.add(addSet);
            selectionSet.update(existingAddSet);
        } else {
            selectionSet.remove(selectionSet.getCompleteSet());
        }
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/click.js":
/*!**************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/click.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./packages/muze-firebolt/src/actions/physical/helpers/index.js");



/**
 * Adds mouse interactions to target element.
 * @param {VisualUnit} instance instance of visual unit.
 * @param {SVGElement} targetEl Element on which the event listeners will be attached.
 * @param {Array} behaviours Array of behaviours
 */
/* istanbul ignore next */ const click = firebolt => (targetEl, behaviours) => {
    const dispatchBehaviour = function (args) {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        const payload = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["generatePayloadFromEvent"])(args, event, firebolt);
        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, payload));
        event.stopPropagation();
    };

    targetEl.on('click', dispatchBehaviour);
};
/* harmony default export */ __webpack_exports__["default"] = (click);


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/drag.js":
/*!*************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/drag.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers_drag_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/drag-event */ "./packages/muze-firebolt/src/actions/physical/helpers/drag-event.js");


/**
 * Adds dragging action to the target element.
 * @param {VisualUnit} instance Instance of visual unit.
 * @param {SVGElement} targetEl Element on which brushing action is needed.
 * @param {Array} behaviours Array of behaviours
 */
/* istanbul ignore next */ const drag = firebolt => (targetEl, behaviours) => {
    Object(_helpers_drag_event__WEBPACK_IMPORTED_MODULE_0__["attachDragEvent"])(targetEl, behaviours, firebolt);
};

/* harmony default export */ __webpack_exports__["default"] = (drag);


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/helpers/drag-action-config.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/helpers/drag-action-config.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");

/**
 * Gets the drag action configuration
 * @param {VisualUnit} instance instance of visual unit
 * @param {Object} config x y positions
 * @return {Object} Payload of behaviour
*/
/* istanbul ignore next */ const getDragActionConfig = (sourceInfo, config, fieldsConfig) => {
    if (!(sourceInfo.axes.x || sourceInfo.axes.y)) {
        return {
            criteria: null
        };
    }

    const axes = sourceInfo.axes;
    const xAxis = axes.x[0];
    const yAxis = axes.y[0];
    const axisFields = sourceInfo.fields;
    const xField = axisFields.x[0].getMembers()[0];
    const yField = axisFields.y[0].getMembers()[0];
    const xFieldType = fieldsConfig[xField].def.subtype;
    const yFieldType = fieldsConfig[yField].def.subtype;
    const dimensions = {};
    const stPos = config.startPos;
    const endPos = config.endPos;

    if (stPos.x === endPos.x && stPos.y === endPos.y) {
        return {
            criteria: null
        };
    }

    const dragDim = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS ? (yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS ?
        ['x', 'y'] : ['y']) : ['x'];
    const criteria = {};
    const isXDimension = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL;
    const isYDimension = yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL;
    const xRange = xAxis.invertExtent(stPos.x, endPos.x);
    const yRange = yAxis.invertExtent(stPos.y, endPos.y);
    const selectedDomains = {
        x: stPos.x === endPos.x ? [] : (isXDimension ? xRange : xRange.sort((a, b) => a - b)),
        y: stPos.y === endPos.y ? [] : (isYDimension ? yRange : yRange.sort((a, b) => a - b))
    };
    const rangeObj = {};

    if (dragDim.length === 2) {
        rangeObj[xField] = selectedDomains.x;
        rangeObj[yField] = selectedDomains.y;
        if (xField === yField) {
            const xdom = selectedDomains.x;
            const ydom = selectedDomains.y;
            const min = xdom[0] > ydom[0] ? ydom : xdom;
            const max = min === ydom ? xdom : ydom;
            if (min[1] < max[0]) {
                rangeObj[xField] = [];
            } else {
                rangeObj[xField] = [max[0], min[1] < max[1] ? min[1] : max[1]];
            }
            dimensions.x = [stPos.x, endPos.x];
            dimensions.y = [stPos.y, endPos.y];
        }
    } else {
        criteria[dragDim[0]] = selectedDomains[dragDim[0]] || [];

        if (dragDim[0] === 'x') {
            rangeObj[xField] = criteria.x;
            if (xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL) {
                dimensions.x = (config.snap && stPos.x !== endPos.x) ? xAxis.getNearestRange(stPos.x, endPos.x) :
                    [stPos.x, endPos.x];
            }
        } else {
            rangeObj[yField] = criteria.y;
            if (yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL) {
                dimensions.y = (config.snap && stPos.y !== endPos.y) ? yAxis.getNearestRange(stPos.y, endPos.y) :
                    [stPos.y, endPos.y];
            }
        }
    }

    return {
        criteria: rangeObj,
        dimensions
    };
};

/* harmony default export */ __webpack_exports__["default"] = (getDragActionConfig);


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/helpers/drag-event.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/helpers/drag-event.js ***!
  \***************************************************************************/
/*! exports provided: attachDragEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachDragEvent", function() { return attachDragEvent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _drag_action_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drag-action-config */ "./packages/muze-firebolt/src/actions/physical/helpers/drag-action-config.js");




/**
 * Adds dragging action to the target element.
 * @param {VisualUnit} instance Instance of visual unit.
 * @param {SVGElement} targetEl Element on which brushing action is needed.
 * @param {Array} behaviours Array of behaviours
 */
const attachDragEvent = (targetEl, behaviours, firebolt, touch) => {
    let startPos = {};
    let endPos = {};
    let drawingInf;

    const d3Drag = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getD3Drag"])();
    let touchStart;
    targetEl.call(d3Drag().on('start', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        startPos = {
            x: event.x,
            y: event.y
        };
        drawingInf = firebolt.context.getDrawingContext();
        touchStart = new Date().getTime();
    }).on('drag', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        endPos = {
            x: event.x,
            y: event.y
        };
        if (touch && Math.abs(startPos.x - endPos.x) <= 5) {
            return;
        }
        endPos.x = Math.max(0, Math.min(endPos.x, drawingInf.width));
        endPos.y = Math.max(0, Math.min(endPos.y, drawingInf.height));

        const payload = Object(_drag_action_config__WEBPACK_IMPORTED_MODULE_1__["default"])(firebolt.context.getSourceInfo(), {
            startPos,
            endPos
        }, firebolt.context.data().getFieldsConfig());
        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, payload));
    }).on('end', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        endPos = {
            x: event.x,
            y: event.y
        };
        const duration = new Date().getTime() - touchStart;

        if (touch && duration > 100 && Math.abs(startPos.x - endPos.x) <= 5) {
            return;
        }
        endPos.x = Math.max(0, Math.min(endPos.x, drawingInf.width));
        endPos.y = Math.max(0, Math.min(endPos.y, drawingInf.height));

        const payload = Object(_drag_action_config__WEBPACK_IMPORTED_MODULE_1__["default"])(firebolt.context.getSourceInfo(), {
            startPos,
            endPos,
            snap: true
        }, firebolt.context.data().getFieldsConfig());
        payload.dragEnd = true;
        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, payload));
    }));
};



/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/helpers/index.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/helpers/index.js ***!
  \**********************************************************************/
/*! exports provided: generatePayloadFromEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generatePayloadFromEvent", function() { return generatePayloadFromEvent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const generatePayloadFromEvent = function (args, event, firebolt) {
    const context = firebolt.context;
    const pos = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getClientPoint"])(context.getDrawingContext().svgContainer, event.touches ? event.touches[0] : event);
    const nearestPoint = context.getNearestPoint(pos.x, pos.y, {
        data: args,
        event
    });
    return {
        criteria: nearestPoint ? nearestPoint.id : null,
        showInPosition: nearestPoint.showInPosition,
        target: nearestPoint.target,
        position: pos
    };
};


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/hover.js":
/*!**************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/hover.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");



/**
 * Adds mouse interactions to target element.
 * @param {Firebolt} instance instance of firebolt.
 * @param {SVGElement} targetEl Element on which the event listeners will be attached.
 * @param {Array} behaviours Array of behaviours
 */
/* istanbul ignore next */ const hover = firebolt => (targetEl, behaviours) => {
    const dispatchBehaviour = function (args) {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        const context = firebolt.context;
        const tooltipConf = context.config().interaction.tooltip;
        const mode = tooltipConf.mode;
        const pos = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getClientPoint"])(context.getDrawingContext().svgContainer, event);
        const nearestPoint = context.getNearestPoint(pos.x, pos.y, {
            getAllPoints: mode === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CONSOLIDATED"] || mode === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["FRAGMENTED"],
            data: args,
            event
        });
        const payload = {
            criteria: nearestPoint ? nearestPoint.id : null,
            showInPosition: nearestPoint.showInPosition,
            target: nearestPoint.target,
            position: pos,
            mode
        };

        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, payload));
        event.stopPropagation();
    };

    targetEl.on('mouseover', dispatchBehaviour)
                    .on('mousemove', dispatchBehaviour)
                    .on('mouseout', () => {
                        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, {
                            criteria: null
                        }));
                    });
};

/* harmony default export */ __webpack_exports__["default"] = (hover);


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/index.js":
/*!**************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/index.js ***!
  \**************************************************************/
/*! exports provided: physicalActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "physicalActions", function() { return physicalActions; });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./packages/muze-firebolt/src/actions/physical/drag.js");
/* harmony import */ var _hover__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hover */ "./packages/muze-firebolt/src/actions/physical/hover.js");
/* harmony import */ var _longtouch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./longtouch */ "./packages/muze-firebolt/src/actions/physical/longtouch.js");
/* harmony import */ var _touch_drag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./touch-drag */ "./packages/muze-firebolt/src/actions/physical/touch-drag.js");
/* harmony import */ var _enums_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/actions */ "./packages/muze-firebolt/src/enums/actions.js");
/* harmony import */ var _click__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./click */ "./packages/muze-firebolt/src/actions/physical/click.js");







const physicalActions = {
    [_enums_actions__WEBPACK_IMPORTED_MODULE_4__["DRAG"]]: _drag__WEBPACK_IMPORTED_MODULE_0__["default"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_4__["HOVER"]]: _hover__WEBPACK_IMPORTED_MODULE_1__["default"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_4__["CLICK"]]: _click__WEBPACK_IMPORTED_MODULE_5__["default"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_4__["LONGTOUCH"]]: _longtouch__WEBPACK_IMPORTED_MODULE_2__["longtouch"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_4__["TOUCHDRAG"]]: _touch_drag__WEBPACK_IMPORTED_MODULE_3__["touchdrag"]
};



/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/longtouch.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/longtouch.js ***!
  \******************************************************************/
/*! exports provided: longtouch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "longtouch", function() { return longtouch; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./packages/muze-firebolt/src/actions/physical/helpers/index.js");
/* global setTimeout */



/**
 * Adds mouse interactions to target element.
 * @param {VisualUnit} instance instance of visual unit.
 * @param {SVGElement} targetEl Element on which the event listeners will be attached.
 * @param {Array} behaviours Array of behaviours
 */
const longtouch = firebolt => (targetEl, behaviours) => {
    let event;
    let touchEnd;
    const dispatchBehaviour = function (args) {
        const payload = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["generatePayloadFromEvent"])(args, event, firebolt);
        behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, payload));
        event.stopPropagation();
    };

    touchEnd = false;
    event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
    targetEl.on('touchstart', (args) => {
        event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        touchEnd = false;
        setTimeout(() => {
            if (!touchEnd) {
                dispatchBehaviour(args);
            } else {
                behaviours.forEach(beh => firebolt.dispatchBehaviour(beh, {
                    criteria: null
                }));
            }
        }, 100);
    }).on('touchend', () => {
        touchEnd = true;
    });
};


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/selection-box-drag.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/selection-box-drag.js ***!
  \***************************************************************************/
/*! exports provided: selectionBoxDrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectionBoxDrag", function() { return selectionBoxDrag; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helpers_drag_action_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/drag-action-config */ "./packages/muze-firebolt/src/actions/physical/helpers/drag-action-config.js");




const selectionBoxDrag = firebolt => (targetEl, behaviours) => {
    let subject;
    let drawingInf;
    const context = firebolt.context;
    const onDrag = (payload) => {
        behaviours.forEach(action => firebolt.dispatchBehaviour(action, payload));
    };
    const d3Drag = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getD3Drag"])();

    targetEl.call(d3Drag().on('start', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        drawingInf = context.getDrawingContext();
        subject = event.subject;
    }).on('drag', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        subject.x += event.dx;
        subject.y += event.dy;
        const width = drawingInf.width;
        const height = drawingInf.height;
        const x = Math.min(width - subject.width, Math.max(subject.x, 0));
        const y = Math.min(height - subject.height, Math.max(subject.y, 0));
        const y2 = y + subject.height;
        const x2 = x + subject.width;

        if (x >= 0 && x2 <= width && y >= 0 && y2 <= height) {
            const payload = Object(_helpers_drag_action_config__WEBPACK_IMPORTED_MODULE_1__["default"])(context.getSourceInfo(), {
                startPos: {
                    x,
                    y
                },
                endPos: {
                    x: x2,
                    y: y2
                }
            }, context.data().getFieldsConfig());
            onDrag(payload);
        }
    }).on('end', () => {
        const width = drawingInf.width;
        const height = drawingInf.height;
        const x = Math.min(width - subject.width, Math.max(subject.x, 0));
        const y = Math.min(height - subject.height, Math.max(subject.y, 0));
        const y2 = y + subject.height;
        const x2 = x + subject.width;

        if (x >= 0 && x2 <= width && y >= 0 && y2 <= height) {
            const payload = Object(_helpers_drag_action_config__WEBPACK_IMPORTED_MODULE_1__["default"])(context.getSourceInfo(), {
                startPos: {
                    x,
                    y
                },
                endPos: {
                    x: x2,
                    y: y2
                },
                snap: true
            }, context.data().getFieldsConfig());
            payload.dragEnd = true;
            onDrag(payload);
        }
    }));
};


/***/ }),

/***/ "./packages/muze-firebolt/src/actions/physical/touch-drag.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-firebolt/src/actions/physical/touch-drag.js ***!
  \*******************************************************************/
/*! exports provided: touchdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "touchdrag", function() { return touchdrag; });
/* harmony import */ var _helpers_drag_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/drag-event */ "./packages/muze-firebolt/src/actions/physical/helpers/drag-event.js");


/**
 * Adds dragging action to the target element.
 * @param {VisualUnit} instance Instance of visual unit.
 * @param {SVGElement} targetEl Element on which brushing action is needed.
 * @param {Array} behaviours Array of behaviours
 */
const touchdrag = firebolt => (targetEl, behaviours) => {
    Object(_helpers_drag_event__WEBPACK_IMPORTED_MODULE_0__["attachDragEvent"])(targetEl, behaviours, firebolt, true);
};



/***/ }),

/***/ "./packages/muze-firebolt/src/behaviour-effect-map.js":
/*!************************************************************!*\
  !*** ./packages/muze-firebolt/src/behaviour-effect-map.js ***!
  \************************************************************/
/*! exports provided: behaviourEffectMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "behaviourEffectMap", function() { return behaviourEffectMap; });
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");


const behaviourEffectMap = {
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["BRUSH"]]: ['selectionBox', {
        name: 'highlighter',
        options: {
            strategy: 'fade'
        }
    }, 'brush-anchors'],
    [`${_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["BRUSH"]},${_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["SELECT"]}`]: [{
        name: 'tooltip',
        options: {
            strategy: 'selectionSummary',
            order: 0,
            filter: context => context.config().mode === 'fragmented'
        }
    }],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["HIGHLIGHT"]]: [{
        name: 'highlighter',
        options: {
            strategy: 'highlight'
        }
    }, 'crossline', {
        name: 'tooltip',
        options: {
            order: 9999
        }
    }, 'anchors'],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["FILTER"]]: ['filter'],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["SELECT"]]: [{
        name: 'highlighter',
        options: {
            strategy: 'focus'
        }
    }, 'persistent-anchors']
};


/***/ }),

/***/ "./packages/muze-firebolt/src/enums/actions.js":
/*!*****************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/actions.js ***!
  \*****************************************************/
/*! exports provided: DRAG, HOVER, SELECTIONDRAG, CLICK, LONGTOUCH, TOUCHDRAG, ALL_ACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DRAG", function() { return DRAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOVER", function() { return HOVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTIONDRAG", function() { return SELECTIONDRAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLICK", function() { return CLICK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LONGTOUCH", function() { return LONGTOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCHDRAG", function() { return TOUCHDRAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALL_ACTIONS", function() { return ALL_ACTIONS; });
const DRAG = 'drag';
const HOVER = 'hover';
const SELECTIONDRAG = 'selectiondrag';
const CLICK = 'click';
const LONGTOUCH = 'longtouch';
const TOUCHDRAG = 'touchdrag';
const ALL_ACTIONS = '*';


/***/ }),

/***/ "./packages/muze-firebolt/src/enums/behaviours.js":
/*!********************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/behaviours.js ***!
  \********************************************************/
/*! exports provided: BRUSH, HIGHLIGHT, TOOLTIP, FILTER, SELECT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BRUSH", function() { return BRUSH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIGHLIGHT", function() { return HIGHLIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP", function() { return TOOLTIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILTER", function() { return FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT", function() { return SELECT; });
const BRUSH = 'brush';
const HIGHLIGHT = 'highlight';
const TOOLTIP = 'tooltip';
const FILTER = 'filter';
const SELECT = 'select';


/***/ }),

/***/ "./packages/muze-firebolt/src/enums/constants.js":
/*!*******************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/constants.js ***!
  \*******************************************************/
/*! exports provided: CLASSPREFIX, CONSOLIDATED, FRAGMENTED */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLIDATED", function() { return CONSOLIDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENTED", function() { return FRAGMENTED; });
const CLASSPREFIX = 'muze';
const CONSOLIDATED = 'consolidated';
const FRAGMENTED = 'fragmented';



/***/ }),

/***/ "./packages/muze-firebolt/src/enums/selection.js":
/*!*******************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/selection.js ***!
  \*******************************************************/
/*! exports provided: SELECTION_NEW_ENTRY, SELECTION_NEW_EXIT, SELECTION_NULL, SELECTION_OLD_ENTRY, SELECTION_OLD_EXIT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_NEW_ENTRY", function() { return SELECTION_NEW_ENTRY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_NEW_EXIT", function() { return SELECTION_NEW_EXIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_NULL", function() { return SELECTION_NULL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_OLD_ENTRY", function() { return SELECTION_OLD_ENTRY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_OLD_EXIT", function() { return SELECTION_OLD_EXIT; });
const SELECTION_NEW_ENTRY = 1;
const SELECTION_NEW_EXIT = -1;
const SELECTION_NULL = 0;
const SELECTION_OLD_ENTRY = 2;
const SELECTION_OLD_EXIT = -2;




/***/ }),

/***/ "./packages/muze-firebolt/src/enums/side-effects.js":
/*!**********************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/side-effects.js ***!
  \**********************************************************/
/*! exports provided: ANCHORS, BRUSH_ANCHORS, PERSISTENT_ANCHORS, FILTER, HIGHLIGHTER, CROSSLINE, TOOLTIP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANCHORS", function() { return ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BRUSH_ANCHORS", function() { return BRUSH_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PERSISTENT_ANCHORS", function() { return PERSISTENT_ANCHORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILTER", function() { return FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIGHLIGHTER", function() { return HIGHLIGHTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CROSSLINE", function() { return CROSSLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP", function() { return TOOLTIP; });
const ANCHORS = 'anchors';
const TOOLTIP = 'tooltip';
const BRUSH_ANCHORS = 'brush-anchors';
const PERSISTENT_ANCHORS = 'persistent-anchors';
const FILTER = 'filter';
const HIGHLIGHTER = 'highlighter';
const CROSSLINE = 'crossline';




/***/ }),

/***/ "./packages/muze-firebolt/src/enums/tooltip-strategies.js":
/*!****************************************************************!*\
  !*** ./packages/muze-firebolt/src/enums/tooltip-strategies.js ***!
  \****************************************************************/
/*! exports provided: SELECTION_SUMMARY, HIGHLIGHT_SUMMARY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTION_SUMMARY", function() { return SELECTION_SUMMARY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIGHLIGHT_SUMMARY", function() { return HIGHLIGHT_SUMMARY; });
const SELECTION_SUMMARY = 'selectionSummary';
const HIGHLIGHT_SUMMARY = 'highlightSummary';


/***/ }),

/***/ "./packages/muze-firebolt/src/firebolt.js":
/*!************************************************!*\
  !*** ./packages/muze-firebolt/src/firebolt.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Firebolt; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/actions */ "./packages/muze-firebolt/src/enums/actions.js");
/* harmony import */ var _selection_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selection-set */ "./packages/muze-firebolt/src/selection-set/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./packages/muze-firebolt/src/helper/index.js");





/**
 * This class is responsible for dispatching behavioural actions and side effects. It also keeps the information of
 * registered physical actions, behavioural actions and side effects. Also, it keeps the map of physical and behavioural
 * actions and behavioural actions and side effects. Whenever any behavioural action is dispatched, it also propagates
 * the rows which got affected to the other datamodels. This class is initialized by {@link VisualUnit} and legend to
 * manage it's interaction.
 *
 * @public
 * @class Firebolt
 * @module Firebolt
 */
class Firebolt {
    constructor (context, actions, sideEffects, behaviourEffectMap) {
        this.context = context;
        this._sideEffectDefinitions = {};
        this._sideEffects = {};
        this._propagationInf = {};
        this._actions = {
            behavioural: {},
            physical: {}
        };
        this._selectionSet = {};
        this._volatileSelectionSet = {};
        this._propagationFields = {};
        this._sourceSideEffects = {};
        this._propagationBehaviourMap = {};
        this._sourceBehaviours = {};
        this._actionBehaviourMap = {};
        this._config = {};
        this._behaviourEffectMap = {};
        this._entryExitSet = {};
        this._actionHistory = {};
        this._queuedSideEffects = {};

        this.mapSideEffects(behaviourEffectMap);
        this.registerBehaviouralActions(actions.behavioural);
        this.registerSideEffects(sideEffects);
        this.registerPhysicalBehaviouralMap(actions.physicalBehaviouralMap);
        this.registerPhysicalActions(actions.physical);
    }

    config (...config) {
        if (config.length) {
            this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._config, config[0]);
            Object(_helper__WEBPACK_IMPORTED_MODULE_3__["setSideEffectConfig"])(this.sideEffects(), this._config);
            return this;
        }
        return this._config;
    }

    mapSideEffects (behEffectMap) {
        const behaviourEffectMap = this._behaviourEffectMap;
        for (const key in behEffectMap) {
            if ({}.hasOwnProperty.call(behEffectMap, key)) {
                const sideEffects = behEffectMap[key] || [];
                let preventDefaultActions = false;
                let effectNames;
                if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(sideEffects)) {
                    effectNames = sideEffects.effects;
                    preventDefaultActions = sideEffects.preventDefaultActions;
                } else {
                    effectNames = sideEffects;
                }
                !behaviourEffectMap[key] && (behaviourEffectMap[key] = []);
                this._behaviourEffectMap[key] = [...new Set(preventDefaultActions ? effectNames :
                    [...behaviourEffectMap[key], ...effectNames])];
            }
        }
        return this;
    }

    registerBehaviouralActions (actions) {
        const behaviours = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["initializeBehaviouralActions"])(this, actions);
        this.prepareSelectionSets(behaviours);
        Object.assign(this._actions.behavioural, behaviours);
        return this;
    }

    prepareSelectionSets () {
        return this;
    }

    registerSideEffects (sideEffects) {
        for (const key in sideEffects) {
            this._sideEffectDefinitions[sideEffects[key].formalName()] = sideEffects[key];
        }
        this.initializeSideEffects();
        return this;
    }

    applySideEffects (sideEffects, selectionSet, payload) {
        const sideEffectStore = this.sideEffects();
        const actionHistory = this._actionHistory;
        const queuedSideEffects = this._queuedSideEffects;
        sideEffects.forEach((sideEffect) => {
            let options;
            let name;
            const effects = sideEffect.effects;
            const behaviours = sideEffect.behaviours;
            const combinedSet = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["unionSets"])(this, behaviours, selectionSet);
            effects.forEach((effect) => {
                if (typeof effect === 'object') {
                    name = effect.name;
                    options = effect.options;
                } else {
                    name = effect;
                }

                const sideEffectInstance = sideEffectStore[name];
                if (sideEffectInstance.isEnabled()) {
                    if (!sideEffectInstance.constructor.mutates() &&
                        Object.values(actionHistory).some(d => d.isMutableAction)) {
                        queuedSideEffects[`${name}-${behaviours.join()}`] = {
                            name,
                            params: [combinedSet, payload, options]
                        };
                    } else {
                        this.dispatchSideEffect(name, combinedSet, payload, options);
                    }
                }
            });
        });
        return this;
    }

    dispatchSideEffect (name, selectionSet, payload, options = {}) {
        const sideEffectStore = this.sideEffects();
        const sideEffect = sideEffectStore[name];
        let disable = false;
        if (options.filter && options.filter(sideEffect)) {
            disable = true;
        }
        !disable && sideEffectStore[name].apply(selectionSet, payload, options);
    }

    registerPropagationBehaviourMap (map) {
        this._propagationBehaviourMap = Object.assign(this._propagationBehaviourMap, map || {});
        return this;
    }

    dispatchBehaviour (behaviour, payload, propagationInfo = {}) {
        const propagate = propagationInfo.propagate !== undefined ? propagationInfo.propagate : true;
        const behaviouralActions = this._actions.behavioural;
        const action = behaviouralActions[behaviour];
        const behaviourEffectMap = this._behaviourEffectMap;
        const sideEffects = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getSideEffects"])(behaviour, behaviourEffectMap);
        this._propagationInf = propagationInfo;

        if (action) {
            const selectionSet = action.dispatch(payload);
            const propagationSelectionSet = this.getPropagationSelectionSet(selectionSet);
            this._entryExitSet[behaviour] = propagationSelectionSet;
            const shouldApplySideEffects = this.shouldApplySideEffects(propagate);

            if (propagate) {
                this.propagate(behaviour, payload, selectionSet.find(d => d.sourceSelectionSet), sideEffects);
            }
            if (shouldApplySideEffects) {
                const applicableSideEffects = this.getApplicableSideEffects(sideEffects, payload, propagationInfo);
                this.applySideEffects(applicableSideEffects, propagationSelectionSet, payload);
            }
        }

        return this;
    }

    getPropagationSelectionSet (selectionSet) {
        return selectionSet.find(d => !d.sourceSelectionSet);
    }

    shouldApplySideEffects () {
        return true;
    }

    changeBehaviourStateOnPropagation (behaviour, value, key = 'default') {
        const behaviourConditions = this._sourceBehaviours[behaviour] || (this._sourceBehaviours[behaviour] = {});
        if (value instanceof Function) {
            behaviourConditions[key] = value;
        } else {
            behaviourConditions[key] = () => value;
        }
        return this;
    }

    changeSideEffectStateOnPropagation (sideEffect, value, key = 'default') {
        const sideEffectConditions = this._sourceSideEffects[sideEffect] || (this._sourceSideEffects[sideEffect] = {});
        if (value instanceof Function) {
            sideEffectConditions[key] = value;
        } else {
            sideEffectConditions[key] = () => value;
        }
    }

    removeSideEffectPolicy (sideEffect, key) {
        delete this._sourceSideEffects[sideEffect][key];
        return this;
    }

    removeBehaviourPolicy (behaviour, key) {
        delete this._sourceBehaviours[behaviour][key];
        return this;
    }

    propagate () {
        return this;
    }

    sideEffects (...sideEffects) {
        if (sideEffects.length) {
            this._sideEffects = sideEffects[0];
            return this;
        }
        return this._sideEffects;
    }

    enableSideEffects (fn) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_3__["changeSideEffectAvailability"])(this, fn, true);
        return this;
    }

    disableSideEffects (fn) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_3__["changeSideEffectAvailability"])(this, fn, false);
        return this;
    }

    dissociateBehaviour (behaviour, physicalAction) {
        const actionBehaviourMap = this._actionBehaviourMap;
        for (const key in actionBehaviourMap) {
            if (key === physicalAction) {
                const behaviourMap = actionBehaviourMap[key];
                behaviourMap.behaviours = behaviourMap.behaviours.filter(d => d !== behaviour);
                this.mapActionsAndBehaviour(key);
            }
        }

        return this;
    }

    dissociateSideEffect (sideEffect, behaviour) {
        const behaviourEffectMap = this._behaviourEffectMap;
        behaviourEffectMap[behaviour] = behaviourEffectMap[behaviour].filter(d => (d.name || d) !== sideEffect);
        return this;
    }

    getApplicableSideEffects (sideEffects) {
        return sideEffects;
    }

    attachPropagationListener (dataModel) {
        dataModel.unsubscribe('propagation');
        dataModel.on('propagation', this.onDataModelPropagation());
        return this;
    }

    onDataModelPropagation () {
        return (propValue) => {
            const payload = propValue.payload;
            const action = payload.action;

            this.dispatchBehaviour(action, payload, {
                propagate: false
            });
        };
    }

    createSelectionSet (uniqueIds, behaviouralActions) {
        const behaviours = behaviouralActions || this._actions.behavioural;
        const selectionSet = this._selectionSet;
        const volatileSelectionSet = this._volatileSelectionSet;

        for (const key in behaviours) {
            if ({}.hasOwnProperty.call(behaviours, key)) {
                selectionSet[key] = new _selection_set__WEBPACK_IMPORTED_MODULE_2__["default"](uniqueIds);
                volatileSelectionSet[key] = new _selection_set__WEBPACK_IMPORTED_MODULE_2__["default"](uniqueIds, true);
                this._entryExitSet[key] = null;
            }
        }
        this._volatileSelectionSet = volatileSelectionSet;
        this.selectionSet(selectionSet);
        return this;
    }

    selectionSet (...selectionSet) {
        if (selectionSet.length) {
            this._selectionSet = selectionSet[0];
            return this;
        }
        return this._selectionSet;
    }

    initializeSideEffects () {
        const sideEffectDefinitions = this._sideEffectDefinitions;
        this.sideEffects(Object(_helper__WEBPACK_IMPORTED_MODULE_3__["initializeSideEffects"])(this, sideEffectDefinitions));
        return this;
    }

    registerPhysicalActions (actions) {
        const initedActions = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["initializePhysicalActions"])(this, actions);
        Object.assign(this._actions.physical, initedActions);
        return this;
    }

    /**
     * Allows to propagate the datamodel with only the supplied fields. When propagation is done, then the fields
     * which are supplied for the specified behavioural action is propagated.
     *
     * @public
     *
     * @param {string} action Name of behavioural action. If '*' is specified, then for all behavioural actions it is
     * applied.
     * @param {Array} fields Array of field names which will be propagated.
     * @param {boolean} append If true, then it is appended to the existing propagation data model fields else only
     * those fields are projected from propagation data model and propagated.
     *
     * @return {Firebolt} Instance of firebolt
     */
    propagateWith (action, fields, append = false) {
        const behaviouralActions = this._actions.behavioural;
        if (action === _enums_actions__WEBPACK_IMPORTED_MODULE_1__["ALL_ACTIONS"]) {
            for (const key in behaviouralActions) {
                this._propagationFields[key] = {
                    fields,
                    append
                };
            }
        } else {
            this._propagationFields[action] = {
                fields,
                append
            };
        }
        return this;
    }

    /**
     * Map actions and behaviours
     * @return {Firebolt} Firebolt instance
     */
    mapActionsAndBehaviour (phyAction) {
        const initedPhysicalActions = this._actions.physical;
        const map = this._actionBehaviourMap;

        for (const action in map) {
            if (!({}).hasOwnProperty.call(action, map) && action === (phyAction || action)) {
                let target;
                const mapObj = map[action];
                target = mapObj.target;
                const touch = mapObj.touch;
                if (!target) {
                    target = this.context.getDefaultTargetContainer();
                }
                const bind = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["hasTouch"])() ? touch === true || touch === undefined : !touch;
                bind && this.bindActionWithBehaviour(initedPhysicalActions[action],
                    target, mapObj.behaviours);
            }
        }
        return this;
    }

    registerPhysicalBehaviouralMap (map) {
        this._actionBehaviourMap = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._actionBehaviourMap, map);
        return this;
    }

    /**
     * Binds a target element with an action.
     *
     * @param {Function} action Action method
     * @param {string} target Class name of element
     * @param {Array} behaviourList Array of behaviours
     * @return {FireBolt} Instance of firebolt
     */
    bindActionWithBehaviour (action, targets, behaviourList) {
        if (typeof (targets) === 'string') {
            targets = [targets];
        }
        targets.forEach((target) => {
            const mount = this.context.mount();
            const nodes = target.node instanceof Function ? target : Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount).selectAll(target);
            if (!nodes.empty()) {
                if (nodes instanceof Array) {
                    nodes.forEach((node) => {
                        action(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(node), behaviourList);
                    });
                } else {
                    action(nodes, behaviourList);
                }
            }
        });
        return this;
    }

    getPropagationInf () {
        return this._propagationInf;
    }

    getAddSetFromCriteria (criteria, propagationInf = {}) {
        const context = this.context;
        const filteredDataModel = propagationInf.data ? propagationInf.data :
            context.getDataModelFromIdentifiers(criteria, 'all');
        return {
            model: filteredDataModel,
            uids: criteria === null ? null : (propagationInf.data ? propagationInf.entryRowIds :
                filteredDataModel[0].getUids())
        };
    }

    getSelectionSets (action) {
        const sourceId = this.context.id();
        const propagationInf = this._propagationInf || {};
        const propagationSource = propagationInf.sourceId;
        let applicableSelectionSets = [];
        if (propagationSource !== sourceId) {
            applicableSelectionSets = [this._volatileSelectionSet[action]];
        }

        if (propagationSource) {
            applicableSelectionSets.push(this.selectionSet()[action]);
        }
        return applicableSelectionSets;
    }

    getFullData () {
        return this.context.data();
    }

    resetted () {
        return this._resetted;
    }

    /**
     * Returns the entry and exit set information of the specified behavioural action.
     *
     * @public
     *
     * @param {string} behaviour Name of behavioural action.
     *
     * @return {Object} Entry exit set information.
     */
    getEntryExitSet (behaviour) {
        return this._entryExitSet[behaviour];
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/helper/index.js":
/*!****************************************************!*\
  !*** ./packages/muze-firebolt/src/helper/index.js ***!
  \****************************************************/
/*! exports provided: initializeSideEffects, setSideEffectConfig, initializeBehaviouralActions, initializePhysicalActions, changeSideEffectAvailability, getMergedSet, getSourceFields, getModelFromSet, getSetInfo, getSideEffects, unionSets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeSideEffects", function() { return initializeSideEffects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSideEffectConfig", function() { return setSideEffectConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeBehaviouralActions", function() { return initializeBehaviouralActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializePhysicalActions", function() { return initializePhysicalActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeSideEffectAvailability", function() { return changeSideEffectAvailability; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMergedSet", function() { return getMergedSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSourceFields", function() { return getSourceFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModelFromSet", function() { return getModelFromSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSetInfo", function() { return getSetInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSideEffects", function() { return getSideEffects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unionSets", function() { return unionSets; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/selection */ "./packages/muze-firebolt/src/enums/selection.js");



const initializeSideEffects = (context, sideEffects) => {
    const sideEffectsMap = context._sideEffects;
    sideEffects = sideEffects instanceof Array ? sideEffects : Object.values(sideEffects);
    sideEffects.forEach((SideEffect) => {
        const formalName = SideEffect.formalName();
        const sideEffectInstance = sideEffectsMap[formalName];
        sideEffectsMap[formalName] = sideEffectInstance || new SideEffect(context);
    });
    return sideEffectsMap;
};

const setSideEffectConfig = (sideEffects, config) => {
    for (const key in sideEffects) {
        const sideEffect = sideEffects[key];
        const formalName = sideEffect.constructor.formalName();
        const sideEffectConf = config[formalName];

        sideEffectConf && sideEffect.config(sideEffectConf);
    }
};

const initializeBehaviouralActions = (context, actions) => {
    const dispatchableBehaviours = {};

    actions = actions instanceof Array ? actions : Object.values(actions);
    actions.forEach((Action) => {
        dispatchableBehaviours[Action.formalName()] = new Action(context);
    });
    return dispatchableBehaviours;
};

const initializePhysicalActions = (context, actions) => {
    const physicalActions = {};

    for (const name in actions) {
        if (!({}).hasOwnProperty.call(name, actions)) {
            physicalActions[name] = actions[name](context);
        }
    }
    return physicalActions;
};

const changeSideEffectAvailability = (context, fn, toEnable) => {
    const sideEffects = context.sideEffects();
    for (const key in sideEffects) {
        if ({}.hasOwnProperty.call(sideEffects, key)) {
            let change = true;
            if (fn && fn(key) === false) {
                change = false;
            }
            if (change) {
                toEnable ? sideEffects[key].enable() : sideEffects[key].disable();
            }
        }
    }
};

const getMergedSet = set => [...new Set([...set[0], ...set[1]])];

const getSourceFields = (propagationInf, criteria = {}) => {
    const sourceIdentifiers = propagationInf.sourceIdentifiers;
    let sourceFields;
    if (sourceIdentifiers) {
        sourceFields = sourceIdentifiers.getSchema().map(d => d.name);
    } else if (criteria instanceof Array) {
        sourceFields = criteria[0];
    } else {
        sourceFields = Object.keys(criteria || {});
    }
    return sourceFields;
};

const conditionsMap = {
    mergedEnter: [_enums_selection__WEBPACK_IMPORTED_MODULE_1__["SELECTION_NEW_ENTRY"], _enums_selection__WEBPACK_IMPORTED_MODULE_1__["SELECTION_OLD_ENTRY"]],
    mergedExit: [_enums_selection__WEBPACK_IMPORTED_MODULE_1__["SELECTION_NEW_EXIT"], _enums_selection__WEBPACK_IMPORTED_MODULE_1__["SELECTION_OLD_EXIT"]],
    complete: []
};

const getModelFromSet = (type, model, set) => {
    const conditions = conditionsMap[type];
    if (model && conditions) {
        return model.select((fields, i) =>
           (conditions.some(condition => set[i] === condition)), {
               saveChild: false
           });
    }
    return null;
};

const getSetInfo = (type, set, config) => {
    let model = null;
    const filteredDataModel = config.filteredDataModel;
    const selectionSet = config.selectionSet;
    if (!config.propagationData) {
        if (selectionSet.resetted()) {
            model = null;
        } else if (type === 'mergedEnter') {
            model = getModelFromSet(type, config.dataModel, config.selectionSet._set);
        }
    } else if (filteredDataModel) {
        model = type === 'mergedEnter' ? filteredDataModel[0] : filteredDataModel[1];
    }
    return {
        uids: set,
        length: set.length,
        model
    };
};

const getSideEffects = (behaviour, behaviourEffectMap) => {
    const sideEffects = [];
    for (const key in behaviourEffectMap) {
        const behaviours = key.split(',');
        const found = behaviours.some(d => d === behaviour);
        if (found) {
            sideEffects.push({
                effects: behaviourEffectMap[key],
                behaviours
            });
        }
    }
    return sideEffects;
};

const unionSets = (context, behaviours) => {
    let combinedSet = {};
    const models = {
        mergedEnter: null,
        mergedExit: null
    };
    behaviours.forEach((behaviour) => {
        const entryExitSet = context._entryExitSet[behaviour];
        if (entryExitSet) {
            combinedSet = Object.assign(combinedSet, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(entryExitSet));
            ['mergedEnter', 'mergedExit'].forEach((type) => {
                const model = entryExitSet[type].model;
                let existingModel = models[type];
                let aggFns = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveNearestGroupByReducers"])(model);
                if (!existingModel) {
                    existingModel = models[type] = model;
                } else if (`${model.getSchema().map(d => d.name).sort()}` ===
                    `${existingModel.getSchema().map(d => d.name).sort()}`) {
                    aggFns = Object.assign({}, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveNearestGroupByReducers"])(existingModel));
                    existingModel = models[type] = model.union(existingModel);
                } else {
                    existingModel = model;
                }
                combinedSet[type].model = existingModel;
                combinedSet[type].aggFns = aggFns;
            });
        }
    });
    return combinedSet;
};


/***/ }),

/***/ "./packages/muze-firebolt/src/index.js":
/*!*********************************************!*\
  !*** ./packages/muze-firebolt/src/index.js ***!
  \*********************************************/
/*! exports provided: behaviouralActions, VolatileBehaviour, GenericBehaviour, PersistentBehaviour, physicalActions, Firebolt, BEHAVIOURS, ACTIONS, sideEffects, SelectionSet, behaviourEffectMap, SurrogateSideEffect, SpawnableSideEffect, GenericSideEffect, SELECTION, SIDE_EFFECTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebolt */ "./packages/muze-firebolt/src/firebolt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Firebolt", function() { return _firebolt__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _actions_behavioural__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions/behavioural */ "./packages/muze-firebolt/src/actions/behavioural/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "behaviouralActions", function() { return _actions_behavioural__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _actions_behavioural_persistent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions/behavioural/persistent */ "./packages/muze-firebolt/src/actions/behavioural/persistent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PersistentBehaviour", function() { return _actions_behavioural_persistent__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _actions_behavioural_generic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/behavioural/generic */ "./packages/muze-firebolt/src/actions/behavioural/generic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GenericBehaviour", function() { return _actions_behavioural_generic__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _actions_behavioural_volatile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions/behavioural/volatile */ "./packages/muze-firebolt/src/actions/behavioural/volatile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VolatileBehaviour", function() { return _actions_behavioural_volatile__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _actions_physical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions/physical */ "./packages/muze-firebolt/src/actions/physical/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "physicalActions", function() { return _actions_physical__WEBPACK_IMPORTED_MODULE_5__["physicalActions"]; });

/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enums/behaviours */ "./packages/muze-firebolt/src/enums/behaviours.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "BEHAVIOURS", function() { return _enums_behaviours__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _enums_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums/actions */ "./packages/muze-firebolt/src/enums/actions.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ACTIONS", function() { return _enums_actions__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _enums_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./enums/selection */ "./packages/muze-firebolt/src/enums/selection.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SELECTION", function() { return _enums_selection__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SIDE_EFFECTS", function() { return _enums_side_effects__WEBPACK_IMPORTED_MODULE_9__; });
/* harmony import */ var _side_effects_surrogate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./side-effects/surrogate */ "./packages/muze-firebolt/src/side-effects/surrogate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SurrogateSideEffect", function() { return _side_effects_surrogate__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _side_effects_spawnable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./side-effects/spawnable */ "./packages/muze-firebolt/src/side-effects/spawnable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpawnableSideEffect", function() { return _side_effects_spawnable__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _side_effects_generic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./side-effects/generic */ "./packages/muze-firebolt/src/side-effects/generic/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GenericSideEffect", function() { return _side_effects_generic__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _side_effects__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./side-effects */ "./packages/muze-firebolt/src/side-effects/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "sideEffects", function() { return _side_effects__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _selection_set__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./selection-set */ "./packages/muze-firebolt/src/selection-set/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectionSet", function() { return _selection_set__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _behaviour_effect_map__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./behaviour-effect-map */ "./packages/muze-firebolt/src/behaviour-effect-map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "behaviourEffectMap", function() { return _behaviour_effect_map__WEBPACK_IMPORTED_MODULE_15__["behaviourEffectMap"]; });





















/***/ }),

/***/ "./packages/muze-firebolt/src/selection-set/index.js":
/*!***********************************************************!*\
  !*** ./packages/muze-firebolt/src/selection-set/index.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_set__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection-set */ "./packages/muze-firebolt/src/selection-set/selection-set.js");


/* harmony default export */ __webpack_exports__["default"] = (_selection_set__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./packages/muze-firebolt/src/selection-set/selection-set.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-firebolt/src/selection-set/selection-set.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/selection */ "./packages/muze-firebolt/src/enums/selection.js");

/* eslint-disable guard-for-in */

/**
 * This component is used to keep track of the row tuples of the data which gets added and removed. This keeps
 * information of which rows are in previous and new entry set and previous and new exit set. This is initialized by
 * {@link Firebolt}.
 *
 * @public
 *
 * @class SelectionSet
 */
class SelectionSet {
    /**
     * Creates an instance of selection set
     *
     * @param {Array.<string>} completeSet Set of unique ids.
     */
    constructor (completeSet, _volatile) {
        this.completeSet = completeSet;
        this._set = completeSet.reduce((obj, key) => {
            obj[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NULL"];
            return obj;
        }, {});
        this._volatile = _volatile;
        this._completeSetCount = completeSet.length;
        this._lockedSelection = {};
        this._resetted = true;
    }

    /**
     * Adds a set of ids to the selection set. This also moves the other rows to exit set.
     *
     * @public
     * @param {Array.<number|string>} ids Array of unique ids.
     *
     * @return {SelectionSet} Instance of selection set.
     */
    add (ids) {
        this._resetted = false;

        const set = this._set;
        // from exitset to entryset
        ids.forEach((i) => {
            set[i] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"];
        });

        for (const key in set) {
            if (set[key] !== _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] && set[key] !== _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"]) {
                set[key] = set[key] < 0 ? _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"] : _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"];
            }
        }
        return this;
    }

    /**
     * Adds an array of ids to the old entry set.
     *
     * @param {Array.<number|string>} ids Array of unique ids
     *
     * @return {SelectionSet} Instance of selection set.
     */
    update (ids) {
        const set = this._set;
        // from exitset to entryset
        ids.forEach((i) => {
            set[i] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"];
        });

        return this;
    }

    /**
     * Moves all ids which in new entry set  to old entry set.
     *
     * @public
     * @param {Array.<number|string>} ids Array of unique ids
     *
     * @return {SelectionSet} Instance of selection set.
     */
    updateEntry () {
        const set = this._set;

        // from exitset to entryset
        for (const key in set) {
            set[key] = set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] ? _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"] : set[key];
        }
        return this;
    }

    /**
     * Moves an array of ids which are in new exit set to old exit set.
     *
     * @public
     *
     * @param {Array.<number|string>} ids Array of unique ids.
     *
     * @return {SelectionSet} Instance of selection set.
     */
    updateExit () {
        const set = this._set;
        // from exitset to entryset
        for (const key in set) {
            set[key] = set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"] ? _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"] : set[key];
        }
        return this;
    }

    /**
     * Removes an array of ids from the selection set. It also moves the remaining row ids to entry set.
     *
     * @public
     * @param {Array.<string>} ids Array of unique ids
     *
     * @return {SelectionSet}  Instance of selection set
     */
    remove (ids) {
        this._resetted = false;

        const set = this._set;
        ids.forEach((i) => {
            set[i] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"];
        });

        for (const key in set) {
            if (set[key] !== _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"] && set[key] !== _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"]) {
                set[key] = set[key] === 0 ? _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] : _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"];
            }
        }

        return this;
    }

    getSets () {
        const set = this._set;
        const retObj = {
            entrySet: [[], []],
            exitSet: [[], []],
            completeSet: []
        };

        for (const key in set) {
            if (set[key] > 0) {
                set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"] && retObj.entrySet[0].push(key);
                set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] && retObj.entrySet[1].push(key);
            } else if (set[key] < 0) {
                set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"] && retObj.exitSet[0].push(key);
                set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"] && retObj.exitSet[1].push(key);
            }
            retObj.completeSet.push(key);
        }

        ['entrySet', 'exitSet'].forEach((type) => {
            retObj[type] = retObj[type].map(e => e.map(Number));
        });
        retObj.completeSet = retObj.completeSet.map(Number);

        return retObj;
    }

    /**
     * Resets an array of ids in the selection set to initial state. It sets the value of every unique id value to
     * null in the selection set which means they are neither in entry set nor in exit set. If no ids are passed,
     * then it resets all the ids to null.
     *
     * @public
     *
     * @param {Array} ids Array of unique ids.
     * @return {SelectionSet} Instance of selection set.
     */
    reset (ids) {
        const set = this._set;
        if (ids) {
            ids.forEach((i) => {
                set[i] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NULL"];
            });
        } else {
            const lockedSel = this._lockedSelection;
            for (const key in set) {
                if (!(key in lockedSel)) {
                    set[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NULL"];
                }
            }
        }
        this._resetted = true;
        return this;
    }

    /**
     * Gets the set of ids which are added in the selection set.
     *
     * @public
     *
     * @return {Array.<string>} Array of unique ids
     */
    getEntrySet () {
        const set = this._set;
        const addSet = [];

        for (const key in set) {
            set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] && addSet.push(key);
        }

        return addSet;
    }

    /**
     * Returns a set of unique ids which are already present in entry set.
     *
     * @public
     * @param {Array} addSet Array of unique ids which are added
     *
     * @return {Array} Array of unique ids which are already in old entry set or new entry set
     */
    getExistingEntrySet (addSet) {
        const set = this._set;
        return addSet.filter(d => set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"] || set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"]);
    }

    /**
     * Returns a set of unique ids which are already present in exit set.
     *
     * @public
     * @param {Array} addSet Array of unique ids which are added
     *
     * @return {Array} Array of unique ids which are already in old exit set or new exit set
     */
    getExistingExitSet (removeSet) {
        const set = this._set;
        return removeSet.filter(d => set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"] || set[d] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"]);
    }

    /**
     * Gets the set of ids which are added in the selection set.
     * @return {Array.<string>} Array of unique ids
     */
    getOldEntry () {
        const set = this._set;
        const updateSet = [];

        for (const key in set) {
            set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"] && updateSet.push(key);
        }
        return updateSet;
    }

    /**
     * Gets the set of ids which are added in the selection set.
     * @return {Array.<string>} Array of unique ids
     */
    getOldExit () {
        const set = this._set;
        const updateSet = [];

        for (const key in set) {
            set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"] && updateSet.push(key);
        }

        return updateSet;
    }

    /**
     * Gets the array of ids which are in the exit set.
     *
     * @public
     * @return {Array.<string>} Array of unique ids
     */
    getExitSet () {
        const set = this._set;
        const removeSet = [];

        for (const key in set) {
            set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"] && removeSet.push(key);
        }
        return removeSet;
    }

    /**
     * Gets all the ids which are either in exit or entry set.
     *
     * @public
     * @return {Array} Array of unique ids
     */
    getCompleteSet () {
        const set = this._set;
        const completeSet = [];

        for (const key in set) {
            completeSet.push(key);
        }

        return completeSet;
    }

    getCompleteSetCount () {
        return this._completeSetCount;
    }

    resetted () {
        return this._resetted;
    }

    /**
     * Swaps the add set and remove set in the selection set.
     * @return {SelectionSet} Instance of selection set.
     */
    toggle () {
        const set = this._set;

        for (const key in set) {
            if (set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"]) {
                set[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"];
            } else if (set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_EXIT"]) {
                set[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_NEW_ENTRY"];
            } else if (set[key] === _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"]) {
                set[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_EXIT"];
            } else {
                set[key] = _enums_selection__WEBPACK_IMPORTED_MODULE_0__["SELECTION_OLD_ENTRY"];
            }
        }

        return this;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SelectionSet);


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/anchors/index.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/anchors/index.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnchorEffect; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");
/* harmony import */ var _spawnable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../spawnable */ "./packages/muze-firebolt/src/side-effects/spawnable.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-firebolt/src/side-effects/anchors/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_4__);







const addLayer = (layerRegistry, context, sideEffect) => {
    context.addLayer((layerDefs) => {
        const layers = [];

        if (layerDefs) {
            layerDefs.forEach((layerDef) => {
                const mark = layerDef.mark;
                const layerCls = layerRegistry[mark];

                if (layerCls && layerCls.shouldDrawAnchors()) {
                    const depLayerEncoding = layerDef.def.encoding;
                    const encoding = {
                        x: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(depLayerEncoding, 'x', 'field'),
                        y: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(depLayerEncoding, 'y', 'field'),
                        color: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(depLayerEncoding, 'color', 'field'),
                        size: {
                            field: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(depLayerEncoding, 'size', 'field'),
                            value: sideEffect.defaultSizeValue()
                        }
                    };
                    const commonName = sideEffect.constructor.formalName();
                    const name = `${layerDef.def.name}-${commonName}`;

                    layers.push({
                        name,
                        mark: 'point',
                        groupId: commonName,
                        className: sideEffect.constructor.defaultConfig().className,
                        encoding,
                        transform: {
                            type: 'identity'
                        },
                        calculateDomain: false,
                        transition: sideEffect.getTransitionConfig(),
                        source: dm => dm.select(() => false, {
                            saveChild: false
                        }),
                        interactive: false,
                        owner: layerDef.def.name
                    });
                }
            });
        }
        return layers;
    });
};

class AnchorEffect extends _spawnable__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor (...params) {
        super(...params);
        this._layersMap = {};
        this.addAnchorLayers();
    }

    static target () {
        return 'visual-unit';
    }

    static defaultConfig () {
        return {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-anchors-group`
        };
    }

    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__["ANCHORS"];
    }

    addAnchorLayers () {
        const context = this.firebolt.context;
        const layerRegistry = context.registry().layerRegistry;

        addLayer(layerRegistry, context, this);
        return this;
    }

    getTransitionConfig () {
        return {
            disabled: true
        };
    }

    /**
     * Returns the default area value of the anchor point.
     * @return { number } Default area value of anchor.
     */
    defaultSizeValue () {
        return 100;
    }

    apply (selectionSet) {
        const dataModel = selectionSet.mergedEnter.model;
        const formalName = this.constructor.formalName();

        const context = this.firebolt.context;
        const layers = context.layers().filter(layer => layer.config().groupId === formalName);

        layers.forEach((layer) => {
            const linkedLayer = context.getLayerByName(layer.config().owner);
            const [transformedData, schema] = linkedLayer.getTransformedDataFromIdentifiers(dataModel);
            const transformedDataModel = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"](transformedData, schema);

            layer.data(transformedDataModel);
        });
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/anchors/styles.scss":
/*!*********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/anchors/styles.scss ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/brush-anchors.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/brush-anchors.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BrushAnchors; });
/* harmony import */ var _anchors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anchors */ "./packages/muze-firebolt/src/side-effects/anchors/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");




class BrushAnchors extends _anchors__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__["BRUSH_ANCHORS"];
    }

    static defaultConfig () {
        return {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-brush-anchors`
        };
    }

    getTransitionConfig () {
        return {
            disabled: true
        };
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/crossline/index.js":
/*!********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/crossline/index.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Crossline; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-firebolt/src/side-effects/crossline/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");
/* harmony import */ var _spawnable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../spawnable */ "./packages/muze-firebolt/src/side-effects/spawnable.js");







class Crossline extends _spawnable__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static defaultConfig () {
        return {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_2__["CLASSPREFIX"]}-crossline-group`,
            bandClass: `${_enums_constants__WEBPACK_IMPORTED_MODULE_2__["CLASSPREFIX"]}-crossband`,
            lineClass: `${_enums_constants__WEBPACK_IMPORTED_MODULE_2__["CLASSPREFIX"]}-crossline`
        };
    }

    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_3__["CROSSLINE"];
    }

    apply (selectionSet, payload) {
        let height;
        let bandWidth;
        let px;
        let width;
        const {
            className,
            bandClass,
            lineClass
        } = this.config();
        const dataModel = selectionSet.mergedEnter.model;
        const drawingInf = this.drawingContext();
        if (payload.criteria && dataModel && dataModel.isEmpty()) {
            return this;
        }
        if (payload.criteria === null || !dataModel) {
            this.hide();
            return this;
        }

        const dataObj = dataModel.getData();
        const sourceInf = this.firebolt.context.getSourceInfo();
        const axes = sourceInf.axes;
        const axisFields = sourceInf.fields;
        const fields = selectionSet.fields;
        const data = dataObj.data;
        const fieldsConfig = dataModel.getFieldsConfig();
        const svgContainer = drawingInf.sideEffectGroup;

        const elemData = [];
        fields.forEach((field) => {
            const fieldIndex = fieldsConfig[field] && fieldsConfig[field].index;
            const dataArr = data.map(d => d[fieldIndex]);
            const axisIndex = [['x', 0], ['x', 1], ['y', 0], ['y', 1]].find((arr) => {
                const fieldInst = axisFields[arr[0]][arr[1]];
                return fieldInst && fieldInst.type() === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION &&
                    fieldInst.getMembers().indexOf(field) !== -1;
            });
            if (axisIndex !== undefined && data.length) {
                const type = axisIndex[0];
                const axis = axes[type][axisIndex[1]];
                const value = dataArr[0];
                bandWidth = axis.getUnitWidth() || 0;
                px = axis.getScaleValue(value) + bandWidth / 2 + drawingInf.xOffset;
                const layers = this.firebolt.context.layers();
                const plotWidth = Math.max(...layers.map(layer => layer.getPlotSpan()[type]));
                const pad = Math.max(...layers.map(layer => layer.getPlotPadding()[type]));
                height = drawingInf.height;
                width = drawingInf.width;
                const startPx = px - plotWidth / 2 - pad / 2;
                const endPx = px + plotWidth / 2 + pad / 2;
                const dataPoint = {};
                if (type === 'y') {
                    dataPoint.d = `M 0 ${startPx} L 0 ${endPx} L ${width} ${endPx} L ${width} ${startPx} Z`;
                } else {
                    dataPoint.d = `M ${startPx} 0 L ${endPx} 0 L ${endPx} ${height} L ${startPx} ${height} Z`;
                }
                dataPoint.className = plotWidth ? bandClass : lineClass;
                !isNaN(px) && elemData.push(dataPoint);
            }
        });
        if (elemData.length) {
            const parentGroup = this.createElement(svgContainer, 'g', [1], className);
            const elem = this.createElement(parentGroup, 'path', elemData);
            elem.attr('d', d => d.d).style('pointer-events', 'none')
                            .attr('class', d => d.className);
        }
        return this;
    }

    hide () {
        const className = this.config().className;
        const drawingInf = this.drawingContext();
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(drawingInf.sideEffectGroup).selectAll(`.${className}`).remove();
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/crossline/styles.scss":
/*!***********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/crossline/styles.scss ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/filter/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/filter/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FilterEffect; });
/* harmony import */ var _surrogate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../surrogate */ "./packages/muze-firebolt/src/side-effects/surrogate.js");


class FilterEffect extends _surrogate__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return 'filter';
    }

    static target () {
        return 'visual-unit';
    }

    static mutates () {
        return true;
    }

    apply (selectionSet, payload) {
        const context = this.firebolt.context;
        const entryModel = selectionSet.mergedEnter.model;
        if (payload.criteria === null) {
            context.clearCaching().resetData();
        } else {
            context.enableCaching().data(entryModel);
        }
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/generic/generic-sideeffect.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/generic/generic-sideeffect.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GenericSideEffect; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./props */ "./packages/muze-firebolt/src/side-effects/generic/props.js");



/**
 * This is the base class of all side effects. It contains all common methods like setting configuration, disabling,
 * enabling side effect, etc. Every new side effect has to inherit this class or {@link SpawnableSideEffect} or
 * {@link SurrogateSideEffect} class. All side effects are initialized by firebolt. The instance of firebolt is
 * passed on initialization. The firebolt instance contains ```context``` which is the instance of visual unit with
 * which the firebolt is attached.
 *
 * @public
 * @class
 * @module GenericSideEffect
 */
class GenericSideEffect {
    constructor (firebolt) {
        this.firebolt = firebolt;
        this._enabled = true;
        this._strategy = 'default';
        this._config = {};
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._strategies = {};
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_1__["PROPS"]);
        this.config(this.constructor.defaultConfig());
    }

    /**
     * Returns the default configuration of the side effect.
     *
     * @public
     * @return {Object} Default configuration of side effect.
     */
    static defaultConfig () {
        return {};
    }

    /**
     * Returns the formal name of a side effect. This method must be implemented by all side effects which changes
     * or adds any element in the visualization.
     *
     * @return {string} Formal name of side effect.
     */
    static formalName () {
        return 'generic';
    }

    static target () {
        return 'all';
    }

    /**
     * Returns true if the side effects mutates the data of chart.
     *
     * @public
     *
     * @return {boolean} If the side effect mutates the data of chart.
     */
    static mutates () {
        return false;
    }

    /**
     * Sets or gets the configuration of side effect.
     *
     * When setter,
     * @param {Object} config Configuration of side effect.
     * @return {GenericSideEffect} Side effect instance.
     *
     * When getter,
     * @return {Object} Side effect configuration.
     */
    config (...params) {
        if (params.length) {
            this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._config, params[0]);
            return this;
        }
        return this._config;
    }

    disable () {
        this._enabled = false;
        return this;
    }

    enable () {
        this._enabled = true;
        return this;
    }

    isEnabled () {
        return this._enabled;
    }

    /**
     * Applies the interaction effect on the chart. This is where the implemntation of the side effect is defined.
     *
     * @param {Object} selectionSet Contains the entry and exit set of data which got affected during interaction.
     * @param {Object} selectionSet.mergedEnter Combined previous entry and new entry set.
     * @param {DataModel} selectionSet.mergedEnter.model Instance of data model containing all rows which got
     * affected during interaction.
     * @param {Array} selectionSet.mergedEnter.uids Ids of all rows which were affected during interaction.
     * @param {Object} selectionSet.mergedExit Combined previous exit and new exit set.
     * @param {DataModel} selectionSet.mergedExit.model Instance of data model containing rows which were not affected
     * during interaction.
     * @param {Array} selectionSet.mergedExit.uids Ids of all rows which were not affected during interaction.
     * @param {Object} selectionSet.entrySet Entry set information.
     * @param {Array} selectionSet.entrySet[0].uids All row ids which got affected during previous interaction.
     * @param {Array} selectionSet.entrySet[1].uids All row ids which got affected during current interaction.
     * @param {Array} selectionSet.exitSet[0].uids All row ids which were not affected during previous interaction.
     * @param {Array} selectionSet.exitSet[1].uids All row ids which were not affected during current interaction.
     * @param {Object} payload Payload information of the behavioural action on trigger of which this side effect
     * is applied.
     * @param {Object} options Optional information for side effect like strategy, etc.
     */
    apply () {
        return this;
    }

    /**
     * Adds a new strategy method for this side effect. The strategy method is implemented by side effect class.
     *
     * @param {string} name Name of the strategy.
     * @param {Function} fn Strategy method.
     *
     * @return {GenericSideEffect} Instance of side effect.
     */
    setStrategy (name, fn) {
        if (fn) {
            this._strategies[name] = fn;
        }
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/generic/index.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/generic/index.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _generic_sideeffect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generic-sideeffect */ "./packages/muze-firebolt/src/side-effects/generic/generic-sideeffect.js");


/* harmony default export */ __webpack_exports__["default"] = (_generic_sideeffect__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/generic/props.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/generic/props.js ***!
  \******************************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
const PROPS = {
    valueParser: {
        defaultValue: val => val
    }
};


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/helper/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/helper/index.js ***!
  \*****************************************************************/
/*! exports provided: spaceOutBoxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceOutBoxes", function() { return spaceOutBoxes; });
const spaceOutBoxes = (boxes, extent, showVertically) => {
    let y;
    let height;
    let x;
    let width;
    let i;
    const pad = 5;
    const len = boxes.length;
    const spaceOutIfOverlap = (firstBox, secondBox, opposite) => {
        x = firstBox.x;
        width = firstBox.width;
        y = firstBox.y;
        height = firstBox.height;
        const bottom = y + height;
        const right = x + width;

        if (showVertically) {
            if (opposite ? y < (secondBox.y + secondBox.height) : bottom > secondBox.y) {
                secondBox.y = opposite ? firstBox.y - secondBox.height - pad :
                        bottom + pad;
            }
        } else if (opposite ? x < (secondBox.x + secondBox.width) : right > secondBox.x) {
            secondBox.x = opposite ? firstBox.x - secondBox.width - pad :
                    right + pad;
        }
    };

    boxes.sort((a, b) => (showVertically ? a.y - b.y : a.x - b.x));
    i = 0;

    for (i = 0; i < len - 1; i++) {
        spaceOutIfOverlap(boxes[i], boxes[i + 1]);
    }

    if ((boxes[i].y + boxes[i].height) > extent.height ||
            (boxes[i].x + boxes[i].width) > extent.width) {
        if (showVertically) {
            boxes[i].y -= (boxes[i].height + boxes[i].y) - extent.height;
        } else {
            boxes[i].x -= (boxes[i].width + boxes[i].x) - extent.width;
        }
        for (i = len - 1; i > 0; i--) {
            spaceOutIfOverlap(boxes[i], boxes[i - 1], true);
        }
    }
    return boxes;
}
;


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/index.js":
/*!**********************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/index.js ***!
  \**********************************************************/
/*! exports provided: SelectionBox, Tooltip, Crossline, PlotHighlighter, FilterEffect, PersistentAnchors, BrushAnchors, AnchorEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection-box */ "./packages/muze-firebolt/src/side-effects/selection-box/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectionBox", function() { return _selection_box__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tooltip */ "./packages/muze-firebolt/src/side-effects/tooltip/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return _tooltip__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _crossline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crossline */ "./packages/muze-firebolt/src/side-effects/crossline/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Crossline", function() { return _crossline__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _plot_highlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plot-highlighter */ "./packages/muze-firebolt/src/side-effects/plot-highlighter/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlotHighlighter", function() { return _plot_highlighter__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter */ "./packages/muze-firebolt/src/side-effects/filter/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FilterEffect", function() { return _filter__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _persistent_anchors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./persistent-anchors */ "./packages/muze-firebolt/src/side-effects/persistent-anchors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PersistentAnchors", function() { return _persistent_anchors__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _brush_anchors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./brush-anchors */ "./packages/muze-firebolt/src/side-effects/brush-anchors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BrushAnchors", function() { return _brush_anchors__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _anchors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./anchors */ "./packages/muze-firebolt/src/side-effects/anchors/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnchorEffect", function() { return _anchors__WEBPACK_IMPORTED_MODULE_7__["default"]; });











/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/persistent-anchors.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/persistent-anchors.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PersistentAnchors; });
/* harmony import */ var _anchors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anchors */ "./packages/muze-firebolt/src/side-effects/anchors/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");




class PersistentAnchors extends _anchors__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__["PERSISTENT_ANCHORS"];
    }

    static defaultConfig () {
        return {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-persistent-anchors`
        };
    }

    getTransitionConfig () {
        return {
            disabled: true
        };
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/plot-highlighter/index.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/plot-highlighter/index.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PlotHighlighter; });
/* harmony import */ var _surrogate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../surrogate */ "./packages/muze-firebolt/src/side-effects/surrogate.js");
/* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strategy */ "./packages/muze-firebolt/src/side-effects/plot-highlighter/strategy.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");




class PlotHighlighter extends _surrogate__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (...params) {
        super(...params);
        this._strategy = 'highlight';
        this._strategies = _strategy__WEBPACK_IMPORTED_MODULE_1__["strategies"];
    }

    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__["HIGHLIGHTER"];
    }

    static target () {
        return 'visual-unit';
    }

    apply (selectionSet, payload, options = {}) {
        const strategy = this._strategies[options.strategy || this._strategy];

        strategy(selectionSet, this, options.strategy || this._strategy);

        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/plot-highlighter/strategy.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/plot-highlighter/strategy.js ***!
  \******************************************************************************/
/*! exports provided: strategies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strategies", function() { return strategies; });
const fadeFn = (set, context, strategy) => {
    const {
        mergedEnter,
        mergedExit,
        exitSet,
        completeSet
    } = set;

    if (!mergedEnter.length && !mergedExit.length) {
        context.applyInteractionStyle(completeSet, {}, strategy, false);
    } else {
        context.applyInteractionStyle(exitSet[1], {}, strategy, true);
        context.applyInteractionStyle(mergedEnter, {}, strategy, false);
    }
};

const strategies = {
    fade: fadeFn,
    focus: (set, context) => {
        const {
            mergedEnter,
            mergedExit,
            completeSet
        } = set;
        if (!mergedEnter.length && !mergedExit.length) {
            context.applyInteractionStyle(completeSet, {}, 'focus', false);
        } else {
            context.applyInteractionStyle(mergedExit, {}, 'focus', true);
            context.applyInteractionStyle(mergedEnter, {}, 'focus', false);
        }
    },
    highlight: (set, context) => {
        const {
            mergedEnter,
            mergedExit,
            entrySet,
            exitSet,
            completeSet
        } = set;
        if (!mergedEnter.length && !mergedExit.length) {
            context.applyInteractionStyle(completeSet, {}, 'highlight', false);
        } else {
            context.applyInteractionStyle(entrySet[1], {}, 'highlight', true);
            context.applyInteractionStyle(exitSet[1], {}, 'highlight', false);
        }
    }
};


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/selection-box/helper.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/selection-box/helper.js ***!
  \*************************************************************************/
/*! exports provided: getBoxDimensionsFromPayload, changeVisibility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoxDimensionsFromPayload", function() { return getBoxDimensionsFromPayload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeVisibility", function() { return changeVisibility; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const getBoxDimensionsFromPayload = (payload, axes, axisFields) => {
    let x1;
    let x2;
    let y1;
    let y2;
    let xRange;
    let yRange;
    let direction;
    const criteria = payload.criteria;
    const dimensions = payload.dimensions || {};
    const xDim = dimensions.x;
    const yDim = dimensions.y;

    if (criteria === null) {
        return null;
    }

    const xAxis = axes.x[0];
    const yAxis = axes.y[0];
    const xLinear = xAxis.constructor.type() === 'linear';
    const yLinear = yAxis.constructor.type() === 'linear';
    const xField = `${axisFields.x[0]}`;
    const yField = `${axisFields.y[0]}`;
    const xCriteria = criteria[xField];
    const yCriteria = criteria[yField];

    if (xCriteria && xCriteria[0] instanceof Array) {
        xRange = xCriteria[0];
        yRange = xCriteria[1];
    } else {
        xRange = xCriteria || [];
        yRange = yCriteria || [];
    }
    direction = xCriteria && yCriteria ? 'both' : (xCriteria ? 'vertical' : 'horizontal');
    if (xRange && xRange.length) {
        if ((yAxis.constructor.type() === 'band' && xLinear)) {
            x1 = x2 = undefined;
            direction = 'horizontal';
        } else {
            const domain = xAxis.domain();
            const bandScale = xAxis.constructor.type() === 'band';
            let x1Val;
            let x2Val;
            if (bandScale) {
                let x1DomainIndex = domain.indexOf(xRange[0]);
                let x2DomainIndex = domain.indexOf(xRange[xRange.length - 1]);
                [x1DomainIndex, x2DomainIndex] = [x1DomainIndex, x2DomainIndex].sort((a, b) => a - b);
                x1Val = domain[x1DomainIndex];
                x2Val = domain[x2DomainIndex];
            } else {
                x1Val = xRange[0];
                x2Val = xRange[xRange.length - 1];
            }
            x1 = xAxis.getScaleValue(x1Val);
            x2 = xAxis.getScaleValue(x2Val);
            x2 += bandScale ? xAxis.getUnitWidth() : 0;
        }
    } else {
        x1 = x2 = undefined;
    }
    if (yRange && yRange.length) {
        if ((xAxis.constructor.type() === 'band' && yLinear)) {
            y1 = y2 = undefined;
            direction = 'vertical';
        } else {
            const domain = yAxis.domain();
            const bandScale = yAxis.constructor.type() === 'band';
            let y1Val;
            let y2Val;
            if (bandScale) {
                let y1DomainIndex = domain.indexOf(yRange[0]);
                let y2DomainIndex = domain.indexOf(yRange[yRange.length - 1]);
                [y1DomainIndex, y2DomainIndex] = [y1DomainIndex, y2DomainIndex].sort(((a, b) => b - a));
                y1Val = domain[y1DomainIndex];
                y2Val = domain[y2DomainIndex];
            } else {
                y1Val = yRange[0];
                y2Val = yRange[yRange.length - 1];
            }
            y1 = yAxis.getScaleValue(y1Val);
            y2 = yAxis.getScaleValue(y2Val);
            y2 += yAxis.constructor.type() === 'band' ? yAxis.getUnitWidth() : 0;
        }
    } else {
        y1 = y2 = undefined;
    }

    if ((yLinear && xLinear) || !payload.dragEnd) {
        if (xDim) {
            [x1, x2] = xDim;
        }
        if (yDim) {
            [y1, y2] = yDim;
        }
    }

    return {
        dimension: {
            x1,
            x2,
            y1,
            y2
        },
        direction
    };
};

const changeVisibility = (context, sideEffectGroup, visible) => {
    const config = context.config();
    const className = config.defClassName;
    const classPrefix = config.classPrefix;
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(sideEffectGroup).selectAll(`.${classPrefix}-${className}`)
                    .style('display', visible ? 'block' : 'none');
};


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/selection-box/index.js":
/*!************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/selection-box/index.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-firebolt/src/side-effects/selection-box/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _spawnable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../spawnable */ "./packages/muze-firebolt/src/side-effects/spawnable.js");
/* harmony import */ var _actions_physical_selection_box_drag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../actions/physical/selection-box-drag */ "./packages/muze-firebolt/src/actions/physical/selection-box-drag.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper */ "./packages/muze-firebolt/src/side-effects/selection-box/helper.js");







/**
 * This class is used to create a selection box which is used by visual unit for brushing and
 * selection in the canvas.
 * @class SelectionBox
 */
class SelectionBox extends _spawnable__WEBPACK_IMPORTED_MODULE_3__["default"] {
    /**
     * It returns the default configuration needed by selectionbox.
     * @return {Object} Default configuration of the selection box.
     */
    static defaultConfig () {
        return {
            defClassName: 'selection-box-group',
            className: '',
            classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"],
            box: {
                defClassName: 'selection-box',
                className: ''
            },
            transition: {
                duration: 200
            }
        };
    }

    static formalName () {
        return 'selectionBox';
    }

    /**
     * Draws the selectionbox with the specified dimensions.
     * @param {Object} dimension Dimensions of the selection box.
     * @param {number} dimension.x1 Starting x position
     * @param {number} dimension.x2 Ending x position
     * @param {number} dimension.y1 Starting y position
     * @param {number} dimension.y2 Ending y position
     * @param {Object} conf Configuration needed to draw the selection box
     * @param {number} unitWidth Width of the visual unit.
     * @param {number} unitHeight Height of the visual unit.
     */
    apply (selectionSet, payload) {
        let x;
        let y;
        let width;
        let height;
        const config = this._config;
        const boxConf = config.box;
        const firebolt = this.firebolt;
        const drawingInf = this.drawingContext();
        const mountPoint = drawingInf.sideEffectGroup;
        const unitWidth = drawingInf.width;
        const unitHeight = drawingInf.height;
        const classPrefix = config.classPrefix;
        const selectionGroupClassName = config.defClassName;

        if (payload.criteria === null) {
            this.hide(drawingInf);
            return this;
        }

        const sourceInf = firebolt.context.getSourceInfo();
        const { dimension, direction } = Object(_helper__WEBPACK_IMPORTED_MODULE_5__["getBoxDimensionsFromPayload"])(payload, sourceInf.axes,
            sourceInf.fields);
        const transition = payload.dragEnd && config.transition;

        if (direction === 'both' || direction === 'vertical') {
            x = Math.min(dimension.x1, dimension.x2);
            width = Math.abs(dimension.x2 - dimension.x1);
        } else {
            x = 0;
            width = unitWidth;
        }
        if (direction === 'both' || direction === 'horizontal') {
            y = Math.min(dimension.y1, dimension.y2);
            height = Math.abs(dimension.y2 - dimension.y1);
        } else {
            height = unitHeight;
            y = 0;
        }
        this.show(drawingInf);
        // Create the data array for drawing the rectangle
        const points = [
            {
                x,
                y,
                width,
                height
            }
        ];
        // Create the container group for selection box.
        const selectionGroup = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mountPoint), 'g', [1],
            `.${classPrefix}-${selectionGroupClassName}`);
        const sideEffect = this;
        const selection = selectionGroup.selectAll('rect').data(points);
        const selectionBox = selection.enter().append('rect')
                        .each(function () {
                            Object(_actions_physical_selection_box_drag__WEBPACK_IMPORTED_MODULE_4__["selectionBoxDrag"])(firebolt)(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this), ['brush'], sideEffect);
                        })
                        .merge(selection)
                        .each(function (attrs) {
                            let element = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                            transition && (element = element.transition().duration(transition.duration));
                            for (const key in attrs) {
                                if ({}.hasOwnProperty.call(attrs, key)) {
                                    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isValidValue"])(attrs[key]) && element.attr(key, attrs[key]);
                                }
                            }
                        });
        // Get the qualified class name for selection box rectangle
        const boxClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(boxConf.defClassName, this._id, classPrefix);
        selectionBox.classed(boxClassName.join(' '), true);
        selectionBox.classed(boxConf.className, true);

        return this;
    }

    hide (drawingInf) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_5__["changeVisibility"])(this, drawingInf.sideEffectGroup, false);
    }

    show (drawingInf) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_5__["changeVisibility"])(this, drawingInf.sideEffectGroup, true);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SelectionBox);



/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/selection-box/styles.scss":
/*!***************************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/selection-box/styles.scss ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/spawnable.js":
/*!**************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/spawnable.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SpawnableSideEffect; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generic */ "./packages/muze-firebolt/src/side-effects/generic/index.js");




/**
 * Any side effect which will add any new element to the chart like drawing a rectangular box or any annotation over
 * the chart needs to inherit this class. This class has methods which returns the container where the dom elements
 * needs to be created.
 *
 * To use this,
 * ```
 *      const SpawnableSideEffect = muze.SideEffects.standards.SpawnableSideEffect;
 *
 *      class SelectionBox extends SpawnableSideEffect {
 *          static formalName () {
 *              return 'selectionBox';
 *          }
 *
 *          // Implement the logic of applying the style here.
 *          apply () {
 *          }
 *      }
 * ```
 * @public
 * @class
 * @extends GenericSideEffect
 * @module SpawnableSideEffect
 */
class SpawnableSideEffect extends _generic__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Creates a html or svg element in the container.
     *
     * @public
     * @param {SVGElement|HTMLElement} container Container where the dom element will be rendered.
     * @param {string} elemType Type of dom element.
     * @param {Array} data Array of objects with which the dom elements will be binded.
     * @param {string} className class name of the element.
     *
     * @return {Selection} D3 Selection of the element.
     */
    createElement (container, elemType, data, className, callbacks) {
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, elemType, data, className, callbacks);
    }

    /**
     * Returns the drawing information for side effect like svg container, dimensions of the visual unit.
     *
     * @public
     * @return {Object} Drawing information for side effect.
     * ```
     *      sideEffectGroup: // svg container where the side effect needs to be appended.
     *      svgContainer: // svg container of the {@link VisualUnit}.
     *      htmlContainer: // html div container of the {@link VisualUnit}.
     *      width: // Width of the {@link VisualUnit}
     *      height: // Height of the {@link VisualUnit}
     * ```
     */
    drawingContext (...drawingContext) {
        if (drawingContext.length) {
            this._drawingContext = drawingContext[0];
            return this;
        }
        return this._drawingContext();
    }

    show () {
        return this;
    }

    hide () {
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/surrogate.js":
/*!**************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/surrogate.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SurrogateSideEffect; });
/* harmony import */ var _generic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generic */ "./packages/muze-firebolt/src/side-effects/generic/index.js");


/**
 * This class is inherited by all side effects which changes the look of any existing elements in the visualization.
 * For example, if a side effect wants to change the color of bar plots, then it is a surrogate side effect.
 *
 * To use this,
 * ```
 *      const SurrogateSideEffect = muze.SideEffects.standards.SurrogateSideEffect;
 *
 *      class BarColorChanger extends SurrogateSideEffect {
 *          static formalName () {
 *              return 'colorChanger';
 *          }
 *
 *          // Implement the logic of applying the style here.
 *          apply () {
 *          }
 *      }
 * ```
 * @public
 *
 * @module SurrogateSideEffect
 * @class
 * @extends GenericSideEffect
 */
class SurrogateSideEffect extends _generic__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Applies or removes interaction styles from plot elements. An array of row ids needs to be passed
     * which identifies the plot elements and applies styles to them.
     *
     * To apply the interaction style,
     * ```
     *      const entryRowIds = entrySet[0].uids;
     *      const interactionStyle = [{
     *          type: 'fill',
     *          intensity: [0, 0, 15, 0] // hsla configuration
     *      }];
     *
     *      this.applyInteractionStyle(entryRowIds, interactionStyle, 'brighten', true);
     * ```
     * @public
     * @param {Array} set Array of row ids.
     * @param {Array} config Style configuration.
     * @param {Object} config[0] fill or stroke configuration.
     * @param {string} config[0].type Type of style - fill or stroke.
     * @param {Array} config[0].intensity hsla configuration.
     * @param {string} interactionType Type of interaction. This is needed for storing the styles for
     * each type of interaction in the plot elements.
     * @param {boolean} apply Whether to apply or remove the interaction style.
     *
     * @return {SurrogateSideEffect} Instance of surrogate side effect.
     */
    applyInteractionStyle (set, config = {}, interactionType, apply) {
        const layers = this.firebolt.context.layers();
        layers.forEach(layer => layer.config().interactive !== false &&
            layer.applyInteractionStyle(interactionType, set.uids, apply));
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/tooltip/index.js":
/*!******************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/tooltip/index.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tooltip; });
/* harmony import */ var _chartshq_muze_tooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-tooltip */ "./packages/muze-tooltip/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper */ "./packages/muze-firebolt/src/side-effects/helper/index.js");
/* harmony import */ var _strategies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategies */ "./packages/muze-firebolt/src/side-effects/tooltip/strategies.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-firebolt/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../enums/side-effects */ "./packages/muze-firebolt/src/enums/side-effects.js");
/* harmony import */ var _spawnable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../spawnable */ "./packages/muze-firebolt/src/side-effects/spawnable.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-firebolt/src/side-effects/tooltip/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../enums/tooltip-strategies */ "./packages/muze-firebolt/src/enums/tooltip-strategies.js");











const configResolvers = {
    [_enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_8__["HIGHLIGHT_SUMMARY"]]: (specificConf, config) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(specificConf, config),
    default: specificConf => Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(specificConf, {})
};

const sanitizeConfig = (config, context) => {
    const strategyObj = context._strategies;
    const sanitizedConf = Object.assign({}, config);
    for (const key in strategyObj) {
        sanitizedConf[key] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(configResolvers[key], configResolvers.default)(config[key], config);
    }
    return sanitizedConf;
};

class Tooltip extends _spawnable__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor (...params) {
        super(...params);
        this._tooltips = {};
        this._strategies = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["mergeRecursive"])({}, _strategies__WEBPACK_IMPORTED_MODULE_3__["strategies"]);
        this._strategy = _enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_8__["HIGHLIGHT_SUMMARY"];
    }

    static defaultConfig () {
        return {
            padding: 5,
            offset: {
                x: 0,
                y: 0
            },
            highlightSummary: {
                dataTransform: (dt, fields) => (fields ? dt.project(fields, { saveChild: false }) : dt
                )
            },
            selectionSummary: {
                dataTransform: (dt, fields) => {
                    const fieldspace = dt.getFieldspace();
                    const dimensions = Object.keys(fieldspace.getDimension());
                    const measures = Object.keys(fieldspace.getMeasure());
                    const projectedFields = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(fields, measures.length ? [measures[0]] : []);
                    return dt.project([...dimensions, ...projectedFields], {
                        saveChild: false
                    });
                }
            }
        };
    }

    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_5__["TOOLTIP"];
    }

    config (...params) {
        if (params.length) {
            const config = this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["mergeRecursive"])(this._config, sanitizeConfig(params[0], this));
            const strategyObj = this._strategies;
            for (const key in strategyObj) {
                const formatter = config[key].formatter;
                this.setStrategy(key, formatter);
            }
            return this;
        }
        return this._config;
    }

    apply (selectionSet, payload, options = {}) {
        let totalHeight = 0;
        let totalWidth = 0;
        const dataModel = selectionSet.mergedEnter.model;
        const context = this.firebolt.context;
        const drawingInf = this.drawingContext();
        if ((dataModel.isEmpty() || payload.criteria === null)) {
            this.hide(options, null);
            return this;
        }

        const tooltips = this._tooltips;
        const config = this.config();
        const boundBox = {
            width: drawingInf.width,
            height: drawingInf.height
        };
        const showInPosition = payload.showInPosition;
        const pad = config.padding;
        const dataModels = [];
        const fragmented = config.mode === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["FRAGMENTED"];
        const sourceInf = context.getSourceInfo();
        const fields = sourceInf.fields;
        const xFieldDim = fields.x[0] ? fields.x[0].type() === muze_utils__WEBPACK_IMPORTED_MODULE_1__["FieldType"].DIMENSION : false;
        const showVertically = !!xFieldDim;
        const tooltipPos = payload.position;
        const boxes = [];
        const enter = {};
        const uids = dataModel.getData().uids;
        if (fragmented) {
            dataModels.push(...uids.map(d => dataModel.select((fieldsArr, i) => i === d, {
                saveChild: false
            })));
        } else {
            dataModels.push(dataModel);
        }

        let target = payload.target;
        let targetFields = [];
        if (target) {
            targetFields = target[0] || [];
            const sourceFields = payload.sourceFields;
            const indices = [];
            for (let i = 0, len = targetFields.length; i < len; i++) {
                if (sourceFields.indexOf(targetFields[i]) !== -1) {
                    indices.push(i);
                }
            }
            target = target.map(d => d.filter((v, i) => indices.indexOf(i) !== -1));
        }

        const plotDimensions = context.getPlotPointsFromIdentifiers(target || payload.criteria, {
            getBBox: true
        });

        const strategy = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(options.strategy, this._strategy);
        const strategyConf = config[strategy];
        const { dataTransform, fields: projectFields } = strategyConf;
        const strategyObj = this._strategies;
        // Show tooltip for each datamodel
        for (let i = 0; i < dataModels.length; i++) {
            let plotDim = plotDimensions[i];
            if (fragmented) {
                const dimensions = dataModels[i].getData().schema.filter(d => d.type === muze_utils__WEBPACK_IMPORTED_MODULE_1__["FieldType"].DIMENSION)
                    .map(d => d.name);
                plotDim = context.getPlotPointsFromIdentifiers(dataModels[i].project(dimensions), { getBBox: true });
                plotDim = plotDim && plotDim[0];
            }

            const dt = dataTransform(dataModels[i], projectFields, this);

            enter[i] = true;
            const { parentContainer: layoutContainer, parentContainerDimensions } = drawingInf;
            const layoutBoundBox = layoutContainer.getBoundingClientRect();
            const unitBoundBox = drawingInf.htmlContainer.getBoundingClientRect();

            const offsetLeft = unitBoundBox.left - layoutBoundBox.left;
            const offsetTop = unitBoundBox.top - layoutBoundBox.top;
            const tooltipInst = tooltips[i] = tooltips[i] || new _chartshq_muze_tooltip__WEBPACK_IMPORTED_MODULE_0__["Tooltip"](layoutContainer,
                    drawingInf.svgContainer);

            sourceInf.payload = payload;
            sourceInf.firebolt = this.firebolt;
            sourceInf.detailFields = context.detailFields();
            sourceInf.timeDiffs = context.timeDiffsByField();
            sourceInf.valueParser = context.valueParser();
            sourceInf.selectionSet = selectionSet;
            tooltipInst.context(sourceInf);
            const strategyFn = strategyObj[strategy];
            tooltipInst.content(strategy, dt, {
                formatter: strategyFn,
                order: options.order
            })
                            .config(this.config())
                            .extent({
                                x: 0,
                                y: 0,
                                width: parentContainerDimensions.width,
                                height: parentContainerDimensions.height
                            })
                            .offset({
                                x: offsetLeft + (config.offset.x || 0),
                                y: offsetTop + (config.offset.y || 0)
                            });

            if (showInPosition) {
                tooltipInst.position(tooltipPos.x + pad, tooltipPos.y + pad);
            } else if (plotDim) {
                tooltipInst.positionRelativeTo({
                    x: plotDim.x,
                    y: plotDim.y,
                    width: plotDim.width || 0,
                    height: plotDim.height || 0
                }, {
                    orientation: fragmented ?
                        (showVertically ? 'horizontal' : 'vertical') : undefined
                });
            } else {
                tooltipInst.hide();
                break;
            }

            if (fragmented) {
                const position = tooltipInst._position;
                const tooltipBoundBox = tooltipInst._tooltipContainer.node().getBoundingClientRect();

                totalHeight += tooltipBoundBox.height + pad;
                totalWidth += tooltipBoundBox.width + pad;
                if (showVertically ? totalHeight > drawingInf.height : totalWidth > drawingInf.width) {
                    break;
                }
                boxes.push({
                    x: position.x,
                    y: position.y,
                    width: tooltipBoundBox.width,
                    height: tooltipBoundBox.height,
                    tooltip: tooltipInst
                });
            }
        }

        for (const key in tooltips) {
            if (!enter[key]) {
                const tooltip = tooltips[key];
                tooltip.content(payload.action, null);
                if (!tooltip.getContents().length) {
                    tooltip.remove();
                    delete tooltips[key];
                }
            }
        }
        if (fragmented) {
            Object(_helper__WEBPACK_IMPORTED_MODULE_2__["spaceOutBoxes"])(boxes, boundBox, showVertically);
            boxes.forEach(box => box.tooltip.position(box.x, box.y, {
                repositionArrow: true
            }));
        }
        return this;
    }

    hide (options) {
        const tooltips = this._tooltips;
        for (const key in tooltips) {
            if ({}.hasOwnProperty.call(tooltips, key)) {
                const strategy = options.strategy || this._strategy;
                tooltips[key].content(strategy, null);
                tooltips[key].hide();
            }
        }
    }
}


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/tooltip/strategies.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/tooltip/strategies.js ***!
  \***********************************************************************/
/*! exports provided: buildTooltipData, strategies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildTooltipData", function() { return buildTooltipData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strategies", function() { return strategies; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-tooltip */ "./packages/muze-tooltip/src/index.js");
/* harmony import */ var _enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/tooltip-strategies */ "./packages/muze-firebolt/src/enums/tooltip-strategies.js");




const { SUM, COUNT } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["GROUP_BY_FUNCTIONS"];
const { InvalidAwareTypes } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"];
const FIRST_VALUE_MARGIN = '10px';
const SINGLE_DATA_MARGIN = 10;

const formatters = (formatter, interval, valueParser) => ({
    [muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL]: value => (value instanceof InvalidAwareTypes ? valueParser(value) :
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["formatTemporal"])(Number(value), interval)),
    [muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS]: value => (value instanceof InvalidAwareTypes ? valueParser(value) :
        formatter(value.toFixed(2))),
    [muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL]: value => valueParser(value)
});

const getTabularData = (dataObj, fieldInf) => {
    const rows = [];
    const { data, schema } = dataObj;
    rows.push(schema.map(d => fieldInf[d.name].displayName));

    data.forEach((d) => {
        const row = [];
        schema.forEach((fieldObj, i) => {
            const value = fieldInf[fieldObj.name].fn(d[i]);
            row.push(value);
        });
        rows.push(row);
    });
    return rows;
};

const getKeyValue = (params) => {
    const { field, value, classPrefix, margin, isSelected, removeKey } = params;

    if (!removeKey) {
        const keyObj = {
            value: field,
            className: `${classPrefix}-tooltip-key`
        };
        const valueObj = {
            value,
            className: `${classPrefix}-tooltip-value`
        };
        if (margin !== undefined) {
            keyObj.style = {
                'margin-left': `${margin}px`
            };
            valueObj.style = {
                'margin-left': `${margin}px`
            };
        }

        return ({
            className: isSelected ? `${classPrefix}-tooltip-row ${classPrefix}-tooltip-selected-row`
                : `${classPrefix}-tooltip-row`,
            data: [keyObj, valueObj]
        }
        );
    }
    return ({
        data: [{
            className: '',
            value,
            style: {
                'margin-left': FIRST_VALUE_MARGIN
            }
        }],
        className: `${classPrefix}-tooltip-first`
    });
};

const generateRetinalFieldsValues = (valueArr, retinalFields, content, context) => {
    const { fieldsConfig, dimensionMeasureMap, axes, config, fieldInf, dataLen, target } = context;
    const { classPrefix, margin, separator } = config;
    const colorAxis = axes.color[0];
    const shapeAxis = axes.shape[0];
    const sizeAxis = axes.size[0];
    const REF_VALUES_INDEX = 1;
    const REF_KEYS_INDEX = 0;

    for (const retField in retinalFields) {
        const retIndex = fieldsConfig[retField].index;
        const retinalFieldValue = valueArr[retIndex];
        const measuresArr = dimensionMeasureMap[retField];
        const icon = {
            type: 'icon',
            color: colorAxis.getColor(retinalFieldValue),
            shape: shapeAxis.getShape(retinalFieldValue),
            size: sizeAxis.getSize(retinalFieldValue) * config.iconScale
        };
        const { displayName, fn } = fieldInf[retField];
        const formattedRetinalValue = fn(retinalFieldValue);

        if (dataLen === 1) {
            content.push(getKeyValue({
                field: displayName,
                value: formattedRetinalValue,
                classPrefix,
                margin: SINGLE_DATA_MARGIN
            }));
        } else {
            const hasMultipleMeasures = measuresArr.length > 1;
            hasMultipleMeasures && (content.push({ data: [icon, formattedRetinalValue] }));
            const selectedContext = target[REF_VALUES_INDEX][target[REF_KEYS_INDEX].indexOf(retField)];
            const isSelected = selectedContext === retinalFieldValue;
            measuresArr.forEach((measure) => {
                const measureIndex = fieldsConfig[measure].index;
                const { displayName: dName, fn: formatterFn } = fieldInf[measure];
                const value = formatterFn(valueArr[measureIndex]);
                const keyValue = getKeyValue({
                    field: hasMultipleMeasures ? `${dName}${separator}` : formattedRetinalValue,
                    value,
                    classPrefix,
                    margin: hasMultipleMeasures ? margin : undefined,
                    isSelected
                });
                if (!hasMultipleMeasures) {
                    keyValue.data = [icon, ...keyValue.data];
                }
                content.push(keyValue);
            });
        }
    }
};

const getFieldInf = (schema, dataModel, context) => {
    const { valueParser, timeDiffs } = context;
    const fieldsObj = dataModel.getFieldspace().fieldsObj();
    const defFormatter = formatters(null, null, valueParser)[muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL];

    return schema.reduce((inf, field) => {
        const { subtype, name, type } = field;
        const interval = subtype === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL ? timeDiffs[name] : 0;
        const nf = type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE ? fieldsObj[name].numberFormat() : val => val;
        inf[name] = {
            fn: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(formatters(nf, interval, valueParser)[subtype], defFormatter),
            displayName: `${Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveFieldDisplayName"])(dataModel, name)}`
        };
        return inf;
    }, {});
};

const buildTooltipData = (dataModel, config = {}, context) => {
    let nestedDataObj;
    let fieldValues = [];
    const { data, schema } = dataModel.getData();
    const fieldspace = dataModel.getFieldspace();
    const fieldsConfig = dataModel.getFieldsConfig();
    const { color, shape, size } = context.firebolt.context.retinalFields();
    const detailFields = context.detailFields || [];
    const dimensions = schema.filter(d => d.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);
    const measures = schema.filter(d => d.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE);
    const containsDetailField = !!Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["intersect"])(schema, detailFields).length;
    const dataLen = data.length;
    const {
        dimensionMeasureMap,
        axes
    } = context;
    const fieldInf = getFieldInf(schema, dataModel, context);

    let displayFormat;
    if (dataLen > 1 && containsDetailField) {
        fieldValues = getTabularData({
            data,
            schema,
            fieldspace
        }, fieldInf);
        displayFormat = _chartshq_muze_tooltip__WEBPACK_IMPORTED_MODULE_1__["TABLE_FORMAT"];
    } else {
        const retinalFields = [color.field, shape.field, size.field].reduce((acc, field) => {
            field && fieldsConfig[field].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION && (acc[field] = 1);
            return acc;
        }, {});
        const filteredDimensions = dimensions.filter(field => !retinalFields[field.name]);
        const indices = filteredDimensions.map(dim => fieldsConfig[dim.name].index);
        const allMeasures = [...new Set(...Object.values(dimensionMeasureMap))];
        const filteredMeasures = dataLen > 1 ? measures.filter(d => allMeasures.indexOf(d.name) === -1) : measures;

        nestedDataObj = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["nestCollection"])({
            data,
            keys: indices
        });
        nestedDataObj = !Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(nestedDataObj[0], 'key') ? [{
            values: nestedDataObj
        }] : nestedDataObj;

        const generateTooltipContent = (nestedData, index = 0, content = []) => {
            const { classPrefix, separator } = config;
            for (let i = 0, len = nestedData.length; i < len; i++) {
                const { values, key } = nestedData[i];
                const field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(schema, indices[index], 'name');
                const margin = dataLen === 1 || Object.keys(retinalFields).length === 0
                ? SINGLE_DATA_MARGIN : undefined;
                if (field) {
                    const { displayName, fn } = fieldInf[field];
                    const formattedValue = fn(key);
                    const removeKey = values.length > 1;
                    content.push(getKeyValue({
                        field: `${displayName}${separator}`,
                        value: formattedValue,
                        classPrefix,
                        margin,
                        isSelected: undefined,
                        removeKey
                    }));
                }

                if (values[0] && values[0].key) {
                    generateTooltipContent(values, index + 1, content);
                } else {
                    for (let j = 0, len2 = values.length; j < len2; j++) {
                        const valueArr = values[j];
                        generateRetinalFieldsValues(valueArr, retinalFields, content, {
                            fieldInf,
                            axes,
                            config,
                            fieldsConfig,
                            dimensionMeasureMap,
                            dataLen,
                            target: context.payload.target
                        });

                        filteredMeasures.forEach((measure) => {
                            const { name } = measure;
                            const { displayName, fn } = fieldInf[name];
                            content.push(getKeyValue({
                                field: `${displayName}${separator}`,
                                value: fn(valueArr[fieldsConfig[name].index]),
                                classPrefix,
                                margin: SINGLE_DATA_MARGIN
                            }));
                        });
                    }
                }
            }
        };
        generateTooltipContent(nestedDataObj, 0, fieldValues);
    }

    return {
        content: fieldValues,
        displayFormat
    };
};

const strategies = {
    [_enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_2__["SELECTION_SUMMARY"]]: (dm, config, context) => {
        const { selectionSet } = context;
        const aggFns = selectionSet.mergedEnter.aggFns;
        const dataObj = dm.getData();
        const measures = dataObj.schema.filter(d => d.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE);
        const aggregatedModel = dm.groupBy([''], measures.reduce((acc, v) => {
            acc[v.name] = aggFns[v.name] === COUNT ? SUM : aggFns[v.name];
            return acc;
        }, {
            saveChild: false
        }));
        const fieldsConf = aggregatedModel.getFieldsConfig();
        let values = [[{
            value: `${dataObj.data.length}`,
            style: {
                'font-weight': 'bold'
            }
        }, 'Items Selected']];
        const measureNames = measures.map(d => d.name);
        const data = aggregatedModel.getData().data;
        measureNames.forEach((measure) => {
            const value = data[0][fieldsConf[measure].index];
            value instanceof InvalidAwareTypes ? values.push([]) : values.push([`(${aggFns[measure].toUpperCase()})`,
                `${Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveFieldDisplayName"])(dm, measure)}`,
                {
                    value: `${value.toFixed(2)}`,
                    style: {
                        'font-weight': 'bold'
                    }
                }]);
        });
        if (measureNames.length === 1) {
            values = [[...values[0], ...values[1]]];
        }
        return ([{
            data: values[0]
        }]);
    },
    [_enums_tooltip_strategies__WEBPACK_IMPORTED_MODULE_2__["HIGHLIGHT_SUMMARY"]]: (data, config, context) => buildTooltipData(data, config, context)
};


/***/ }),

/***/ "./packages/muze-firebolt/src/side-effects/tooltip/styles.scss":
/*!*********************************************************************!*\
  !*** ./packages/muze-firebolt/src/side-effects/tooltip/styles.scss ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-legend/src/enums/actions.js":
/*!***************************************************!*\
  !*** ./packages/muze-legend/src/enums/actions.js ***!
  \***************************************************/
/*! exports provided: DRAG, HOVER, SELECTIONDRAG, CLICK */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DRAG", function() { return DRAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOVER", function() { return HOVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTIONDRAG", function() { return SELECTIONDRAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLICK", function() { return CLICK; });
const DRAG = 'drag';
const HOVER = 'hover';
const SELECTIONDRAG = 'selectiondrag';
const CLICK = 'click';


/***/ }),

/***/ "./packages/muze-legend/src/enums/behaviours.js":
/*!******************************************************!*\
  !*** ./packages/muze-legend/src/enums/behaviours.js ***!
  \******************************************************/
/*! exports provided: BRUSH, HIGHLIGHT, TOOLTIP, FILTER, SELECT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BRUSH", function() { return BRUSH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIGHLIGHT", function() { return HIGHLIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP", function() { return TOOLTIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILTER", function() { return FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECT", function() { return SELECT; });
const BRUSH = 'brush';
const HIGHLIGHT = 'highlight';
const TOOLTIP = 'tooltip';
const FILTER = 'filter';
const SELECT = 'select';



/***/ }),

/***/ "./packages/muze-legend/src/enums/constants.js":
/*!*****************************************************!*\
  !*** ./packages/muze-legend/src/enums/constants.js ***!
  \*****************************************************/
/*! exports provided: CLASSPREFIX, IDFIELD, CONFIG, DATAMODEL, AXES, LAYERDEFS, WIDTH, MAXWIDTH, HEIGHT, MOUNTPOINT, GRIDLINEPARENTGROUPCLASS, TRANSFORM, CONSOLIDATED, FRAGMENTED, DEFAULTCOLOR, DEFAULTSIZE, DEFAULTSHAPE, STEP, GRADIENT, ORDINAL, SCALE_FUNCTIONS, TOP, LEFT, RIGHT, BOTTOM, HORIZONTAL, VERTICAL, CENTER, VALUE, PATH, SHAPE, ICON, RECT, START, UPPER, LOWER, END, SIZE, DISCRETE, MEASURE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDFIELD", function() { return IDFIELD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATAMODEL", function() { return DATAMODEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXES", function() { return AXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERDEFS", function() { return LAYERDEFS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAXWIDTH", function() { return MAXWIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNTPOINT", function() { return MOUNTPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRIDLINEPARENTGROUPCLASS", function() { return GRIDLINEPARENTGROUPCLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLIDATED", function() { return CONSOLIDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENTED", function() { return FRAGMENTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULTCOLOR", function() { return DEFAULTCOLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULTSIZE", function() { return DEFAULTSIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULTSHAPE", function() { return DEFAULTSHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEP", function() { return STEP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRADIENT", function() { return GRADIENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDINAL", function() { return ORDINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCALE_FUNCTIONS", function() { return SCALE_FUNCTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL", function() { return HORIZONTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL", function() { return VERTICAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CENTER", function() { return CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VALUE", function() { return VALUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PATH", function() { return PATH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPE", function() { return SHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ICON", function() { return ICON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RECT", function() { return RECT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "START", function() { return START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPPER", function() { return UPPER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOWER", function() { return LOWER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "END", function() { return END; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIZE", function() { return SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DISCRETE", function() { return DISCRETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASURE", function() { return MEASURE; });
const CLASSPREFIX = 'muze';
const IDFIELD = '__id__';
const CONFIG = 'config';
const DATAMODEL = 'dataModel';
const AXES = 'axes';
const LAYERDEFS = 'layerDef';
const WIDTH = 'width';
const MAXWIDTH = 'max-width';
const HEIGHT = 'height';
const MOUNTPOINT = 'mountPoint';
const GRIDLINEPARENTGROUPCLASS = 'grid-lines';
const TRANSFORM = 'transform';
const CONSOLIDATED = 'consolidated';
const FRAGMENTED = 'fragmented';
const DEFAULTCOLOR = '#F44336';
const DEFAULTSIZE = 50;
const DEFAULTSHAPE = 'circle';
const STEP = 'step';
const GRADIENT = 'gradient';
const ORDINAL = 'ordinal';
const SCALE_FUNCTIONS = {
    size: 'getSize',
    shape: 'getShape',
    color: 'getColor'
};
const TOP = 'top';
const LEFT = 'left';
const RIGHT = 'right';
const BOTTOM = 'bottom';
const HORIZONTAL = 'horizontal';
const VERTICAL = 'vertical';
const CENTER = 'center';
const VALUE = 'value';
const PATH = 'path';
const SHAPE = 'shape';
const ICON = 'icon';
const RECT = 'rect';
const START = 'start';
const UPPER = 'upper';
const LOWER = 'lower';
const END = 'end';
const SIZE = 'size';
const DISCRETE = 'discrete';
const MEASURE = 'measure';



/***/ }),

/***/ "./packages/muze-legend/src/enums/side-effects.js":
/*!********************************************************!*\
  !*** ./packages/muze-legend/src/enums/side-effects.js ***!
  \********************************************************/
/*! exports provided: SELECTIONBOX, Highlighter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTIONBOX", function() { return SELECTIONBOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Highlighter", function() { return Highlighter; });
const SELECTIONBOX = 'selectionBox';
const Highlighter = 'highlighter';



/***/ }),

/***/ "./packages/muze-legend/src/firebolt/action-behaviour-map.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/action-behaviour-map.js ***!
  \*******************************************************************/
/*! exports provided: actionBehaviourMap, propagationBehaviourMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionBehaviourMap", function() { return actionBehaviourMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagationBehaviourMap", function() { return propagationBehaviourMap; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");


const CLASSPREFIX = 'muze';

const actionBehaviourMap = {
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].DRAG]: {
        target: `.${CLASSPREFIX}-gradient-rect`,
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].BRUSH]
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].HOVER]: {
        target: [`.${CLASSPREFIX}-legend-columns`],
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].HIGHLIGHT]
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].CLICK]: {
        target: [`.${CLASSPREFIX}-legend-columns`],
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].SELECT]
    }
};

const propagationBehaviourMap = {
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].SELECT]: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].FILTER,
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].BRUSH]: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].HIGHLIGHT
};


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/behaviour-effect-map.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/behaviour-effect-map.js ***!
  \*******************************************************************/
/*! exports provided: behaviourEffectMap, propagationSideEffects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "behaviourEffectMap", function() { return behaviourEffectMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagationSideEffects", function() { return propagationSideEffects; });
/* harmony import */ var _enums_behaviours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/behaviours */ "./packages/muze-legend/src/enums/behaviours.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/side-effects */ "./packages/muze-legend/src/enums/side-effects.js");



const behaviourEffectMap = {
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["BRUSH"]]: [_enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["SELECTIONBOX"], {
        name: _enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["Highlighter"],
        options: {
            strategy: 'fade'
        }
    }],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["HIGHLIGHT"]]: [_enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["Highlighter"]],
    select: [{
        name: _enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["Highlighter"],
        options: {
            strategy: 'fade'
        }
    }]
};

const propagationSideEffects = {
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["BRUSH"]]: [{
        name: _enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["Highlighter"],
        options: {
            strategy: 'fade'
        }
    }],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["HIGHLIGHT"]]: [{
        name: _enums_side_effects__WEBPACK_IMPORTED_MODULE_1__["Highlighter"],
        options: {
            strategy: 'fade'
        }
    }],
    [_enums_behaviours__WEBPACK_IMPORTED_MODULE_0__["SELECT"]]: ['filter']
};



/***/ }),

/***/ "./packages/muze-legend/src/firebolt/behavioural/index.js":
/*!****************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/behavioural/index.js ***!
  \****************************************************************/
/*! exports provided: SelectBehaviour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./packages/muze-legend/src/firebolt/behavioural/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectBehaviour", function() { return _select__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-legend/src/firebolt/behavioural/select.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/behavioural/select.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SelectBehaviour; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");


class SelectBehaviour extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["PersistentBehaviour"] {
    static formalName () {
        return 'select';
    }

    setSelectionSet (addSet, selectionSet) {
        if (addSet === null) {
            selectionSet.reset();
        } else if (addSet.length) {
            // new add set
            const existingRemoveSet = addSet.filter(d => selectionSet._set[d] === _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["SELECTION"].SELECTION_OLD_EXIT
                || selectionSet._set[d] === _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["SELECTION"].SELECTION_NEW_EXIT);
                // existing add set
            if (existingRemoveSet.length) {
                selectionSet.updateEntry();
                selectionSet.add(existingRemoveSet);
            } else {
                selectionSet.updateExit();
                selectionSet.remove(addSet);
            }
            const { exitSet } = selectionSet.getSets();
            const mergedExitSet = [...new Set(exitSet[1]), ...new Set(exitSet[0])];
            const completeSetCount = selectionSet.getCompleteSet().length;
            if (exitSet[1].length !== completeSetCount && mergedExitSet.length === completeSetCount) {
                selectionSet.reset();
            }
        } else {
            selectionSet.remove(selectionSet.getCompleteSet());
        }
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/helper.js":
/*!*****************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/helper.js ***!
  \*****************************************************/
/*! exports provided: propagate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagate", function() { return propagate; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _action_behaviour_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./action-behaviour-map */ "./packages/muze-legend/src/firebolt/action-behaviour-map.js");
/* harmony import */ var _behaviour_effect_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./behaviour-effect-map */ "./packages/muze-legend/src/firebolt/behaviour-effect-map.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");





const propagate = (firebolt, action, selectionSet, config = {}) => {
    let propagationData;
    const context = firebolt.context;
    const type = context.constructor.type();
    const payload = config.payload;
    const data = context.data();
    const metaData = context.metaData();
    const fieldType = metaData.getData().schema[0].type;

    const propPayload = {};
    const sourceId = context._id;
    propPayload.action = _action_behaviour_map__WEBPACK_IMPORTED_MODULE_1__["propagationBehaviourMap"][action] || action;
    propPayload.sideEffects = _behaviour_effect_map__WEBPACK_IMPORTED_MODULE_2__["propagationSideEffects"][action];
    propPayload.sourceCanvas = context.canvasAlias();
    const isMutableAction = firebolt._actions.behavioural[propPayload.action].constructor.mutates();
    if (payload.criteria === null) {
        propagationData = null;
    } else {
        const entrySet = selectionSet.mergedEnter;
        let values = data.filter(d => entrySet.uids.indexOf(d.id) !== -1).map(d => d.rawVal);
        if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STEP"] || (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["DISCRETE"] && fieldType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["MEASURE"])) {
            const field = Object.keys(payload.criteria || {})[0];
            values = data.filter(d => entrySet.uids.indexOf(d.id) !== -1).map(d => d.range);
            propagationData = values.length ? metaData.select((fields) => {
                let check = false;
                for (let i = 0; i < values.length; i++) {
                    check = fields[field].internalValue >= values[i][0] && fields[field].internalValue <= values[i][1];
                    if (check === true) {
                        break;
                    }
                }
                return check;
            }, {
                saveChild: false
            }) : null;
        } else if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRADIENT"]) {
            propagationData = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDataModelFromRange"])(metaData, payload.criteria);
        } else if (values.length) {
            propagationData = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["assembleModelFromIdentifiers"])(metaData, [payload.criteria[0], ...values.map(d => [d])]);
        } else {
            propPayload.criteria = null;
            propagationData = metaData.select(() => true, {
                saveChild: false
            });
        }
    }

    let propagateInterpolatedValues = false;

    if (propagationData) {
        const schema = propagationData.getSchema();
        propagateInterpolatedValues = schema.every(d => d.type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["MEASURE"]);
    }

    const propConfig = {
        sourceId: `legend-${sourceId}`,
        payload: propPayload,
        criteria: propPayload.criteria === null ? null : propagationData,
        isMutableAction,
        propagateInterpolatedValues,
        action: propPayload.action
    };

    metaData.propagate(propagationData, propConfig, true);
};


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/legend-firebolt.js":
/*!**************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/legend-firebolt.js ***!
  \**************************************************************/
/*! exports provided: LegendFireBolt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LegendFireBolt", function() { return LegendFireBolt; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze-legend/src/firebolt/helper.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");




/**
 * This class manages the interactions of legend.
 * @export
 * @class LegendFireBolt
 * @extends {Firebolt}
 */
class LegendFireBolt extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["Firebolt"] {
    constructor (...params) {
        super(...params);
        this.initializeSideEffects();
    }

    getPropagationSelectionSet (selectionSet) {
        return selectionSet[0];
    }

    propagate (behaviourName, payload, selectionSet) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["propagate"])(this, behaviourName, selectionSet, {
            payload
        });
    }

    getAddSetFromCriteria (criteria) {
        let values;
        let uniqueIds;
        const type = this.context.constructor.type();

        if (criteria === null) {
            uniqueIds = null;
        } else if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["STEP"]) {
            values = Object.values(criteria);
            uniqueIds = this.context.data().filter(d => values.indexOf(d.range) !== -1).map(d => d.id);
        } else if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["GRADIENT"]) {
            uniqueIds = [];
        } else {
            values = criteria[1];
            if (values) {
                uniqueIds = this.context.data().filter(d => values.indexOf(d.rawVal) !== -1).map(d => d.id);
            } else {
                values = Object.values(criteria);
                uniqueIds = this.context.data().filter(d => values.indexOf(d.range) !== -1).map(d => d.id);
            }
        }
        return {
            uids: uniqueIds,
            model: null
        };
    }

    getFullData () {
        return null;
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/physical/click.js":
/*!*************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/physical/click.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Adds mouse interactions to target element.
 * @param {VisualUnit} instance instance of visual unit.
 * @param {SVGElement} targetEl Element on which the event listeners will be attached.
 * @param {Array} behaviours Array of behaviours
 */
const click = firebolt => (targetEl, behaviours) => {
    const dispatchBehaviour = function (args) {
        const payload = {
            criteria: firebolt.context.getCriteriaFromData(args)
        };
        behaviours.forEach(behaviour => firebolt.dispatchBehaviour(behaviour, payload));
    };

    targetEl.on('click', dispatchBehaviour);
};

/* harmony default export */ __webpack_exports__["default"] = (click);


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/physical/drag.js":
/*!************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/physical/drag.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * Adds dragging action to the target element.
 * @param {firebolt} firebolt firebolt
 * @param {SVGElement} targetEl Element on which brushing action is needed.
 * @param {Array} behaviours Array of behaviours
 */
/* istanbul ignore next */ const drag = firebolt => (targetEl, behaviours) => {
    let startPos = {};
    let endPos = {};
    let payload;
    const d3Drag = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getD3Drag"])();
    const context = firebolt.context;
    const boundingBox = context.measurement().gradientDimensions;
    const axisType = context.config().align === 'horizontal' ? 'x' : 'y';
    const axisScale = context.axis().source().scale();
    const rangeShifter = axisScale.range()[axisType === 'x' ? 0 : 1];

    targetEl.call(d3Drag().on('start', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        startPos = {
            x: event.x,
            y: event.y
        };
    }).on('drag', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();

        endPos = {
            x: event.x,
            y: event.y
        };
        endPos.x = Math.max(0, Math.min(endPos.x, boundingBox.width));
        endPos.y = Math.max(0, Math.min(endPos.y, boundingBox.height));

        payload = {
            criteria: {
                [context.fieldName()]: [axisScale.invert(startPos[axisType] + rangeShifter * 2),
                    axisScale.invert(endPos[axisType] + rangeShifter * 2)].sort((a, b) => a - b)
            }
        };
        behaviours.forEach(behaviour => firebolt.dispatchBehaviour(behaviour, payload));
    }).on('end', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();

        endPos = {
            x: event.x,
            y: event.y
        };
        endPos.x = Math.max(0, Math.min(endPos.x, boundingBox.width));
        endPos.y = Math.max(0, Math.min(endPos.y, boundingBox.height));
        if (startPos[axisType] === endPos[axisType]) {
            payload = {
                criteria: {}
            };
        } else {
            payload = {
                criteria: {
                    [context.fieldName()]: [axisScale.invert(startPos[axisType] + rangeShifter * 2),
                        axisScale.invert(endPos[axisType] + rangeShifter * 2)].sort((a, b) => a - b)
                }
            };
        }
        behaviours.forEach(behaviour => firebolt.dispatchBehaviour(behaviour, payload));
    }));
};

/* harmony default export */ __webpack_exports__["default"] = (drag);


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/physical/hover.js":
/*!*************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/physical/hover.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * Adds mouse interactions to target element.
 * @param {Firebolt} Firebolt instance of firebolt.
 * @param {SVGElement} targetEl Element on which the event listeners will be attached.
 * @param {Array} behaviours Array of behaviours
 */
/* istanbul ignore next */ const hover = firebolt => (targetEl, behaviours) => {
    const dispatchBehaviour = function (args) {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        const payload = {
            criteria: firebolt.context.getCriteriaFromData(args)
        };
        behaviours.forEach(behaviour => firebolt.dispatchBehaviour(behaviour, payload));
        event.stopPropagation();
    };

    targetEl.on('mouseover', dispatchBehaviour)
                    .on('mousemove', dispatchBehaviour)
                    .on('mouseout', () => {
                        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
                        behaviours.forEach(behaviour => firebolt.dispatchBehaviour(behaviour, {
                            criteria: null
                        }));
                        event.stopPropagation();
                    });
};

/* harmony default export */ __webpack_exports__["default"] = (hover);


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/physical/index.js":
/*!*************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/physical/index.js ***!
  \*************************************************************/
/*! exports provided: physicalActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "physicalActions", function() { return physicalActions; });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./packages/muze-legend/src/firebolt/physical/drag.js");
/* harmony import */ var _hover__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hover */ "./packages/muze-legend/src/firebolt/physical/hover.js");
/* harmony import */ var _click__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./click */ "./packages/muze-legend/src/firebolt/physical/click.js");
/* harmony import */ var _enums_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/actions */ "./packages/muze-legend/src/enums/actions.js");





const physicalActions = {
    [_enums_actions__WEBPACK_IMPORTED_MODULE_3__["DRAG"]]: _drag__WEBPACK_IMPORTED_MODULE_0__["default"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_3__["HOVER"]]: _hover__WEBPACK_IMPORTED_MODULE_1__["default"],
    [_enums_actions__WEBPACK_IMPORTED_MODULE_3__["CLICK"]]: _click__WEBPACK_IMPORTED_MODULE_2__["default"]
};



/***/ }),

/***/ "./packages/muze-legend/src/firebolt/physical/selection-box-drag.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/physical/selection-box-drag.js ***!
  \**************************************************************************/
/*! exports provided: selectionBoxDrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectionBoxDrag", function() { return selectionBoxDrag; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze-legend/src/enums/constants.js");



const getSelectionCriteria = (subject, axis, measures) => {
    let criteria = [];
    const {
        axisScale,
        axisType
    } = axis;
    const {
        startPos,
        endPos,
        selectionBoxMeasure,
        drawingInfMeasure,
        offset
    } = measures;
    const subjectStartPoint = subject[axisType];

    if (startPos[axisType] === endPos[axisType]) {
        criteria = [];
    } else if (subjectStartPoint + selectionBoxMeasure >= drawingInfMeasure + offset) {
        criteria = [axisScale.invert(drawingInfMeasure + offset - selectionBoxMeasure),
            axisScale.invert(drawingInfMeasure + offset)];
    } else if (subjectStartPoint - offset < offset) {
        criteria = [axisScale.invert(offset * 2), axisScale.invert(selectionBoxMeasure + offset * 2)];
    } else {
        criteria = [axisScale.invert(subjectStartPoint), axisScale.invert(subjectStartPoint + selectionBoxMeasure)];
    }
    axisType === 'x' ? criteria : criteria.reverse();
    return criteria;
};

const selectionBoxDrag = firebolt => (targetEl, behaviours) => {
    let startPos = {};
    let payload;
    const endPos = {};
    const d3Drag = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getD3Drag"])();
    const context = firebolt.context;
    const axisScale = context.axis().source().scale();
    const axisType = context.config().align === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HORIZONTAL"] ? 'x' : 'y';
    const drawingInfMeasure = context.measurement().gradientDimensions[axisType === 'x' ?
        _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"]];
    const offset = axisScale.range()[axisType === 'x' ? 0 : 1];
    const measures = {
        drawingInfMeasure,
        offset
    };
    let subject = {};

    targetEl.call(d3Drag().on('start', function () {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        startPos = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getMousePos"])(this, event.sourceEvent);
        subject = event.subject;
    }).on('drag', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        const selectionBoxMeasure = subject[axisType === 'x' ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"]];

        subject.x += event.dx;
        subject.y += event.dy;

        measures.selectionBoxMeasure = selectionBoxMeasure;
        measures.startPos = startPos;
        measures.endPos = endPos;
        const criteria = getSelectionCriteria(subject, { axisScale, axisType }, measures);

        payload = {
            criteria: {
                [context.fieldName()]: criteria
            },
            fadeOut: true
        };
        firebolt.dispatchBehaviour(behaviours[0], payload);
    }).on('end', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        const selectionBoxMeasure = subject[axisType === 'x' ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"] : _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"]];
        measures.selectionBoxMeasure = selectionBoxMeasure;
        measures.startPos = startPos;
        measures.endPos = endPos;
        const criteria = getSelectionCriteria(event, { axisScale, axisType }, measures);
        payload = {
            criteria: {
                [context.fieldName()]: criteria
            },
            fadeOut: true,
            config: {
                transition: {
                    duration: 200
                }
            }
        };
        firebolt.dispatchBehaviour(behaviours[0], payload);
    }));
};



/***/ }),

/***/ "./packages/muze-legend/src/firebolt/side-effects/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/side-effects/index.js ***!
  \*****************************************************************/
/*! exports provided: SelectionBox, LegendHighlighter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection-box */ "./packages/muze-legend/src/firebolt/side-effects/selection-box/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectionBox", function() { return _selection_box__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _legend_highlighter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend-highlighter */ "./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LegendHighlighter", function() { return _legend_highlighter__WEBPACK_IMPORTED_MODULE_1__["default"]; });








/***/ }),

/***/ "./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/index.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/index.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LegendHighlighter; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _strategies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strategies */ "./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/strategies.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../enums/side-effects */ "./packages/muze-legend/src/enums/side-effects.js");




class LegendHighlighter extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["GenericSideEffect"] {
    constructor (...params) {
        super(...params);
        this._strategies = Object(_strategies__WEBPACK_IMPORTED_MODULE_1__["strategies"])(this.firebolt);
        this._strategy = 'brighten';
    }

    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_2__["Highlighter"];
    }

    apply (selectionSet, payload, options = {}) {
        const strategy = this._strategies[options.strategy || this._strategy];

        strategy(selectionSet, this);
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/strategies.js":
/*!*****************************************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/side-effects/legend-highlighter/strategies.js ***!
  \*****************************************************************************************/
/*! exports provided: strategies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strategies", function() { return strategies; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const strategies = (firebolt) => {
    const context = firebolt.context;
    const classed = (set, className, change) => {
        const classPrefix = context.config().classPrefix;
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(context.mount())
                        .selectAll(`.${classPrefix}-legend-columns`)
                        .filter(d => set.uids.indexOf(d.id) !== -1)
                        .selectAll('div')
                        .classed(className, change);
    };

    return {
        fade: (set, config = {}) => {
            const classPrefix = context.config().classPrefix;
            if (!set.mergedEnter.length && !set.mergedExit.length) {
                classed(set.completeSet, config.className || `${classPrefix}-legend-fadeout`, false);
            } else {
                classed(set.mergedExit, config.className || `${classPrefix}-legend-brighten`, false);
                classed(set.mergedExit, config.className || `${classPrefix}-legend-fadeout`, true);
                classed(set.mergedEnter, config.className || `${classPrefix}-legend-fadeout`, false);
            }
        },
        brighten: (set, config = {}) => {
            const classPrefix = context.config().classPrefix;
            if (!set.mergedEnter.length && !set.mergedExit.length) {
                classed(set.completeSet, config.className || `${classPrefix}-legend-brighten`, false);
            } else {
                classed(set.mergedEnter, config.className || `${classPrefix}-legend-brighten`, true);
                classed(set.mergedExit, config.className || `${classPrefix}-legend-brighten`, false);
            }
        }
    };
};


/***/ }),

/***/ "./packages/muze-legend/src/firebolt/side-effects/selection-box/index.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/side-effects/selection-box/index.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _enums_side_effects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../enums/side-effects */ "./packages/muze-legend/src/enums/side-effects.js");
/* harmony import */ var _physical_selection_box_drag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../physical/selection-box-drag */ "./packages/muze-legend/src/firebolt/physical/selection-box-drag.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-legend/src/firebolt/side-effects/selection-box/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);







/**
 * This class is used to create a selection box which is used by visual unit for brushing and
 * selection in the canvas.
 * @class SelectionBox
 */
/* istanbul ignore next */ class SelectionBox extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__["SpawnableSideEffect"] {
    static formalName () {
        return _enums_side_effects__WEBPACK_IMPORTED_MODULE_3__["SELECTIONBOX"];
    }

    /**
     * It returns the default configuration needed by selectionbox.
     * @return {Object} Default configuration of the selection box.
     */
    static defaultConfig () {
        return {
            className: 'legend-selection-box',
            classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["CLASSPREFIX"]
        };
    }

    /**
     * Draws the selectionbox with the specified dimensions.
     */
    /* istanbul ignore next */ apply (selectionSet, payload) {
        let x;
        let y;
        let width;
        let height;
        const firebolt = this.firebolt;
        const context = firebolt.context;
        const config = this.config();
        const axis = context.axis().source();
        const className = `${config.classPrefix}-${config.className}`;

        const domain = payload.criteria[firebolt.context.fieldName()];
        const axisScale = axis.scale();
        const range = domain ? [axis.getScaleValue(domain[0]), axis.getScaleValue(domain[1])] : [];

        const axisType = context.config().align === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"] ? 'x' : 'y';

        const gradientDimension = firebolt.context.measurement().gradientDimensions[axisType === 'x' ?
            _enums_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"]];

        const rangeShifter = axisScale.range()[axisType === 'x' ? 0 : 1];
        const legendGradContainer = context.getDrawingContext().svgContainer;
        const legendSelGroup = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendGradContainer, 'g', [1], `${config.classPrefix}-selection-box-group`);

        if (firebolt.context.config().align === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"]) {
            x = range[0] - rangeShifter || 0;
            y = 0;
            width = range[1] - range[0] || 0;
            height = gradientDimension;
        } else {
            x = 0;
            y = range[1] - rangeShifter || 0;
            height = range[0] - range[1] || 0;
            width = gradientDimension;
        }
        const enterFn = function (el) {
            Object(_physical_selection_box_drag__WEBPACK_IMPORTED_MODULE_4__["selectionBoxDrag"])(firebolt)(el, ['brush']);
        };
        const selBox = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendSelGroup, _enums_constants__WEBPACK_IMPORTED_MODULE_2__["RECT"], [{ domain, x, y, width, height }], className,
            { enter: enterFn });
        selBox.attr('y', y)
                        .attr('x', x)
                        .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], width)
                        .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], height);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SelectionBox);



/***/ }),

/***/ "./packages/muze-legend/src/firebolt/side-effects/selection-box/styles.scss":
/*!**********************************************************************************!*\
  !*** ./packages/muze-legend/src/firebolt/side-effects/selection-box/styles.scss ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-legend/src/index.js":
/*!*******************************************!*\
  !*** ./packages/muze-legend/src/index.js ***!
  \*******************************************/
/*! exports provided: DiscreteLegend, GradientLegend, SimpleLegend, StepLegend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-legend/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend */ "./packages/muze-legend/src/legend/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscreteLegend", function() { return _legend__WEBPACK_IMPORTED_MODULE_1__["DiscreteLegend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GradientLegend", function() { return _legend__WEBPACK_IMPORTED_MODULE_1__["GradientLegend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleLegend", function() { return _legend__WEBPACK_IMPORTED_MODULE_1__["SimpleLegend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StepLegend", function() { return _legend__WEBPACK_IMPORTED_MODULE_1__["StepLegend"]; });






/***/ }),

/***/ "./packages/muze-legend/src/legend/defaults.js":
/*!*****************************************************!*\
  !*** ./packages/muze-legend/src/legend/defaults.js ***!
  \*****************************************************/
/*! exports provided: ALIGN, DEFAULT_MEASUREMENT, LEGEND_TITLE, DEFAULT_CONFIG, ICON_MAP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALIGN", function() { return ALIGN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MEASUREMENT", function() { return DEFAULT_MEASUREMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEGEND_TITLE", function() { return LEGEND_TITLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ICON_MAP", function() { return ICON_MAP; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");



const ALIGN = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
};

const DEFAULT_MEASUREMENT = {
    height: 30,
    width: 30,
    maxWidth: Infinity,
    maxHeight: Infinity,
    padding: 2,
    margin: 2,
    border: 1
};

const LEGEND_TITLE = {
    text: '',
    orientation: (pos) => {
        if (pos === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LEFT"] || pos === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["RIGHT"]) {
            return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LEFT"];
        } return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["CENTER"];
    }
};

const DEFAULT_CONFIG = {
    classPrefix: 'muze',
    borderStyle: 'solid',
    borderColor: 'rgba(0,0,0,0)',
    formatter: {
        bounds: {
            lower: 'less than',
            upper: 'more than'
        }
    },
    item: {
        text: {
            orientation: 'right',
            width: 10,
            formatter: (val, i, data, context) => context.valueParser()(val)
        },
        icon: {
            className: 'legend-icon',
            height: 20,
            width: 20,
            color: 'rgba(0,0,0,.5)',
            type: 'square'
        }
    }
};

/**
 * Creates a map of pre defined icons
 *
 * @param {string} icon Accepts a icon name like 'square', 'cross', 'diamond' etc
 * @return {Object} icon object which can be used to draw the icons
 */
const ICON_MAP = (icon) => {
    if (icon && typeof (icon) === 'string') {
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSymbol"])(icon);
    } return icon;
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/discrete-legend.js":
/*!************************************************************!*\
  !*** ./packages/muze-legend/src/legend/discrete-legend.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiscreteLegend; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-legend */ "./packages/muze-legend/src/legend/simple-legend.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _legend_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legend-helper */ "./packages/muze-legend/src/legend/legend-helper.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer */ "./packages/muze-legend/src/legend/renderer.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles.scss */ "./packages/muze-legend/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);







/**
 * Creates a Legend from the axes of a canvas
 *
 * @param {Object} dependencies : legend data
 * @class Legend
 */
class DiscreteLegend extends _simple_legend__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Initializes an instance of the class
     *
     * @static
     * @param {Object} dependencies Set of dependencies required by the legend
     * @return {Instance} returns a new instance of Legend
     * @memberof Legend
     */
    static create (dependencies) {
        return new DiscreteLegend(dependencies);
    }

    /**
     *
     *
     * @static
     *
     * @memberof DiscreteLegend
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_2__["DISCRETE"];
    }

    /**
     *
     *
     * @param {*} scale
     *
     * @memberof DiscreteLegend
     */
    dataFromScale () {
        const scale = this.scale();
        const { scaleType, domain, scaleFn } = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_3__["getScaleInfo"])(scale);
        let domainForLegend = [...new Set(domain)];
        const field = this.metaData().getFieldspace().fields[0];
        const { type, subtype } = field.schema();

        domainForLegend = domainForLegend.map((ele, i) => {
            let value = 0;
            let range = 0;
            const rawVal = domainForLegend[i];
            if (type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE) {
                value = (+domainForLegend[i]).toFixed(0);
                const nextVal = domainForLegend[i + 1] ? +domainForLegend[i + 1] : +value;
                range = [value, nextVal.toFixed(0)];
            } else {
                let domainVal = rawVal;
                if (subtype === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
                    domainVal = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["formatTemporal"])(domainForLegend[i], field.minimumConsecutiveDifference());
                }
                value = domainVal;
                range = [domainVal];
            }
            return {
                [scaleType]: scale[scaleFn](ele),
                value,
                id: i,
                range,
                rawVal
            };
        }).filter(d => d.value !== null);

        domainForLegend = scaleType === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["SIZE"] ? domainForLegend.sort((a, b) => a[scaleType] - b[scaleType])
            : domainForLegend;
        return domainForLegend;
    }

    /**
     * Render the legend with its title
     *
     * @param {DOM} mountPoint Point where the legend and title are to be appended
     * @return {Instance} Current instance of legend
     * @memberof Legend
     */
    render () {
        const firebolt = this.firebolt();
        const data = this.data();
        const { classPrefix } = this.config();
        const legendContainer = super.render(this.mount());
        // create Legend
        const { legendItem } = Object(_renderer__WEBPACK_IMPORTED_MODULE_4__["createLegendSkeleton"])(this, legendContainer, classPrefix, data);
        const { itemSkeleton } = Object(_renderer__WEBPACK_IMPORTED_MODULE_4__["createItemSkeleton"])(this, legendItem);
        Object(_renderer__WEBPACK_IMPORTED_MODULE_4__["renderDiscreteItem"])(this, itemSkeleton);
        legendContainer.selectAll('div').style('float', _enums_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"]);
        firebolt.mapActionsAndBehaviour();
        firebolt.createSelectionSet(this.data().map(d => d.id));
        return legendContainer;
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/legend/gradient-helper.js":
/*!************************************************************!*\
  !*** ./packages/muze-legend/src/legend/gradient-helper.js ***!
  \************************************************************/
/*! exports provided: getGradientDomain, makeLinearGradient, createAxis, renderAxis, renderGradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradientDomain", function() { return getGradientDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLinearGradient", function() { return makeLinearGradient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAxis", function() { return createAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderAxis", function() { return renderAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderGradient", function() { return renderGradient; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaults */ "./packages/muze-legend/src/legend/defaults.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles.scss */ "./packages/muze-legend/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_4__);






/**
 *
 *
 * @param {*} data
 *
 */
const getGradientDomain = (data) => {
    if (typeof data[0].value === 'number') {
        return data.reduce((accumulator, currentValue) =>
            [Math.min(currentValue.value, accumulator[0]), Math.max(currentValue.value, accumulator[1])],
                [Number.MAX_VALUE, Number.MIN_VALUE]);
    }
    return data.map(e => e.value);
};

/**
 *
 *
 * @param {*} container
 * @param {*} data
 * @param {*} domain
 *
 */
const makeLinearGradient = (container, data, domain) => {
    const defs = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'defs', [1]);
    const linearGradient = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(defs, 'linearGradient', [1])
                .attr('id', 'linear-gradient')
                .attr('x1', '0%')
                .attr('y2', '0%');

    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(linearGradient, 'stop', data, 'stop-gradient')
                    .attr('offset', d => `${(d.value - domain[0]) * 100 / (domain[1] - domain[0]) || 1}%`)
                    .attr('stop-color', d => d.color);
    return linearGradient;
};

/**
 * Creates an axis cell with a linear axis for computing space and
 * creating gradient legend
 *
 * @return {AxisCell} Instance of Axis Cell for the gradient axis
 * @memberof Legend
 */
const createAxis = (context) => {
    const data = context.data();
    const { align } = context.config();
    const AxisCell = context._cells.AxisCell;
    const newAxis = new _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__["ContinousAxis"]({
        id: `legend-${context._id}`,
        orientation: align === _defaults__WEBPACK_IMPORTED_MODULE_3__["ALIGN"].VERTICAL ? _enums_constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"],
        style: context._computedStyle,
        nice: false,
        showAxisName: false,
        tickValues: data.map(d => d.value),
        fixedBaseline: false,
        labels: {
            rotation: null
        }
    }, { labelManager: context._labelManager });

    newAxis.domain(getGradientDomain(data));
    newAxis.range([1, 1]);
    return new AxisCell().source(newAxis).config({
        margin: { left: 0, bottom: 0, top: 0, right: 0 }
    });
};

/**
 *
 *
 * @param {*} container
 * @param {*} data
 * @param {*} classPrefix
 *
 * @memberof GradientLegend
 */
const createLegendSkeleton = (container, classPrefix, data) => {
    const domain = getGradientDomain(data);
    const legendContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', [1], `${classPrefix}-legend-body`);
    const legendGradSvg = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendContainer, 'svg', [1], `${classPrefix}-gradient`);
    const legendGradCont = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendGradSvg, 'g', [1], `${classPrefix}-gradient-group`);
    const linearGradient = makeLinearGradient(legendGradSvg, data, domain);
    const legendRect = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendGradCont, 'rect', [1], `${classPrefix}-gradient-rect`);

    return {
        legendContainer,
        legendGradCont,
        legendGradSvg,
        linearGradient,
        legendRect
    };
};

/**
 * Renders the axis for the gradient
 *
 * @param {Selection} container Point where axis is to be mounted
 * @param {number} height Height for axis
 * @param {number} width Width for axis
 * @memberof Legend
 */
const renderAxis = (context, container, height, width) => {
    const axis = context.axis();

    axis.setAvailableSpace(width, height);
    axis.render(container.node());
    axis.source().render();
};

/**
 * Renders gradient legends
 *
 * @param {Selection} container Point where the legend is to be appended
 * @memberof GradientLegend
 */
const renderGradient = (context, container) => {
    let gradHeight = 0;
    let gradWidth = 0;
    const {
        align,
        classPrefix,
        item
    } = context.config();
    const data = context.data();
    // Create the skeleton for the legend
    const {
        legendContainer,
        legendGradSvg,
        legendGradCont,
        linearGradient,
        legendRect
    } = createLegendSkeleton(container, classPrefix, data);
    const labelDim = context.axis().source().getAxisDimensions().tickDimensions;
    const {
        padding,
        margin,
        border,
        titleSpaces,
        maxItemSpaces,
        maxHeight,
        maxWidth,
        height,
        width
    } = context.measurement();
    const gradientDimensions = {};

    gradHeight = Math.floor(Math.min(height, maxHeight) - (titleSpaces.height + 2 * margin + 2 * border));
    gradWidth = Math.floor(Math.min(width, maxWidth) - (margin * 2 + border * 2));

    if (align === _defaults__WEBPACK_IMPORTED_MODULE_3__["ALIGN"].HORIZONTAL) {
        gradientDimensions.height = item.icon.height;
        gradientDimensions.width = gradWidth - 2 * padding - labelDim.width / 2;
        linearGradient.attr('x2', '100%').attr('y1', '0%');
        legendGradCont.attr('transform', `translate( ${labelDim.width / 2} 0)`);
        renderAxis(context, legendContainer, gradHeight - item.icon.height - padding, gradWidth - 2 * padding - 1);

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(legendContainer, {
            height: `${maxItemSpaces.height + border + padding}px`,
            width: `${Math.min(width, maxWidth)}px`,
            padding: `${padding}px`
        });

        legendRect.attr('height', gradientDimensions.height);
        legendRect.attr('width', gradientDimensions.width - labelDim.width / 2);
    } else {
        gradientDimensions.height = gradHeight - 2 * padding - labelDim.height / 2;
        gradientDimensions.width = item.icon.width;
        linearGradient.attr('x2', '0%').attr('y1', '100%');
        legendGradCont.attr('transform', `translate(0 ${labelDim.height / 2})`);
        renderAxis(context, legendContainer, gradHeight - 2 * padding - 1, gradWidth - item.icon.width - padding * 2);

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(legendContainer, {
            height: `${Math.min(height, maxHeight)}px`,
            width: `${maxWidth}px`,
            padding: `${padding}px`
        });
        legendRect.attr('height', gradientDimensions.height - labelDim.height / 2);
        legendRect.attr('width', gradientDimensions.width);
    }

    // Apply Styles to the legend plot area
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(legendGradSvg, {
        height: `${gradientDimensions.height}px`,
        width: `${gradientDimensions.width}px`
    });

        // Apply styles to the legend rect
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(legendRect, {
        fill: 'url(#linear-gradient)'
    });
    legendGradSvg.attr('height', gradientDimensions.height);
    legendGradSvg.attr('width', gradientDimensions.width);

    context.measurement({
        gradientDimensions
    });
    context._legendGradientSvg = legendGradSvg;
    return context;
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/gradient-legend.js":
/*!************************************************************!*\
  !*** ./packages/muze-legend/src/legend/gradient-legend.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GradientLegend; });
/* harmony import */ var _simple_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-legend */ "./packages/muze-legend/src/legend/simple-legend.js");
/* harmony import */ var _legend_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend-helper */ "./packages/muze-legend/src/legend/legend-helper.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _gradient_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gradient-helper */ "./packages/muze-legend/src/legend/gradient-helper.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles.scss */ "./packages/muze-legend/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_4__);






/**
 * Creates a Legend from the axes of a canvas
 *
 * @param {Object} dependencies : legend data
 * @class Legend
 */
class GradientLegend extends _simple_legend__WEBPACK_IMPORTED_MODULE_0__["default"] {

    /**
     * Initializes an instance of the class
     *
     * @static
     * @param {Object} dependencies Set of dependencies required by the legend
     * @return {Instance} returns a new instance of Legend
     * @memberof Legend
     */
    static create (dependencies) {
        return new GradientLegend(dependencies);
    }

    /**
     *
     *
     * @static
     *
     * @memberof GradientLegend
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_2__["GRADIENT"];
    }

    /**
     *
     *
     * @param {*} axis
     *
     * @memberof GradientLegend
     */
    axis (...axis) {
        if (axis.length) {
            this._axis = axis[0];
            return this;
        }
        return this._axis;
    }

    /**
     *
     *
     * @param {*} scale
     *
     * @memberof GradientLegend
     */
    dataFromScale () {
        let domainForLegend = [];
        const scale = this.scale();
        const { scaleType, domain, steps, scaleFn } = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getScaleInfo"])(scale);

        // defining scaleParams
        const scaleParams = {
            smartLabel: this.labelManager(),
            measures: this.measurement(),
            alignment: this.config().position,
            minTickDistance: this.minTickDistance()
        };

        if (steps instanceof Array) {
            if (domain[0] < steps[0]) {
                domainForLegend[0] = domain[0];
            }
            domainForLegend = [...domainForLegend, ...steps];
            if (domain[domain.length - 1] > steps[steps.length - 1]) {
                domainForLegend.push(domain[1]);
            }
            // Sorting the domain Array
            domainForLegend = [...new Set(domainForLegend)].sort((a, b) => a - b);

            domainForLegend = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getInterpolatedArrayData"])(domainForLegend, scaleParams);
        } else {
            domainForLegend = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getInterpolatedData"])(domain, steps - 1, scaleParams);
        }
        domainForLegend = [...new Set(domainForLegend)].sort((a, b) => a - b);

        return domainForLegend.map((ele, i) => {
            const value = domainForLegend[i];
            return {
                [scaleType]: scaleType === _enums_constants__WEBPACK_IMPORTED_MODULE_2__["SIZE"] ? scale[scaleFn](ele) * scale.getScaleFactor()
                    : scale[scaleFn](Math.floor(ele)),
                value: +value.toFixed(2),
                id: i
            };
        }).filter(d => d.value !== null);
    }

    /**
     *
     *
     * @param {*} effPadding
     * @param {*} align
     *
     * @memberof Legend
     */
    getLabelSpaces (effPadding) {
        this.config({
            item: {
                text: {
                    orientation: this.config().position
                }
            }
        });
        const axis = Object(_gradient_helper__WEBPACK_IMPORTED_MODULE_3__["createAxis"])(this);
        const axisSpace = axis.getLogicalSpace();
        const space = { width: axisSpace.width - effPadding, height: axisSpace.height - effPadding };
        const axisDomainLength = axis.source().domain().length;
        const labelSpaces = new Array(axisDomainLength).fill(space);

        this.axis(axis);
        return labelSpaces;
    }

    /**
     *
     *
     *
     * @memberof GradientLegend
     */
    getDrawingContext () {
        return {
            svgContainer: this._legendGradientSvg
        };
    }

    /**
     * Render the legend with its title
     *
     * @param {DOM} mountPoint Point where the legend and title are to be appended
     * @return {Instance} Current instance of legend
     * @memberof Legend
     */
    render () {
        const firebolt = this.firebolt();
        const legendContainer = super.render(this.mount());
        // create Legend
        Object(_gradient_helper__WEBPACK_IMPORTED_MODULE_3__["renderGradient"])(this, legendContainer);
        legendContainer.selectAll('div').style('float', _enums_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"]);
        firebolt.mapActionsAndBehaviour();
        firebolt.createSelectionSet(this.data().map(d => d.id));
        return legendContainer;
    }
 /**
     *
     *
     * @param {*} data
     *
     * @memberof SimpleLegend
     */
    getCriteriaFromData (data) {
        return [[this.fieldName()], [data.value]];
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/legend/index.js":
/*!**************************************************!*\
  !*** ./packages/muze-legend/src/legend/index.js ***!
  \**************************************************/
/*! exports provided: DiscreteLegend, GradientLegend, SimpleLegend, StepLegend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _discrete_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./discrete-legend */ "./packages/muze-legend/src/legend/discrete-legend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscreteLegend", function() { return _discrete_legend__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _gradient_legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gradient-legend */ "./packages/muze-legend/src/legend/gradient-legend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GradientLegend", function() { return _gradient_legend__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _simple_legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simple-legend */ "./packages/muze-legend/src/legend/simple-legend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleLegend", function() { return _simple_legend__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _step_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./step-legend */ "./packages/muze-legend/src/legend/step-legend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StepLegend", function() { return _step_legend__WEBPACK_IMPORTED_MODULE_3__["default"]; });









/***/ }),

/***/ "./packages/muze-legend/src/legend/legend-helper.js":
/*!**********************************************************!*\
  !*** ./packages/muze-legend/src/legend/legend-helper.js ***!
  \**********************************************************/
/*! exports provided: getScaleInfo, getInterpolatedArrayData, getInterpolatedData, titleCreator, getMaxMeasures, getItemMeasures, computeItemSpaces, getDomainBounds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaleInfo", function() { return getScaleInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInterpolatedArrayData", function() { return getInterpolatedArrayData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInterpolatedData", function() { return getInterpolatedData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "titleCreator", function() { return titleCreator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxMeasures", function() { return getMaxMeasures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getItemMeasures", function() { return getItemMeasures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeItemSpaces", function() { return computeItemSpaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDomainBounds", function() { return getDomainBounds; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");




/**
 *
 *
 * @param {*} scale
 *
 */
const getScaleInfo = (scale) => {
    const scaleType = scale.constructor.type();
    const domain = scale.uniqueValues();
    const steps = scale.config().stops || 1;
    const scaleFn = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SCALE_FUNCTIONS"][scaleType];

    return { scaleType, domain, steps, scaleFn };
};

/**
 * Function to recompute the stops in array in case to left and right alignment of legend.
 *
 * @param  {string} param - parameter to measure
 * @param  {Object} requiredMeasure - required measure parameters
 * @param  {Object} availableMeasure - available meassure parameters
 * @param  {Array} domainForLegend - array
 * @param  {Object} smartLabelCalc - smartLabel Manager
 * @return {Array} - Array
 */
const getcomputedArray = (computationhelper, requiredMeasure, availableMeasure, domainForLegend) => {
    // declaring Current and Next Tick Value variable
    let currentTickValue;
    let nextTickValue;
    const upperBound = domainForLegend[domainForLegend.length - 1];
    const param = computationhelper.measureParam;
    const smartLabelCalc = computationhelper.smartLabelCalc;

    // calculating pixel required per Tick Values
    const pixelPerTick = (availableMeasure[param] / upperBound);

    // checking if available max width is smaller than required width for legend.
    if (availableMeasure[param] >= requiredMeasure[param]) {
        return domainForLegend;
    }

    currentTickValue = (smartLabelCalc.getOriSize((domainForLegend[0]))[param]);
    for (let i = 1; i < domainForLegend.length - 1; i++) {
        nextTickValue = Math.floor((currentTickValue / pixelPerTick) + domainForLegend[i - 1]);
        if (domainForLegend[i] < nextTickValue) {
            domainForLegend.splice(i, 1);
            i -= 1;
        }
        currentTickValue = (smartLabelCalc.getOriSize((domainForLegend[i]))[param]);
    }
    return domainForLegend;
};

/**
 * function to recompute the Stops Array provided to prevent the Overlapping of values
 * @param  {Array} domainForLegend - Stops Array
 * @param  {Object} scaleParams - Scale Parameters
 * @return {Array} - modified Stops Array
 */
const getInterpolatedArrayData = (domainForLegend, scaleParams) => {
    // defining param for height/width selector
    let measureParam;

    // declaring variable for required Width
    let requiredWidth;

    // declaring variable for required height
    let requiredHeight;

    // declaring the variable for upperbound
    let upperBound = domainForLegend[domainForLegend.length - 1];

    // Initializing Minimum Tick Difference Variable and checking if it's less than 1 or not
    let minTickDiff = Math.ceil(domainForLegend[1] - domainForLegend[0]);

    // calculating max tick difference
    const maxTickDiff = Math.ceil(upperBound - domainForLegend[0]);

    // gradient Alignment
    const { alignment } = scaleParams;

    // getting SmartLabel Manager to calculate tick Params
    const smartLabelCalc = scaleParams.smartLabel;

    // scale Measurements (i.e MaxWidth and MaxHeight available)
    const availableSpace = scaleParams.measures;

    // getting minimum Tick size (i.e height and width)
    const minimumTickSize = scaleParams.minTickDistance;

    // getting domain upperbound dimensions
    const { height: tickDimHeight, width: tickDimWidth } = smartLabelCalc.getOriSize((upperBound));

    /* Checking if UpperBound of Domain is Floating or Not.
    In case of floating constricting it to 2 decimals after point. */
    if (!Number.isInteger(upperBound)) {
        upperBound = ((upperBound).toFixed(2));
    }

    // Calculating minimum tick difference
    minTickDiff = minTickDiff < 1 ? 1 : minTickDiff;

    // required width to render legend
    requiredWidth = (Math.abs(maxTickDiff) / Math.abs(minTickDiff)) * (tickDimWidth + (minimumTickSize.width));

    requiredWidth -= Math.abs(maxTickDiff);

    // require height to render legend
    requiredHeight = (Math.abs(maxTickDiff) / Math.abs(minTickDiff)) * tickDimHeight;

    requiredHeight -= Math.abs(maxTickDiff);

    // checking the alignment of legend
    if (alignment === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"] || alignment === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) {
        measureParam = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"];
    } else {
        measureParam = _enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"];
    }

    // calculating computed array
    domainForLegend = getcomputedArray({
        smartLabelCalc,
        measureParam
    }, {
        height: requiredHeight,
        width: requiredWidth
    }, {
        height: availableSpace.maxHeight,
        width: availableSpace.maxWidth
    }, domainForLegend);

    return domainForLegend;
};

/**
 * function to recalculate steps on providing more number of stops than canvas can accomodate.
 * @param  {Array} domain - Array
 * @param  {Array} steps - Array
 * @param  {Object} scaleParams - Scale Parameters
 * @return {Array} - recalculated Step Array
 */
const getInterpolatedData = (domain, steps, scaleParams) => {
    // declaring recomputeSteps Variable
    let recomputeSteps = 0;

    const getTickMeasure = scaleParams.smartLabel;
    const { maxWidth, maxHeight } = scaleParams.measures;
    const { alignment } = scaleParams;
    const domainForLegend = [];
    const interpolatedFn = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["numberInterpolator"])()(domain[0], domain[1]);

    // getting tick measure(i.e height and width)
    const tickValue = getTickMeasure.getOriSize(domain[1].toFixed(2));

    // To round the floating values to Integer and checking if value is 1.
    steps = Math.round(steps);
    steps = steps < 1 ? (steps + 1) : steps;

    // checking alignment of the Axis
    if (alignment === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"] || alignment === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) {
        recomputeSteps = Math.floor(maxWidth / (tickValue.width));
    } else {
        recomputeSteps = Math.floor(maxHeight / (tickValue.height));
    }
    steps = Math.min(steps, recomputeSteps);

    // scaling the axis based on steps provided
    for (let i = 0; i <= steps; i++) {
        domainForLegend[i] = interpolatedFn(i / steps);
    }
    return domainForLegend;
};

/**
 *
 *
 * @param {*} container
 * @param {*} text
 * @param {*} measurement
 * @param {*} classPrefix
 */
const titleCreator = (container, title, measurement, config) => {
    const titleWidth = Math.min(measurement.maxWidth, measurement.width);

    const titleContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'table', [1], `${config.classPrefix}-legend-title`)
            .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"], `${titleWidth}px`)
            .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"], `${measurement.height}px`)
            .style('border-bottom', `${measurement.border}px ${config.borderStyle} ${config.borderColor}`)
            .style('text-align', title.orientation instanceof Function ?
            title.orientation(config.position) : title.orientation);
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(titleContainer, 'td', [1], `${config.classPrefix}-legend-title-text`)
                    .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"], `${titleWidth}px`)
                    .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["MAXWIDTH"], `${titleWidth}px`)
                    .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"], '100%')
                    .style('line-height', 1)
                    .style('padding', `${measurement.padding}px`)
                    .text(title.text)
                    .style('overflow-x', 'scroll')
                    .node();
};

/**
 *
 *
 * @param {*} data
 * @param {*} prop
 * @param {*} labelManager
 *
 */
const getMaxMeasures = (data, prop, labelManager) => {
    let maxHeight = -Infinity;
    let maxWidth = -Infinity;

    data.forEach((item) => {
        const value = prop ? item[prop] : item;
        const space = labelManager.getOriSize(value);
        maxHeight = Math.max(space.height + 2, maxHeight);
        maxWidth = Math.max(space.width + 2, maxWidth);
    });

    return { height: maxHeight, width: maxWidth };
};

/**
 *
 *
 * @param {*} data
 * @param {*} prop
 * @param {*} labelManager
 *
 */
const getItemMeasures = (context, prop, formatter) => {
    const space = [];
    const data = context.data();
    const labelManager = context._labelManager;

    data.forEach((item, index) => {
        const value = prop ? item[prop] : item;
        const { height, width } = labelManager.getOriSize(formatter(value, index, data, context));
        space[index] = { height: height + 1, width: width + 1 };
    });
    return space;
};

/**
 *
 *
 * @param {*} textOrientation
 * @param {*} effPadding
 * @param {*} titleSpace
 *
 * @memberof Legend
 */
const computeItemSpaces = (config, measures, data) => {
    let totalHeight = 0;
    let totalWidth = 0;
    let maxItemSpaces = {
        width: 0, height: 0
    };
    const {
        effPadding,
        titleWidth,
        labelSpaces,
        titleHeight,
        maxWidth
    } = measures;
    const {
        item,
        align
    } = config;
    const {
        icon,
        text
    } = item;
    const textOrientation = text.orientation;
    const itemSpaces = [];
    const iconSpaces = [];
    let maxIconWidth = 0;
    labelSpaces.forEach((labelSpace, i) => {
        const itemSpace = { width: 0, height: 0 };
        const iconSpace = { width: 0, height: 0 };
        const datum = data[i] || {};
            // Compute each legend item height/width
        if (textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LEFT"] || textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["RIGHT"]) {
            // Get label, icon and item widths
            labelSpace.width += effPadding;
            iconSpace.width = (datum.size ? 2 * Math.sqrt(datum.size / Math.PI) : icon.width) + effPadding;
            maxIconWidth = Math.max(iconSpace.width, maxIconWidth);
            itemSpace.width = labelSpace.width + maxIconWidth;

            // Get label, icon and item heights
            labelSpace.height = Math.max(labelSpace.height, icon.height) + effPadding;
            iconSpace.height = labelSpace.height;
            itemSpace.height = labelSpace.height;
        } else {
            // Get label, icon and item widths
            labelSpace.width = Math.max(labelSpace.width, datum.size ? 2 * Math.sqrt(datum.size / Math.PI)
            : icon.width) + effPadding;
            iconSpace.width = labelSpace.width;
            itemSpace.width = labelSpace.width;
            maxIconWidth = Math.max(iconSpace.width, maxIconWidth);

            // Get label, icon and item heights
            labelSpace.height += effPadding;
            iconSpace.height = icon.height + effPadding;
            itemSpace.height = labelSpace.height + iconSpace.height;
        }
        // Compute height and width of legend for each alignment
        if (align === 'horizontal') {
            totalHeight = Math.max(totalHeight, itemSpace.height);
        } else {
            totalHeight += itemSpace.height;
            totalWidth = Math.max(totalWidth, itemSpace.width, titleWidth);
        }
        maxItemSpaces = {
            width: Math.max(itemSpace.width, maxItemSpaces.width),
            height: Math.max(itemSpace.height, maxItemSpaces.height)
        };
        itemSpaces.push(itemSpace);
        iconSpaces.push(iconSpace);
    });
    itemSpaces.forEach((itemSpace, i) => {
        if (align === 'horizontal') {
            itemSpace.height = totalHeight;
            iconSpaces[i].width = maxIconWidth;
            if (textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["LEFT"] || textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["RIGHT"]) {
                labelSpaces[i].height = totalHeight;
                iconSpaces[i].height = totalHeight;
                itemSpaces[i].width = labelSpaces[i].width + maxIconWidth;
            } else {
                labelSpaces[i].width = maxIconWidth;
                itemSpaces[i].width = maxIconWidth;
                labelSpaces[i].width = maxIconWidth;
            }
            totalWidth = Math.max(totalWidth + itemSpaces[i].width);
        } else {
            itemSpace.width = Math.max(totalWidth, maxWidth);
            if (textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"] || textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) {
                labelSpaces[i].width = totalWidth;
                iconSpaces[i].width = totalWidth;
                maxIconWidth = totalWidth;
            } else {
                const labelWidth = labelSpaces[i].width;
                const newLabelWidth = (maxItemSpaces.width - maxIconWidth);
                iconSpaces[i].width = maxIconWidth;
                itemSpaces[i].width = labelSpaces[i].width + maxIconWidth;
                labelSpaces[i].width = Math.max(labelWidth, newLabelWidth);
                totalWidth = Math.max(totalWidth, itemSpace.width);
            }
        }
    });
    totalWidth = Math.ceil(Math.max(totalWidth, titleWidth)) + effPadding;
    totalHeight += titleHeight + effPadding;
    totalHeight = Math.ceil(totalHeight);
    return { totalHeight, totalWidth, itemSpaces, iconSpaces, maxItemSpaces, maxIconWidth };
};

/**
 *
 *
 * @param {*} type
 * @param {*} scaleInfo
 * @param {*} domainInfo
 *
 */
const getDomainBounds = (type, scaleInfo, domainInfo) => {
    const {
        scaleFn,
        scaleType,
        scale
    } = scaleInfo;
    const {
        domain,
        domainBounds,
        domainLeg,
        steps
    } = domainInfo;
    const ele = domain[type === 'lower' ? 0 : domain.length - 1];
    const step = steps[type === 'lower' ? 0 : steps.length - 1];

    return {
        [scaleType]: scaleType === 'size' ? scale[scaleFn](ele) * scale.getScaleFactor() : scale[scaleFn](ele),
        value: domainBounds[type],
        id: type === 'lower' ? 0 : domainLeg.length + 2,
        range: [ele, step]
    };
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/position-config.js":
/*!************************************************************!*\
  !*** ./packages/muze-legend/src/legend/position-config.js ***!
  \************************************************************/
/*! exports provided: positionConfig, alignmentMap, stepData, itemStack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionConfig", function() { return positionConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alignmentMap", function() { return alignmentMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepData", function() { return stepData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "itemStack", function() { return itemStack; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");


const legendOrientation = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"]]: {
        datasets: data => ({
            row: [1],
            column: data
        }),
        itemContainerMeasures: (measurement) => {
            const {
                itemSpaces,
                width
            } = measurement;
            return {
                row: {
                    width: `${width}px`,
                    padding: `${0}px`
                },
                column: {
                    width: (d, i) => `${itemSpaces[i].width}px`,
                    padding: `${0}px`
                }
            };
        },
        getStepSpacesInfo: (measurement) => {
            const { maxItemSpaces, height } = measurement;
            return {
                iconHeight: height,
                iconWidth: maxItemSpaces.width,
                stepPadding: {
                    horizontal: true,
                    vertical: false
                }
            };
        }
    },
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"]]: {
        datasets: data => ({
            row: data,
            column: d => [d]
        }),
        itemContainerMeasures: (measurement, config) => {
            const {
                width
            } = measurement;
            const { padding } = config;

            return {
                row: {
                    width: `${width}px`,
                    padding: `${padding}px`
                },
                column: {
                    width: `${width}px`,
                    padding: `${0}px`
                }
            };
        },
        getStepSpacesInfo: (measurement) => {
            const { maxItemSpaces, width } = measurement;
            return {
                iconHeight: maxItemSpaces.height,
                iconWidth: width,
                stepPadding: {
                    horizontal: false,
                    vertical: true
                }
            };
        }
    }
};

const positionConfig = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: legendOrientation[_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: legendOrientation[_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: legendOrientation[_enums_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: legendOrientation[_enums_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"]]
};

const alignmentMap = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["END"],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["START"],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"]
};

// Reverses data for step legend
const stepData = data => ({
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: data.reverse(),
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: data.reverse(),
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: data,
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: data
});

// Changes the item layout based on the position of the text
const itemStack = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VALUE"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["VALUE"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["VALUE"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"]],
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_0__["VALUE"]]
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/props.js":
/*!**************************************************!*\
  !*** ./packages/muze-legend/src/legend/props.js ***!
  \**************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const PROPS = {
    config: {
        sanitization: (context, value) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._config || {}, value)
    },
    data: {},
    fieldName: {},
    legendContainer: {},
    measurement: {
        sanitization: (context, value) => {
            const measurement = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._measurement, value);
            ['padding', 'border', 'margin'].forEach((space) => {
                measurement[space] = Math.min(measurement[space] > 0 ? measurement[space] : 0,
                     measurement.maxWidth * 0.1, measurement.maxHeight * 0.1);
            });
            return measurement;
        }
    },
    logicalSpace: {},
    metaData: {},
    range: {
        sanitization: (context, value) => {
            context.scale().range(value);
            context.resetLogicalSpace();
            context.store().commit('range', value);
            return value;
        }
    },
    scale: {},
    smartTicks: {},
    store: {},
    title: {
        sanitization: (context, value) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._title || {}, value)
    },
    labelManager: {},
    minTickDistance: {},
    valueParser: {
        defaultValue: val => val
    }
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/renderer.js":
/*!*****************************************************!*\
  !*** ./packages/muze-legend/src/legend/renderer.js ***!
  \*****************************************************/
/*! exports provided: getItemContainers, createLegendSkeleton, createItemSkeleton, applyItemStyle, getLegendIcon, renderIcon, renderDiscreteItem, renderStepItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getItemContainers", function() { return getItemContainers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLegendSkeleton", function() { return createLegendSkeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createItemSkeleton", function() { return createItemSkeleton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyItemStyle", function() { return applyItemStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLegendIcon", function() { return getLegendIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderIcon", function() { return renderIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderDiscreteItem", function() { return renderDiscreteItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderStepItem", function() { return renderStepItem; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./packages/muze-legend/src/legend/defaults.js");
/* harmony import */ var _position_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position-config */ "./packages/muze-legend/src/legend/position-config.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");





/**
 *
 *
 * @param {*} container
 * @param {*} data
 * @param {*} legendInstance
 * @param {*} align
 *
 */
const getItemContainers = (container, data, legendInstance) => {
    const measurement = legendInstance.measurement();
    const config = legendInstance.config();
    const {
        itemSpaces
    } = measurement;
    const {
        classPrefix,
        position
    } = config;
    const positionObj = _position_config__WEBPACK_IMPORTED_MODULE_2__["positionConfig"][position];
    const datasets = positionObj.datasets(data);
    const measures = positionObj.itemContainerMeasures(measurement, config);

    const rows = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', datasets.row, `${classPrefix}-legend-row`);
    rows.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], (d, i) => `${itemSpaces[i].height}px`);
    rows.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], measures.row.width);
    rows.style('padding', measures.row.padding);

    const columns = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(rows, 'div', datasets.column, `${classPrefix}-legend-columns`);
    columns.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], measures.column.width);
    columns.style('padding', measures.column.padding);

    return columns;
};

/**
 *
 *
 * @param {*} container
 * @param {*} classPrefix
 * @param {*} data
 *
 * @memberof DiscreteLegend
 */
const createLegendSkeleton = (context, container, classPrefix, data) => {
    let gradWidth = 0;
    let gradHeight = 0;
    let maxGradHeight = 0;
    let maxGradWidth = 0;
    const measurement = context.measurement();
    const {
            margin,
            border,
            titleSpaces,
            width,
            height,
            maxWidth,
            maxHeight
        } = measurement;

    gradHeight = height - (titleSpaces.height + 2 * margin + 2 * border);
    gradWidth = width - (margin * 2 + border * 2);

    maxGradHeight = maxHeight - (titleSpaces.height + margin * 2 + border * 2);
    maxGradWidth = maxWidth - (margin * 2 + border * 2);

    let legendBody = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', [1], `${classPrefix}-legend-body`);
    legendBody.select(`.${classPrefix}-legend-overflow`).remove();
        // Create a div with scroll when overflow
    if (maxGradWidth && maxGradWidth < gradWidth) {
        legendBody = legendBody.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], `${maxGradWidth}px`).style('overflow-x', 'scroll');
    }
        // Create a div with scroll when overflow
    if (maxGradHeight && maxGradHeight < gradHeight) {
        legendBody.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], `${maxGradHeight}px`).style('overflow-y', 'scroll');
    }

    legendBody = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendBody, 'div', [1], `${classPrefix}-legend-overflow`);

    legendBody.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], `${gradWidth}px`);
    legendBody.style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], `${gradHeight}px`);

    const legendItem = getItemContainers(legendBody, data, context);
    return { legendItem };
};

/**
 * Creates legend item based on alignment and text orientation
 *
 * @param {Selection} container Point where items are to be mounted
 * @return {Instance} Current instance
 * @memberof Legend
 */
const createItemSkeleton = (context, container) => {
    const {
        classPrefix,
        item
    } = context.config();
    const textOrientation = item.text.orientation;

    const stack = _position_config__WEBPACK_IMPORTED_MODULE_2__["itemStack"][textOrientation];
    const itemSkeleton = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', (d, i) => stack.map(e => [e, d[e], d.color, d.size,
        d.value, context.fieldName(), i]), `${classPrefix}-legend-item-info`);

    const alignClass = _position_config__WEBPACK_IMPORTED_MODULE_2__["alignmentMap"][textOrientation];

    itemSkeleton.classed(alignClass, true);
    return { itemSkeleton };
};

/**
 *
 *
 * @param {*} measureType
 * @param {*} stepColorCheck
 */
const applyItemStyle = (item, measureType, stepColorCheck, context) => {
    const {
        padding,
        labelSpaces,
        iconSpaces,
        maxIconWidth
    } = context.measurement();
    const diff = stepColorCheck ? -padding * 2 : 0;

    if (item[0] === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["VALUE"]) {
        return `${labelSpaces[item[6]][measureType]}px`;
    }
    return `${measureType === 'width' && !stepColorCheck ? maxIconWidth : iconSpaces[item[6]][measureType] - diff}px`;
};

/**
 *
 *
 * @param {*} str
 *
 */
const checkPath = (str) => {
    if (/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(str) && /[\dz]$/i.test(str) && str.length > 4) {
        return true;
    }
    return false;
};

/**
 *
 *
 * @param {*} d
 * @param {*} elem
 */
const createShape = function (d, elem, defaultIcon, width, height) {
    const groupElement = elem;
    // const { shape, size, update } = d;
    const size = d[3] || Math.min(width, height) * Math.PI;
    const shape = d[1] || defaultIcon;

    if (shape instanceof Promise) {
        shape.then((res) => {
            d.shape = res;
            return createShape(d, elem);
        });
    } else if (shape instanceof Element) {
        let newShape = shape.cloneNode(true);

        if (newShape.nodeName.toLowerCase() === 'img') {
            const src = newShape.src || newShape.href;
            newShape = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            newShape.setAttribute('href', src);
        }
        const shapeElement = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(newShape);
        shapeElement.attr('transform', `scale(${size / 100})`);
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(groupElement.node().appendChild(newShape));
    } else if (typeof shape === 'string') {
        let pathStr;
        if (checkPath(shape)) {
            pathStr = shape;
        } else {
            pathStr = Object(_defaults__WEBPACK_IMPORTED_MODULE_1__["ICON_MAP"])(shape).size(size)();
        }
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(groupElement, 'path', data => [data]).attr('d', pathStr);
    }
    d[1] = 'circle';
    return createShape(d, elem, 'circle');
};

/**
 * Returns the icon of the legend item
 *
 * @param {Object} datum Data property attached to the item
 * @param {number} width width of the item
 * @param {number} height height of the item
 * @return {Object|string} returns the path string or the string name of the icon
 * @memberof Legend
 */
const getLegendIcon = (datum, width, height, defaultIcon) => {
    const icon = Object(_defaults__WEBPACK_IMPORTED_MODULE_1__["ICON_MAP"])(datum[1]);

    if (icon) {
        return icon.size(datum[3] || Math.min(width, height) * Math.PI);
    }
    return Object(_defaults__WEBPACK_IMPORTED_MODULE_1__["ICON_MAP"])(datum[3] ? 'circle' : defaultIcon).size(datum[3] || Math.min(width, height) * Math.PI);
};

/**
 *
 *
 */
const renderIcon = (icon, container, datum, context) => {
    const {
        classPrefix,
        iconHeight,
        iconWidth,
        maxIconWidth,
        padding,
        color
    } = context;
    const svg = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'svg', f => [f], `${classPrefix}-legend-icon-svg`)
    .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], maxIconWidth)
    .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], iconHeight)
    .style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], `${maxIconWidth}px`)
    .style(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], `${iconHeight}px`);

    if (icon !== _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RECT"]) {
        const group = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(svg, 'g', [datum[1]], `${classPrefix}-legend-icon`);
        createShape(datum, group, datum[3] ? 'circle' : 'square', iconWidth, iconHeight)
                        .attr('transform', `translate(${maxIconWidth / 2 - padding} ${iconHeight / 2})`)
                        .attr('fill', datum[2] || color);
    } else {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(svg, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RECT"], [datum[1]], `${classPrefix}-legend-icon`)
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], maxIconWidth)
                        .attr(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], iconHeight)
                        .attr('fill', datum[2] || color);
    }
};

/**
 * Renders the items in the legend i.e, icon and text
 *
 * @param {DOM} container Point where item is to be mounted
 * @memberof Legend
 */
const renderDiscreteItem = (context, container) => {
    const labelManager = context._labelManager;
    const {
           item,
           classPrefix
    } = context.config();
    const {
        maxIconWidth,
        padding
    } = context.measurement();
    const {
            width: iconWidth,
            height: iconHeight,
            color,
            className
        } = item.icon;

    const textOrientation = item.text.orientation;
    const formatter = item.text.formatter;

    labelManager.useEllipsesOnOverflow(true);
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(container, {
        width: d => applyItemStyle(d, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], false, context),
        height: d => applyItemStyle(d, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], false, context),
        'text-align': _enums_constants__WEBPACK_IMPORTED_MODULE_3__["CENTER"],
        padding: `${padding}px`
    });

    labelManager.setStyle(context._computedStyle);
    const dataArr = container.data();
    container.each(function (d, i) {
        if (d[0] === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["VALUE"]) {
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).text(formatter(d[1], i, dataArr, context))
                            .style(`padding-${textOrientation === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RIGHT"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_3__["LEFT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RIGHT"]}`, '0px');
        } else {
            // const icon = getLegendIcon(d, iconWidth, iconHeight, type);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).classed(`${classPrefix}-${className}`, true);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).classed(`${classPrefix}-${className}-${i}`, true);
            renderIcon('circle', Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this), d, {
                classPrefix,
                iconWidth,
                // iconWidth: 2 * Math.sqrt(d[3] / Math.PI) || iconWidth,
                iconHeight,
                maxIconWidth,
                padding,
                color
            });
        }
    });
};

/**
* Renders the items in the legend i.e, icon and text
*
* @param {DOM} container Point where item is to be mounted
* @memberof Legend
*/
const renderStepItem = (context, container) => {
    const labelManager = context._labelManager;
    const {
      item,
      position,
      classPrefix
   } = context.config();
    const {
      maxItemSpaces,
      maxIconWidth,
      padding
   } = context.measurement();
    const {
       width,
       height,
       color
   } = item.icon;
    const {
        formatter
   } = item.text;

    labelManager.useEllipsesOnOverflow(true);
    const { iconHeight, iconWidth, stepPadding } = _position_config__WEBPACK_IMPORTED_MODULE_2__["positionConfig"][position].getStepSpacesInfo({
        maxItemSpaces, height, width
    });

    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(container, {
        width: d => applyItemStyle(d, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["WIDTH"], stepPadding.horizontal, context),
        height: d => applyItemStyle(d, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["HEIGHT"], stepPadding.vertical, context),
        'text-align': 'center',
        padding: `${padding}px`
    });

    labelManager.setStyle(context._computedStyle);
    const dataArr = container.data();
    container.each(function (d, i) {
        if (d[0] === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["VALUE"]) {
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).text(formatter(d[1], i, dataArr, context));
        } else {
            renderIcon(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["RECT"], Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this), d, {
                classPrefix,
                iconWidth,
                iconHeight,
                maxIconWidth,
                color
            });
        }
    });
};


/***/ }),

/***/ "./packages/muze-legend/src/legend/simple-legend.js":
/*!**********************************************************!*\
  !*** ./packages/muze-legend/src/legend/simple-legend.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SimpleLegend; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _firebolt_behavioural__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../firebolt/behavioural */ "./packages/muze-legend/src/firebolt/behavioural/index.js");
/* harmony import */ var _firebolt_legend_firebolt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../firebolt/legend-firebolt */ "./packages/muze-legend/src/firebolt/legend-firebolt.js");
/* harmony import */ var _firebolt_action_behaviour_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../firebolt/action-behaviour-map */ "./packages/muze-legend/src/firebolt/action-behaviour-map.js");
/* harmony import */ var _firebolt_physical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../firebolt/physical */ "./packages/muze-legend/src/firebolt/physical/index.js");
/* harmony import */ var _firebolt_side_effects__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../firebolt/side-effects */ "./packages/muze-legend/src/firebolt/side-effects/index.js");
/* harmony import */ var _firebolt_behaviour_effect_map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../firebolt/behaviour-effect-map */ "./packages/muze-legend/src/firebolt/behaviour-effect-map.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./props */ "./packages/muze-legend/src/legend/props.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./defaults */ "./packages/muze-legend/src/legend/defaults.js");
/* harmony import */ var _legend_helper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./legend-helper */ "./packages/muze-legend/src/legend/legend-helper.js");














/**
 * Creates a Legend from the axes of a canvas
 *
 * @param {Object} dependencies : legend data
 * @class SimpleLegend
 */
class SimpleLegend {

    /**
     * Creates an instance of Legend.
     * @param {Object} dependencies Set of dependencies required by the legend
     * @memberof Legend
     */
    constructor (dependencies) {
        this._data = [];
        this._metaData = [];
        this._mount = null;
        this._fieldName = null;
        this._title = Object.assign({}, _defaults__WEBPACK_IMPORTED_MODULE_10__["LEGEND_TITLE"]);
        this._metaData = null;
        this._labelManager = dependencies.labelManager;
        this._cells = dependencies.cells;
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._measurement = Object.assign({}, this.constructor.defaultMeasurement());
        this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());

        const dist = dependencies.labelManager.getOriSize('w');
        this._minTickDistance = { width: dist.width * 3 / 4, height: dist.height / 2 };

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_9__["PROPS"]);
        this._computedStyle = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])('body'),
            `${this.config().classPrefix}-legend-item-info`);

        this._firebolt = new _firebolt_legend_firebolt__WEBPACK_IMPORTED_MODULE_3__["LegendFireBolt"](this, {
            behavioural: Object.assign({}, _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__["behaviouralActions"], _firebolt_behavioural__WEBPACK_IMPORTED_MODULE_2__),
            physical: _firebolt_physical__WEBPACK_IMPORTED_MODULE_5__["physicalActions"],
            physicalBehaviouralMap: _firebolt_action_behaviour_map__WEBPACK_IMPORTED_MODULE_4__["actionBehaviourMap"]
        }, _firebolt_side_effects__WEBPACK_IMPORTED_MODULE_6__, _firebolt_behaviour_effect_map__WEBPACK_IMPORTED_MODULE_7__["behaviourEffectMap"]);
    }

    id () {
        return this._id;
    }
    /**
     * Initializes an instance of the class
     *
     * @static
     * @param {Object} dependencies Set of dependencies required by the legend
     * @return {Instance} returns a new instance of Legend
     * @memberof Legend
     */
    static create (dependencies) {
        return new SimpleLegend(dependencies);
    }

    /**
     *
     *
     * @static
     *
     * @memberof SimpleLegend
     */
    static defaultConfig () {
        return _defaults__WEBPACK_IMPORTED_MODULE_10__["DEFAULT_CONFIG"];
    }

    /**
     *
     *
     * @static
     *
     * @memberof SimpleLegend
     */
    static defaultMeasurement () {
        return _defaults__WEBPACK_IMPORTED_MODULE_10__["DEFAULT_MEASUREMENT"];
    }

    /**
     *
     *
     * @readonly
     * @memberof SimpleLegend
     */
    firebolt (...params) {
        if (params.length) {
            return this;
        }
        return this._firebolt;
    }

    /**
     *
     *
     *
     * @memberof Legend
     */
    elemType () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_8__["PATH"];
    }

    canvasAlias (...alias) {
        if (alias.length) {
            this._canvasAlias = alias[0];
            return this;
        }
        return this._canvasAlias;
    }

    /**
     *
     *
     *
     * @memberof Legend
     */
    mount (...params) {
        if (params.length) {
            this._mount = params[0];
            this.render();
            return this;
        }
        return this._mount;
    }

    /**
     *
     *
     * @param {*} effPadding
     * @param {*} align
     *
     * @memberof Legend
     */
    getLabelSpaces () {
        const {
            item,
            classPrefix
        } = this.config();
        this._labelManager.setStyle(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])('body'),
            `${classPrefix}-legend-item-info`));
        return Object(_legend_helper__WEBPACK_IMPORTED_MODULE_11__["getItemMeasures"])(this, _enums_constants__WEBPACK_IMPORTED_MODULE_8__["VALUE"], item.text.formatter);
    }

    /**
     * Sets the height and width of a legend based on provided max
     * height and width and based on its contents
     *
     * @return {Instance} Current instance
     * @memberof Legend
     */
    setLegendMeasures () {
        const {
            width,
            height,
            maxWidth,
            maxHeight,
            padding,
            margin,
            border
        } = this.measurement();
        const {
            align
        } = this.config();

        // Effective padding, margin and padding
        const effPadding = padding * 2;
        const effBorder = border * 2;
        const effMargin = margin * 2;

        this.data(this.dataFromScale());
        // Get space occupied by title
        const titleSpace = this.getTitleSpace();
        const titleHeight = titleSpace.height > 0 ? titleSpace.height + effPadding : 0;
        const titleWidth = titleSpace.width + effPadding;

        // Get space occupied by labels
        const labelSpaces = this.getLabelSpaces(effPadding, align);
        const {
            totalHeight, totalWidth, itemSpaces, iconSpaces, maxItemSpaces, maxIconWidth
        } = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_11__["computeItemSpaces"])(this.config(),
        { effPadding, titleWidth, labelSpaces, titleHeight, maxWidth, maxHeight }, this.data());

        this.measurement({
            width: Math.max(totalWidth, width) + effMargin + effBorder,
            height: Math.max(totalHeight, height) + effMargin + effBorder,
            labelSpaces,
            iconSpaces,
            itemSpaces,
            maxItemSpaces,
            maxIconWidth,
            titleSpaces: {
                width: Math.min(maxWidth, this.measurement().width) - effMargin - effBorder,
                height: titleHeight
            }
        });
        return this;
    }

    /**
     * Returns the space occupied by the legend title
     *
     * @return {Object} Space occupied by title
     * @memberof Legend
     */
    getTitleSpace () {
        this._labelManager.setStyle(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])('body'),
                                                `${this.config().classPrefix}-legend-title`));
        return this._labelManager.getOriSize(this.title().text ? this.title().text : '');
    }

    /**
     * Creates the title for the legend
     *
     * @param {DOM} container Container made for the title
     * @return {Selection} Title and it's node
     * @memberof Legend
     */
    renderTitle (container) {
        const { titleSpaces, border, padding, width, maxWidth } = this.measurement();
        const { borderStyle, borderColor } = this.config();
        return Object(_legend_helper__WEBPACK_IMPORTED_MODULE_11__["titleCreator"])(container, this.title(), {
            height: titleSpaces.height,
            width,
            maxWidth,
            border,
            padding,
            borderStyle,
            borderColor
        }, this.config());
    }

    /**
     * Render the legend with its title
     *
     * @param {DOM} mountPoint Point where the legend and title are to be appended
     * @return {Instance} Current instance of legend
     * @memberof Legend
     */
    render () {
        const firebolt = this.firebolt();
        const {
            classPrefix,
            borderStyle,
            borderColor,
            position
        } = this.config();
        const {
            maxWidth,
            maxHeight,
            width,
            height,
            margin,
            border
        } = this.measurement();
        const legendContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this.mount()), 'div', [1], `${classPrefix}-legend-box`);
        let marginPosition;
        switch (position) {
        case _enums_constants__WEBPACK_IMPORTED_MODULE_8__["TOP"]:
            marginPosition = `margin-${_enums_constants__WEBPACK_IMPORTED_MODULE_8__["BOTTOM"]}`;
            break;
        case _enums_constants__WEBPACK_IMPORTED_MODULE_8__["LEFT"]:
            marginPosition = `margin-${_enums_constants__WEBPACK_IMPORTED_MODULE_8__["RIGHT"]}`;
            break;
        case _enums_constants__WEBPACK_IMPORTED_MODULE_8__["BOTTOM"]:
            marginPosition = `margin-${_enums_constants__WEBPACK_IMPORTED_MODULE_8__["TOP"]}`;
            break;
        default:
            marginPosition = `margin-${_enums_constants__WEBPACK_IMPORTED_MODULE_8__["LEFT"]}`;
        }
        legendContainer.classed(`${classPrefix}-legend-box-${this._id}`, true);
        legendContainer.style('float', 'left');
        // set height and width
        legendContainer.style('width', `${Math.min(maxWidth, width) - margin * 2}px`)
                        .style('height', `${Math.min(maxHeight, height) - margin * 2}px`)
                        .style(`${marginPosition}`, `${margin}px`)
                        .style('border', `${border}px ${borderStyle} ${borderColor}`);
        this.legendContainer(legendContainer.node());

        // create title
        this.renderTitle(legendContainer);
        firebolt.createSelectionSet(this.data().map(d => d.id));
        return legendContainer;
    }
  /**
     *
     *
     * @param {*} data
     *
     * @memberof StepLegend
     */
    getCriteriaFromData (data) {
        const fieldName = this.fieldName();
        const type = this.metaData().getData().schema[0].type;
        if (type === 'measure') {
            return {
                [fieldName]: data.range
            };
        }
        return [[fieldName], [data.rawVal]];
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/legend/step-legend.js":
/*!********************************************************!*\
  !*** ./packages/muze-legend/src/legend/step-legend.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StepLegend; });
/* harmony import */ var _simple_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-legend */ "./packages/muze-legend/src/legend/simple-legend.js");
/* harmony import */ var _legend_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./legend-helper */ "./packages/muze-legend/src/legend/legend-helper.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./packages/muze-legend/src/legend/renderer.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/muze-legend/src/enums/constants.js");
/* harmony import */ var _position_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./position-config */ "./packages/muze-legend/src/legend/position-config.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles.scss */ "./packages/muze-legend/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);







/**
 * Creates a Legend from the axes of a canvas
 *
 * @param {Object} dependencies : legend data
 * @class Legend
 */
class StepLegend extends _simple_legend__WEBPACK_IMPORTED_MODULE_0__["default"] {

    /**
     * Initializes an instance of the class
     *
     * @static
     * @param {Object} dependencies Set of dependencies required by the legend
     * @return {Instance} returns a new instance of Legend
     * @memberof Legend
     */
    static create (dependencies) {
        return new StepLegend(dependencies);
    }

    /**
     *
     *
     * @static
     *
     * @memberof StepLegend
     */
    static type () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STEP"];
    }

    /**
     *
     *
     * @param {*} scale
     *
     * @memberof StepLegend
     */
    dataFromScale () {
        let domainLeg = [];
        const scale = this.scale();
        const { scaleType, domain, steps, scaleFn } = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getScaleInfo"])(scale);

        const { formatter } = this.config();
        const domainBounds = {
            lower: null, upper: null
        };

        // defining scaleParams
        const scaleParams = {
            smartLabel: this.labelManager(),
            measures: this.measurement(),
            alignment: this.config().position,
            minTickDistance: this.minTickDistance()
        };

        if (steps instanceof Array) {
            if (domain[0] < steps[0]) {
                domainBounds.lower = [`${formatter.bounds.lower} ${steps[0]}`];
            }
            domainLeg = [...domainLeg, ...steps];
            if (domain[domain.length - 1] > steps[steps.length - 1]) {
                domainBounds.upper = [`${formatter.bounds.upper} ${steps[steps.length - 1]}`];
            }
        } else {
            domainLeg = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getInterpolatedData"])(domain, steps, scaleParams);
        }

        domainLeg = [...new Set(domainLeg)].sort((a, b) => a - b);
        domainLeg = domainLeg.map((ele, i) => {
            let value = null;
            if (i < domainLeg.length - 1) {
                value = `${(ele.toFixed(1))} - ${(+domainLeg[i + 1].toFixed(1))}`;
            } else if (domainLeg.length === 1) {
                value = ele.toFixed(1);
            }
            return {
                [scaleType]: scaleType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"] ? scale[scaleFn](ele) * scale.getScaleFactor() : scale[scaleFn](ele),
                value,
                id: i + 1,
                range: [ele, domainLeg[i + 1]]
            };
        }).filter(d => d.value !== null);

        if (domainBounds.lower) {
            const lowerBounds = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getDomainBounds"])(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["LOWER"], { scale, scaleFn, scaleType },
                { domain, steps, domainBounds });
            domainLeg = [lowerBounds, ...domainLeg];
        }
        if (domainBounds.upper) {
            const upperBounds = Object(_legend_helper__WEBPACK_IMPORTED_MODULE_1__["getDomainBounds"])(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["UPPER"], { scale, scaleFn, scaleType },
            { domain, steps, domainBounds, domainLeg });
            domainLeg = [...domainLeg, upperBounds];
        }

        return domainLeg;
    }

     /**
     *
     *
     * @param {*} effPadding
     * @param {*} align
     *
     * @memberof Legend
     */
    getLabelSpaces (effPadding, align) {
        this.config({
            item: {
                text: {
                    orientation: this.config().position
                }
            }
        });
        return super.getLabelSpaces(effPadding, align);
    }

    /**
     *
     *
     *
     * @memberof Legend
     */
    elemType () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["RECT"];
    }

     /**
     * Render the legend with its title
     *
     * @param {DOM} mountPoint Point where the legend and title are to be appended
     * @return {Instance} Current instance of legend
     * @memberof Legend
     */
    render () {
        const firebolt = this.firebolt();
        const { classPrefix, position } = this.config();
        const data = Object(_position_config__WEBPACK_IMPORTED_MODULE_4__["stepData"])(this.data())[position];

        const legendContainer = super.render(this.mount());

        // create Legend
        const { legendItem } = Object(_renderer__WEBPACK_IMPORTED_MODULE_2__["createLegendSkeleton"])(this, legendContainer, classPrefix, data);
        const { itemSkeleton } = Object(_renderer__WEBPACK_IMPORTED_MODULE_2__["createItemSkeleton"])(this, legendItem);

        Object(_renderer__WEBPACK_IMPORTED_MODULE_2__["renderStepItem"])(this, itemSkeleton);
        legendContainer.selectAll('div').style('float', _enums_constants__WEBPACK_IMPORTED_MODULE_3__["LEFT"]);
        firebolt.mapActionsAndBehaviour();
        firebolt.createSelectionSet(this.data().map(d => d.id));
        return legendContainer;
    }

    /**
     *
     *
     * @param {*} data
     *
     * @memberof StepLegend
     */
    getCriteriaFromData (data) {
        const fieldName = this.fieldName();
        return {
            [fieldName]: data.range
        };
    }
}


/***/ }),

/***/ "./packages/muze-legend/src/styles.scss":
/*!**********************************************!*\
  !*** ./packages/muze-legend/src/styles.scss ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-tooltip/src/constants.js":
/*!************************************************!*\
  !*** ./packages/muze-tooltip/src/constants.js ***!
  \************************************************/
/*! exports provided: CLASSPREFIX, ARROW_RIGHT, ARROW_TOP, ARROW_BOTTOM, ARROW_LEFT, TOOLTIP_LEFT, TOOLTIP_RIGHT, TOOLTIP_BOTTOM, TOOLTIP_TOP, INITIAL_STYLE, TABLE_FORMAT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW_RIGHT", function() { return ARROW_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW_TOP", function() { return ARROW_TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW_BOTTOM", function() { return ARROW_BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW_LEFT", function() { return ARROW_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_LEFT", function() { return TOOLTIP_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_RIGHT", function() { return TOOLTIP_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_BOTTOM", function() { return TOOLTIP_BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_TOP", function() { return TOOLTIP_TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INITIAL_STYLE", function() { return INITIAL_STYLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TABLE_FORMAT", function() { return TABLE_FORMAT; });
const CLASSPREFIX = 'muze';
const ARROW_RIGHT = 'right';
const ARROW_TOP = 'top';
const ARROW_BOTTOM = 'bottom';
const ARROW_LEFT = 'left';
const TOOLTIP_LEFT = 'left';
const TOOLTIP_RIGHT = 'right';
const TOOLTIP_BOTTOM = 'bottom';
const TOOLTIP_TOP = 'top';
const INITIAL_STYLE = {
    position: 'absolute',
    width: 0,
    height: 0
};
const TABLE_FORMAT = 'table';


/***/ }),

/***/ "./packages/muze-tooltip/src/content.js":
/*!**********************************************!*\
  !*** ./packages/muze-tooltip/src/content.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Content; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/muze-tooltip/src/constants.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-config */ "./packages/muze-tooltip/src/default-config.js");




/**
 * This class is used to manage the content of tooltip.
 */
class Content {
    /**
     * Creates an instance of content.
     */
    constructor () {
        this._model = null;
        this._formatter = null;
        this._config = this.constructor.defaultConfig();
    }
   /**
     * Returns the default configuration of tooltip
     * @return {Object} Configuration of tooltip.
     */
    static defaultConfig () {
        const config = _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"].content;
        config.classPrefix = _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"].classPrefix;
        return config;
    }

    config (...c) {
        if (c.length > 0) {
            this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._config, c[0]);
            return this;
        }
        return this._config;
    }

    /**
     * Update model. The format contains presentation strategy which determines how to show the content.
     * If no strategy is mentioned then default is to show key value pair
    */
    update (item) {
        this._model = item.model;
        this._formatter = item.formatter;
        return this;
    }

    context (ctx) {
        this._context = ctx;
        return this;
    }

    render (mount) {
        let data;
        const config = this._config;
        const iconContainerSize = config.iconContainerSize;
        const formatter = this._formatter;
        const rowMargin = config.rowMargin;
        const model = this._model;
        const { classPrefix } = config;

        this._mount = mount;
        if (model instanceof Array) {
            data = model;
        } else {
            data = formatter(this._model, this.config(), this._context);
        }

        if (data instanceof Function) {
            const mountHtmlTooltip = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'div', [1], `${classPrefix}-tooltip-html-container`);
            mountHtmlTooltip.html(data());
        } else {
            let content = data;
            let displayFormat = 'default';

            if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(data)) {
                content = data.content;
                displayFormat = data.displayFormat;
            }

            const body = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'div', [displayFormat], `${classPrefix}-tooltip-content`, {},
                d => d);

            if (displayFormat === _constants__WEBPACK_IMPORTED_MODULE_1__["TABLE_FORMAT"]) {
                const table = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(body, 'table', [1], `${classPrefix}-tooltip-table`);
                const tbody = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(table, 'tbody', [1], `${classPrefix}-tooltip-table-tbody`);
                const rows = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(tbody, 'tr', content, `${classPrefix}-tooltip-table-row`);
                rows.each(function (d, i) {
                    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).classed(`${classPrefix}-tooltip-table-row-${i}`, true);
                });
                const cells = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(rows, 'td', d => d, `${classPrefix}-tooltip-table-cell`);
                cells.each(function (d) {
                    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this).html(d);
                });
            } else {
                const rows = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(body, 'div', content, '', {
                    update: (elem, elemData) => elem.attr('class', elemData.className)
                });
                const cells = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(rows, 'span', d => d.data, `${classPrefix}-tooltip-content`);
                cells.attr('class', `${classPrefix}-tooltip-content`);
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(rows, {
                    margin: rowMargin
                });
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(cells, {
                    display: 'inline-block' // 'margin-right': `${config.spacing}px`
                });

                cells.each(function (d) {
                    const el = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                    el.html('');
                    if (d instanceof Object) {
                        if (d.type === 'icon') {
                            const svg = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(el, 'svg', [1]);
                            const path = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(svg, 'path', [1]);
                            const shape = d.shape instanceof Function ? d.shape : Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSymbol"])(d.shape);

                            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setAttrs"])(svg, {
                                x: 0,
                                y: 0,
                                width: iconContainerSize,
                                height: iconContainerSize
                            });
                            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setAttrs"])(path, {
                                d: shape.size(d.size)(),
                                transform: `translate(${iconContainerSize / 2}, ${iconContainerSize / 2})`
                            });
                            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(path, {
                                fill: d.color
                            });
                            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(svg, {
                                width: `${iconContainerSize}px`,
                                height: `${iconContainerSize}px`
                            });
                        } else {
                            el.html(d.value);
                            d.className && el.classed(d.className, true);
                            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(el, d.style);
                        }
                    } else {
                        el.html(d);
                    }
                });
            }
        }
        return this;
    }

    clear () {
        this._model = null;
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-tooltip/src/default-config.js":
/*!*****************************************************!*\
  !*** ./packages/muze-tooltip/src/default-config.js ***!
  \*****************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./packages/muze-tooltip/src/constants.js");


const defaultConfig = {
    classPrefix: _constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'tooltip-box',
    connectorClassName: 'tooltip-connectors',
    className: '',
    row: {
        margin: 0
    },
    content: {
        spacing: 5,
        iconContainerSize: 10,
        iconScale: 1,
        iconShape: 'circle',
        iconColor: '#ff0000',
        rowMargin: '4px 0 4px 0',
        margin: 10,
        separator: ':',
        className: 'tooltip-content-container',
        parentClassName: 'tooltip-content-parent-container'
    },
    arrow: {
        size: 10,
        disabled: false,
        defClassName: 'tooltip-arrow',
        className: '',
        color: 'rgba(195,195,195,0.85)'
    }
};


/***/ }),

/***/ "./packages/muze-tooltip/src/helper.js":
/*!*********************************************!*\
  !*** ./packages/muze-tooltip/src/helper.js ***!
  \*********************************************/
/*! exports provided: getArrowPos, placeArrow, reorderContainers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrowPos", function() { return getArrowPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placeArrow", function() { return placeArrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reorderContainers", function() { return reorderContainers; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/muze-tooltip/src/constants.js");



const getArrowPos = (orient, dim, measurement, config) => {
    let arrowPos;
    const { x, y, boxHeight, boxWidth } = measurement;
    const arrowDisabled = config.arrow.disabled;
    const arrowWidth = arrowDisabled ? 0 : config.arrow.size;

    if (orient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_LEFT"] || orient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_RIGHT"]) {
        let start = 0;
        let diff = boxHeight / 2;
        const plotBottom = dim.y + dim.height;
        const boxBottom = y + boxHeight;

        if (dim.y > y) {
            start = dim.y - y;
            diff = (plotBottom >= boxBottom ? (boxBottom - dim.y) : dim.height) / 2;
        } else if (boxBottom > plotBottom) {
            diff = Math.abs(y - (dim.y + dim.height)) / 2;
        }
        arrowPos = start + diff - arrowWidth / 2;
    } else {
        let start = 0;
        let diff = boxWidth / 2;
        const plotRight = dim.x + dim.width;
        const boxRight = x + boxWidth;

        if (dim.x > x) {
            start = dim.x - x;
            diff = (plotRight >= boxRight ? (boxRight - dim.x) : dim.width) / 2;
        } else if (boxRight > plotRight) {
            diff = Math.abs(x - (dim.x + dim.width)) / 2;
        }
        arrowPos = start + diff - arrowWidth / 2;
    }
    return arrowPos;
};

/**
 * Places the arrow in the specified arrow position. It also applies appropriate arrow
 * class name to the arrow element.
 * @param {string} position Left, bottom or right position of the arrow;
 * @param {number} arrowPos position of arrow in pixels
 * @return {Tooltip} Instance of tooltip.
 */
const placeArrow = (context, position, arrowPos) => {
    const tooltipArrow = context._tooltipArrow;
    const tooltipBackground = context._tooltipBackground;
    const config = context._config;
    const classPrefix = config.classPrefix;
    const arrowConf = config.arrow;
    const className = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(arrowConf.defClassName, context._id, config.classPrefix);

    tooltipArrow.style('display', 'block');
    tooltipArrow.attr('class', `${className.join(' ')}`);
    if (position === _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_LEFT"] || position === _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_RIGHT"]) {
        tooltipArrow.style('top', `${arrowPos}px`);
        tooltipArrow.style('left', '');
        tooltipBackground.style('top', `${arrowPos}px`);
        tooltipBackground.style('left', '');
    } else {
        position === _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_BOTTOM"] ? tooltipArrow.style('top', '100%') : tooltipArrow.style('top',
            `-${arrowConf.size}px`);
        tooltipArrow.style('left', `${arrowPos}px`);
        position === _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_BOTTOM"] ? tooltipBackground.style('top', '100%') : tooltipBackground.style('top',
            `-${arrowConf.size + 3}px`);
        tooltipBackground.style('left', `${arrowPos}px`);
    }
    tooltipArrow.classed(`${classPrefix}-tooltip-arrow`, true);
    tooltipArrow.classed(`${classPrefix}-tooltip-arrow-${context._arrowOrientation}`, false);
    tooltipArrow.classed(`${classPrefix}-tooltip-arrow-${position}`, true);
    tooltipBackground.classed(`${classPrefix}-tooltip-background-arrow`, true);
    tooltipBackground.classed(`${classPrefix}-tooltip-background-arrow-${context._arrowOrientation}`, false);
    tooltipBackground.classed(`${classPrefix}-tooltip-background-arrow-${position}`, true);
    return undefined;
};

const reorderContainers = (parentContainer, className) => {
    parentContainer.selectAll(className).sort((a, b) => a - b);
};


/***/ }),

/***/ "./packages/muze-tooltip/src/index.js":
/*!********************************************!*\
  !*** ./packages/muze-tooltip/src/index.js ***!
  \********************************************/
/*! exports provided: Tooltip, TABLE_FORMAT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tooltip */ "./packages/muze-tooltip/src/tooltip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return _tooltip__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/muze-tooltip/src/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TABLE_FORMAT", function() { return _constants__WEBPACK_IMPORTED_MODULE_1__["TABLE_FORMAT"]; });





/***/ }),

/***/ "./packages/muze-tooltip/src/styles.scss":
/*!***********************************************!*\
  !*** ./packages/muze-tooltip/src/styles.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze-tooltip/src/tooltip.js":
/*!**********************************************!*\
  !*** ./packages/muze-tooltip/src/tooltip.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tooltip; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/muze-tooltip/src/constants.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-config */ "./packages/muze-tooltip/src/default-config.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./packages/muze-tooltip/src/helper.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles.scss */ "./packages/muze-tooltip/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./content */ "./packages/muze-tooltip/src/content.js");







/**
 * This component is responsible for creating a tooltip element. It appends the tooltip
 * in the body element.
 * @class Tooltip
 */
class Tooltip {
    /**
     * Initializes the tooltip with the container element and configuration
     * @param {HTMLElement} container container where the tooltip will be mounted.
     * @param {string} className Class name of the tooltip.
     */
    constructor (htmlContainer, svgContainer) {
        let connectorContainer = svgContainer;
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
        this._config = {};
        this.config({});
        const tooltipConf = this._config;
        const classPrefix = tooltipConf.classPrefix;
        const contentClass = tooltipConf.content.parentClassName;
        const container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(htmlContainer, 'div', [1], `${classPrefix}-tooltip-container`);
        this._container = container;
        this._tooltipContainer = container.append('div').style('position', 'absolute');
        this._contentContainer = this._tooltipContainer.append('div').attr('class', `${classPrefix}-${contentClass}`);
        this._tooltipBackground = this._tooltipContainer.append('div').style('position', 'relative');
        this._tooltipArrow = this._tooltipContainer.append('div');

        if (!svgContainer) {
            connectorContainer = htmlContainer.append('svg').style('pointer-events', 'none');
        }
        this._contents = {};
        this._tooltipConnectorContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(connectorContainer)
            .append('g')
            .attr('class', `${tooltipConf.classPrefix}-${tooltipConf.connectorClassName}`);
        const id = this._id;
        const defClassName = tooltipConf.defClassName;
        const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(defClassName, id, tooltipConf.classPrefix);

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(this._tooltipArrow, _constants__WEBPACK_IMPORTED_MODULE_1__["INITIAL_STYLE"]);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(this._tooltipBackground, _constants__WEBPACK_IMPORTED_MODULE_1__["INITIAL_STYLE"]);
        this.addClass(qualifiedClassName.join(' '));
        this.addClass(tooltipConf.className);
        this.hide();
    }

    /**
     * Sets the configuration of tooltip.
     * @param {Object} config Configuration of tooltip
     * @return {Tooltip} Instance of tooltip
     */
    config (...config) {
        if (config.length > 0) {
            const defConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());
            this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defConf, config[0]);
            return this;
        }
        return this._config;
    }

    /**
     * Returns the default configuration of tooltip
     * @return {Object} Configuration of tooltip.
     */
    static defaultConfig () {
        return _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"];
    }
    /**
     * Sets the class name of tooltip
     * @param {string} className tooltip class name
     * @return {Tooltip} Instance of tooltip.
     */
    addClass (className) {
        this._tooltipContainer.classed(className, true);
        return this;
    }

    context (...ctx) {
        if (ctx.length) {
            this._context = ctx[0];
            return this;
        }
        return this._context;
    }

    content (name, data, contentConfig = {}) {
        const config = this.config();
        const { classPrefix } = config;
        const contentClass = config.content.className;
        const formatter = config.formatter;
        const className = contentConfig.className || `${classPrefix}-${contentClass}-${name}`;
        const content = this._contents[name] = this._contents[name] || new _content__WEBPACK_IMPORTED_MODULE_5__["default"]();
        const container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(this._contentContainer, 'div', [contentConfig.order], className);
        container.attr('class', `${classPrefix}-${contentClass} ${className}`);
        Object(_helper__WEBPACK_IMPORTED_MODULE_3__["reorderContainers"])(this._contentContainer, `.${classPrefix}-${contentClass}`);
        const contentConf = config.content;
        contentConfig.classPrefix = this._config.classPrefix;
        content.config(contentConf);

        if (data === null) {
            content.clear();
            container.remove();
            delete this._contents[name];
        } else {
            content.update({
                model: data,
                formatter: contentConfig.formatter || formatter
            });
            content.context(this._context);
            content.render(container);
        }

        if (!Object.keys(this._contents).length) {
            this.hide();
        }
        return this;
    }

    getContents () {
        return Object.values(this._contents);
    }

    /**
     * Positions the tooltip at the given x and y position.
     * @param {number} x x position
     * @param {number} y y position
     * @return {Tooltip} Instance of tooltip.
     */
    position (x, y, conf = {}) {
        if (!Object.keys(this._contents).length) {
            this.hide();
            return this;
        }
        this.show();
        const target = this._target;
        const repositionArrow = conf.repositionArrow;

        if (target && repositionArrow) {
            const node = this._tooltipContainer.node();
            const config = this._config;
            const arrowDisabled = config.arrow.disabled;
            const arrowWidth = arrowDisabled ? 0 : config.arrow.size;
            const arrowOrient = this._arrowOrientation;
            const outsidePlot = arrowOrient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_LEFT"] || arrowOrient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_RIGHT"] ?
                (y + node.offsetHeight - arrowWidth) < target.y || y > (target.y + target.height) :
                (x + node.offsetWidth - arrowWidth) < target.x || x > (target.x + target.width);

            if (!arrowDisabled) {
                if (outsidePlot) {
                    let path;
                    this._tooltipArrow.style('display', 'none');
                    this._tooltipBackground.style('display', 'none');
                    this._tooltipConnectorContainer.style('display', 'block');
                    const connector = this._tooltipConnectorContainer.selectAll('path').data([1]);
                    const enter = connector.enter().append('path');
                    if (arrowOrient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_LEFT"]) {
                        path = `M ${x} ${y + node.offsetHeight / 2} L ${target.x + target.width}`
                            + ` ${target.y + target.height / 2}`;
                    } else if (arrowOrient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_RIGHT"]) {
                        path = `M ${x + node.offsetWidth} ${y + node.offsetHeight / 2}`
                                + ` L ${target.x} ${target.y + target.height / 2}`;
                    } else if (arrowOrient === _constants__WEBPACK_IMPORTED_MODULE_1__["ARROW_BOTTOM"]) {
                        path = `M ${x + node.offsetWidth / 2} ${y + node.offsetHeight}`
                            + ` L ${target.x + target.width / 2} ${target.y}`;
                    }
                    enter.merge(connector).attr('d', path).style('display', 'block');
                } else {
                    const arrowPos = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getArrowPos"])(arrowOrient, target, {
                        x,
                        y,
                        boxHeight: node.offsetHeight,
                        boxWidth: node.offsetWidth
                    }, this._config);

                    Object(_helper__WEBPACK_IMPORTED_MODULE_3__["placeArrow"])(this, this._arrowOrientation, arrowPos);
                    this._tooltipConnectorContainer.style('display', 'none');
                }
            }
        }

        const offset = this._offset || {
            x: 0,
            y: 0
        };
        this._tooltipContainer.style('left', `${offset.x + x}px`).style('top',
            `${offset.y + y}px`);

        return this;
    }

    /**
     * Positions the tooltip relative to a rectangular box. It takes care of tooltip overflowing the
     * boundaries.
     * @param {Object} dim Dimensions of the plot.
     */
    positionRelativeTo (dim, tooltipConf = {}) {
        let obj;
        let orientation = tooltipConf.orientation;
        this.show();
        if (!dim) {
            this.hide();
            return this;
        }

        const extent = this._extent;
        const node = this._tooltipContainer.node();

        this._tooltipContainer.style('top', '0px')
                        .style('left', '0px');
        const offsetWidth = node.offsetWidth + 2;
        const offsetHeight = node.offsetHeight + 2;
        const config = this._config;
        const offset = this._offset;
        const arrowDisabled = config.arrow.disabled;
        const arrowSize = arrowDisabled ? 0 : config.arrow.size;
        const draw = tooltipConf.draw !== undefined ? tooltipConf.draw : true;
        const topSpace = dim.y;
        // When there is no space in right
        const dimX = dim.x + dim.width + offset.x;
        const rightSpace = extent.width - dimX;
        const leftSpace = dim.x + offset.x - extent.x;
        const positionTop = topSpace > (offsetHeight + arrowSize);
        const positionRight = rightSpace >= offsetWidth + arrowSize;
        const positionLeft = leftSpace >= offsetWidth + arrowSize;

        const positionHorizontal = () => {
            let position;
            let x = dim.x + dim.width;
            let y = dim.y;

            if (positionRight) {
                position = _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_LEFT"];
                x += arrowSize;
            } else if (positionLeft) {
                x = dim.x - offsetWidth;
                position = _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_RIGHT"];
                x -= arrowSize;
            } else {
                position = 'left';
                x += arrowSize;
            }
            if (dim.height < offsetHeight) {
                y = Math.max(0, dim.y + dim.height / 2 - offsetHeight / 2);
            }

            const arrowPos = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getArrowPos"])(position, dim, {
                x,
                y,
                boxHeight: offsetHeight,
                boxWidth: offsetWidth
            }, this._config);

            return {
                position,
                arrowPos,
                x,
                y
            };
        };

        const positionVertical = () => {
            let position;
            let y;
            // Position tooltip at the center of plot
            let x = dim.x - offsetWidth / 2 + dim.width / 2;

            // Overflows to the right
            if ((extent.width - (dim.x + offset.x)) < offsetWidth) {
                x = extent.width - offsetWidth - offset.x;
            } else if ((x + offset.x) < extent.x) { // Overflows to the left
                x = extent.x;
            }

            if (positionTop) {
                y = dim.y - offsetHeight - arrowSize;
                position = _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_BOTTOM"];
            } else {
                y = dim.y + dim.height + arrowSize;
                position = _constants__WEBPACK_IMPORTED_MODULE_1__["TOOLTIP_TOP"];
            }

            const arrowPos = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getArrowPos"])(position, dim, {
                x,
                y,
                boxHeight: offsetHeight,
                boxWidth: offsetWidth
            }, this._config);

            return {
                position,
                arrowPos,
                x,
                y
            };
        };

        this._target = dim;
        if (!orientation) {
            if (positionTop) {
                orientation = 'vertical';
            } else if (positionRight || positionLeft) {
                orientation = 'horizontal';
            } else {
                orientation = 'vertical';
            }
        }

        if (orientation === 'horizontal') {
            obj = positionHorizontal();
        } else if (orientation === 'vertical') {
            obj = positionVertical();
        }

        this._position = {
            x: obj.x,
            y: obj.y
        };

        this._arrowPos = obj.arrowPos;
        if (!arrowDisabled) {
            Object(_helper__WEBPACK_IMPORTED_MODULE_3__["placeArrow"])(this, obj.position, obj.arrowPos);
        } else {
            this._tooltipArrow.style('display', 'none');
            this._tooltipBackground.style('display', 'none');
        }
        this._arrowOrientation = obj.position;
        draw && this.position(obj.x, obj.y);
        return this;
    }

    /**
     * Hides the tooltip element.
     * @return {Tooltip} Instance of tooltip.
     */
    hide () {
        this._tooltipContainer.style('display', 'none');
        this._tooltipConnectorContainer.style('display', 'none');
        return this;
    }

    /**
     * Shows the tooltip element.
     * @return {Tooltip} Instance of tooltip.
     */
    show () {
        this._tooltipContainer.style('display', 'block');
        return this;
    }

    extent (extent) {
        this._extent = extent;
        return this;
    }

    offset (offset) {
        this._offset = offset;
        return this;
    }

    remove () {
        this._tooltipContainer.remove();
        this._tooltipBackground.remove();
        this._tooltipConnectorContainer.remove();
        return this;
    }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/array.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/array.js ***!
  \****************************************************************/
/*! exports provided: slice, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/ascending.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/ascending.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/bisect.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/bisect.js ***!
  \*****************************************************************/
/*! exports provided: bisectRight, bisectLeft, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./packages/muze-utils/node_modules/d3-array/src/bisector.js");



var ascendingBisect = Object(_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/bisector.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/bisector.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/constant.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/constant.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/cross.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/cross.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./packages/muze-utils/node_modules/d3-array/src/pairs.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__["pair"];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/descending.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/descending.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/deviation.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/deviation.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./packages/muze-utils/node_modules/d3-array/src/variance.js");


/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  var v = Object(_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/extent.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/extent.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/histogram.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/histogram.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./packages/muze-utils/node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./packages/muze-utils/node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./packages/muze-utils/node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./packages/muze-utils/node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./packages/muze-utils/node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./packages/muze-utils/node_modules/d3-array/src/threshold/sturges.js");









/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(_ticks__WEBPACK_IMPORTED_MODULE_6__["tickStep"])(x0, x1, tz);
      tz = Object(_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/identity.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/identity.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/index.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/index.js ***!
  \****************************************************************/
/*! exports provided: bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./packages/muze-utils/node_modules/d3-array/src/bisect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"]; });

/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return _ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "./packages/muze-utils/node_modules/d3-array/src/bisector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return _bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./packages/muze-utils/node_modules/d3-array/src/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return _cross__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "./packages/muze-utils/node_modules/d3-array/src/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return _descending__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "./packages/muze-utils/node_modules/d3-array/src/deviation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return _deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "./packages/muze-utils/node_modules/d3-array/src/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return _extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "./packages/muze-utils/node_modules/d3-array/src/histogram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "./packages/muze-utils/node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "./packages/muze-utils/node_modules/d3-array/src/threshold/scott.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return _threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "./packages/muze-utils/node_modules/d3-array/src/threshold/sturges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "./packages/muze-utils/node_modules/d3-array/src/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "./packages/muze-utils/node_modules/d3-array/src/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _mean__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "./packages/muze-utils/node_modules/d3-array/src/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _median__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "./packages/muze-utils/node_modules/d3-array/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _merge__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "./packages/muze-utils/node_modules/d3-array/src/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "./packages/muze-utils/node_modules/d3-array/src/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "./packages/muze-utils/node_modules/d3-array/src/permute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return _permute__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "./packages/muze-utils/node_modules/d3-array/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return _quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "./packages/muze-utils/node_modules/d3-array/src/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "./packages/muze-utils/node_modules/d3-array/src/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _scan__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "./packages/muze-utils/node_modules/d3-array/src/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "./packages/muze-utils/node_modules/d3-array/src/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _sum__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "./packages/muze-utils/node_modules/d3-array/src/ticks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickStep"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "./packages/muze-utils/node_modules/d3-array/src/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "./packages/muze-utils/node_modules/d3-array/src/variance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return _variance__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "./packages/muze-utils/node_modules/d3-array/src/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip__WEBPACK_IMPORTED_MODULE_26__["default"]; });






























/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/max.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/max.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/mean.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/mean.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/median.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/median.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./packages/muze-utils/node_modules/d3-array/src/quantile.js");




/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/merge.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/merge.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/min.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/min.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/number.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/number.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x === null ? NaN : +x;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/pairs.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/pairs.js ***!
  \****************************************************************/
/*! exports provided: default, pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return pair; });
/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/permute.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/permute.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/quantile.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/quantile.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/range.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/range.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/scan.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/scan.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/shuffle.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/shuffle.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/sum.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/sum.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./packages/muze-utils/node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./packages/muze-utils/node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./packages/muze-utils/node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./packages/muze-utils/node_modules/d3-array/src/quantile.js");





/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * (Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/threshold/scott.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/threshold/scott.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./packages/muze-utils/node_modules/d3-array/src/deviation.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/threshold/sturges.js":
/*!****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/threshold/sturges.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/ticks.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/ticks.js ***!
  \****************************************************************/
/*! exports provided: default, tickIncrement, tickStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/transpose.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/transpose.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./packages/muze-utils/node_modules/d3-array/src/min.js");


/* harmony default export */ __webpack_exports__["default"] = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function length(d) {
  return d.length;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/variance.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/variance.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-array/src/number.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-array/src/zip.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-array/src/zip.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./packages/muze-utils/node_modules/d3-array/src/transpose.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-axis/index.js":
/*!***********************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-axis/index.js ***!
  \***********************************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/axis */ "./packages/muze-utils/node_modules/d3-axis/src/axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return _src_axis__WEBPACK_IMPORTED_MODULE_0__["axisTop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return _src_axis__WEBPACK_IMPORTED_MODULE_0__["axisRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return _src_axis__WEBPACK_IMPORTED_MODULE_0__["axisBottom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return _src_axis__WEBPACK_IMPORTED_MODULE_0__["axisLeft"]; });




/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-axis/src/array.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-axis/src/array.js ***!
  \***************************************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-axis/src/axis.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-axis/src/axis.js ***!
  \**************************************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return axisTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return axisRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return axisBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return axisLeft; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-axis/src/array.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "./packages/muze-utils/node_modules/d3-axis/src/identity.js");



var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickTransform = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"))
        .style('transform', tickTransform);

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.tickTransform = function(_) {
    return arguments.length ? (tickTransform = _, axis) : tickTransform;
  };

  axis.ticks = function() {
    return tickArguments = _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-axis/src/identity.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-axis/src/identity.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/index.js ***!
  \*****************************************************************/
/*! exports provided: nest, set, map, keys, values, entries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/nest */ "./packages/muze-utils/node_modules/d3-collection/src/nest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return _src_nest__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/set */ "./packages/muze-utils/node_modules/d3-collection/src/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _src_set__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/map */ "./packages/muze-utils/node_modules/d3-collection/src/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _src_map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/keys */ "./packages/muze-utils/node_modules/d3-collection/src/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _src_keys__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/values */ "./packages/muze-utils/node_modules/d3-collection/src/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _src_values__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/entries */ "./packages/muze-utils/node_modules/d3-collection/src/entries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return _src_entries__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/entries.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/entries.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/keys.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/keys.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/map.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/map.js ***!
  \*******************************************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/nest.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/nest.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./packages/muze-utils/node_modules/d3-collection/src/map.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/set.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/set.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./packages/muze-utils/node_modules/d3-collection/src/map.js");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__["prefix"] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-collection/src/values.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-collection/src/values.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/color.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/color.js ***!
  \****************************************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./packages/muze-utils/node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/cubehelix.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/cubehelix.js ***!
  \********************************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./packages/muze-utils/node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./packages/muze-utils/node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/define.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/define.js ***!
  \*****************************************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/index.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/index.js ***!
  \****************************************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, lch, gray, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _color__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _color__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _color__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lab */ "./packages/muze-utils/node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _lab__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _lab__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return _lab__WEBPACK_IMPORTED_MODULE_1__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return _lab__WEBPACK_IMPORTED_MODULE_1__["gray"]; });

/* harmony import */ var _cubehelix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubehelix */ "./packages/muze-utils/node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _cubehelix__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/lab.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/lab.js ***!
  \**************************************************************/
/*! exports provided: gray, default, Lab, lch, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return gray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return lch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./packages/muze-utils/node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./packages/muze-utils/node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"];
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-color/src/math.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-color/src/math.js ***!
  \***************************************************************/
/*! exports provided: deg2rad, rad2deg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-dispatch/src/dispatch.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-dispatch/src/dispatch.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-dispatch/src/index.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-dispatch/src/index.js ***!
  \*******************************************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dispatch */ "./packages/muze-utils/node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _dispatch__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/constant.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/constant.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/drag.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/drag.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./packages/muze-utils/node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./packages/muze-utils/node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./packages/muze-utils/node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./packages/muze-utils/node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].x, y: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__["mouse"], this, arguments);
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
    mousemoving = false;
    mousedownx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX;
    mousedowny = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY;
    gesture("start");
  }

  function mousemoved() {
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    if (!mousemoving) {
      var dx = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientX - mousedownx, dy = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view, mousemoving);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__["touch"], this, arguments)) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/event.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/event.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/index.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/index.js ***!
  \***************************************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./packages/muze-utils/node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _drag__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodrag */ "./packages/muze-utils/node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _nodrag__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });





/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/nodrag.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/nodrag.js ***!
  \****************************************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./packages/muze-utils/node_modules/d3-drag/src/noevent.js");



/* harmony default export */ __webpack_exports__["default"] = (function(view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-drag/src/noevent.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-drag/src/noevent.js ***!
  \*****************************************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/back.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/back.js ***!
  \**************************************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/bounce.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/bounce.js ***!
  \****************************************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/circle.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/circle.js ***!
  \****************************************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/cubic.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/cubic.js ***!
  \***************************************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/elastic.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/elastic.js ***!
  \*****************************************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/exp.js":
/*!*************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/exp.js ***!
  \*************************************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/index.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/index.js ***!
  \***************************************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _linear__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _quad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quad */ "./packages/muze-utils/node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _quad__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _quad__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _cubic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubic */ "./packages/muze-utils/node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _cubic__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _cubic__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./poly */ "./packages/muze-utils/node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _poly__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _poly__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _sin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sin */ "./packages/muze-utils/node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _sin__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _sin__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _exp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exp */ "./packages/muze-utils/node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _exp__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _exp__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circle */ "./packages/muze-utils/node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _circle__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _circle__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _bounce__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bounce */ "./packages/muze-utils/node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _bounce__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _bounce__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _back__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./back */ "./packages/muze-utils/node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _back__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _back__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _elastic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./elastic */ "./packages/muze-utils/node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _elastic__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _elastic__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });






















/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/linear.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/linear.js ***!
  \****************************************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
function linear(t) {
  return +t;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/poly.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/poly.js ***!
  \**************************************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/quad.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/quad.js ***!
  \**************************************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-ease/src/sin.js":
/*!*************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-ease/src/sin.js ***!
  \*************************************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/defaultLocale.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/defaultLocale.js ***!
  \*************************************************************************/
/*! exports provided: format, formatPrefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return formatPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return defaultLocale; });
/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale */ "./packages/muze-utils/node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = Object(_locale__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/exponent.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/exponent.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatDecimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal */ "./packages/muze-utils/node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x = Object(_formatDecimal__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(x)), x ? x[1] : NaN;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatDecimal.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatDecimal.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatGroup.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatGroup.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatNumerals.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatNumerals.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatPrefixAuto.js":
/*!****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatPrefixAuto.js ***!
  \****************************************************************************/
/*! exports provided: prefixExponent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefixExponent", function() { return prefixExponent; });
/* harmony import */ var _formatDecimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal */ "./packages/muze-utils/node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  var d = Object(_formatDecimal__WEBPACK_IMPORTED_MODULE_0__["default"])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + Object(_formatDecimal__WEBPACK_IMPORTED_MODULE_0__["default"])(x, Math.max(0, p + i - 1))[0]; // less than 1y!
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatRounded.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatRounded.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatDecimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal */ "./packages/muze-utils/node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ __webpack_exports__["default"] = (function(x, p) {
  var d = Object(_formatDecimal__WEBPACK_IMPORTED_MODULE_0__["default"])(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatSpecifier.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatSpecifier.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatSpecifier; });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatTrim.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatTrim.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ __webpack_exports__["default"] = (function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/formatTypes.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/formatTypes.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _formatPrefixAuto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatPrefixAuto */ "./packages/muze-utils/node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded */ "./packages/muze-utils/node_modules/d3-format/src/formatRounded.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return Object(_formatRounded__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p); },
  "r": _formatRounded__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto__WEBPACK_IMPORTED_MODULE_0__["default"],
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/identity.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/identity.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/index.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/index.js ***!
  \*****************************************************************/
/*! exports provided: formatDefaultLocale, format, formatPrefix, formatLocale, formatSpecifier, precisionFixed, precisionPrefix, precisionRound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultLocale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale */ "./packages/muze-utils/node_modules/d3-format/src/defaultLocale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "format", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["formatPrefix"]; });

/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale */ "./packages/muze-utils/node_modules/d3-format/src/locale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return _locale__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _formatSpecifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatSpecifier */ "./packages/muze-utils/node_modules/d3-format/src/formatSpecifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return _formatSpecifier__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _precisionFixed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./precisionFixed */ "./packages/muze-utils/node_modules/d3-format/src/precisionFixed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return _precisionFixed__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _precisionPrefix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./precisionPrefix */ "./packages/muze-utils/node_modules/d3-format/src/precisionPrefix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return _precisionPrefix__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _precisionRound__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./precisionRound */ "./packages/muze-utils/node_modules/d3-format/src/precisionRound.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return _precisionRound__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/locale.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/locale.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent */ "./packages/muze-utils/node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup */ "./packages/muze-utils/node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals */ "./packages/muze-utils/node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier */ "./packages/muze-utils/node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTrim */ "./packages/muze-utils/node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTypes */ "./packages/muze-utils/node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto */ "./packages/muze-utils/node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./identity */ "./packages/muze-utils/node_modules/d3-format/src/identity.js");









var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ __webpack_exports__["default"] = (function(locale) {
  var group = locale.grouping && locale.thousands ? Object(_formatGroup__WEBPACK_IMPORTED_MODULE_1__["default"])(locale.grouping, locale.thousands) : _identity__WEBPACK_IMPORTED_MODULE_7__["default"],
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? Object(_formatNumerals__WEBPACK_IMPORTED_MODULE_2__["default"])(locale.numerals) : _identity__WEBPACK_IMPORTED_MODULE_7__["default"],
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = Object(_formatSpecifier__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes__WEBPACK_IMPORTED_MODULE_5__["default"][type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes__WEBPACK_IMPORTED_MODULE_5__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = Object(_formatTrim__WEBPACK_IMPORTED_MODULE_4__["default"])(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto__WEBPACK_IMPORTED_MODULE_6__["prefixExponent"] / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = Object(_formatSpecifier__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/precisionFixed.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/precisionFixed.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent */ "./packages/muze-utils/node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step) {
  return Math.max(0, -Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/precisionPrefix.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/precisionPrefix.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent */ "./packages/muze-utils/node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3 - Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(Math.abs(step)));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-format/src/precisionRound.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-format/src/precisionRound.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _exponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent */ "./packages/muze-utils/node_modules/d3-format/src/exponent.js");


/* harmony default export */ __webpack_exports__["default"] = (function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(max) - Object(_exponent__WEBPACK_IMPORTED_MODULE_0__["default"])(step)) + 1;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/array.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/array.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./packages/muze-utils/node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/basis.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/basis.js ***!
  \**********************************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/basisClosed.js":
/*!****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/basisClosed.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/color.js ***!
  \**********************************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/constant.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/constant.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/cubehelix.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/cubehelix.js ***!
  \**************************************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/date.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/date.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/discrete.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/discrete.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/hcl.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/hcl.js ***!
  \********************************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/hsl.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/hsl.js ***!
  \********************************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/hue.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/hue.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = Object(_color__WEBPACK_IMPORTED_MODULE_0__["hue"])(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/index.js ***!
  \**********************************************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./packages/muze-utils/node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _value__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _array__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _basis__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _basisClosed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed */ "./packages/muze-utils/node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _basisClosed__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _date__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date */ "./packages/muze-utils/node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _date__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discrete__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete */ "./packages/muze-utils/node_modules/d3-interpolate/src/discrete.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return _discrete__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue */ "./packages/muze-utils/node_modules/d3-interpolate/src/hue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return _hue__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _number__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object */ "./packages/muze-utils/node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _object__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _round__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./round */ "./packages/muze-utils/node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _round__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./string */ "./packages/muze-utils/node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _string__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _transform_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform/index */ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _transform_index__WEBPACK_IMPORTED_MODULE_11__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _transform_index__WEBPACK_IMPORTED_MODULE_11__["interpolateTransformSvg"]; });

/* harmony import */ var _zoom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./zoom */ "./packages/muze-utils/node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _zoom__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _rgb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./rgb */ "./packages/muze-utils/node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _rgb__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _rgb__WEBPACK_IMPORTED_MODULE_13__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _rgb__WEBPACK_IMPORTED_MODULE_13__["rgbBasisClosed"]; });

/* harmony import */ var _hsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./hsl */ "./packages/muze-utils/node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _hsl__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _hsl__WEBPACK_IMPORTED_MODULE_14__["hslLong"]; });

/* harmony import */ var _lab__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lab */ "./packages/muze-utils/node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _lab__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _hcl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./hcl */ "./packages/muze-utils/node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _hcl__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _hcl__WEBPACK_IMPORTED_MODULE_16__["hclLong"]; });

/* harmony import */ var _cubehelix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cubehelix */ "./packages/muze-utils/node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _cubehelix__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _cubehelix__WEBPACK_IMPORTED_MODULE_17__["cubehelixLong"]; });

/* harmony import */ var _piecewise__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./piecewise */ "./packages/muze-utils/node_modules/d3-interpolate/src/piecewise.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return _piecewise__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _quantize__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./quantize */ "./packages/muze-utils/node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _quantize__WEBPACK_IMPORTED_MODULE_19__["default"]; });























/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/lab.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/lab.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/number.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/number.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/object.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/object.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./packages/muze-utils/node_modules/d3-interpolate/src/value.js");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/piecewise.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/piecewise.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return piecewise; });
function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/quantize.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/quantize.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/rgb.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/rgb.js ***!
  \********************************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed */ "./packages/muze-utils/node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color */ "./packages/muze-utils/node_modules/d3-interpolate/src/color.js");





/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/round.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/round.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/string.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/string.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/decompose.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/transform/decompose.js ***!
  \************************************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/index.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/transform/index.js ***!
  \********************************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number */ "./packages/muze-utils/node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse */ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/parse.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/transform/parse.js ***!
  \********************************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose */ "./packages/muze-utils/node_modules/d3-interpolate/src/transform/decompose.js");


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/value.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/value.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var _rgb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb */ "./packages/muze-utils/node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date */ "./packages/muze-utils/node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object */ "./packages/muze-utils/node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string */ "./packages/muze-utils/node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-interpolate/src/constant.js");









/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? Object(_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(b)
      : (t === "number" ? _number__WEBPACK_IMPORTED_MODULE_4__["default"]
      : t === "string" ? ((c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string__WEBPACK_IMPORTED_MODULE_6__["default"])
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof Date ? _date__WEBPACK_IMPORTED_MODULE_3__["default"]
      : Array.isArray(b) ? _array__WEBPACK_IMPORTED_MODULE_2__["default"]
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object__WEBPACK_IMPORTED_MODULE_5__["default"]
      : _number__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-interpolate/src/zoom.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-interpolate/src/zoom.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ __webpack_exports__["default"] = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-path/src/index.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-path/src/index.js ***!
  \***************************************************************/
/*! exports provided: path */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ "./packages/muze-utils/node_modules/d3-path/src/path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _path__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-path/src/path.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-path/src/path.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (path);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Accent.js":
/*!***************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Accent.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Dark2.js":
/*!**************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Dark2.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Paired.js":
/*!***************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Paired.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js":
/*!****************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js":
/*!****************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set1.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set1.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set2.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set2.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set3.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/category10.js":
/*!*******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/BrBG.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/BrBG.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PRGn.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PRGn.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PiYG.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PiYG.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PuOr.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PuOr.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdBu.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdBu.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdGy.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdGy.js ***!
  \***********************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js ***!
  \*************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js ***!
  \*************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/Spectral.js":
/*!***************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/Spectral.js ***!
  \***************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/index.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/index.js ***!
  \**************************************************************************/
/*! exports provided: schemeCategory10, schemeAccent, schemeDark2, schemePaired, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, interpolateBrBG, schemeBrBG, interpolatePRGn, schemePRGn, interpolatePiYG, schemePiYG, interpolatePuOr, schemePuOr, interpolateRdBu, schemeRdBu, interpolateRdGy, schemeRdGy, interpolateRdYlBu, schemeRdYlBu, interpolateRdYlGn, schemeRdYlGn, interpolateSpectral, schemeSpectral, interpolateBuGn, schemeBuGn, interpolateBuPu, schemeBuPu, interpolateGnBu, schemeGnBu, interpolateOrRd, schemeOrRd, interpolatePuBuGn, schemePuBuGn, interpolatePuBu, schemePuBu, interpolatePuRd, schemePuRd, interpolateRdPu, schemeRdPu, interpolateYlGnBu, schemeYlGnBu, interpolateYlGn, schemeYlGn, interpolateYlOrBr, schemeYlOrBr, interpolateYlOrRd, schemeYlOrRd, interpolateBlues, schemeBlues, interpolateGreens, schemeGreens, interpolateGreys, schemeGreys, interpolatePurples, schemePurples, interpolateReds, schemeReds, interpolateOranges, schemeOranges, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateSinebow, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _categorical_category10__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categorical/category10 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return _categorical_category10__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _categorical_Accent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./categorical/Accent */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Accent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return _categorical_Accent__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _categorical_Dark2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categorical/Dark2 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Dark2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return _categorical_Dark2__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _categorical_Paired__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./categorical/Paired */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Paired.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return _categorical_Paired__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _categorical_Pastel1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./categorical/Pastel1 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return _categorical_Pastel1__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _categorical_Pastel2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./categorical/Pastel2 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return _categorical_Pastel2__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _categorical_Set1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./categorical/Set1 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return _categorical_Set1__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _categorical_Set2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./categorical/Set2 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return _categorical_Set2__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _categorical_Set3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./categorical/Set3 */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return _categorical_Set3__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./diverging/BrBG */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/BrBG.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return _diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return _diverging_BrBG__WEBPACK_IMPORTED_MODULE_9__["scheme"]; });

/* harmony import */ var _diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diverging/PRGn */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PRGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return _diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return _diverging_PRGn__WEBPACK_IMPORTED_MODULE_10__["scheme"]; });

/* harmony import */ var _diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./diverging/PiYG */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PiYG.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return _diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return _diverging_PiYG__WEBPACK_IMPORTED_MODULE_11__["scheme"]; });

/* harmony import */ var _diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./diverging/PuOr */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/PuOr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return _diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return _diverging_PuOr__WEBPACK_IMPORTED_MODULE_12__["scheme"]; });

/* harmony import */ var _diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./diverging/RdBu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return _diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return _diverging_RdBu__WEBPACK_IMPORTED_MODULE_13__["scheme"]; });

/* harmony import */ var _diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diverging/RdGy */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdGy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return _diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return _diverging_RdGy__WEBPACK_IMPORTED_MODULE_14__["scheme"]; });

/* harmony import */ var _diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./diverging/RdYlBu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return _diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return _diverging_RdYlBu__WEBPACK_IMPORTED_MODULE_15__["scheme"]; });

/* harmony import */ var _diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./diverging/RdYlGn */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return _diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return _diverging_RdYlGn__WEBPACK_IMPORTED_MODULE_16__["scheme"]; });

/* harmony import */ var _diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./diverging/Spectral */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/diverging/Spectral.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return _diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return _diverging_Spectral__WEBPACK_IMPORTED_MODULE_17__["scheme"]; });

/* harmony import */ var _sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./sequential-multi/BuGn */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return _sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return _sequential_multi_BuGn__WEBPACK_IMPORTED_MODULE_18__["scheme"]; });

/* harmony import */ var _sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./sequential-multi/BuPu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return _sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return _sequential_multi_BuPu__WEBPACK_IMPORTED_MODULE_19__["scheme"]; });

/* harmony import */ var _sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./sequential-multi/GnBu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return _sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return _sequential_multi_GnBu__WEBPACK_IMPORTED_MODULE_20__["scheme"]; });

/* harmony import */ var _sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./sequential-multi/OrRd */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return _sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return _sequential_multi_OrRd__WEBPACK_IMPORTED_MODULE_21__["scheme"]; });

/* harmony import */ var _sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sequential-multi/PuBuGn */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return _sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return _sequential_multi_PuBuGn__WEBPACK_IMPORTED_MODULE_22__["scheme"]; });

/* harmony import */ var _sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./sequential-multi/PuBu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return _sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return _sequential_multi_PuBu__WEBPACK_IMPORTED_MODULE_23__["scheme"]; });

/* harmony import */ var _sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./sequential-multi/PuRd */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return _sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return _sequential_multi_PuRd__WEBPACK_IMPORTED_MODULE_24__["scheme"]; });

/* harmony import */ var _sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./sequential-multi/RdPu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return _sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return _sequential_multi_RdPu__WEBPACK_IMPORTED_MODULE_25__["scheme"]; });

/* harmony import */ var _sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./sequential-multi/YlGnBu */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return _sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return _sequential_multi_YlGnBu__WEBPACK_IMPORTED_MODULE_26__["scheme"]; });

/* harmony import */ var _sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./sequential-multi/YlGn */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return _sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return _sequential_multi_YlGn__WEBPACK_IMPORTED_MODULE_27__["scheme"]; });

/* harmony import */ var _sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./sequential-multi/YlOrBr */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return _sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return _sequential_multi_YlOrBr__WEBPACK_IMPORTED_MODULE_28__["scheme"]; });

/* harmony import */ var _sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./sequential-multi/YlOrRd */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return _sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return _sequential_multi_YlOrRd__WEBPACK_IMPORTED_MODULE_29__["scheme"]; });

/* harmony import */ var _sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./sequential-single/Blues */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return _sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return _sequential_single_Blues__WEBPACK_IMPORTED_MODULE_30__["scheme"]; });

/* harmony import */ var _sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./sequential-single/Greens */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return _sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return _sequential_single_Greens__WEBPACK_IMPORTED_MODULE_31__["scheme"]; });

/* harmony import */ var _sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./sequential-single/Greys */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return _sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return _sequential_single_Greys__WEBPACK_IMPORTED_MODULE_32__["scheme"]; });

/* harmony import */ var _sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./sequential-single/Purples */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return _sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePurples", function() { return _sequential_single_Purples__WEBPACK_IMPORTED_MODULE_33__["scheme"]; });

/* harmony import */ var _sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./sequential-single/Reds */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return _sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeReds", function() { return _sequential_single_Reds__WEBPACK_IMPORTED_MODULE_34__["scheme"]; });

/* harmony import */ var _sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./sequential-single/Oranges */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return _sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return _sequential_single_Oranges__WEBPACK_IMPORTED_MODULE_35__["scheme"]; });

/* harmony import */ var _sequential_multi_cubehelix__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./sequential-multi/cubehelix */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return _sequential_multi_cubehelix__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./sequential-multi/rainbow */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return _sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return _sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["warm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return _sequential_multi_rainbow__WEBPACK_IMPORTED_MODULE_37__["cool"]; });

/* harmony import */ var _sequential_multi_sinebow__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./sequential-multi/sinebow */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSinebow", function() { return _sequential_multi_sinebow__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./sequential-multi/viridis */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return _sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return _sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["magma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return _sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["inferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return _sequential_multi_viridis__WEBPACK_IMPORTED_MODULE_39__["plasma"]; });











































/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(scheme) {
  return Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateRgbBasis"])(scheme[scheme.length - 1]);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js":
/*!******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js ***!
  \******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js":
/*!***********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(300, 0.5, 0.0), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-240, 0.5, 1.0)));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js":
/*!*********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js ***!
  \*********************************************************************************************/
/*! exports provided: warm, cool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warm", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cool", function() { return cool; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");



var warm = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-100, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var cool = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(260, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])();

/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js":
/*!*********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");


var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;

/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c.r = 255 * (x = Math.sin(t)) * x;
  c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c + "";
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js":
/*!*********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js ***!
  \*********************************************************************************************/
/*! exports provided: default, magma, inferno, plasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "magma", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferno", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plasma", function() { return plasma; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js":
/*!*********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js ***!
  \*********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js":
/*!********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js ***!
  \********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js":
/*!**********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js ***!
  \**********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js":
/*!**********************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js ***!
  \**********************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js":
/*!*******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js ***!
  \*******************************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/colors.js");
/* harmony import */ var _ramp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/ramp.js");



var scheme = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(_colors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/index.js":
/*!************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/index.js ***!
  \************************************************************/
/*! exports provided: scaleBand, scalePoint, scaleIdentity, scaleLinear, scaleLog, scaleOrdinal, scaleImplicit, scalePow, scaleSqrt, scaleQuantile, scaleQuantize, scaleThreshold, scaleTime, scaleUtc, schemeCategory10, schemeCategory20b, schemeCategory20c, schemeCategory20, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma, scaleSequential */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_band__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/band */ "./packages/muze-utils/node_modules/d3-scale/src/band.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return _src_band__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return _src_band__WEBPACK_IMPORTED_MODULE_0__["point"]; });

/* harmony import */ var _src_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/identity */ "./packages/muze-utils/node_modules/d3-scale/src/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return _src_identity__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/linear */ "./packages/muze-utils/node_modules/d3-scale/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return _src_linear__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/log */ "./packages/muze-utils/node_modules/d3-scale/src/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return _src_log__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_ordinal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/ordinal */ "./packages/muze-utils/node_modules/d3-scale/src/ordinal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return _src_ordinal__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return _src_ordinal__WEBPACK_IMPORTED_MODULE_4__["implicit"]; });

/* harmony import */ var _src_pow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/pow */ "./packages/muze-utils/node_modules/d3-scale/src/pow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return _src_pow__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return _src_pow__WEBPACK_IMPORTED_MODULE_5__["sqrt"]; });

/* harmony import */ var _src_quantile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/quantile */ "./packages/muze-utils/node_modules/d3-scale/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return _src_quantile__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/quantize */ "./packages/muze-utils/node_modules/d3-scale/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_threshold__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/threshold */ "./packages/muze-utils/node_modules/d3-scale/src/threshold.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return _src_threshold__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/time */ "./packages/muze-utils/node_modules/d3-scale/src/time.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _src_time__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_utcTime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/utcTime */ "./packages/muze-utils/node_modules/d3-scale/src/utcTime.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return _src_utcTime__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_category10__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/category10 */ "./packages/muze-utils/node_modules/d3-scale/src/category10.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return _src_category10__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_category20b__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/category20b */ "./packages/muze-utils/node_modules/d3-scale/src/category20b.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return _src_category20b__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_category20c__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/category20c */ "./packages/muze-utils/node_modules/d3-scale/src/category20c.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20c", function() { return _src_category20c__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_category20__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/category20 */ "./packages/muze-utils/node_modules/d3-scale/src/category20.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return _src_category20__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/cubehelix */ "./packages/muze-utils/node_modules/d3-scale/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_rainbow__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/rainbow */ "./packages/muze-utils/node_modules/d3-scale/src/rainbow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return _src_rainbow__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return _src_rainbow__WEBPACK_IMPORTED_MODULE_16__["warm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return _src_rainbow__WEBPACK_IMPORTED_MODULE_16__["cool"]; });

/* harmony import */ var _src_viridis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/viridis */ "./packages/muze-utils/node_modules/d3-scale/src/viridis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return _src_viridis__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return _src_viridis__WEBPACK_IMPORTED_MODULE_17__["magma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return _src_viridis__WEBPACK_IMPORTED_MODULE_17__["inferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return _src_viridis__WEBPACK_IMPORTED_MODULE_17__["plasma"]; });

/* harmony import */ var _src_sequential__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/sequential */ "./packages/muze-utils/node_modules/d3-scale/src/sequential.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return _src_sequential__WEBPACK_IMPORTED_MODULE_18__["default"]; });








































/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/array.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/array.js ***!
  \****************************************************************/
/*! exports provided: map, slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/band.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/band.js ***!
  \***************************************************************/
/*! exports provided: default, point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return band; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ordinal */ "./packages/muze-utils/node_modules/d3-scale/src/ordinal.js");



function band() {
  var scale = Object(_ordinal__WEBPACK_IMPORTED_MODULE_1__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;
  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  scale.invertExtent = function(r0, r1) {
    var lo = +r0,
        hi = arguments.length > 1 ? +r1 : lo,
        reverse = range[1] < range[0],
        values = reverse ? ordinalRange().reverse() : ordinalRange(),
        n = values.length - 1, a, b, t,
        hiIndex;
    values.push(values[n] + this.step());
    // order range inputs, bail if outside of scale range
    if (hi < lo) t = lo, lo = hi, hi = t;
    if (hi < values[0] || lo > range[1-reverse]) return undefined;

    // binary search to index into scale range
    a = Math.max(0, getClosestIndexOf(values, lo));
    hiIndex = getClosestIndexOf(values, hi);
    b = lo===hi ? a : Math.max(a, hiIndex - 1);

    // increment index a if lo is within padding gap
    // if (lo - values[a] > bandwidth + 1e-10) ++a;

    if (reverse) t = a, a = n - b, b = n - t; // map + swap
    return (a > b) ? undefined : domain().slice(a, b+1);
  };

  scale.invert = function (r0, r1) {
    var lo = +r0,
        hi = arguments.length > 1 ? +r1 : lo,
        reverse = range[1] < range[0],
        values = reverse ? ordinalRange().reverse() : ordinalRange(),
        n = values.length - 1,
        a,
        t;

    // order range inputs, bail if outside of scale range
    if (hi < lo) t = lo, lo = hi, hi = t;
    if (hi < values[0] || lo > range[1-reverse]) return undefined;

    // binary search to index into scale range
    a = Math.max(0, getClosestIndexOf(values, lo, 'left'));

    // increment index a if lo is within padding gap
    // if (lo - values[a] > bandwidth + 1e-10) ++a;

    return domain()[reverse ? n - a : a];
  }
  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

function getClosestIndexOf (arr, value, side) {
  var low = 0,
      arrLen = arr.length,
      high = arrLen - 1,
      highVal,
      mid,
      d1,
      d2;

  while (low < high) {
      mid = Math.floor((low + high) / 2);
      d1 = Math.abs(arr[mid] - value);
      d2 = Math.abs(arr[mid + 1] - value);

      if (d2 <= d1) {
          low = mid + 1;
      }
      else {
          high = mid;
      }
  }

  if (!side) {
      return high;
  }

  highVal = arr[high];
  if (highVal === value) {
      return high;
  } else if (highVal > value) {
      if (high === 0) { return high; }
      return side === 'left'? high - 1 : high;
  } else {
      if (high === arr.length - 1) { return high; }
      return side === 'left'? high : high + 1;
  }
}

/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/category10.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/category10.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ "./packages/muze-utils/node_modules/d3-scale/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/category20.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/category20.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ "./packages/muze-utils/node_modules/d3-scale/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/category20b.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/category20b.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ "./packages/muze-utils/node_modules/d3-scale/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/category20c.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/category20c.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ "./packages/muze-utils/node_modules/d3-scale/src/colors.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/colors.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/colors.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/constant.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/constant.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/continuous.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/continuous.js ***!
  \*********************************************************************/
/*! exports provided: deinterpolateLinear, copy, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deinterpolateLinear", function() { return deinterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return continuous; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-scale/src/number.js");






var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolate"],
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_2__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_4__["default"]), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRound"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/cubehelix.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/cubehelix.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(300, 0.5, 0.0), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-240, 0.5, 1.0)));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/identity.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/identity.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return identity; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number */ "./packages/muze-utils/node_modules/d3-scale/src/number.js");




function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_2__["default"]), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_1__["linearish"])(scale);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/linear.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/linear.js ***!
  \*****************************************************************/
/*! exports provided: linearish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearish", function() { return linearish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return linear; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous */ "./packages/muze-utils/node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tickFormat */ "./packages/muze-utils/node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return Object(_tickFormat__WEBPACK_IMPORTED_MODULE_3__["default"])(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_2__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_2__["deinterpolateLinear"], d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]);

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_2__["copy"])(scale, linear());
  };

  return linearish(scale);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/log.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/log.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return log; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./packages/muze-utils/node_modules/d3-format/src/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-scale/src/constant.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nice */ "./packages/muze-utils/node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./continuous */ "./packages/muze-utils/node_modules/d3-scale/src/continuous.js");






function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["default"])(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(Object(_nice__WEBPACK_IMPORTED_MODULE_3__["default"])(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, log().base(base));
  };

  return scale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/nice.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/nice.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/number.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/number.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return +x;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/ordinal.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/ordinal.js ***!
  \******************************************************************/
/*! exports provided: implicit, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "implicit", function() { return implicit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ordinal; });
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./packages/muze-utils/node_modules/d3-collection/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");



var implicit = {name: "implicit"};

function ordinal(range) {
  var index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/pow.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/pow.js ***!
  \**************************************************************/
/*! exports provided: default, sqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-scale/src/constant.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous */ "./packages/muze-utils/node_modules/d3-scale/src/continuous.js");




function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_2__["default"])(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_2__["copy"])(scale, pow().exponent(exponent));
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_1__["linearish"])(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/quantile.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/quantile.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantile; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["quantile"])(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/quantize.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/quantize.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantize; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-scale/src/linear.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(scale);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/rainbow.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/rainbow.js ***!
  \******************************************************************/
/*! exports provided: warm, cool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warm", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cool", function() { return cool; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");



var warm = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-100, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var cool = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(260, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var rainbow = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])();

/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/sequential.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/sequential.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sequential; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-scale/src/linear.js");


function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_0__["linearish"])(scale);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/threshold.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/threshold.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return threshold; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/tickFormat.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/tickFormat.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./packages/muze-utils/node_modules/d3-format/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, count == null ? 10 : count),
      precision;
  specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatSpecifier"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionPrefix"])(step, value))) specifier.precision = precision;
      return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatPrefix"])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/time.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/time.js ***!
  \***************************************************************/
/*! exports provided: calendar, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calendar", function() { return calendar; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./packages/muze-utils/node_modules/d3-array/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./packages/muze-utils/node_modules/d3-time/src/index.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time-format */ "./packages/muze-utils/node_modules/d3-time-format/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-scale/src/array.js");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./continuous */ "./packages/muze-utils/node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nice */ "./packages/muze-utils/node_modules/d3-scale/src/nice.js");








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_5__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_5__["deinterpolateLinear"], d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(_array__WEBPACK_IMPORTED_MODULE_4__["map"].call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(Object(_nice__WEBPACK_IMPORTED_MODULE_6__["default"])(d, interval))
        : scale;
  };

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_5__["copy"])(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return calendar(d3_time__WEBPACK_IMPORTED_MODULE_2__["timeYear"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeMonth"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeWeek"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeDay"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeHour"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeMinute"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeSecond"], d3_time__WEBPACK_IMPORTED_MODULE_2__["timeMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_3__["timeFormat"]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/utcTime.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/utcTime.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "./packages/muze-utils/node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time-format */ "./packages/muze-utils/node_modules/d3-time-format/src/index.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./packages/muze-utils/node_modules/d3-time/src/index.js");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_time__WEBPACK_IMPORTED_MODULE_0__["calendar"])(d3_time__WEBPACK_IMPORTED_MODULE_2__["utcYear"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMonth"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcWeek"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcDay"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcHour"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMinute"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcSecond"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_1__["utcFormat"]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-scale/src/viridis.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-scale/src/viridis.js ***!
  \******************************************************************/
/*! exports provided: default, magma, inferno, plasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "magma", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferno", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plasma", function() { return plasma; });
/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ "./packages/muze-utils/node_modules/d3-scale/src/colors.js");


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(Object(_colors__WEBPACK_IMPORTED_MODULE_0__["default"])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/constant.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/constant.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/create.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/create.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./creator */ "./packages/muze-utils/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select */ "./packages/muze-utils/node_modules/d3-selection/src/select.js");



/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return Object(_select__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name).call(document.documentElement));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/creator.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/creator.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./packages/muze-utils/node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./packages/muze-utils/node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"]
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/index.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/index.js ***!
  \********************************************************************/
/*! exports provided: create, creator, local, matcher, mouse, namespace, namespaces, clientPoint, select, selectAll, selection, selector, selectorAll, style, touch, touches, window, event, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create */ "./packages/muze-utils/node_modules/d3-selection/src/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./creator */ "./packages/muze-utils/node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _creator__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local */ "./packages/muze-utils/node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _local__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matcher */ "./packages/muze-utils/node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mouse */ "./packages/muze-utils/node_modules/d3-selection/src/mouse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return _mouse__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./namespace */ "./packages/muze-utils/node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _namespace__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./namespaces */ "./packages/muze-utils/node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _namespaces__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-selection/src/point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return _point__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ "./packages/muze-utils/node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _select__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./selectAll */ "./packages/muze-utils/node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _selectAll__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./selection/index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _selection_index__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selector */ "./packages/muze-utils/node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _selector__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectorAll */ "./packages/muze-utils/node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _selectorAll__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _selection_style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection/style */ "./packages/muze-utils/node_modules/d3-selection/src/selection/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _selection_style__WEBPACK_IMPORTED_MODULE_13__["styleValue"]; });

/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./touch */ "./packages/muze-utils/node_modules/d3-selection/src/touch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return _touch__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _touches__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./touches */ "./packages/muze-utils/node_modules/d3-selection/src/touches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return _touches__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./window */ "./packages/muze-utils/node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _window__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./selection/on */ "./packages/muze-utils/node_modules/d3-selection/src/selection/on.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return _selection_on__WEBPACK_IMPORTED_MODULE_17__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return _selection_on__WEBPACK_IMPORTED_MODULE_17__["customEvent"]; });





















/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/local.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/local.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/matcher.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/matcher.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return function() {
    return this.matches(selector);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/mouse.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/mouse.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./packages/muze-utils/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/namespace.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/namespace.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./packages/muze-utils/node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/namespaces.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/namespaces.js ***!
  \*************************************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/point.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/point.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/select.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/select.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selectAll.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selectAll.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return typeof selector === "string"
      ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([document.querySelectorAll(selector)], [document.documentElement])
      : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/append.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/append.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./packages/muze-utils/node_modules/d3-selection/src/creator.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/attr.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/attr.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./packages/muze-utils/node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/call.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/call.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/classed.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/classed.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/clone.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/clone.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

/* harmony default export */ __webpack_exports__["default"] = (function(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/data.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/data.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./packages/muze-utils/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./packages/muze-utils/node_modules/d3-selection/src/constant.js");




var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/datum.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/datum.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/dispatch.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/dispatch.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./packages/muze-utils/node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/each.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/each.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/empty.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/empty.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return !this.node();
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/enter.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/enter.js ***!
  \******************************************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./packages/muze-utils/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/exit.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/exit.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./packages/muze-utils/node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/filter.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/filter.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./packages/muze-utils/node_modules/d3-selection/src/matcher.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/html.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/html.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/index.js ***!
  \******************************************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./packages/muze-utils/node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./packages/muze-utils/node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./packages/muze-utils/node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./packages/muze-utils/node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./packages/muze-utils/node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./packages/muze-utils/node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./join */ "./packages/muze-utils/node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./packages/muze-utils/node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./packages/muze-utils/node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sort */ "./packages/muze-utils/node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./call */ "./packages/muze-utils/node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodes */ "./packages/muze-utils/node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node */ "./packages/muze-utils/node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size */ "./packages/muze-utils/node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./empty */ "./packages/muze-utils/node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./each */ "./packages/muze-utils/node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./attr */ "./packages/muze-utils/node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ "./packages/muze-utils/node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./property */ "./packages/muze-utils/node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classed */ "./packages/muze-utils/node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./text */ "./packages/muze-utils/node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./html */ "./packages/muze-utils/node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./raise */ "./packages/muze-utils/node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lower */ "./packages/muze-utils/node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./append */ "./packages/muze-utils/node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./insert */ "./packages/muze-utils/node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./remove */ "./packages/muze-utils/node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./clone */ "./packages/muze-utils/node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./datum */ "./packages/muze-utils/node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./on */ "./packages/muze-utils/node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./dispatch */ "./packages/muze-utils/node_modules/d3-selection/src/selection/dispatch.js");
































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  join: _join__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_8__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_9__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_10__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_11__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_12__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_13__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_14__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_15__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_16__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_17__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_18__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_19__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_20__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_21__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_22__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_23__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_24__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_25__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_26__["default"],
  clone: _clone__WEBPACK_IMPORTED_MODULE_27__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_28__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_29__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_30__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (selection);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/insert.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/insert.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./packages/muze-utils/node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./packages/muze-utils/node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, before) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/join.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/join.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/lower.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/lower.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(lower);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/merge.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/merge.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/node.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/node.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/nodes.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/nodes.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/on.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/on.js ***!
  \***************************************************************************/
/*! exports provided: event, default, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return customEvent; });
var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/order.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/order.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/property.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/property.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/raise.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/raise.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(raise);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/remove.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/remove.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.each(remove);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/select.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/select.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./packages/muze-utils/node_modules/d3-selection/src/selector.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/selectAll.js":
/*!**********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/selectAll.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./packages/muze-utils/node_modules/d3-selection/src/selectorAll.js");



/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  if (typeof select !== "function") select = Object(_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/size.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/size.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/sort.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/sort.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/sparse.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/sparse.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(update) {
  return new Array(update.length);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/style.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/style.js ***!
  \******************************************************************************/
/*! exports provided: default, styleValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleValue", function() { return styleValue; });
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./packages/muze-utils/node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selection/text.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selection/text.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selector.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selector.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/selectorAll.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/selectorAll.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/sourceEvent.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/sourceEvent.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./packages/muze-utils/node_modules/d3-selection/src/selection/on.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__["event"], source;
  while (source = current.sourceEvent) current = source;
  return current;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/touch.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/touch.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./packages/muze-utils/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/touches.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/touches.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./packages/muze-utils/node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-selection/src/point.js");



/* harmony default export */ __webpack_exports__["default"] = (function(node, touches) {
  if (touches == null) touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-selection/src/window.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-selection/src/window.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/arc.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/arc.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./packages/muze-utils/node_modules/d3-path/src/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./packages/muze-utils/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["max"])(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        a1 = endAngle.apply(this, arguments) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        da = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
      context.moveTo(r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a0), r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        context.moveTo(r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a1), r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && (padRadius ? +padRadius.apply(this, arguments) : Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(r0 * r0 + r1 * r1)),
          rc = Object(_math__WEBPACK_IMPORTED_MODULE_2__["min"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        var p0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["asin"])(rp / r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(ap)),
            p1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["asin"])(rp / r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(ap));
        if ((da0 -= p0 * 2) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a01),
          y01 = r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a01),
          x10 = r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a10),
          y10 = r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a10);

      // Apply rounded corners?
      if (rc > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        var x11 = r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a11),
            y11 = r1 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a11),
            x00 = r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a00),
            y00 = r0 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < _math__WEBPACK_IMPORTED_MODULE_2__["pi"] && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])((ax * bx + ay * by) / (Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(ax * ax + ay * ay) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(bx * bx + by * by))) / 2),
              lc = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["min"])(rc, (r0 - lc) / (kc - 1));
          rc1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["min"])(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y11, t1.x11), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) || !(da0 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"])) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y01, t0.x01), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y11, t1.x11), Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(a) * r, Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/area.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/area.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./packages/muze-utils/node_modules/d3-path/src/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear */ "./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line */ "./packages/muze-utils/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-shape/src/point.js");






/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x0 = _point__WEBPACK_IMPORTED_MODULE_4__["x"],
      x1 = null,
      y0 = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      y1 = _point__WEBPACK_IMPORTED_MODULE_4__["y"],
      defined = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return Object(_line__WEBPACK_IMPORTED_MODULE_3__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/areaRadial.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/areaRadial.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./packages/muze-utils/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./packages/muze-utils/node_modules/d3-shape/src/area.js");
/* harmony import */ var _lineRadial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lineRadial */ "./packages/muze-utils/node_modules/d3-shape/src/lineRadial.js");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  var a = Object(_area__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return Object(_lineRadial__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return Object(_lineRadial__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return Object(_lineRadial__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return Object(_lineRadial__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/array.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/array.js ***!
  \****************************************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/constant.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/constant.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function constant() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js ***!
  \**********************************************************************/
/*! exports provided: point, Basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Basis", function() { return Basis; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Basis(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/basisClosed.js":
/*!****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./packages/muze-utils/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: Object(_basis__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisClosed(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/basisOpen.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: Object(_basis__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisOpen(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/bundle.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/bundle.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis__WEBPACK_IMPORTED_MODULE_0__["Basis"](context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis__WEBPACK_IMPORTED_MODULE_0__["Basis"](context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js ***!
  \*************************************************************************/
/*! exports provided: point, Cardinal, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cardinal", function() { return Cardinal; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \*******************************************************************************/
/*! exports provided: CardinalClosed, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalClosed", function() { return CardinalClosed; });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./packages/muze-utils/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_cardinal__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \*****************************************************************************/
/*! exports provided: CardinalOpen, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalOpen", function() { return CardinalOpen; });
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(_cardinal__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRom.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \***************************************************************************/
/*! exports provided: point, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./packages/muze-utils/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal__WEBPACK_IMPORTED_MODULE_1__["Cardinal"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./packages/muze-utils/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom */ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_catmullRom__WEBPACK_IMPORTED_MODULE_2__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed__WEBPACK_IMPORTED_MODULE_0__["CardinalClosed"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom */ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: Object(_catmullRom__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen__WEBPACK_IMPORTED_MODULE_0__["CardinalOpen"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Linear(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/linearClosed.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./packages/muze-utils/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new LinearClosed(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/monotone.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/monotone.js ***!
  \*************************************************************************/
/*! exports provided: monotoneX, monotoneY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneX", function() { return monotoneX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneY", function() { return monotoneY; });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/natural.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/natural.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Natural(context);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/radial.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/radial.js ***!
  \***********************************************************************/
/*! exports provided: curveRadialLinear, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveRadialLinear", function() { return curveRadialLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return curveRadial; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/curve/step.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/curve/step.js ***!
  \*********************************************************************/
/*! exports provided: default, stepBefore, stepAfter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepBefore", function() { return stepBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepAfter", function() { return stepAfter; });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/descending.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/descending.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/identity.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/identity.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(d) {
  return d;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/index.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/index.js ***!
  \****************************************************************/
/*! exports provided: arc, area, line, pie, areaRadial, radialArea, lineRadial, radialLine, pointRadial, linkHorizontal, linkVertical, linkRadial, symbol, symbols, symbolCircle, symbolCross, symbolDiamond, symbolSquare, symbolStar, symbolTriangle, symbolWye, curveBasisClosed, curveBasisOpen, curveBasis, curveBundle, curveCardinalClosed, curveCardinalOpen, curveCardinal, curveCatmullRomClosed, curveCatmullRomOpen, curveCatmullRom, curveLinearClosed, curveLinear, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore, stack, stackOffsetExpand, stackOffsetDiverging, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderAppearance, stackOrderAscending, stackOrderDescending, stackOrderInsideOut, stackOrderNone, stackOrderReverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc */ "./packages/muze-utils/node_modules/d3-shape/src/arc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arc", function() { return _arc__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./packages/muze-utils/node_modules/d3-shape/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "area", function() { return _area__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./packages/muze-utils/node_modules/d3-shape/src/line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _line__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pie */ "./packages/muze-utils/node_modules/d3-shape/src/pie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return _pie__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _areaRadial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./areaRadial */ "./packages/muze-utils/node_modules/d3-shape/src/areaRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "areaRadial", function() { return _areaRadial__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialArea", function() { return _areaRadial__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lineRadial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lineRadial */ "./packages/muze-utils/node_modules/d3-shape/src/lineRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return _lineRadial__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialLine", function() { return _lineRadial__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointRadial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointRadial */ "./packages/muze-utils/node_modules/d3-shape/src/pointRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointRadial", function() { return _pointRadial__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _link_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./link/index */ "./packages/muze-utils/node_modules/d3-shape/src/link/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return _link_index__WEBPACK_IMPORTED_MODULE_7__["linkHorizontal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return _link_index__WEBPACK_IMPORTED_MODULE_7__["linkVertical"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return _link_index__WEBPACK_IMPORTED_MODULE_7__["linkRadial"]; });

/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol */ "./packages/muze-utils/node_modules/d3-shape/src/symbol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbol", function() { return _symbol__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return _symbol__WEBPACK_IMPORTED_MODULE_8__["symbols"]; });

/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/circle */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return _symbol_circle__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/cross */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCross", function() { return _symbol_cross__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/diamond */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return _symbol_diamond__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/square */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/square.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return _symbol_square__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./symbol/star */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/star.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolStar", function() { return _symbol_star__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./symbol/triangle */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return _symbol_triangle__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./symbol/wye */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/wye.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolWye", function() { return _symbol_wye__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _curve_basisClosed__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./curve/basisClosed */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return _curve_basisClosed__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _curve_basisOpen__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./curve/basisOpen */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return _curve_basisOpen__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _curve_basis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./curve/basis */ "./packages/muze-utils/node_modules/d3-shape/src/curve/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasis", function() { return _curve_basis__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _curve_bundle__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./curve/bundle */ "./packages/muze-utils/node_modules/d3-shape/src/curve/bundle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBundle", function() { return _curve_bundle__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./curve/cardinalClosed */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return _curve_cardinalClosed__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./curve/cardinalOpen */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return _curve_cardinalOpen__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _curve_cardinal__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./curve/cardinal */ "./packages/muze-utils/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return _curve_cardinal__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./curve/catmullRomClosed */ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return _curve_catmullRomClosed__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./curve/catmullRomOpen */ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return _curve_catmullRomOpen__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _curve_catmullRom__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./curve/catmullRom */ "./packages/muze-utils/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return _curve_catmullRom__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _curve_linearClosed__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./curve/linearClosed */ "./packages/muze-utils/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return _curve_linearClosed__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./curve/linear */ "./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinear", function() { return _curve_linear__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _curve_monotone__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./curve/monotone */ "./packages/muze-utils/node_modules/d3-shape/src/curve/monotone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return _curve_monotone__WEBPACK_IMPORTED_MODULE_28__["monotoneX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return _curve_monotone__WEBPACK_IMPORTED_MODULE_28__["monotoneY"]; });

/* harmony import */ var _curve_natural__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./curve/natural */ "./packages/muze-utils/node_modules/d3-shape/src/curve/natural.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveNatural", function() { return _curve_natural__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _curve_step__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./curve/step */ "./packages/muze-utils/node_modules/d3-shape/src/curve/step.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return _curve_step__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return _curve_step__WEBPACK_IMPORTED_MODULE_30__["stepAfter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return _curve_step__WEBPACK_IMPORTED_MODULE_30__["stepBefore"]; });

/* harmony import */ var _stack__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./stack */ "./packages/muze-utils/node_modules/d3-shape/src/stack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _stack__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _offset_expand__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./offset/expand */ "./packages/muze-utils/node_modules/d3-shape/src/offset/expand.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return _offset_expand__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _offset_diverging__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./offset/diverging */ "./packages/muze-utils/node_modules/d3-shape/src/offset/diverging.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return _offset_diverging__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./offset/none */ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return _offset_none__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _offset_silhouette__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./offset/silhouette */ "./packages/muze-utils/node_modules/d3-shape/src/offset/silhouette.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return _offset_silhouette__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _offset_wiggle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./offset/wiggle */ "./packages/muze-utils/node_modules/d3-shape/src/offset/wiggle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return _offset_wiggle__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _order_appearance__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./order/appearance */ "./packages/muze-utils/node_modules/d3-shape/src/order/appearance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAppearance", function() { return _order_appearance__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _order_ascending__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./order/ascending */ "./packages/muze-utils/node_modules/d3-shape/src/order/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return _order_ascending__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _order_descending__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./order/descending */ "./packages/muze-utils/node_modules/d3-shape/src/order/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return _order_descending__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _order_insideOut__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./order/insideOut */ "./packages/muze-utils/node_modules/d3-shape/src/order/insideOut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return _order_insideOut__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./order/none */ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return _order_none__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _order_reverse__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./order/reverse */ "./packages/muze-utils/node_modules/d3-shape/src/order/reverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return _order_reverse__WEBPACK_IMPORTED_MODULE_42__["default"]; });





 // Note: radialArea is deprecated!
 // Note: radialLine is deprecated!










































/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/line.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/line.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./packages/muze-utils/node_modules/d3-path/src/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear */ "./packages/muze-utils/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-shape/src/point.js");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x = _point__WEBPACK_IMPORTED_MODULE_3__["x"],
      y = _point__WEBPACK_IMPORTED_MODULE_3__["y"],
      defined = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/lineRadial.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/lineRadial.js ***!
  \*********************************************************************/
/*! exports provided: lineRadial, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return lineRadial; });
/* harmony import */ var _curve_radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial */ "./packages/muze-utils/node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./packages/muze-utils/node_modules/d3-shape/src/line.js");



function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return lineRadial(Object(_line__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/link/index.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/link/index.js ***!
  \*********************************************************************/
/*! exports provided: linkHorizontal, linkVertical, linkRadial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return linkHorizontal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return linkVertical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return linkRadial; });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./packages/muze-utils/node_modules/d3-path/src/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array */ "./packages/muze-utils/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../point */ "./packages/muze-utils/node_modules/d3-shape/src/point.js");
/* harmony import */ var _pointRadial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pointRadial */ "./packages/muze-utils/node_modules/d3-shape/src/pointRadial.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = _point__WEBPACK_IMPORTED_MODULE_3__["x"],
      y = _point__WEBPACK_IMPORTED_MODULE_3__["y"],
      context = null;

  function link() {
    var buffer, argv = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = Object(_pointRadial__WEBPACK_IMPORTED_MODULE_4__["default"])(x0, y0),
      p1 = Object(_pointRadial__WEBPACK_IMPORTED_MODULE_4__["default"])(x0, y0 = (y0 + y1) / 2),
      p2 = Object(_pointRadial__WEBPACK_IMPORTED_MODULE_4__["default"])(x1, y0),
      p3 = Object(_pointRadial__WEBPACK_IMPORTED_MODULE_4__["default"])(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/math.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/math.js ***!
  \***************************************************************/
/*! exports provided: abs, atan2, cos, max, min, sin, sqrt, epsilon, pi, halfPi, tau, acos, asin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/noop.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/noop.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/offset/diverging.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/offset/diverging.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/offset/expand.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/offset/expand.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/offset/none.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/offset/silhouette.js":
/*!****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/offset/silhouette.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/offset/wiggle.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/offset/wiggle.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/appearance.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/appearance.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var peaks = series.map(peak);
  return Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
});

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/ascending.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/ascending.js ***!
  \**************************************************************************/
/*! exports provided: default, sum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var sums = series.map(sum);
  return Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/descending.js":
/*!***************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/descending.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/insideOut.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/insideOut.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _appearance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appearance */ "./packages/muze-utils/node_modules/d3-shape/src/order/appearance.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "./packages/muze-utils/node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending__WEBPACK_IMPORTED_MODULE_1__["sum"]),
      order = Object(_appearance__WEBPACK_IMPORTED_MODULE_0__["default"])(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/none.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/order/reverse.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/order/reverse.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none */ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_none__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/pie.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/pie.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending */ "./packages/muze-utils/node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity */ "./packages/muze-utils/node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./packages/muze-utils/node_modules/d3-shape/src/math.js");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_2__["default"],
      sortValues = _descending__WEBPACK_IMPORTED_MODULE_1__["default"],
      sort = null,
      startAngle = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      endAngle = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(_math__WEBPACK_IMPORTED_MODULE_3__["tau"]),
      padAngle = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math__WEBPACK_IMPORTED_MODULE_3__["tau"], Math.max(-_math__WEBPACK_IMPORTED_MODULE_3__["tau"], endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), pie) : padAngle;
  };

  return pie;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/point.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/point.js ***!
  \****************************************************************/
/*! exports provided: x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/pointRadial.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/pointRadial.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/stack.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/stack.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./packages/muze-utils/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none */ "./packages/muze-utils/node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none */ "./packages/muze-utils/node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol.js ***!
  \*****************************************************************/
/*! exports provided: symbols, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return symbols; });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./packages/muze-utils/node_modules/d3-path/src/index.js");
/* harmony import */ var _symbol_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/circle */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/cross */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/diamond */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/square */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/triangle */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/wye */ "./packages/muze-utils/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle__WEBPACK_IMPORTED_MODULE_1__["default"],
  _symbol_cross__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_diamond__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_square__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_star__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_triangle__WEBPACK_IMPORTED_MODULE_6__["default"],
  _symbol_wye__WEBPACK_IMPORTED_MODULE_7__["default"]
];

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var type = Object(_constant__WEBPACK_IMPORTED_MODULE_8__["default"])(_symbol_circle__WEBPACK_IMPORTED_MODULE_1__["default"]),
      size = Object(_constant__WEBPACK_IMPORTED_MODULE_8__["default"])(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__["path"])();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_8__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_8__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/circle.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/circle.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./packages/muze-utils/node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math__WEBPACK_IMPORTED_MODULE_0__["pi"]);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/cross.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/cross.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/diamond.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/diamond.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/square.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/square.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/star.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/star.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./packages/muze-utils/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10) / Math.sin(7 * _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10),
    kx = Math.sin(_math__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr,
    ky = -Math.cos(_math__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math__WEBPACK_IMPORTED_MODULE_0__["tau"] * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/triangle.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/triangle.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var sqrt3 = Math.sqrt(3);

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-shape/src/symbol/wye.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-shape/src/symbol/wye.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time-format/src/defaultLocale.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time-format/src/defaultLocale.js ***!
  \******************************************************************************/
/*! exports provided: timeFormat, timeParse, utcFormat, utcParse, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return timeFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return timeParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return utcFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return utcParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return defaultLocale; });
/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale */ "./packages/muze-utils/node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = Object(_locale__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time-format/src/index.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time-format/src/index.js ***!
  \**********************************************************************/
/*! exports provided: timeFormatDefaultLocale, timeFormat, timeParse, utcFormat, utcParse, timeFormatLocale, isoFormat, isoParse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultLocale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale */ "./packages/muze-utils/node_modules/d3-time-format/src/defaultLocale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatDefaultLocale", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["timeFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["timeParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["utcFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return _defaultLocale__WEBPACK_IMPORTED_MODULE_0__["utcParse"]; });

/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale */ "./packages/muze-utils/node_modules/d3-time-format/src/locale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatLocale", function() { return _locale__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _isoFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isoFormat */ "./packages/muze-utils/node_modules/d3-time-format/src/isoFormat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoFormat", function() { return _isoFormat__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _isoParse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isoParse */ "./packages/muze-utils/node_modules/d3-time-format/src/isoParse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoParse", function() { return _isoParse__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time-format/src/isoFormat.js":
/*!**************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time-format/src/isoFormat.js ***!
  \**************************************************************************/
/*! exports provided: isoSpecifier, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isoSpecifier", function() { return isoSpecifier; });
/* harmony import */ var _defaultLocale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultLocale */ "./packages/muze-utils/node_modules/d3-time-format/src/defaultLocale.js");


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : Object(_defaultLocale__WEBPACK_IMPORTED_MODULE_0__["utcFormat"])(isoSpecifier);

/* harmony default export */ __webpack_exports__["default"] = (formatIso);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time-format/src/isoParse.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time-format/src/isoParse.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _isoFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isoFormat */ "./packages/muze-utils/node_modules/d3-time-format/src/isoFormat.js");
/* harmony import */ var _defaultLocale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultLocale */ "./packages/muze-utils/node_modules/d3-time-format/src/defaultLocale.js");



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : Object(_defaultLocale__WEBPACK_IMPORTED_MODULE_1__["utcParse"])(_isoFormat__WEBPACK_IMPORTED_MODULE_0__["isoSpecifier"]);

/* harmony default export */ __webpack_exports__["default"] = (parseIso);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time-format/src/locale.js":
/*!***********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time-format/src/locale.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatLocale; });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "./packages/muze-utils/node_modules/d3-time/src/index.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"].ceil(week) : Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"])(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_0__["utcDay"].offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"].ceil(week) : Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"])(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_0__["timeDay"].offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_0__["timeDay"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeSunday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"])(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"].ceil(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeThursday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d) + (Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeMonday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["timeYear"])(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_0__["utcDay"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcSunday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"])(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"].ceil(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcThursday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d) + (Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcMonday"].count(Object(d3_time__WEBPACK_IMPORTED_MODULE_0__["utcYear"])(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/day.js":
/*!*************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/day.js ***!
  \*************************************************************/
/*! exports provided: default, days */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "days", function() { return days; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var day = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationDay"];
}, function(date) {
  return date.getDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (day);
var days = day.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/duration.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/duration.js ***!
  \******************************************************************/
/*! exports provided: durationSecond, durationMinute, durationHour, durationDay, durationWeek */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationSecond", function() { return durationSecond; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationMinute", function() { return durationMinute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationHour", function() { return durationHour; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationDay", function() { return durationDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "durationWeek", function() { return durationWeek; });
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/hour.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/hour.js ***!
  \**************************************************************/
/*! exports provided: default, hours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hours", function() { return hours; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var hour = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration__WEBPACK_IMPORTED_MODULE_1__["durationSecond"] - date.getMinutes() * _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(date, step) {
  date.setTime(+date + step * _duration__WEBPACK_IMPORTED_MODULE_1__["durationHour"]);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationHour"];
}, function(date) {
  return date.getHours();
});

/* harmony default export */ __webpack_exports__["default"] = (hour);
var hours = hour.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/index.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/index.js ***!
  \***************************************************************/
/*! exports provided: timeInterval, timeMillisecond, timeMilliseconds, utcMillisecond, utcMilliseconds, timeSecond, timeSeconds, utcSecond, utcSeconds, timeMinute, timeMinutes, timeHour, timeHours, timeDay, timeDays, timeWeek, timeWeeks, timeSunday, timeSundays, timeMonday, timeMondays, timeTuesday, timeTuesdays, timeWednesday, timeWednesdays, timeThursday, timeThursdays, timeFriday, timeFridays, timeSaturday, timeSaturdays, timeMonth, timeMonths, timeYear, timeYears, utcMinute, utcMinutes, utcHour, utcHours, utcDay, utcDays, utcWeek, utcWeeks, utcSunday, utcSundays, utcMonday, utcMondays, utcTuesday, utcTuesdays, utcWednesday, utcWednesdays, utcThursday, utcThursdays, utcFriday, utcFridays, utcSaturday, utcSaturdays, utcMonth, utcMonths, utcYear, utcYears */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return _interval__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _millisecond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./millisecond */ "./packages/muze-utils/node_modules/d3-time/src/millisecond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return _millisecond__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return _millisecond__WEBPACK_IMPORTED_MODULE_1__["milliseconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return _millisecond__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return _millisecond__WEBPACK_IMPORTED_MODULE_1__["milliseconds"]; });

/* harmony import */ var _second__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./second */ "./packages/muze-utils/node_modules/d3-time/src/second.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return _second__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return _second__WEBPACK_IMPORTED_MODULE_2__["seconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSecond", function() { return _second__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return _second__WEBPACK_IMPORTED_MODULE_2__["seconds"]; });

/* harmony import */ var _minute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minute */ "./packages/muze-utils/node_modules/d3-time/src/minute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return _minute__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return _minute__WEBPACK_IMPORTED_MODULE_3__["minutes"]; });

/* harmony import */ var _hour__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hour */ "./packages/muze-utils/node_modules/d3-time/src/hour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return _hour__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHours", function() { return _hour__WEBPACK_IMPORTED_MODULE_4__["hours"]; });

/* harmony import */ var _day__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./day */ "./packages/muze-utils/node_modules/d3-time/src/day.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return _day__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDays", function() { return _day__WEBPACK_IMPORTED_MODULE_5__["days"]; });

/* harmony import */ var _week__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./week */ "./packages/muze-utils/node_modules/d3-time/src/week.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["sunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["sundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSunday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["sunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSundays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["sundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["monday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMondays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["mondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["tuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["tuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["wednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["wednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["thursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["thursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFriday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["friday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFridays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["fridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["saturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return _week__WEBPACK_IMPORTED_MODULE_6__["saturdays"]; });

/* harmony import */ var _month__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./month */ "./packages/muze-utils/node_modules/d3-time/src/month.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return _month__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonths", function() { return _month__WEBPACK_IMPORTED_MODULE_7__["months"]; });

/* harmony import */ var _year__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./year */ "./packages/muze-utils/node_modules/d3-time/src/year.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return _year__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYears", function() { return _year__WEBPACK_IMPORTED_MODULE_8__["years"]; });

/* harmony import */ var _utcMinute__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utcMinute */ "./packages/muze-utils/node_modules/d3-time/src/utcMinute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinute", function() { return _utcMinute__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return _utcMinute__WEBPACK_IMPORTED_MODULE_9__["utcMinutes"]; });

/* harmony import */ var _utcHour__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utcHour */ "./packages/muze-utils/node_modules/d3-time/src/utcHour.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHour", function() { return _utcHour__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return _utcHour__WEBPACK_IMPORTED_MODULE_10__["utcHours"]; });

/* harmony import */ var _utcDay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utcDay */ "./packages/muze-utils/node_modules/d3-time/src/utcDay.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDay", function() { return _utcDay__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return _utcDay__WEBPACK_IMPORTED_MODULE_11__["utcDays"]; });

/* harmony import */ var _utcWeek__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utcWeek */ "./packages/muze-utils/node_modules/d3-time/src/utcWeek.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeek", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcMonday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcMondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcTuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcTuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcWednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcWednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcThursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcThursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcFriday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcFridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSaturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return _utcWeek__WEBPACK_IMPORTED_MODULE_12__["utcSaturdays"]; });

/* harmony import */ var _utcMonth__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utcMonth */ "./packages/muze-utils/node_modules/d3-time/src/utcMonth.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonth", function() { return _utcMonth__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return _utcMonth__WEBPACK_IMPORTED_MODULE_13__["utcMonths"]; });

/* harmony import */ var _utcYear__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utcYear */ "./packages/muze-utils/node_modules/d3-time/src/utcYear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYear", function() { return _utcYear__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return _utcYear__WEBPACK_IMPORTED_MODULE_14__["utcYears"]; });
































/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/interval.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/interval.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return newInterval; });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/millisecond.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/millisecond.js ***!
  \*********************************************************************/
/*! exports provided: default, milliseconds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "milliseconds", function() { return milliseconds; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");


var millisecond = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ __webpack_exports__["default"] = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/minute.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/minute.js ***!
  \****************************************************************/
/*! exports provided: default, minutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minutes", function() { return minutes; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var minute = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration__WEBPACK_IMPORTED_MODULE_1__["durationSecond"]);
}, function(date, step) {
  date.setTime(+date + step * _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"];
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (minute);
var minutes = minute.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/month.js":
/*!***************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/month.js ***!
  \***************************************************************/
/*! exports provided: default, months */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "months", function() { return months; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");


var month = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (month);
var months = month.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/second.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/second.js ***!
  \****************************************************************/
/*! exports provided: default, seconds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "seconds", function() { return seconds; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var second = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration__WEBPACK_IMPORTED_MODULE_1__["durationSecond"]);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationSecond"];
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ __webpack_exports__["default"] = (second);
var seconds = second.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcDay.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcDay.js ***!
  \****************************************************************/
/*! exports provided: default, utcDays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return utcDays; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var utcDay = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationDay"];
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ __webpack_exports__["default"] = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcHour.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcHour.js ***!
  \*****************************************************************/
/*! exports provided: default, utcHours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return utcHours; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var utcHour = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration__WEBPACK_IMPORTED_MODULE_1__["durationHour"]);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationHour"];
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ __webpack_exports__["default"] = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcMinute.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcMinute.js ***!
  \*******************************************************************/
/*! exports provided: default, utcMinutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return utcMinutes; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



var utcMinute = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]);
}, function(start, end) {
  return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"];
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcMonth.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcMonth.js ***!
  \******************************************************************/
/*! exports provided: default, utcMonths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return utcMonths; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");


var utcMonth = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ __webpack_exports__["default"] = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcWeek.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcWeek.js ***!
  \*****************************************************************/
/*! exports provided: utcSunday, utcMonday, utcTuesday, utcWednesday, utcThursday, utcFriday, utcSaturday, utcSundays, utcMondays, utcTuesdays, utcWednesdays, utcThursdays, utcFridays, utcSaturdays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return utcSunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return utcMonday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return utcTuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return utcWednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return utcThursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return utcFriday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return utcSaturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return utcSundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return utcMondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return utcTuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return utcWednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return utcThursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return utcFridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return utcSaturdays; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationWeek"];
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/utcYear.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/utcYear.js ***!
  \*****************************************************************/
/*! exports provided: default, utcYears */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return utcYears; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");


var utcYear = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/week.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/week.js ***!
  \**************************************************************/
/*! exports provided: sunday, monday, tuesday, wednesday, thursday, friday, saturday, sundays, mondays, tuesdays, wednesdays, thursdays, fridays, saturdays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sunday", function() { return sunday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monday", function() { return monday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuesday", function() { return tuesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wednesday", function() { return wednesday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thursday", function() { return thursday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "friday", function() { return friday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturday", function() { return saturday; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sundays", function() { return sundays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mondays", function() { return mondays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tuesdays", function() { return tuesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wednesdays", function() { return wednesdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thursdays", function() { return thursdays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fridays", function() { return fridays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturdays", function() { return saturdays; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-time/src/duration.js");



function weekday(i) {
  return Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration__WEBPACK_IMPORTED_MODULE_1__["durationMinute"]) / _duration__WEBPACK_IMPORTED_MODULE_1__["durationWeek"];
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-time/src/year.js":
/*!**************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-time/src/year.js ***!
  \**************************************************************/
/*! exports provided: default, years */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "years", function() { return years; });
/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-time/src/interval.js");


var year = Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : Object(_interval__WEBPACK_IMPORTED_MODULE_0__["default"])(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (year);
var years = year.range;


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-timer/src/index.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-timer/src/index.js ***!
  \****************************************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./packages/muze-utils/node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _timer__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _timer__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _timer__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _timeout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timeout */ "./packages/muze-utils/node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _timeout__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interval */ "./packages/muze-utils/node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _interval__WEBPACK_IMPORTED_MODULE_2__["default"]; });








/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-timer/src/interval.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-timer/src/interval.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./packages/muze-utils/node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"], total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(_timer__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-timer/src/timeout.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-timer/src/timeout.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./packages/muze-utils/node_modules/d3-timer/src/timer.js");


/* harmony default export */ __webpack_exports__["default"] = (function(callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"];
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-timer/src/timer.js":
/*!****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-timer/src/timer.js ***!
  \****************************************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/active.js":
/*!**********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/active.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/index.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/index.js ***!
  \*********************************************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./packages/muze-utils/node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _transition_index__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _active__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active */ "./packages/muze-utils/node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _active__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt */ "./packages/muze-utils/node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _interrupt__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/interrupt.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/interrupt.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/selection/index.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/selection/index.js ***!
  \*******************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt */ "./packages/muze-utils/node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition */ "./packages/muze-utils/node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/selection/interrupt.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/selection/interrupt.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt */ "./packages/muze-utils/node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  return this.each(function() {
    Object(_interrupt__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/selection/transition.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/selection/transition.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./packages/muze-utils/node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./packages/muze-utils/node_modules/d3-timer/src/index.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name) {
  var id,
      timing;

  if (name instanceof _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/attr.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/attr.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate */ "./packages/muze-utils/node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/attrTween.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/attrTween.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i(t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i(t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/delay.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/delay.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/duration.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/duration.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/ease.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/ease.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/end.js":
/*!******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/end.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/filter.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/filter.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/index.js ***!
  \********************************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ "./packages/muze-utils/node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay */ "./packages/muze-utils/node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration */ "./packages/muze-utils/node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease */ "./packages/muze-utils/node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter */ "./packages/muze-utils/node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./packages/muze-utils/node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./on */ "./packages/muze-utils/node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remove */ "./packages/muze-utils/node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./select */ "./packages/muze-utils/node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selectAll */ "./packages/muze-utils/node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selection */ "./packages/muze-utils/node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style */ "./packages/muze-utils/node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./styleTween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./text */ "./packages/muze-utils/node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./transition */ "./packages/muze-utils/node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./end */ "./packages/muze-utils/node_modules/d3-transition/src/transition/end.js");




















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select__WEBPACK_IMPORTED_MODULE_10__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_11__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  selection: _selection__WEBPACK_IMPORTED_MODULE_12__["default"],
  transition: _transition__WEBPACK_IMPORTED_MODULE_16__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on__WEBPACK_IMPORTED_MODULE_8__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_13__["default"],
  styleTween: _styleTween__WEBPACK_IMPORTED_MODULE_14__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_15__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_9__["default"],
  tween: _tween__WEBPACK_IMPORTED_MODULE_17__["default"],
  delay: _delay__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease__WEBPACK_IMPORTED_MODULE_5__["default"],
  end: _end__WEBPACK_IMPORTED_MODULE_18__["default"]
};


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/interpolate.js":
/*!**************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/interpolate.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]
      : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/merge.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/merge.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/on.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/on.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/remove.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/remove.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this.on("end.remove", removeFunction(this._id));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js":
/*!***********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js ***!
  \***********************************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./packages/muze-utils/node_modules/d3-dispatch/src/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./packages/muze-utils/node_modules/d3-timer/src/index.js");



var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ __webpack_exports__["default"] = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/select.js":
/*!*********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/select.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/selectAll.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/selectAll.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ __webpack_exports__["default"] = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/selection.js":
/*!************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/selection.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Selection(this._groups, this._parents);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/style.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/style.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate */ "./packages/muze-utils/node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        string1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["style"])(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["set"])(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, Object(_tween__WEBPACK_IMPORTED_MODULE_3__["tweenValue"])(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/styleTween.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/styleTween.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i(t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/text.js":
/*!*******************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/text.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween */ "./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(Object(_tween__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/transition.js":
/*!*************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/transition.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./packages/muze-utils/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js":
/*!********************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-transition/src/transition/tween.js ***!
  \********************************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./packages/muze-utils/node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/Beach.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/Beach.js ***!
  \******************************************************************/
/*! exports provided: removeBeach, addBeach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBeach", function() { return removeBeach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBeach", function() { return addBeach; });
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RedBlackTree */ "./packages/muze-utils/node_modules/d3-voronoi/src/RedBlackTree.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cell */ "./packages/muze-utils/node_modules/d3-voronoi/src/Cell.js");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle */ "./packages/muze-utils/node_modules/d3-voronoi/src/Circle.js");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "./packages/muze-utils/node_modules/d3-voronoi/src/Edge.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Diagram */ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js");






var beachPool = [];

function Beach() {
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(beach);
  _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].remove(beach);
  beachPool.push(beach);
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]
      && Math.abs(y - lArc.circle.cy) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]
      && Math.abs(y - rArc.circle.cy) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["setEdgeEnd"])(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, rArc.site, null, vertex);

  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"]._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -_Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -_Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["createCell"])(site);
  var newArc = createBeach(site);
  _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);
    rArc = createBeach(lArc.site);
    _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].insert(newArc, rArc);
    newArc.edge = rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, newArc.site);
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["setEdgeEnd"])(rArc.edge, lSite, rSite, vertex);
  newArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lSite, site, null, vertex);
  rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(site, rSite, null, vertex);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/Cell.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/Cell.js ***!
  \*****************************************************************/
/*! exports provided: createCell, cellHalfedgeStart, cellHalfedgeEnd, sortCellHalfedges, clipCells */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCell", function() { return createCell; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cellHalfedgeStart", function() { return cellHalfedgeStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cellHalfedgeEnd", function() { return cellHalfedgeEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortCellHalfedges", function() { return sortCellHalfedges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipCells", function() { return clipCells; });
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Edge */ "./packages/muze-utils/node_modules/d3-voronoi/src/Edge.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js");



function createCell(site) {
  return _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"].length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"].length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!_Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Math.abs(endY - startY) > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
          halfedges.splice(iHalfedge, 0, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, end,
              Math.abs(endX - x0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && y1 - endY > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [x0, Math.abs(startX - x0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startY : y1]
              : Math.abs(endY - y1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && x1 - endX > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [Math.abs(startY - y1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startX : x1, y1]
              : Math.abs(endX - x1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && endY - y0 > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [x1, Math.abs(startX - x1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startY : y0]
              : Math.abs(endY - y0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && endX - x0 > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [Math.abs(startY - y0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site = cover.site, v00, v01)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v01, v11)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v11, v10)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
      if (!cell.halfedges.length) {
        delete _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell];
      }
    }
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/Circle.js":
/*!*******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/Circle.js ***!
  \*******************************************************************/
/*! exports provided: firstCircle, attachCircle, detachCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstCircle", function() { return firstCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachCircle", function() { return attachCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachCircle", function() { return detachCircle; });
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RedBlackTree */ "./packages/muze-utils/node_modules/d3-voronoi/src/RedBlackTree.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js");



var circlePool = [];

var firstCircle;

function Circle() {
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -_Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon2"]) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"]._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"].insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"].remove(circle);
    circlePool.push(circle);
    Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(circle);
    arc.circle = null;
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js ***!
  \********************************************************************/
/*! exports provided: epsilon, epsilon2, beaches, cells, circles, edges, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beaches", function() { return beaches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cells", function() { return cells; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circles", function() { return circles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "edges", function() { return edges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Diagram; });
/* harmony import */ var _Beach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Beach */ "./packages/muze-utils/node_modules/d3-voronoi/src/Beach.js");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cell */ "./packages/muze-utils/node_modules/d3-voronoi/src/Cell.js");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle */ "./packages/muze-utils/node_modules/d3-voronoi/src/Circle.js");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "./packages/muze-utils/node_modules/d3-voronoi/src/Edge.js");
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RedBlackTree */ "./packages/muze-utils/node_modules/d3-voronoi/src/RedBlackTree.js");






var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__["default"];
  circles = new _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__["default"];

  while (true) {
    circle = _Circle__WEBPACK_IMPORTED_MODULE_2__["firstCircle"];
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        Object(_Beach__WEBPACK_IMPORTED_MODULE_0__["addBeach"])(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      Object(_Beach__WEBPACK_IMPORTED_MODULE_0__["removeBeach"])(circle.arc);
    } else {
      break;
    }
  }

  Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["sortCellHalfedges"])();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["clipEdges"])(x0, y0, x1, y1);
    Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["clipCells"])(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["cellHalfedgeStart"])(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/Edge.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/Edge.js ***!
  \*****************************************************************/
/*! exports provided: createEdge, createBorderEdge, setEdgeEnd, clipEdges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEdge", function() { return createEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBorderEdge", function() { return createBorderEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setEdgeEnd", function() { return setEdgeEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipEdges", function() { return clipEdges; });
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Diagram */ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js");


function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"].push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  _Diagram__WEBPACK_IMPORTED_MODULE_0__["cells"][left.index].halfedges.push(index);
  _Diagram__WEBPACK_IMPORTED_MODULE_0__["cells"][right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"].length,
      edge;

  while (i--) {
    if (!connectEdge(edge = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"][i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > _Diagram__WEBPACK_IMPORTED_MODULE_0__["epsilon"]
            || Math.abs(edge[0][1] - edge[1][1]) > _Diagram__WEBPACK_IMPORTED_MODULE_0__["epsilon"])) {
      delete _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"][i];
    }
  }
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/RedBlackTree.js":
/*!*************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/RedBlackTree.js ***!
  \*************************************************************************/
/*! exports provided: RedBlackNode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedBlackNode", function() { return RedBlackNode; });
function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

/* harmony default export */ __webpack_exports__["default"] = (RedBlackTree);


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/constant.js":
/*!*********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/constant.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/index.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/index.js ***!
  \******************************************************************/
/*! exports provided: voronoi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _voronoi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./voronoi */ "./packages/muze-utils/node_modules/d3-voronoi/src/voronoi.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "voronoi", function() { return _voronoi__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/point.js":
/*!******************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/point.js ***!
  \******************************************************************/
/*! exports provided: x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}


/***/ }),

/***/ "./packages/muze-utils/node_modules/d3-voronoi/src/voronoi.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/d3-voronoi/src/voronoi.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./packages/muze-utils/node_modules/d3-voronoi/src/constant.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./packages/muze-utils/node_modules/d3-voronoi/src/point.js");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Diagram */ "./packages/muze-utils/node_modules/d3-voronoi/src/Diagram.js");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x = _point__WEBPACK_IMPORTED_MODULE_1__["x"],
      y = _point__WEBPACK_IMPORTED_MODULE_1__["y"],
      extent = null;

  function voronoi(data) {
    return new _Diagram__WEBPACK_IMPORTED_MODULE_2__["default"](data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) * _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"], Math.round(y(d, i, data) / _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) * _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
});


/***/ }),

/***/ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/SmartlabelManager.js":
/*!*******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/SmartlabelManager.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lib = __webpack_require__(/*! ./lib */ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/lib.js");

var _lib2 = _interopRequireDefault(_lib);

var _containerManager = __webpack_require__(/*! ./container-manager */ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/container-manager.js");

var _containerManager2 = _interopRequireDefault(_containerManager);

var slLib = _lib2['default'].init(typeof window !== "undefined" ? window : undefined),
    doc = slLib.win.document,
    M = slLib.win.Math,
    max = M.max,
    round = M.round,
    BLANK = '',
    htmlSplCharSpace = { ' ': '&nbsp;' },
    documentSupport = slLib.getDocumentSupport(),
    SVG_BBOX_CORRECTION = documentSupport.isWebKit ? 0 : 4.5;

/*
 * Create new instance of SmartLabelManager.
 *
 * SmartLabelManager controls the lifetime of the execution space where the text's metrics will be calculated.
 * This takes a string for a given style and returns the height, width.
 * If a bound box is defined it wraps the text and returns the wrapped height and width.
 * It allows to append ellipsis at the end if the text is truncated.
 *
 * @param {String | Number} id - Id of the instance. If the same id is passed, it disposes the old instance and
 *                              save the new one;
 * @param {String | HTMLElement} container - The id or the instance of the container where the intermediate dom
 *                              elements are to be attached. If not passed, it appends in div
 *
 * @param {Boolean} useEllipses - This decides if a ellipses to be appended if the text is truncated.
 * @param {Object} options - Control options
 *                          {
 *                              maxCacheLimit: No of letter to be cached. Default: 500.
 *                          }
 * @constructor
 */
function SmartLabelManager(id, container, useEllipses, options) {
    var wrapper,
        prop,
        max,
        prevInstance,
        isBrowserLess = false,
        store = SmartLabelManager.store;

    if (typeof id === 'undefined' || typeof id === 'object') {
        return;
    }

    if (prevInstance = store[id]) {
        prevInstance.dispose();
    }

    store[id] = this;
    options = options || {};
    options.maxCacheLimit = isFinite(max = options.maxCacheLimit) ? max : slLib.maxDefaultCacheLimit;

    if (typeof container === 'string') {
        container = doc.getElementById(container);
    }

    wrapper = slLib.createContainer(container);
    wrapper.innerHTML = slLib.testStrAvg;

    if (documentSupport.isHeadLess || !documentSupport.isIE && !wrapper.offsetHeight && !wrapper.offsetWidth) {
        isBrowserLess = true;
    }

    wrapper.innerHTML = '';
    for (prop in slLib.parentContainerStyle) {
        wrapper.style[prop] = slLib.parentContainerStyle[prop];
    }

    this.id = id;
    this.parentContainer = wrapper;

    this._containerManager = new _containerManager2['default'](wrapper, isBrowserLess, 10);
    this._showNoEllipses = !useEllipses;
    this._init = true;
    this.style = {};
    this.options = options;

    this.setStyle();
}

/*
 * getSmartText returns the text separated by <br/> whenever a break is necessary. This is to recgonize one
 * generalized format independent of the implementation (canvas based solution, svg based solution). This method
 * converts the output of getSmartText().text to array of lines if the text is wrapped. It sets a named property
 * `lines` on the object passed as parameter.
 *
 * @param {Object} smartlabel - the object returned by getSmartText based on which line arr which to be formed.
 *
 * @return {Object} - The same object which was passed in the arguments. Also a named property `lines` is set.
 */
SmartLabelManager.textToLines = function (smartlabel) {
    smartlabel = smartlabel || {};

    if (!smartlabel.text) {
        smartlabel.text = '';
    } else if (typeof smartlabel.text !== 'string') {
        smartlabel.text = smartlabel.text.toString();
    }

    smartlabel.lines = smartlabel.text.split(/\n|<br\s*?\/?>/ig);
    return smartlabel;
};

// Saves all the instance created so far
SmartLabelManager.store = {};

// Calculates space taken by a character with an approximation value which is calculated by repeating the
// character by string length times.
SmartLabelManager.prototype._calCharDimWithCache = function (text, calculateDifference, length) {
    if (!this._init) {
        return false;
    }

    var size,
        csArr,
        tw,
        twi,
        cachedStyle,
        asymmetricDifference,
        maxAdvancedCacheLimit = this.options.maxCacheLimit,
        container = this._container,
        style = this.style || {},
        cache = this._advancedCache || (this._advancedCache = {}),
        advancedCacheKey = this._advancedCacheKey || (this._advancedCacheKey = []),
        cacheName = text + (style.fontSize || BLANK) + (style.fontFamily || BLANK) + (style.fontWeight || BLANK) + (style.fontStyle || BLANK),
        cacheInitName = text + 'init' + (style.fontSize || BLANK) + (style.fontFamily || BLANK) + (style.fontWeight || BLANK) + (style.fontStyle || BLANK);

    htmlSplCharSpace[text] && (text = htmlSplCharSpace[text]);

    if (!calculateDifference) {
        asymmetricDifference = 0;
    } else {
        if ((asymmetricDifference = cache[cacheInitName]) === undefined) {
            container.innerHTML = text.repeat ? text.repeat(length) : Array(length + 1).join(text); // jshint ignore:line
            tw = container.offsetWidth;

            container.innerHTML = text;
            twi = container.offsetWidth;

            asymmetricDifference = cache[cacheInitName] = (tw - length * twi) / (length + 1);
            advancedCacheKey.push(cacheInitName);
            if (advancedCacheKey.length > maxAdvancedCacheLimit) {
                delete cache[advancedCacheKey.shift()];
            }
        }
    }

    if (cachedStyle = cache[cacheName]) {
        csArr = cachedStyle.split(',');
        return {
            width: parseFloat(csArr[0], 10),
            height: parseFloat(csArr[1], 10)
        };
    }

    container.innerHTML = text;

    size = {
        height: container.offsetHeight,
        width: container.offsetWidth + asymmetricDifference
    };

    cache[cacheName] = size.width + ',' + size.height;
    advancedCacheKey.push(cacheName);
    if (advancedCacheKey.length > maxAdvancedCacheLimit) {
        delete cache[advancedCacheKey.shift()];
    }

    return size;
};

// Provide function to calculate the height and width based on the environment and available support from dom.
SmartLabelManager.prototype._getWidthFn = function () {
    var contObj = this._containerObj,
        container = this._container,
        svgText = contObj.svgText;

    if (svgText) {
        return function (str) {
            var bbox, width;

            svgText.textContent = str;
            bbox = svgText.getBBox();
            width = bbox.width - SVG_BBOX_CORRECTION;
            if (width < 1) {
                width = bbox.width;
            }

            return width;
        };
    } else {
        return function (str) {
            container.innerHTML = str;
            return container.offsetWidth;
        };
    }
};

/*
 * Sets the style based on which the text's metrics to be calculated.
 *
 * @param {Object} style - The style object which affects the text size
 *                      {
 *                          fontSize / 'font-size' : MUST BE FOLLOWED BY PX (10px, 11px)
 *                          fontFamily / 'font-family'
 *                          fontWeight / 'font-weight'
 *                          fontStyle / 'font-style'
 *                      }
 *
 * @return {SmartLabelManager} - Current instance of SmartLabelManager
 */
SmartLabelManager.prototype.setStyle = function (style) {
    if (!this._init) {
        return this;
    }

    var sCont;

    if (style === this.style && !this._styleNotSet) {
        return;
    }

    if (!style) {
        style = this.style;
    }

    slLib.setLineHeight(style);
    this.style = style;

    this._containerObj = sCont = this._containerManager.get(style);

    if (this._containerObj) {
        this._container = sCont.node;
        this._context = sCont.context;
        this._cache = sCont.charCache;
        this._lineHeight = sCont.lineHeight;
        this._styleNotSet = false;
    } else {
        this._styleNotSet = true;
    }

    return this;
};

/*
 * Decides whether ellipses to be shown if the node is truncated
 *
 * @param {Boolean} useEllipses - decides if a ellipses to be appended if the text is truncated. Default: false
 *
 * @return {SmartLabelManager} - Current instance of SmartLabelManager
 */
SmartLabelManager.prototype.useEllipsesOnOverflow = function (useEllipses) {
    if (!this._init) {
        return this;
    }
    this._showNoEllipses = !useEllipses;
    return this;
};

/*
 * Get wrapped or truncated text if a bound box is defined around it. The result text would be separated by <br/>
 * if wrapped
 *
 * @param {String} text - the subject text
 * @param {Number} maxWidth - width in px of the the bound box
 * @param {Number} maxHeight - height in px of the the bound box
 * @param {Boolean} noWrap - whether the text to be wrapped. Default false.
 *
 * @return {Object} - The metrics of the text bounded by the box
 *                  {
 *                      height : height of the wrapped text
 *                      width : width of the wrapped text
 *                      isTruncated : whether the text is truncated
 *                      maxHeight : Maximum height given
 *                      maxWidth : Maximum width given
 *                      oriText : Original text sent
 *                      oriTextHeight : Original text height
 *                      oriTextWidth : Original text width
 *                      text : SMART TEXT
 *                  }
 */
SmartLabelManager.prototype.getSmartText = function (text, maxWidth, maxHeight, noWrap) {
    if (!this._init) {
        return false;
    }

    if (text === undefined || text === null) {
        text = '';
    } else if (typeof text !== 'string') {
        text = text.toString();
    }

    var len,
        trimStr,
        tempArr,
        tmpText,
        maxWidthWithEll,
        toolText,
        oriWidth,
        oriHeight,
        newCharIndex,
        nearestChar,
        tempChar,
        getWidth,
        initialLeft,
        initialTop,
        getOriSizeImproveObj,
        spanArr,
        x,
        y,
        minWidth,
        elem,
        chr,
        elemRightMostPoint,
        elemLowestPoint,
        lastBR,
        removeFromIndex,
        removeFromIndexForEllipses,
        hasHTMLTag = false,
        maxStrWidth = 0,
        lastDash = -1,
        lastSpace = -1,
        lastIndexBroken = -1,
        strWidth = 0,
        strHeight = 0,
        oriTextArr = [],
        i = 0,
        ellipsesStr = this._showNoEllipses ? '' : '...',
        lineHeight = this._lineHeight,
        context = this._context,
        container = this._container,
        sCont = this._containerObj,
        ellipsesWidth = sCont.ellipsesWidth,
        dotWidth = sCont.dotWidth,
        characterArr = [],
        dashIndex = -1,
        spaceIndex = -1,
        lastLineBreak = -1,
        fastTrim = function fastTrim(str) {
        str = str.replace(/^\s\s*/, '');
        var ws = /\s/,
            i = str.length;
        while (ws.test(str.charAt(i -= 1))) {/* jshint noempty:false */}
        return str.slice(0, i + 1);
    },
        smartLabel = {
        text: text,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: null,
        height: null,
        oriTextWidth: null,
        oriTextHeight: null,
        oriText: text,
        isTruncated: false
    };

    getWidth = this._getWidthFn();

    // In some browsers, offsetheight of a single-line text is getting little (1 px) heigher value of the
    // lineheight. As a result, smartLabel is unable to return single-line text.
    // To fix this, increase the maxHeight a little amount. Hence maxHeight =  lineHeight * 1.2
    if (maxHeight === lineHeight) {
        maxHeight *= 1.2;
    }

    if (container) {
        if (!documentSupport.isBrowserLess) {
            hasHTMLTag = slLib.xmlTagRegEx.test(text);
            if (!hasHTMLTag) {
                // Due to support of <,> for xml we convert &lt;, &gt; to <,> respectively so to get the correct
                // width it is required to convert the same before calculation for the new improve version of the
                // get text width.
                tmpText = text.replace(slLib.ltgtRegex, function (match) {
                    return match === '&lt;' ? '<' : '>';
                });
                getOriSizeImproveObj = this.getOriSize(tmpText, true);

                smartLabel.oriTextWidth = oriWidth = getOriSizeImproveObj.width;
                smartLabel.oriTextHeight = oriHeight = getOriSizeImproveObj.height;
            } else {
                container.innerHTML = text;
                smartLabel.oriTextWidth = oriWidth = container.offsetWidth;
                smartLabel.oriTextHeight = oriHeight = container.offsetHeight;
            }

            if (oriHeight <= maxHeight && oriWidth <= maxWidth) {
                smartLabel.width = smartLabel.oriTextWidth = oriWidth;
                smartLabel.height = smartLabel.oriTextHeight = oriHeight;
                return smartLabel;
            }

            if (lineHeight > maxHeight) {
                smartLabel.text = '';
                smartLabel.width = smartLabel.oriTextWidth = 0;
                smartLabel.height = smartLabel.oriTextHeight = 0;
                return smartLabel;
            }
        }

        // Calculate width with ellipses
        text = fastTrim(text).replace(/(\s+)/g, ' ');
        maxWidthWithEll = this._showNoEllipses ? maxWidth : maxWidth - ellipsesWidth;

        if (!hasHTMLTag) {
            oriTextArr = text.split('');
            len = oriTextArr.length;
            trimStr = '', tempArr = [];
            tempChar = oriTextArr[0];

            if (this._cache[tempChar]) {
                minWidth = this._cache[tempChar].width;
            } else {
                minWidth = getWidth(tempChar);
                this._cache[tempChar] = { width: minWidth };
            }

            if (maxWidthWithEll > minWidth) {
                tempArr = text.substr(0, slLib.getNearestBreakIndex(text, maxWidthWithEll, this)).split('');
                i = tempArr.length;
            } else if (minWidth > maxWidth) {
                smartLabel.text = '';
                smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;
                return smartLabel;
            } else if (ellipsesStr) {
                maxWidthWithEll = maxWidth - 2 * dotWidth;
                if (maxWidthWithEll > minWidth) {
                    ellipsesStr = '..';
                } else {
                    maxWidthWithEll = maxWidth - dotWidth;
                    if (maxWidthWithEll > minWidth) {
                        ellipsesStr = '.';
                    } else {
                        maxWidthWithEll = 0;
                        ellipsesStr = '';
                    }
                }
            }

            strWidth = getWidth(tempArr.join(''));
            strHeight = this._lineHeight;

            if (noWrap) {
                for (; i < len; i += 1) {
                    tempChar = tempArr[i] = oriTextArr[i];
                    if (this._cache[tempChar]) {
                        minWidth = this._cache[tempChar].width;
                    } else {
                        if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {
                            minWidth = getWidth(tempChar);
                        }
                        this._cache[tempChar] = {
                            width: minWidth
                        };
                    }
                    strWidth += minWidth;
                    if (strWidth > maxWidthWithEll) {
                        if (!trimStr) {
                            trimStr = tempArr.slice(0, -1).join('');
                        }
                        if (strWidth > maxWidth) {
                            smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                            smartLabel.tooltext = smartLabel.oriText;
                            smartLabel.width = getWidth(smartLabel.text);
                            smartLabel.height = this._lineHeight;
                            return smartLabel;
                        }
                    }
                }

                smartLabel.text = tempArr.join('');
                smartLabel.width = strWidth;
                smartLabel.height = this._lineHeight;
                return smartLabel;
            } else {
                for (; i < len; i += 1) {
                    tempChar = tempArr[i] = oriTextArr[i];
                    if (tempChar === ' ' && !context) {
                        tempChar = '&nbsp;';
                    }

                    if (this._cache[tempChar]) {
                        minWidth = this._cache[tempChar].width;
                    } else {
                        if (!getOriSizeImproveObj || !(minWidth = getOriSizeImproveObj.detailObj[tempChar])) {
                            minWidth = getWidth(tempChar);
                        }
                        this._cache[tempChar] = {
                            width: minWidth
                        };
                    }
                    strWidth += minWidth;

                    if (strWidth > maxWidthWithEll) {
                        if (!trimStr) {
                            trimStr = tempArr.slice(0, -1).join('');
                        }
                        if (strWidth > maxWidth) {
                            /** @todo use regular expressions for better performance. */
                            lastSpace = text.substr(0, tempArr.length).lastIndexOf(' ');
                            lastDash = text.substr(0, tempArr.length).lastIndexOf('-');
                            if (lastSpace > lastIndexBroken) {
                                strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                tempArr.splice(lastSpace, 1, '<br/>');
                                lastIndexBroken = lastSpace;
                                newCharIndex = lastSpace + 1;
                            } else if (lastDash > lastIndexBroken) {
                                if (lastDash === tempArr.length - 1) {
                                    strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                    tempArr.splice(lastDash, 1, '<br/>-');
                                } else {
                                    strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                    tempArr.splice(lastDash, 1, '-<br/>');
                                }
                                lastIndexBroken = lastDash;
                                newCharIndex = lastDash + 1;
                            } else {
                                tempArr.splice(tempArr.length - 1, 1, '<br/>' + oriTextArr[i]);
                                lastLineBreak = tempArr.length - 2;
                                strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastLineBreak + 1).join(''));
                                lastIndexBroken = lastLineBreak;
                                newCharIndex = i;
                            }
                            strHeight += this._lineHeight;
                            if (strHeight > maxHeight) {
                                smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                                smartLabel.tooltext = smartLabel.oriText;
                                // The max width among all the lines will be the width of the string.
                                smartLabel.width = maxWidth;
                                smartLabel.height = strHeight - this._lineHeight;
                                return smartLabel;
                            } else {
                                maxStrWidth = max(maxStrWidth, strWidth);
                                trimStr = null;
                                nearestChar = slLib.getNearestBreakIndex(text.substr(newCharIndex), maxWidthWithEll, this);
                                strWidth = getWidth(text.substr(newCharIndex, nearestChar || 1));
                                if (tempArr.length < newCharIndex + nearestChar) {
                                    tempArr = tempArr.concat(text.substr(tempArr.length, newCharIndex + nearestChar - tempArr.length).split(''));
                                    i = tempArr.length - 1;
                                }
                            }
                        }
                    }
                }

                maxStrWidth = max(maxStrWidth, strWidth);

                smartLabel.text = tempArr.join('');
                smartLabel.width = maxStrWidth;
                smartLabel.height = strHeight;
                return smartLabel;
            }
        } else {
            toolText = text.replace(slLib.spanAdditionRegx, '$2');
            text = text.replace(slLib.spanAdditionRegx, slLib.spanAdditionReplacer);
            text = text.replace(/(<br\s*\/*\>)/g, '<span class="' + [slLib.classNameWithTag, ' ', slLib.classNameWithTagBR].join('') + '">$1</span>');

            container.innerHTML = text;

            spanArr = container[documentSupport.childRetriverFn](documentSupport.childRetriverString);

            for (x = 0, y = spanArr.length; x < y; x += 1) {
                elem = spanArr[x];
                //chech whether this span is temporary inserted span from it's class
                if (documentSupport.noClassTesting || slLib.classNameReg.test(elem.className)) {
                    chr = elem.innerHTML;
                    if (chr !== '') {
                        if (chr === ' ') {
                            spaceIndex = characterArr.length;
                        } else if (chr === '-') {
                            dashIndex = characterArr.length;
                        }

                        characterArr.push({
                            spaceIdx: spaceIndex,
                            dashIdx: dashIndex,
                            elem: elem
                        });
                        oriTextArr.push(chr);
                    }
                }
            }

            i = 0;
            len = characterArr.length;
            minWidth = characterArr[0].elem.offsetWidth;

            if (minWidth > maxWidth) {
                smartLabel.text = '';
                smartLabel.width = smartLabel.oriTextWidth = smartLabel.height = smartLabel.oriTextHeight = 0;

                return smartLabel;
            } else if (minWidth > maxWidthWithEll && !this._showNoEllipses) {

                maxWidthWithEll = maxWidth - 2 * dotWidth;
                if (maxWidthWithEll > minWidth) {
                    ellipsesStr = '..';
                } else {
                    maxWidthWithEll = maxWidth - dotWidth;
                    if (maxWidthWithEll > minWidth) {
                        ellipsesStr = '.';
                    } else {
                        maxWidthWithEll = 0;
                        ellipsesStr = '';
                    }
                }
            }

            initialLeft = characterArr[0].elem.offsetLeft;
            initialTop = characterArr[0].elem.offsetTop;

            if (noWrap) {
                for (; i < len; i += 1) {
                    elem = characterArr[i].elem;
                    elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;

                    if (elemRightMostPoint > maxWidthWithEll) {
                        if (!removeFromIndexForEllipses) {
                            removeFromIndexForEllipses = i;
                        }
                        if (container.offsetWidth > maxWidth) {
                            removeFromIndex = i;
                            i = len;
                        }
                    }
                }
            } else {
                for (; i < len; i += 1) {
                    elem = characterArr[i].elem;
                    elemLowestPoint = elem.offsetHeight + (elem.offsetTop - initialTop);
                    elemRightMostPoint = elem.offsetLeft - initialLeft + elem.offsetWidth;

                    lastBR = null;

                    if (elemRightMostPoint > maxWidthWithEll) {
                        if (!removeFromIndexForEllipses) {
                            removeFromIndexForEllipses = i;
                        }

                        if (elemRightMostPoint > maxWidth) {
                            lastSpace = characterArr[i].spaceIdx;
                            lastDash = characterArr[i].dashIdx;
                            if (lastSpace > lastIndexBroken) {
                                characterArr[lastSpace].elem.innerHTML = '<br/>';
                                lastIndexBroken = lastSpace;
                            } else if (lastDash > lastIndexBroken) {
                                if (lastDash === i) {
                                    // in case the overflowing character itself is the '-'
                                    characterArr[lastDash].elem.innerHTML = '<br/>-';
                                } else {
                                    characterArr[lastDash].elem.innerHTML = '-<br/>';
                                }
                                lastIndexBroken = lastDash;
                            } else {
                                elem.parentNode.insertBefore(lastBR = doc.createElement('br'), elem);
                            }

                            //check whether this break made current element outside the area height
                            if (elem.offsetHeight + elem.offsetTop > maxHeight) {
                                //remove the lastly inserted line break
                                if (lastBR) {
                                    lastBR.parentNode.removeChild(lastBR);
                                } else if (lastIndexBroken === lastDash) {
                                    characterArr[lastDash].elem.innerHTML = '-';
                                } else {
                                    characterArr[lastSpace].elem.innerHTML = ' ';
                                }
                                removeFromIndex = i;
                                //break the looping condition
                                i = len;
                            } else {
                                removeFromIndexForEllipses = null;
                            }
                        }
                    } else {
                        //check whether this break made current element outside the area height
                        if (elemLowestPoint > maxHeight) {
                            removeFromIndex = i;
                            i = len;
                        }
                    }
                }
            }

            if (removeFromIndex < len) {
                //set the trancated property of the smartlabel
                smartLabel.isTruncated = true;

                /** @todo is this really needed? */
                removeFromIndexForEllipses = removeFromIndexForEllipses ? removeFromIndexForEllipses : removeFromIndex;

                for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {
                    elem = characterArr[i].elem;
                    //chech whether this span is temporary inserted span from it's class
                    elem.parentNode.removeChild(elem);
                }

                for (; i >= 0; i -= 1) {
                    elem = characterArr[i].elem;
                    if (slLib.classNameBrReg.test(elem.className)) {
                        //chech whether this span is temporary inserted span from it's class
                        elem.parentNode.removeChild(elem);
                    } else {
                        i = 0;
                    }
                }
            }

            //get the smart text
            smartLabel.text = container.innerHTML.replace(slLib.spanRemovalRegx, '$1').replace(/\&amp\;/g, '&');
            if (smartLabel.isTruncated) {
                smartLabel.text += ellipsesStr;
                smartLabel.tooltext = toolText;
            }
        }

        smartLabel.height = container.offsetHeight;
        smartLabel.width = container.offsetWidth;

        return smartLabel;
    } else {
        smartLabel.error = new Error('Body Tag Missing!');
        return smartLabel;
    }
};

/*
 * Get the height and width of a text.
 *
 * @param {String} text - Text whose metrics to be measured
 * @param {Boolean} Optional detailedCalculationFlag - this flag if set it calculates per letter position
 *                          information and returns it. Ideally you dont need it unless you want to post process the
 *                          string. And its an EXPENSIVE OPERATION.
 *
 * @return {Object} - If detailedCalculationFlag is set to true the returned object would be
 *                  {
 *                      height: height of the text
 *                      width: width of the text
 *                      detailObj: detail calculation of letters in the format {lettername: width}
 *                  }
 *                  If detailedCalculationFlag is set to false the returned object wont have the detailObj prop.
 */
SmartLabelManager.prototype.getOriSize = function (text, detailedCalculationFlag) {
    if (!this._init) {
        return false;
    }

    var textArr,
        letter,
        lSize,
        i,
        l,
        cumulativeSize = 0,
        height = 0,
        indiSizeStore = {};

    if (!detailedCalculationFlag) {
        return this._calCharDimWithCache(text);
    }

    // Calculate the width of every letter with an approximation
    textArr = text.split('');
    for (i = 0, l = textArr.length; i < l; i++) {
        letter = textArr[i];
        lSize = this._calCharDimWithCache(letter, true, textArr.length);
        height = max(height, lSize.height);
        cumulativeSize += lSize.width;
        indiSizeStore[letter] = lSize.width;
    }

    return {
        width: round(cumulativeSize),
        height: height,
        detailObj: indiSizeStore
    };
};

/*
 * Dispose the container and object allocated by the smartlabel
 */
SmartLabelManager.prototype.dispose = function () {
    if (!this._init) {
        return this;
    }

    this._containerManager && this._containerManager.dispose && this._containerManager.dispose();

    delete this._container;
    delete this._context;
    delete this._cache;
    delete this._containerManager;
    delete this._containerObj;
    delete this.id;
    delete this.style;
    delete this.parentContainer;
    delete this._showNoEllipses;

    return this;
};

exports['default'] = SmartLabelManager;
module.exports = exports['default'];

/***/ }),

/***/ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/container-manager.js":
/*!*******************************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/container-manager.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lib = __webpack_require__(/*! ./lib */ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/lib.js");

var _lib2 = _interopRequireDefault(_lib);

var slLib = _lib2['default'].init(typeof window !== "undefined" ? window : undefined),
    doc = slLib.win.document,
    documentSupport = slLib.getDocumentSupport(),
    SVG_BBOX_CORRECTION = documentSupport.isWebKit ? 0 : 4.5;

function ContainerManager(parentContainer, isBrowserLess, maxContainers) {
    var svg;

    maxContainers = maxContainers > 5 ? maxContainers : 5;
    maxContainers = maxContainers < 20 ? maxContainers : 20;

    this.maxContainers = maxContainers;
    this.first = null;
    this.last = null;
    this.containers = {};
    this.length = 0;
    this.rootNode = parentContainer;

    if (isBrowserLess) {
        svg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttributeNS('http://www.w3.org/2000/svg', 'xlink', 'http://www.w3.org/1999/xlink');
        svg.setAttributeNS('http://www.w3.org/2000/svg', 'height', '0');
        svg.setAttributeNS('http://www.w3.org/2000/svg', 'width', '0');
        this.svgRoot = svg;
        this.rootNode.appendChild(svg);
    }
}

ContainerManager.prototype.get = function (style) {
    var diff,
        key,
        containerObj,
        containers = this.containers,
        len = this.length,
        max = this.maxContainers,
        keyStr = '';

    for (key in slLib.supportedStyle) {
        if (style[key] !== undefined) {
            keyStr += slLib.supportedStyle[key] + ':' + style[key] + ';';
        }
    }

    if (!keyStr) {
        return false;
    }

    if (containerObj = containers[keyStr]) {
        if (this.first !== containerObj) {
            containerObj.prev && (containerObj.prev.next = containerObj.next);
            containerObj.next && (containerObj.next.prev = containerObj.prev);
            containerObj.next = this.first;
            containerObj.next.prev = containerObj;
            this.last === containerObj && (this.last = containerObj.prev);
            containerObj.prev = null;
            this.first = containerObj;
        }
    } else {
        if (len >= max) {
            diff = len - max + 1;
            // +1 is to remove an extra entry to make space for the new container to be added.
            while (diff--) {
                this.removeContainer(this.last);
            }
        }
        containerObj = this.addContainer(keyStr);
    }

    return containerObj;
};

ContainerManager.prototype.addContainer = function (keyStr) {
    var node, container;

    this.containers[keyStr] = container = {
        next: null,
        prev: null,
        node: null,
        ellipsesWidth: 0,
        lineHeight: 0,
        dotWidth: 0,
        avgCharWidth: 4,
        keyStr: keyStr,
        charCache: {}
    };

    // Since the container objects are arranged from most recent to least recent order, we need to add the new
    // object at the beginning of the list.
    container.next = this.first;
    container.next && (container.next.prev = container);
    this.first = container;
    if (!this.last) {
        this.last = container;
    }
    this.length += 1;

    node = container.node = doc.createElement('div');
    this.rootNode.appendChild(node);

    if (documentSupport.isIE && !documentSupport.hasSVG) {
        node.style.setAttribute('cssText', keyStr);
    } else {
        node.setAttribute('style', keyStr);
    }

    node.setAttribute('aria-hidden', 'true');
    node.setAttribute('role', 'presentation');
    node.style.display = 'inline-block';

    node.innerHTML = slLib.testStrAvg; // A test string.
    container.lineHeight = node.offsetHeight;
    container.avgCharWidth = node.offsetWidth / 3;

    if (documentSupport.isBrowserLess) {
        node = container.svgText = doc.createElementNS('http://www.w3.org/2000/svg', 'text');
        node.setAttribute('style', keyStr);
        this.svgRoot.appendChild(node);

        node.textContent = slLib.testStrAvg; // A test string.
        container.lineHeight = node.getBBox().height;
        container.avgCharWidth = (node.getBBox().width - SVG_BBOX_CORRECTION) / 3;

        node.textContent = '...';
        container.ellipsesWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
        node.textContent = '.';
        container.dotWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
    } else {
        node.innerHTML = '...';
        container.ellipsesWidth = node.offsetWidth;
        node.innerHTML = '.';
        container.dotWidth = node.offsetWidth;
        node.innerHTML = '';
    }

    return container;
};

ContainerManager.prototype.removeContainer = function (cObj) {
    var keyStr = cObj.keyStr;

    if (!keyStr || !this.length || !cObj) {
        return;
    }
    this.length -= 1;

    cObj.prev && (cObj.prev.next = cObj.next);
    cObj.next && (cObj.next.prev = cObj.prev);
    this.first === cObj && (this.first = cObj.next);
    this.last === cObj && (this.last = cObj.prev);

    cObj.node.parentNode.removeChild(cObj.node);

    delete this.containers[keyStr];
};

ContainerManager.prototype.dispose = function () {
    var key,
        containers = this.containers;

    this.maxContainers = null;
    for (key in containers) {
        this.removeContainer(containers[key]);
    }

    this.rootNode.parentNode.removeChild(this.rootNode);

    this.rootNode = null;
    this.first = null;
    this.last = null;
};

module.exports = ContainerManager;

/***/ }),

/***/ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/lib.js":
/*!*****************************************************************************!*\
  !*** ./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/lib.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
	value: true
});
var lib = {
	init: function init(win) {
		var doc = win.document,
		    nav = win.navigator,
		    userAgent = nav.userAgent,
		    DIV = 'DIV',
		    ceil = Math.ceil,
		    floor = Math.floor,
		    containerInstanceCount = 0,
		    clsNameSpace = 'fusioncharts-smartlabel-',
		    containerClass = clsNameSpace + 'container',
		    classNameWithTag = clsNameSpace + 'tag',
		    classNameWithTagBR = clsNameSpace + 'br';

		lib = {
			win: win,

			containerClass: containerClass,

			classNameWithTag: classNameWithTag,

			classNameWithTagBR: classNameWithTagBR,

			maxDefaultCacheLimit: 500,

			classNameReg: new RegExp('\b' + classNameWithTag + '\b'),

			classNameBrReg: new RegExp('\b' + classNameWithTagBR + '\b'),

			spanAdditionRegx: /(<[^<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,

			spanAdditionReplacer: '$1<span class="' + classNameWithTag + '">$2</span>',

			spanRemovalRegx: new RegExp('\\<span[^\\>]+?' + classNameWithTag + '[^\\>]{0,}\\>(.*?)\\<\\/span\\>', 'ig'),

			xmlTagRegEx: new RegExp('<[^>][^<]*[^>]+>', 'i'),

			ltgtRegex: /&lt;|&gt;/g,

			brReplaceRegex: /<br\/>/ig,

			testStrAvg: 'WgI',

			// This style is applied over the parent smartlabel container. The container is kept hidden from the viewport
			parentContainerStyle: {
				position: 'absolute',
				top: '-9999em',
				whiteSpace: 'nowrap',
				padding: '0px',
				width: '1px',
				height: '1px',
				overflow: 'hidden'
			},

			// All the style which might affect the text metrics
			supportedStyle: {
				font: 'font',
				fontFamily: 'font-family',
				'font-family': 'font-family',
				fontWeight: 'font-weight',
				'font-weight': 'font-weight',
				fontSize: 'font-size',
				'font-size': 'font-size',
				lineHeight: 'line-height',
				'line-height': 'line-height',
				fontStyle: 'font-style',
				'font-style': 'font-style'
			},

			// Get the support list for html the document where the text calcution is to be done.
			getDocumentSupport: function getDocumentSupport() {
				var childRetriverFn, childRetriverString, noClassTesting;

				if (doc.getElementsByClassName) {
					childRetriverFn = 'getElementsByClassName';
					childRetriverString = classNameWithTag;
					noClassTesting = true;
				} else {
					childRetriverFn = 'getElementsByTagName';
					childRetriverString = 'span';
					noClassTesting = false;
				}

				return {
					isIE: /msie/i.test(userAgent) && !win.opera,
					hasSVG: Boolean(win.SVGAngle || doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),
					isHeadLess: new RegExp(' HtmlUnit').test(userAgent),
					isWebKit: new RegExp(' AppleWebKit/').test(userAgent),
					childRetriverFn: childRetriverFn,
					childRetriverString: childRetriverString,
					noClassTesting: noClassTesting
				};
			},

			/*
    * Create a html div element and attach it with a parent. All the subsequent operations are performed
    * by upding this dom tree only.
    *
    * @param {HTMLElement} - The html element where the newly created div is to be attached. If not passed,
    *                      the new div is appended on the body.
    */
			createContainer: function createContainer(containerParent) {
				var body, container;

				if (containerParent && (containerParent.offsetWidth || containerParent.offsetHeight)) {
					if (containerParent.appendChild) {
						containerParent.appendChild(container = doc.createElement(DIV));
						container.className = containerClass;
						container.setAttribute('aria-hidden', 'true');
						container.setAttribute('role', 'presentation');
						return container;
					}
				} else {
					body = doc.getElementsByTagName('body')[0];

					if (body && body.appendChild) {
						container = doc.createElement(DIV);
						container.className = containerClass;
						container.setAttribute('aria-hidden', 'true');
						container.setAttribute('role', 'presentation');
						containerInstanceCount += 1;
						body.appendChild(container);
						return container;
					}
				}
			},

			// Finds a approximate position where the text is to be broken
			getNearestBreakIndex: function getNearestBreakIndex(text, maxWidth, sl) {
				if (!text || !text.length) {
					return 0;
				}

				var difference,
				    getWidth = sl._getWidthFn(),
				    charLen = 0,
				    increment = 0,
				    oriWidth = getWidth(text),
				    avgWidth = oriWidth / text.length;

				difference = maxWidth;
				charLen = ceil(maxWidth / avgWidth);

				if (oriWidth < maxWidth) {
					return text.length - 1;
				}

				if (charLen > text.length) {
					difference = maxWidth - oriWidth;
					charLen = text.length;
				}

				while (difference > 0) {
					difference = maxWidth - getWidth(text.substr(0, charLen));
					increment = floor(difference / avgWidth);
					if (increment) {
						charLen += increment;
					} else {
						return charLen;
					}
				}

				while (difference < 0) {
					difference = maxWidth - getWidth(text.substr(0, charLen));
					increment = floor(difference / avgWidth);
					if (increment) {
						charLen += increment;
					} else {
						return charLen;
					}
				}
				return charLen;
			},

			/*
    * Determine lineheight of a text for a given style. It adds propery lineHeight to the style passed
    *
    * @param {Object} - The style based on which the text's metric needs to be calculated. The calculation happens
    *                  based on fontSize property, if its not present a default font size is assumed.
    *
    * @return {Object} - The style that was passed with lineHeight as a named propery set on the object.
    */
			setLineHeight: function setLineHeight(styleObj) {
				var fSize = styleObj.fontSize = styleObj.fontSize || '12px';
				styleObj.lineHeight = styleObj.lineHeight || styleObj['line-height'] || parseInt(fSize, 10) * 1.2 + 'px';
				return styleObj;
			}
		};

		return lib;
	}
};

exports['default'] = lib;
module.exports = exports['default'];

/***/ }),

/***/ "./packages/muze-utils/node_modules/hyperdis/dist/hyperdis.js":
/*!********************************************************************!*\
  !*** ./packages/muze-utils/node_modules/hyperdis/dist/hyperdis.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined}(window,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();var i=function(e,t){e.forEach(function(e){void 0!==e&&null!==e&&(t[e]=1)})},o=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._set={},i(t,this._set)}return n(e,[{key:"append",value:function(e){return i(e,this._set),this}},{key:"toArray",value:function(){return Object.keys(this._set)}}],[{key:"difference",value:function(t,r){var n=void 0,i=[],o=t._set,u=r._set;for(n in o)({}).hasOwnProperty.call(o,n)&&(n in u||i.push(n));return new e(i)}}]),e}(),u=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function s(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}var l=function(e){if("object"===(void 0===e?"undefined":a(e))){if(null===e)return!1;if("[object Object]"===Object.prototype.toString.call(e))return"Object"===(e.constructor.toString().match(/^function (.*)\(\)/m)||[])[1]}return!1},c="undefined"==typeof window?{}:window,f=c.requestAnimationFrame||c.webkitRequestAnimationFrame||c.mozRequestAnimationFrame||c.oRequestAnimationFrame||c.msRequestAnimationFrame||function(e){setTimeout(e,16)},h=function e(){return e.__lastTime===(new Date).getTime()?e.__lastTime.toString()+(e.__id++).toString():(e.__id=0,(e.__lastTime=(new Date).getTime()).toString()+(e.__id++).toString())},d=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];var n=[];return t.forEach(function(e){return n.push.apply(n,s(e))}),n},p=function(e){var t=[],r=null;return e=e&&"function"==typeof e&&e||function(){},function(n,i){[].push.apply(t,n),null===r&&(r=f(function(){var n=t.slice(0);t.length=0,r=null,function(e){return e.reduce(function(e,t){return t.__id in e.map?e:(e.map[t.__id]=1,e.unique.push(t),e)},{map:{},unique:[]}).unique}(n).forEach(function(e){return e()}),e(i)}))}},v=function(e){return function(){for(var t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];return r.map(function(t){var r=e[t];return{name:r.name,qualifiedName:r.qualifiedName,value:r.seed}})}},y=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return{dependencies:t.slice(0,t.length-1),fn:t[t.length-1]}},g=function(e){var t=[],r={};return e.forEach(function(e){return r[e.qualifiedName]=-1}),function e(n){n.forEach(function(n){var i,o=void 0,u=void 0,a=void 0;(i=n.qualifiedName)in r?-1!==(o=r[i])&&o!==t.length-1&&(u=t.slice(0,o),a=t.slice(o+1),t=u.concat(a),a.forEach(function(e,t){return r[e.qualifiedName]=t+u.length}),r[i]=t.push(n)-1):r[i]=t.push(n)-1,e(n.outgoingEdges)})}(e),t},m={accumulate:function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];var n={};return t.forEach(function(e){Object.assign(n,function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}({},e.name,e.value))}),n},identity:function(e){return e.value}};var _=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.fn=t,this.dep=[]}return u(e,[{key:"addDependencies",value:function(){var e;return(e=this.dep).push.apply(e,arguments),this}},{key:"getDependencies",value:function(){return this.dep}},{key:"get",value:function(){return this.fn}}]),e}(),b=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();function k(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}var w=function(){function e(t,r,n){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),n=n||{},this.name=t,this.qualifiedName=r,this.edges=[],this.outgoingEdges=[],this._seed=null,this.requireResolve=!0,this.retriever=n.retriever,this.history=[],this.resolver=null,this.electricEdges=[]}return b(e,[{key:"addDependencies",value:function(){for(var e,t=this,r=arguments.length,n=Array(r),i=0;i<r;i++)n[i]=arguments[i];return(e=this.edges).push.apply(e,n),n.forEach(function(e){return e.outgoingEdges.push(t)}),this}},{key:"addElectricNode",value:function(e){return this.electricEdges.push(e),this}},{key:"resolve",value:function(){return this.seed=this.resolver.apply(this,k(this.retrieveDetails())),this.history.push(this.seed),this.requireResolve=!1,this}},{key:"retrieveDetails",value:function(){return 0===this.edges.length?[{name:this.name,qualifiedName:this.qualifiedName,value:this.seed}]:this.retriever.apply(this,k(this.edges.map(function(e){return e.qualifiedName})))}},{key:"repeatHead",value:function(){var e=this.history,t=e[e.length-1];return 0===e.length?this:(e.push(t),this)}},{key:"flush",value:function(){var e=this.history,t=e[e.length-1];return e.length=0,e.push(t),this}},{key:"isRoot",value:function(){return null===this.name}},{key:"seed",get:function(){return this._seed},set:function(e){return this._seed=e,this.requireResolve=!0,this}}]),e}(),q=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();var E=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.edges=[],this.listeners={nextFrame:[],currentFrame:[]}}return q(e,[{key:"addEdges",value:function(){var e;return(e=this.edges).push.apply(e,arguments),this}},{key:"regListenerForCurrFrame",value:function(e){var t=this,r=this.listeners.currentFrame,n=r.push(function(e,t){var r=function(){t.apply(void 0,s(e.map(function(e){var t=e.history,r=t.length-1;return[t[r-1<0?0:r-1],t[r]]})))};return r.__id=h(),r}(this.edges,e))-1;return function(){t.listeners.currentFrame=r.filter(function(e,t){return t!==n})}}},{key:"regListenerForNextFrame",value:function(e){var t=this,r=this.listeners.nextFrame,n=r.push(function(e,t){var r=function(){t.apply(void 0,s(e.map(function(e){var t=e.history;return[t[0],t[t.length-1]]})))};return r.__id=h(),r}(this.edges,e))-1;return function(){t.listeners.nextFrame=r.filter(function(e,t){return t!==n})}}},{key:"hasNextFrameListener",value:function(){return!!this.listeners.nextFrame.length}}]),e}(),N=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();function F(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}var O=function(){function e(){var t=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.qualifiedNodeMap={},this.retriever=v(this.qualifiedNodeMap),this.root=new w(null,null,{retriever:this.retriever}),this.root.resolver=m.accumulate,this._wholeSet=null,this._propagate=!0,this.propagationOverride={currentFrameListeners:!1,nextFrameListeners:!1},this._schedule=p(function(e){var r=void 0;for(r in e.flushTarget){if(!{}.hasOwnProperty.call(t.qualifiedNodeMap,r))return;t.qualifiedNodeMap[r].flush()}})}return N(e,[{key:"createNodesFrom",value:function(e,t){var r=void 0,n=void 0,i=this.qualifiedNodeMap,u=this.root,a=this.retriever;return function e(t,n,o){var s=void 0,c=void 0,f=void 0,h=void 0;for(s in t)if({}.hasOwnProperty.call(t,s))if(h=new w(s,c=""+n+s,{retriever:a}),i[c]=h,void 0!==(f=o.perv)?f.addDependencies(h):u.addDependencies(h),l(r=t[s]))e(r,""+n+s+".",{perv:h}),h.resolver=m.accumulate;else if(r instanceof _){var d;h.resolver=r.get(),(d=h).addDependencies.apply(d,F(r.getDependencies().map(function(e){return i[e]})))}else h.resolver=m.identity,h.seed=r}(e,null===t?"":t+".",{perv:i[t]}),this._wholeSet=new o(Object.keys(this.qualifiedNodeMap)),(n=this.constructor.getResolvedList(u).concat(u).filter(function(e){return e.requireResolve})).forEach(function(e){return e.resolve()}),g(n).forEach(function(e){return e.resolve()}),this}},{key:"getNodeValue",value:function(e){if(e in this.qualifiedNodeMap)return this.qualifiedNodeMap[e].seed}},{key:"createElectricNodeOf",value:function(e,t){var r,n=this,i=e.map(function(e){return n.qualifiedNodeMap[e]}),o=(r=new E).addEdges.apply(r,F(i));return i.forEach(function(e){return e.addElectricNode(o)}),o["regListenerFor"+t.type](t.fn)}},{key:"update",value:function(){for(var e=void 0,t=void 0,r=arguments.length,n=Array(r),i=0;i<r;i++)n[i]=arguments[i];var u=[],a=n.map(function(e){return e[0].seed=e[1],e[0]});return a.forEach(function(e){return e.resolve()}),u.push.apply(u,F(d.apply(void 0,F(a.map(function(e){return e.electricEdges}))))),e=new o(a.map(function(e){return e.qualifiedName})),this._propagate?((t=g(a)).forEach(function(e){return e.resolve()}),e.append(t.map(function(e){return e.qualifiedName})),u.push.apply(u,F(d.apply(void 0,F(t.map(function(e){return e.electricEdges}))))),this.__execUniqueElectricEdges(Array.from(new Set(u)),e),this):(this.__execUniqueElectricEdges(u),this._propagate=!0,this)}},{key:"__execUniqueElectricEdges",value:function(e,t){var r=this,n=[],i=[];t&&o.difference(this._wholeSet,t).toArray().forEach(function(e){return r.qualifiedNodeMap[e].repeatHead()});return e.forEach(function(e){n.push.apply(n,F(e.listeners.currentFrame))}),e.forEach(function(e){i.push.apply(i,F(e.listeners.nextFrame))}),!this.propagationOverride.currentFrameListeners&&n.forEach(function(e){return e()}),!this.propagationOverride.nextFrameListeners&&this._schedule(i,{flushTarget:t}),this.resetPropagationOverride(),this}},{key:"resetNodeValue",value:function(){for(var e=this,t=arguments.length,r=Array(t),n=0;n<t;n++)r[n]=arguments[n];var i=r.map(function(t){return e.qualifiedNodeMap[t]}).map(function(e){return[e,e.seed]});return this.update.apply(this,F(i)),this}},{key:"stopPropagation",value:function(){return this._propagate=!1,this}},{key:"resetPropagationOverride",value:function(){return this.propagationOverride.currentFrameListeners=!1,this.propagationOverride.nextFrameListeners=!1,this}},{key:"setPropagationOverride",value:function(e){return this.propagationOverride[e+"Listeners"]=!0,this}},{key:"getNodeFromQualifiedName",value:function(e){return this.qualifiedNodeMap[e]}}],[{key:"getResolvedList",value:function(e){var t=[];return function e(t,r,n){var i=void 0;t.edges.forEach(function(t){e(t,r,n)}),t.isRoot()||(i=t.qualifiedName)in n||(r.push(t),n[i]=1)}(e,t,{}),t}}]),e}(),A=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();function P(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}var j=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._graph=new O,this._lockFlag=!1,this._reqQ=[]}return A(e,[{key:"append",value:function(){var e=void 0,t=void 0;return 1===arguments.length?(e=null,t=arguments.length<=0?void 0:arguments[0]):(e=arguments.length<=0?void 0:arguments[0],t=arguments.length<=1?void 0:arguments[1]),this._addPropInModel(e,t),this}},{key:"calculatedProp",value:function(){var e,t,r,n=void 0,i=void 0,o=void 0;return arguments.length>2?(i=arguments.length<=0?void 0:arguments[0],n=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]):(i=null,n=arguments.length<=0?void 0:arguments[0],o=arguments.length<=1?void 0:arguments[1]),t=o(y),(e=r=new _(t.fn)).addDependencies.apply(e,P(t.dependencies)),this._addPropInModel(i,function(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}({},n,r)),this}},{key:"_addPropInModel",value:function(e,t){return this._graph.createNodesFrom(t,e),this}},{key:"on",value:function(e,t,r){var n,i=e instanceof Array?e:[e],o=this._graph.createElectricNodeOf(i,{type:"CurrFrame",fn:t});r&&(n=this._graph.stopPropagation().setPropagationOverride("nextFrame")).resetNodeValue.apply(n,P(e));return o}},{key:"next",value:function(e,t,r){var n,i=e instanceof Array?e:[e],o=this._graph.createElectricNodeOf(i,{type:"NextFrame",fn:t});r&&(n=this._graph.stopPropagation().setPropagationOverride("currentFrame")).resetNodeValue.apply(n,P(e));return o}},{key:"lock",value:function(){return this._lockFlag=!0,this._reqQ.length=0,this}},{key:"unlock",value:function(){return this._lockFlag=!1,this.setProp.apply(this,P(this._reqQ)),this._reqQ.length=0,this}},{key:"prop",value:function(){var e,t=void 0,r=void 0;switch(e=arguments.length){case 1:t=arguments.length<=0?void 0:arguments[0];break;case 2:t=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1];break;default:return this}return 2===e?(this._lockFlag?this._reqQ.push([t,r]):this.setProp([t,r]),this):this._graph.getNodeValue(t)}},{key:"setProp",value:function(){for(var e,t=this,r=arguments.length,n=Array(r),i=0;i<r;i++)n[i]=arguments[i];return 0===n.length?this:((e=this._graph).update.apply(e,P(n.map(function(e){return[t._graph.getNodeFromQualifiedName(e[0]),e[1]]}))),this)}},{key:"graph",value:function(){return this._graph}},{key:"serialize",value:function(){return this._graph.root.seed}}],[{key:"create",value:function(t){return(new e)._addPropInModel(null,t)}}]),e}();t.default=j}])});
//# sourceMappingURL=hyperdis.js.map

/***/ }),

/***/ "./packages/muze-utils/src/DataSystem/dataSelect.js":
/*!**********************************************************!*\
  !*** ./packages/muze-utils/src/DataSystem/dataSelect.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dataSelect; });
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection */ "./packages/muze-utils/src/DataSystem/selection.js");

/**
 * This function applies a selection operation on a data array.
 *
 * @export
 * @param {Array} [data=[]] The data array to be observed.
 * @return {Selection} Instance of a selection.
 */
function dataSelect (idFn) {
    return new _selection__WEBPACK_IMPORTED_MODULE_0__["default"](idFn);
}



/***/ }),

/***/ "./packages/muze-utils/src/DataSystem/index.js":
/*!*****************************************************!*\
  !*** ./packages/muze-utils/src/DataSystem/index.js ***!
  \*****************************************************/
/*! exports provided: dataSelect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dataSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataSelect */ "./packages/muze-utils/src/DataSystem/dataSelect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dataSelect", function() { return _dataSelect__WEBPACK_IMPORTED_MODULE_0__["default"]; });






/***/ }),

/***/ "./packages/muze-utils/src/DataSystem/selection.js":
/*!*********************************************************!*\
  !*** ./packages/muze-utils/src/DataSystem/selection.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common-utils */ "./packages/muze-utils/src/common-utils.js");


const sortSelection = (dataObjects, updateData, sortFn) =>
    (a, b) => {
        const kA = a[0];
        const kB = b[0];
        return sortFn([a[0], dataObjects.get(kA), updateData.get(kA)], [kB, dataObjects.get(kB), updateData.get(kB)]);
    };

/**
 * This class represents a selection applied on a data array.
 *
 * @class Selection
 */
class Selection {
    /**
     * Creates an instance of Selection.
     * @param {Array<DataObject>} data Array of DataObjects.
     * @memberof Selection
     */
    constructor (idGetter) {
        this._dataObjects = new Map();
        this._updateData = new Map();
        this._enterData = new Map();
        this._exitData = new Map();
        this._idGetter = idGetter;
    }

    /**
     * This method is used to supply seed data to a selection.
     *
     * @param {Array} newData Seed data to create the enter selection.
     * @param {Functon | undefined } idGetter This function is used to uniqely identify a data entry.
     * @return {Selection} Modified selection.
     * @memberof Selection
     */
    data (newData) {
        const entryData = new Map();
        const exitdata = new Map();
        const tempMap = new Map();
        const duplicateData = new Map();
        const updatedData = this._updateData;
        const idGetter = this._idGetter;

        newData.forEach((...params) => {
            const key = idGetter ? idGetter(...params) : params[1];
            if (!tempMap.has(key)) {
                tempMap.set(key, params[0]);
            } else {
                duplicateData.push(key, params[0]);
            }
        });

        let val;
        // prepare enter data
        let entries = tempMap.entries();
        while (val = entries.next().value) {
            if (!updatedData.has(val[0])) {
                entryData.set(val[0], val[1]);
            } else {
                updatedData.set(val[0], val[1]);
            }
        }
        // prepare exit data
        entries = updatedData.entries();
        while (val = entries.next().value) {
            if (!tempMap.has(val[0])) {
                exitdata.set(val[0], val[1]);
            }
        }

        // put duplicate data to exit list
        entries = duplicateData.entries();
        while (val = entries.next().value) {
            exitdata.set(val[0], val[1]);
        }

        const newSelection = new Selection(this._idGetter);
        newSelection._updateData = updatedData;
        newSelection._dataObjects = this._dataObjects;
        newSelection._enterData = entryData;
        newSelection._exitData = exitdata;

        return newSelection;
    }

    /**
     * Applies the supplied callback to each data element
     * and returns a new selection.
     *
     * @param {Function} callback Callback to execute on each item.
     * @return {Selection} New selection with data created using callback.
     * @memberof Selection
     */
    append (callback) {
        let val;
        const dataObjects = new Map();
        const data = new Map();
        const mode = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(this._mode, 'update');
        const currentData = this[`_${mode}Data`];
        const entries = currentData.entries();

        while (val = entries.next().value) {
            dataObjects.set(val[0], callback(val[1]));
            data.set(val[0], val[1]);
        }

        const newSelection = new Selection(this._idGetter);
        newSelection._updateData = data;
        newSelection._dataObjects = dataObjects;

        return newSelection;
    }

     /**
     * This method returns an enter selection that
     * allows or update operations.
     *
     * @return {Selection} Instance of enter selection.
     * @memberof Selection
     */
    enter () {
        this._mode = 'enter';
        return this;
    }

    /**
     * Returns a selection with exit data.
     *
     * @return {Selection} Instance of selection.
     * @memberof Selection
     */
    exit () {
        this._mode = 'exit';
        return this;
    }

     /**
     * This method merges the data of one selection with another.
     *
     * @param {Selection} selection Instance of selection.
     * @return {Selection} Modified selection.
     * @memberof Selection
     */
    merge (target) {
        const mergedObjects = new Map();
        const mergedData = new Map();
        let val;
        let entries;

        // merge Object and data present in this selection
        entries = this._updateData.entries();
        while (val = entries.next().value) {
            if (!this._exitData.has(val[0])) {
                mergedData.set(val[0], val[1]);
                mergedObjects.set(val[0], this._dataObjects.get(val[0]));
            }
        }

        // merge object from target selection
        entries = target._updateData.entries();
        while (val = entries.next().value) {
            if (!(mergedData.has(val[0]) || target._exitData.has(val[0]))) {
                mergedData.set(val[0], val[1]);
                mergedObjects.set(val[0], target._dataObjects.get(val[0]));
            }
        }

        const newSelection = new Selection(this._idGetter);
        newSelection._updateData = mergedData;
        newSelection._dataObjects = mergedObjects;

        return newSelection;
    }

    each (fn) {
        let val;
        const entries = this._dataObjects.entries();

        while (val = entries.next().value) {
            fn(val[1], this._updateData.get(val[0]), val[0]);
        }
    }

    map (fn) {
        const newdata = new Map();
        let val;
        const entries = this._dataObjects.entries();

        while (val = entries.next().value) {
            newdata.set(val[0], fn(val[1], this._updateData.get(val[0]), val[0]));
        }
        const newSelection = new Selection(this._idGetter);
        newSelection._updateData = this._updateData;
        newSelection._dataObjects = newdata;

        return newSelection;
    }

    remove () {
        const mode = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(this._mode, 'update');
        const currentData = this[`_${mode}Data`];

        currentData.clear();

        return this;
    }

    sort (sortFn) {
        const updateData = this._updateData;
        const dataObjects = this._dataObjects;
        const sortSel = sortSelection(dataObjects, updateData, sortFn);

        this._updateData = new Map([...updateData.entries()].sort(sortSel));
        this._dataObjects = new Map([...dataObjects.entries()].sort(sortSel));
        return this;
    }

    /**
     *  Gets the object bound to a class
     *
     * @return {Object} current data set bound to the class
     * @memberof Selection
     */
    getObjects () {
        let val;
        const objects = [];
        const dataObjects = this._dataObjects;
        // select the data to create object
        const mode = Object(_common_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(this._mode, 'update');
        const currentData = this[`_${mode}Data`];
        const entries = currentData.entries();

        while (val = entries.next().value) {
            if (dataObjects.has(val[0])) {
                objects.push(dataObjects.get(val[0]));
            }
        }

        return objects;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Selection);


/***/ }),

/***/ "./packages/muze-utils/src/color-schemes.js":
/*!**************************************************!*\
  !*** ./packages/muze-utils/src/color-schemes.js ***!
  \**************************************************/
/*! exports provided: schemeDark2, schemePaired, schemeAccent, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, schemeBlues, schemeBrBG, schemePRGn, schemePiYG, interpolateBrBG, interpolatePRGn, interpolatePiYG, interpolatePuOr, interpolateRdBu, interpolateRdGy, interpolateRdYlBu, interpolateRdYlGn, interpolateSpectral, interpolateBlues, interpolateGreens, interpolateGreys, interpolateOranges, interpolatePurples, interpolateReds, interpolateViridis, interpolateInferno, interpolateMagma, interpolatePlasma, interpolateWarm, interpolateCool, interpolateCubehelixDefault, interpolateBuGn, interpolateBuPu, interpolateGnBu, interpolateOrRd, interpolatePuBuGn, interpolatePuBu, interpolatePuRd, interpolateRdPu, interpolateYlGnBu, interpolateYlGn, interpolateYlOrBr, interpolateYlOrRd, interpolateRainbow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-scale-chromatic */ "./packages/muze-utils/node_modules/d3-scale-chromatic/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeDark2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemePaired"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeAccent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemePastel1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemePastel2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeSet1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeSet2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeSet3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemeBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["schemePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePuOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRdBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRdGy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRdYlBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRdYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateSpectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateGreens"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateGreys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateOranges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePurples"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateReds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateViridis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateInferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateMagma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePlasma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateWarm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateCool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateCubehelixDefault"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateBuPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePuBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePuBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolatePuRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRdPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateYlGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateYlOrBr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateYlOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_0__["interpolateRainbow"]; });





/***/ }),

/***/ "./packages/muze-utils/src/common-utils.js":
/*!*************************************************!*\
  !*** ./packages/muze-utils/src/common-utils.js ***!
  \*************************************************/
/*! exports provided: mix, partition, getValueParser, require, intersect, Scales, Symbols, pathInterpolators, stack, nestCollection, getSymbol, transformColors, detectColor, hexToHsv, hslToRgb, rgbToHsv, hsvToRgb, concatModels, toArray, angleToRadian, escapeHTML, generateGetterSetters, getArraySum, interpolator, piecewiseInterpolator, getDataModelFromIdentifiers, getDataModelFromRange, colorInterpolator, numberInterpolator, ERROR_MSG, reqAnimFrame, nextAnimFrame, transposeArray, cancelAnimFrame, getMax, getMin, getDomainFromData, getUniqueId, mergeRecursive, unionDomain, symbolFns, easeFns, clone, isEqual, interpolateArray, getMinPoint, defaultValue, getMaxPoint, getClosestIndexOf, Voronoi, checkExistence, sanitizeIP, getMinDiff, capitalizeFirst, getWindow, getQualifiedClassName, getDependencyOrder, objectIterator, intSanitizer, enableChainedTransaction, isHTMLElem, isSimpleObject, nextFrame, registerListeners, replaceCSSPrefix, getObjProp, extendsClass, assembleModelFromIdentifiers, isValidValue, hslInterpolator, getSmallestDiff, getNearestValue, retrieveNearestGroupByReducers, nearestSortingDetails, createSelection, formatTemporal, temporalFields, retrieveFieldDisplayName, sanitizeDomainWhenEqual, sortCategoricalField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return partition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueParser", function() { return getValueParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "require", function() { return require; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scales", function() { return Scales; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Symbols", function() { return Symbols; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathInterpolators", function() { return pathInterpolators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nestCollection", function() { return nestCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSymbol", function() { return getSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformColors", function() { return transformColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectColor", function() { return detectColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexToHsv", function() { return hexToHsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslToRgb", function() { return hslToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHsv", function() { return rgbToHsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsvToRgb", function() { return hsvToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatModels", function() { return concatModels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angleToRadian", function() { return angleToRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeHTML", function() { return escapeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateGetterSetters", function() { return generateGetterSetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArraySum", function() { return getArraySum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolator", function() { return interpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "piecewiseInterpolator", function() { return piecewiseInterpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataModelFromIdentifiers", function() { return getDataModelFromIdentifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataModelFromRange", function() { return getDataModelFromRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorInterpolator", function() { return colorInterpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberInterpolator", function() { return numberInterpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_MSG", function() { return ERROR_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reqAnimFrame", function() { return reqAnimFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextAnimFrame", function() { return nextAnimFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transposeArray", function() { return transposeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelAnimFrame", function() { return cancelAnimFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMax", function() { return getMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMin", function() { return getMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDomainFromData", function() { return getDomainFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniqueId", function() { return getUniqueId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeRecursive", function() { return mergeRecursive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unionDomain", function() { return unionDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbolFns", function() { return symbolFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeFns", function() { return easeFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return isEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return interpolateArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMinPoint", function() { return getMinPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultValue", function() { return defaultValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxPoint", function() { return getMaxPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClosestIndexOf", function() { return getClosestIndexOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Voronoi", function() { return Voronoi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkExistence", function() { return checkExistence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeIP", function() { return sanitizeIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMinDiff", function() { return getMinDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalizeFirst", function() { return capitalizeFirst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWindow", function() { return getWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQualifiedClassName", function() { return getQualifiedClassName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDependencyOrder", function() { return getDependencyOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectIterator", function() { return objectIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intSanitizer", function() { return intSanitizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableChainedTransaction", function() { return enableChainedTransaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHTMLElem", function() { return isHTMLElem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSimpleObject", function() { return isSimpleObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return nextFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerListeners", function() { return registerListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceCSSPrefix", function() { return replaceCSSPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjProp", function() { return getObjProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendsClass", function() { return extendsClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assembleModelFromIdentifiers", function() { return assembleModelFromIdentifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidValue", function() { return isValidValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslInterpolator", function() { return hslInterpolator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSmallestDiff", function() { return getSmallestDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNearestValue", function() { return getNearestValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveNearestGroupByReducers", function() { return retrieveNearestGroupByReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestSortingDetails", function() { return nearestSortingDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelection", function() { return createSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTemporal", function() { return formatTemporal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "temporalFields", function() { return temporalFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveFieldDisplayName", function() { return retrieveFieldDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeDomainWhenEqual", function() { return sanitizeDomainWhenEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortCategoricalField", function() { return sortCategoricalField; });
/* harmony import */ var datamodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datamodel */ "../datamodel/dist/datamodel.js");
/* harmony import */ var datamodel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datamodel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-axis */ "./packages/muze-utils/node_modules/d3-axis/index.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./packages/muze-utils/node_modules/d3-shape/src/index.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-scale */ "./packages/muze-utils/node_modules/d3-scale/index.js");
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-collection */ "./packages/muze-utils/node_modules/d3-collection/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./packages/muze-utils/node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-ease */ "./packages/muze-utils/node_modules/d3-ease/src/index.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-color */ "./packages/muze-utils/node_modules/d3-color/src/index.js");
/* harmony import */ var d3_voronoi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-voronoi */ "./packages/muze-utils/node_modules/d3-voronoi/src/index.js");
/* harmony import */ var _DataSystem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DataSystem */ "./packages/muze-utils/src/DataSystem/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./enums */ "./packages/muze-utils/src/enums/index.js");
/* harmony import */ var _enums_stack_config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./enums/stack-config */ "./packages/muze-utils/src/enums/stack-config.js");
/* global window, requestAnimationFrame, cancelAnimationFrame */













const { CATEGORICAL, TEMPORAL } = datamodel__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"];
const { STRING, FUNCTION } = _enums__WEBPACK_IMPORTED_MODULE_10__["DATA_TYPE"];
const { InvalidAwareTypes } = datamodel__WEBPACK_IMPORTED_MODULE_0___default.a;
const HTMLElement = window.HTMLElement;

const isSimpleObject = (obj) => {
    let token;
    if (typeof obj === 'object') {
        if (obj === null) { return false; }
        token = Object.prototype.toString.call(obj);
        if (token === '[object Object]') {
            return (obj.constructor.toString().match(/^function (.*)\(\)/m) || [])[1] === 'Object';
        }
    }
    return false;
};

/**
 * Returns unique id
 * @return {string} Unique id string
 */
const
    getUniqueId = () => `id-${new Date().getTime()}${Math.round(Math.random() * 10000)}`;

/**
 * Deep copies an object and returns a new object.
 * @param {Object} o Object to clone
 * @return {Object} New Object.
 */
const clone = (o) => {
    const output = {};
    let v;
    for (const key in o) {
        if ({}.hasOwnProperty.call(o, key)) {
            v = o[key];
            output[key] = isSimpleObject(v) ? clone(v) : v;
        }
    }
    return output;
};

/**
* Checks the existence of keys in an object
* @param {Array} keys Set of keys which are to be checked
* @param {Object} obj whose keys are checked from the set of keys provided
* @return {Object} Error if the keys are absent, or the object itself
*/
const checkExistence = (keys, obj) => {
    const nonExistentKeys = [];
    keys.forEach((key) => {
        if (key in obj) {
            return;
        }
        nonExistentKeys.push(key);
    });
    return nonExistentKeys;
};

const sanitizeIP = {
    typeObj: (keys, obj) => {
        if (typeof obj !== 'object') {
            return Error('Argument type object expected');
        }

        const nonExistentKeys = checkExistence(keys, obj);
        if (nonExistentKeys.length) {
            return Error(`Missing keys from parameter ${nonExistentKeys.join(', ')}`);
        }
        return obj;
    },

    /* istanbul ignore next */ htmlElem: (elem) => {
        if (!(elem instanceof HTMLElement)) {
            return Error('HTMLElement required');
        }
        return elem;
    }
};

/**
 * Gets the maximum value from an array of objects for a given property name
 * @param  {Array.<Object>} data   Array of objects
 * @param  {string} field Field name
 * @return {number} Maximum value
 */
const getMax = (data, field) => Math.max(...data.map(d => d[field]));

/**
 * Gets the minimum value from an array of objects for a given property name
 * @param  {Array.<Object>} data   Array of objects
 * @param  {string} field Field name
 * @return {number} Minimum value
 */
const getMin = (data, field) => Math.min(...data.map(d => d[field]));

/**
 * Gets the domain from the data based on the field name and type of field
 * @param  {Array.<Object> | Array.<Array>} data       Data Array
 * @param  {Array.<string>} fields    Array of fields from where the domain will be calculated
 * @param {string} fieldType Type of field - nominal, quantitiative, temporal.
 * @return {Array} Usually contains a min and max value if field is quantitative or
 * an array of values if field type is nominal or ordinal
 */
const getDomainFromData = (data, fields, fieldType) => {
    let domain;
    const domArr = [];
    data = data[0] instanceof Array ? data : [data];
    switch (fieldType) {
    case CATEGORICAL:
        domain = [].concat(...data.map(arr => arr.map(d => d[fields[0]]).filter(d => d !== undefined)));
        break;
    default:
        for (let i = 0, len = data.length; i < len; i++) {
            const arr = data[i];
            const [field0, field1] = fields;
            const arr0 = arr.filter(d => !isNaN(d[field0]));
            const arr1 = arr.filter(d => !isNaN(d[field1]));
            if (arr0.length || arr1.length) {
                const firstMin = getMin(arr0, field0);
                const secondMin = getMin(arr1, field1);
                const firstMax = getMax(arr0, field0);
                const secondMax = getMax(arr1, field1);
                domArr.push([Math.min(firstMin, secondMin), Math.max(firstMax, secondMax)]);
            }
        }
        domain = domArr.length ? [Math.min(...domArr.map(d => d[0])), Math.max(...domArr.map(d => d[1]))] : [];
        break;
    }
    return domain;
};

const sanitizeDomainWhenEqual = (domain) => {
    if (domain[0] === domain[1]) {
        domain[0] = domain[0] > 0 ? 0 : domain[0];
        domain[1] = domain[1] > 0 ? domain[1] : 0;
    }
    return domain;
};

/**
 * Union Domain values
 * @param {Array.<Array>} domains Array of domain values
 * @param {string} fieldType type of field - dimension,measure or datetime.
 * @return {Array} Unioned domain of all domain values.
 */
const unionDomain = (domains, fieldType) => {
    let domain = [];
    domains = domains.filter(dom => dom && dom.length);
    if (domains.length) {
        if (fieldType === CATEGORICAL) {
            domain = [].concat(...domains);
        } else {
            domain = [Math.min(...domains.map(d => d[0])), Math.max(...domains.map(d => d[1]))];
        }
    }

    return domain;
};

const symbolFns = {
    circle: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolCircle"],
    cross: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolCross"],
    diamond: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolDiamond"],
    square: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolSquare"],
    star: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolStar"],
    wye: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolWye"],
    triangle: d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbolTriangle"]
};

const easeFns = {
    cubic: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeCubic"],
    bounce: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeBounce"],
    linear: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeLinear"],
    elastic: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeElastic"],
    back: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeBack"],
    poly: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easePoly"],
    circle: d3_ease__WEBPACK_IMPORTED_MODULE_6__["easeCircle"]
};

/**
 * Returns the maximum or minimum points of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @param {string} minOrMax minimum or maximum.
 * @return {Object} Minimum or maximum point.
 */
const getExtremePoint = (points, compareValue, minOrMax) => {
    let extremePoint;
    let point;
    const len = points.length;
    let minOrMaxVal = minOrMax === 'max' ? -Infinity : Infinity;
    let val;

    for (let i = 0; i < len; i++) {
        point = points[i];
        val = point[compareValue];
        if (minOrMax === 'min' ? val < minOrMaxVal : val > minOrMaxVal) {
            minOrMaxVal = val;
            extremePoint = point;
        }
    }

    return extremePoint;
};

/**
 * Returns the minimum point of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @return {Object} Minimum point.
 */
const getMinPoint = (points, compareValue) => getExtremePoint(points, compareValue, 'min');

/**
 * Returns the maximum point of a compare value from an array of objects.
 * @param {Array} points Array of objects
 * @param {string} compareValue Key in the object on which the comparing will be done.
 * @return {Object} Maximum point.
 */
const getMaxPoint = (points, compareValue) => getExtremePoint(points, compareValue, 'max');

/**
 * Gets the index of the closest value of the given value from the array.
 * @param {Array} arr Array of values
 * @param {number} value Value from which the nearest value will be calculated.
 * @param {string} side side property.
 * @return {number} index of the closest value
 */
/* istanbul ignore next */const getClosestIndexOf = (arr, value, side) => {
    let low = 0;
    const arrLen = arr.length;
    let high = arrLen - 1;

    let mid;
    let d1;
    let d2;

    while (low < high) {
        mid = Math.floor((low + high) / 2);
        d1 = Math.abs(arr[mid] - value);
        d2 = Math.abs(arr[mid + 1] - value);

        if (d2 <= d1) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }

    if (!side) {
        return high;
    }

    const highVal = arr[high];
    if (highVal === value) {
        return high;
    } else if (highVal > value) {
        if (high === 0) { return high; }
        return side === 'left' ? high - 1 : high;
    }
    if (high === arr.length - 1) { return high; }
    return side === 'left' ? high : high + 1;
};

const getNearestValue = (data, key) => {
    const filterData = data.filter(d => typeof d === 'number');
    return filterData[getClosestIndexOf(filterData, key)];
};

/**
 * Returns the browser window object
 * @return {Window} Window object
*/
const getWindow = () => window;

/**
 * Returns the browser window object
 * @return {Window} Window object
*/
const reqAnimFrame = (() => requestAnimationFrame)();

const cancelAnimFrame = (() => cancelAnimationFrame)();

/**
 * Capitalizes the first letter of the word
 * @param {string} text word
 * @return {string} Capitalized word
 */
const capitalizeFirst = (text) => {
    text = text.toLowerCase();

    return text.replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1));
};

/**
 *
 *
 * @param {*} arr
 */
const unique = arr => ([...new Set(arr)]);

/**
 * Gets the minimum difference between two consecutive numbers  in an array.
 * @param {Array} arr Array of numbers
 * @param {number} index index of the value
 * @return {number} minimum difference between values
 */
/* istanbul ignore next */ const getMinDiff = (arr, index) => {
    let diff;
    let uniqueVals;
    if (index !== undefined) {
        uniqueVals = unique(arr.map(d => d[index]));
    } else {
        uniqueVals = unique(arr);
    }
    if (uniqueVals.length > 1) {
        diff = Math.abs(uniqueVals[1] - uniqueVals[0]);
        for (let i = 2, len = uniqueVals.length; i < len; i++) {
            diff = Math.min(diff, Math.abs(uniqueVals[i] - uniqueVals[i - 1]));
        }
    } else {
        diff = uniqueVals[0];
    }

    return diff;
};

/**
 * Returns the class name appended with a given id.
 * @param {string} cls class name
 * @param {string} id unique identifier
 * @param {string} prefix string needed to add before the classname
 * @return {string} qualified class name
 */
/* istanbul ignore next */const getQualifiedClassName = (cls, id, prefix) => {
    cls = cls.replace(/^\.*/, '');
    return [`${prefix}-${cls}`, `${prefix}-${cls}-${id}`];
};

/**
 * This method is used to set the default value for variables
 * without sullying the code with conditional statements.
 *
 * @export
 * @param {any} param The parameter to test.
 * @param {any} value The default value to assign.
 * @return {any} The value.
 */
/* istanbul ignore next */ const defaultValue = (param, value) => {
    if (typeof param === 'undefined' || (typeof param === 'object' && !param)) {
        return value;
    }
    return param;
};

/**
 * DESCRIPTION TODO
 *
 * @export
 * @param {Object} graph graph whose dependency order has to be generated
 * @return {Object}
 */
const getDependencyOrder = (graph) => {
    const dependencyOrder = [];
    const visited = {};
    const keys = Object.keys(graph);
    /**
     * DESCRIPTION TODO
     *
     * @export
     * @param {Object} name
     * @return {Object}
     */
    const visit = (name) => {
        if (dependencyOrder.length === keys.length) {
            return true;
        }
        visited[name] = true;
        const edges = graph[name];
        for (let e = 0; e < edges.length; e++) {
            const dep = edges[e];
            if (!visited[dep]) {
                visit(dep);
            }
        }

        dependencyOrder.push(name);
        return false;
    };

    for (let i = 0; i < keys.length; i++) {
        if (visit(keys[i], i)) break;
    }

    return dependencyOrder;
};

/**
 * Iterates over the properties of an object and applies the function
 *
 * @param {any} obj object to be iterated upon
 * @param {any} fn  function to be applied on it
 */
const objectIterator = (obj, fn) => {
    for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            fn(key, obj);
        }
    }
};

/**
 * This class creates a d3 voronoi for retrieving the nearest neighbour of any point from a set of two
 * dimensional points
 * @class Voronoi
 */
/* istanbul ignore next */ class Voronoi {
    /**
     * Initialize the voronoi with the data given.
     * @param {Array.<Object>} data Array of points.
     */
    constructor (data = []) {
        this._voronoi = Object(d3_voronoi__WEBPACK_IMPORTED_MODULE_8__["voronoi"])().x(d => d.x).y(d => d.y);
        this.data(data);
    }

    /**
     * Sets the data to voronoi
     * @param {Array.<Object>} data Array of objects.
     * @return {Voronoi} Instance of voronoi.
     */
    data (data) {
        if (data) {
            this._voronoiFn = this._voronoi(data);
        }
        return this;
    }

    /**
     * Finds the closest point to the x and y position given.
     * @param {number} x x value
     * @param {number} y y value
     * @param {number} radius search radius.
     * @return {Object} Details of the nearest point.
     */
    find (x, y, radius) {
        return this._voronoiFn.find(x, y, radius);
    }
}

const getObjProp = (obj, ...fields) => {
    if (obj === undefined || obj === null) {
        return obj;
    }
    let retObj = obj;
    for (let i = 0, len = fields.length; i < len; i++) {
        retObj = retObj[fields[i]];
        if (retObj === undefined || retObj === null) {
            break;
        }
    }
    return retObj;
};

/**
 * Sanitize an input number / string mixed number. Currently dot in the no is not supported.
 *
 * @param {number | string} val pure number or string mixed number
 * @return {number | null}  Number if it can be extracted. Otherwise null
 */
const intSanitizer = (val) => {
    const arr = val.toString().match(/(\d+)(px)*/g);
    if (!arr) {
        // If only characters are passed
        return null;
    }

    return parseInt(arr[0], 10);
};

const generateGetterSetters = (context, props) => {
    Object.entries(props).forEach((propInfo) => {
        const prop = propInfo[0];
        const { sanitization, preset, onset, typeChecker, defaultValue: defVal } = propInfo[1];
        const prototype = context.constructor.prototype;
        if (!(Object.hasOwnProperty.call(prototype, prop))) {
            if (defVal) {
                context[`_${prop}`] = defVal;
            }
            context[prop] = (...params) => {
                if (params.length) {
                    let value = params[0];
                    if (sanitization) {
                        value = sanitization(context, params[0], context[`_${prop}`]);
                    }
                    if (preset) {
                        preset(context, value);
                    }
                    if (typeChecker && !typeChecker(value)) {
                        return context[`_${prop}`];
                    }
                    context[`_${prop}`] = value;
                    if (onset) {
                        onset(context, value);
                    }
                    return context;
                } return context[`_${prop}`];
            };
        }
    });
};

/**
 *
 *
 * @param {*} arr
 * @param {*} prop
 */
const getArraySum = (arr, prop) => arr.reduce((total, elem) => {
    total += prop ? elem[prop] : elem;
    return total;
}, 0);

/**
 *
 *
 * @param {*} arr1
 * @param {*} arr2
 *
 */
const arraysEqual = (arr1, arr2) => {
    if (arr1.length !== arr2.length) { return false; }
    for (let i = arr1.length; i >= 0; i--) {
        if (arr1[i] !== arr2[i]) { return false; }
    }

    return true;
};

/* eslint valid-typeof:0 */
/**
 * Returns a validation function which can be used to validate variables against a type and value
 *
 * @param {any} type type of value that the object should have
 * @return {Object} validation function
 */
const isEqual = type => (oldVal, newVal) => {
    if (type === 'Array') {
        if (!oldVal) {
            return false;
        }
        return arraysEqual(oldVal, newVal);
    } else if (type === 'Object') {
        return Object.is(oldVal, newVal);
    } return oldVal === newVal;
};

/**
 * Description @todo
 *
 * @param {any} transactionModel @todo
 * @param {any} transactionEndpoint @todo
 * @param {any} transactionItems @todo
 * @return {any} @todo
 */
const enableChainedTransaction = (transactionModel, transactionEndpoint, transactionItems) =>
    transactionItems.forEach(item => transactionModel
        .registerImmediateListener(item, ([, newVal]) => transactionEndpoint[item](newVal)));

/**
 * Chceks if the element is istanceof HTMLElement
 *
 * @param {Object} elem any JS Object
 */
const isHTMLElem = elem => elem instanceof HTMLElement;

const ERROR_MSG = {
    INTERFACE_IMPL: 'Method not implemented'
};

/**
 * Merges the sink object in the source by recursively iterating through the object properties
 * @param {Object} source Source Object
 * @param {Object} sink Sink Object
 * @return {Object} Merged object
 */
const mergeRecursive = (source, sink) => {
    for (const prop in sink) {
        if (isSimpleObject(source[prop]) && isSimpleObject(sink[prop])) {
            mergeRecursive(source[prop], sink[prop]);
        } else if (sink[prop] instanceof Object && sink[prop].constructor === Object) {
            source[prop] = {};
            mergeRecursive(source[prop], sink[prop]);
        } else {
            source[prop] = sink[prop];
        }
    }
    return source;
};

/**
 * Creates a selection set from a data set with corresponding attributes
 *
 * @export
 * @param {Selection} sel contains previous selection
 * @param {Object} appendObj Object to be appended
 * @param {Array} data Data based on which the selection is entered/updated/removed
 * @param {Object} [attrs={}] Attributes to be set on the data
 * @return {Selection} Merged selection
 */
const createSelection = (sel, appendObj, data, idFn) => {
    let selection = sel || Object(_DataSystem__WEBPACK_IMPORTED_MODULE_9__["dataSelect"])(idFn);

    selection = selection.data(data);

    const enter = selection.enter().append(appendObj);
    const mergedSelection = enter.merge(selection);

    const exitSelection = selection.exit();
    exitSelection.getObjects().forEach(inst => inst.remove());
    exitSelection.remove();
    return mergedSelection;
};

const interpolateArray = (data, fitCount) => {
    const linearInterpolate = function (before, after, atPoint) {
        return before + (after - before) * atPoint;
    };
    const newData = [];
    const springFactor = ((data.length - 1) / (fitCount - 1));
    newData[0] = data[0]; // for new allocation
    for (let i = 1; i < fitCount - 1; i++) {
        const tmp = i * springFactor;
        const before = (Math.floor(tmp)).toFixed();
        const after = (Math.ceil(tmp)).toFixed();
        const atPoint = tmp - before;
        newData[i] = linearInterpolate(data[before], data[after], atPoint);
    }
    newData[fitCount - 1] = data[data.length - 1]; // for new allocation
    return newData;
};

/**
 *
 *
 * @param {*} fn
 */
const nextFrame = (fn) => {
    setTimeout(() => {
        fn();
    }, 0);
};

/**
 *
 *
 * @param {*} angle
 */
const angleToRadian = angle => angle * Math.PI / 180;

/**
 *
 *
 * @param {*} newName
 * @param {*} oldName
 */
const replaceCSSPrefix = () => {
    // @todo
};

/**
 * Gets the  interpolator function from d3 color
 *
 */
const interpolator = () => d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["interpolate"];

/**
 * Gets the number interpolator from d3 color
 *
 */
const numberInterpolator = () => d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["interpolateNumber"];

/**
 * Gets the rgb interpolator from d3 color
 *
 */
const colorInterpolator = () => d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["interpolateRgb"];

/**
 * Gets the hsl interpolator from d3 color
 *
 */
const hslInterpolator = () => d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["interpolateHslLong"];

const transformColors = () => ({
    color: d3_color__WEBPACK_IMPORTED_MODULE_7__["color"],
    rgb: d3_color__WEBPACK_IMPORTED_MODULE_7__["rgb"],
    hsl: d3_color__WEBPACK_IMPORTED_MODULE_7__["hsl"]
});

/**
 * Gets the piecewise interpolator from d3 color
 *
 */
const piecewiseInterpolator = () => d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["piecewise"];

function hue2rgb (p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}

  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  l       The lightness
   * @return  Array           The RGB representation
   */
const hslToRgb = (h, s, l, a = 1) => {
    let r;
    let g;
    let b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255, a];
};

  /**
   * Converts an RGB color value to HSV. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h, s, and v in the set [0, 1].
   *
   * @param   Number  r       The red color value
   * @param   Number  g       The green color value
   * @param   Number  b       The blue color value
   * @return  Array           The HSV representation
   */
const rgbToHsv = (r, g, b, a = 1) => {
    r = +r; g = +g; b = +b; a = +a;
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h;
    let s;
    const l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        default: break;
        }
        h /= 6;
    }
    return [h, s, l, a];
};

  /**
   * Converts an HSV color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  v       The value
   * @return  Array           The RGB representation
   */
const hsvToRgb = (h, s, v, a = 1) => {
    let r;
    let g;
    let b;

    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: break;
    }

    return [r * 255, g * 255, b * 255, a];
};

const hexToHsv = (hex) => {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? rgbToHsv(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : '';
};

const detectColor = (col) => {
    const matchRgb = /rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)/;
    const matchHsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g;

    // Source :  https://gist.github.com/sethlopezme/d072b945969a3cc2cc11
     // eslint-disable-next-line
    const matchRgba = /rgba?\(((25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,\s*?){2}(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,?\s*([01]\.?\d*?)?\)/;
     // eslint-disable-next-line
    const matchHsla = /^hsla\(([\d.]+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/;
    const matchHex = /^#([0-9a-f]{3}){1,2}$/i;

    if (matchRgb.test(col) || matchRgba.test(col)) {
        return 'rgb';
    } else if (matchHsl.test(col) || matchHsla.test(col)) {
        return 'hsl';
    } else if (matchHex.test(col)) {
        return 'hex';
    } return col;
};

const assembleModelFromIdentifiers = (model, identifiers) => {
    let schema = [];
    let data;
    const fieldMap = model.getFieldsConfig();
    if (identifiers.length) {
        const fields = identifiers[0];
        const len = fields.length;
        for (let i = 0; i < len; i++) {
            const field = fields[i];
            const fieldObj = fieldMap[field] && Object.assign({}, fieldMap[field].def);
            if (fieldObj) {
                schema.push(Object.assign(fieldObj));
            }
        }

        data = [];
        const header = identifiers[0];
        for (let i = 1; i < identifiers.length; i += 1) {
            const vals = identifiers[i];
            const temp = {};
            vals.forEach((fieldVal, cIdx) => {
                temp[header[cIdx]] = fieldVal;
            });
            data.push(temp);
        }
    } else {
        data = [];
        schema = [];
    }

    return new model.constructor(data, schema);
};

/**
 *
 *
 * @param {*} dataModel
 * @param {*} criteria
 *
 */
const getDataModelFromRange = (dataModel, criteria, mode) => {
    if (criteria === null) {
        return null;
    }
    const selFields = Object.keys(criteria);
    const selFn = fields => selFields.every((field) => {
        const val = fields[field].internalValue;
        const range = criteria[field][0] instanceof Array ? criteria[field][0] : criteria[field];
        if (typeof range[0] === STRING) {
            return range.find(d => d === val) !== undefined;
        }
        return range ? val >= range[0] && val <= range[1] : true;
    });

    return dataModel.select(selFn, {
        saveChild: false,
        mode
    });
};

/**
 *
 *
 * @param {*} dataModel
 * @param {*} identifiers
 *
 */
const getDataModelFromIdentifiers = (dataModel, identifiers, mode) => {
    let filteredDataModel;
    if (identifiers instanceof Array) {
        const fieldsConfig = dataModel.getFieldsConfig();

        const dataArr = identifiers.slice(1, identifiers.length);
        if (identifiers instanceof Function) {
            filteredDataModel = identifiers(dataModel, {}, false);
        } else if (identifiers instanceof Array && identifiers[0].length) {
            const filteredSchema = identifiers[0].filter(d => d in fieldsConfig);
            filteredDataModel = dataModel.select((fields) => {
                let include = true;
                filteredSchema.forEach((propField, idx) => {
                    const value = fields[propField].internalValue;
                    const index = dataArr.findIndex(d => d[idx] === value);
                    include = include && index !== -1;
                });
                return include;
            }, {
                saveChild: false,
                mode
            });
        } else {
            filteredDataModel = dataModel.select(() => false, {
                saveChild: false,
                mode
            });
        }
    } else {
        filteredDataModel = getDataModelFromRange(dataModel, identifiers, mode);
    }
    return filteredDataModel;
};

/**
 *
 *
 * @param {*} context
 * @param {*} listenerMap
 */
const registerListeners = (context, listenerMap, ...params) => {
    const propListenerMap = listenerMap(context, ...params);
    for (const key in propListenerMap) {
        if ({}.hasOwnProperty.call(propListenerMap, key)) {
            const { namespace } = params[1];
            let ns = null;
            if (namespace) {
                ns = namespace;
            }
            const mapObj = propListenerMap[key];
            const propType = mapObj.type;
            const props = mapObj.props;
            const listenerFn = mapObj.listener;
            context.store()[propType](props, listenerFn, false, {
                namespace: ns
            });
        }
    }
};

const isValidValue = value => !isNaN(value) && value !== -Infinity && value !== Infinity;
/**
 *
 *
 * @param {*} str
 *
 */
const escapeHTML = (str) => {
    const htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;'
    };
    const htmlEscaper = /[&<>"'/]/g;
    return (`${str}`).replace(htmlEscaper, match => htmlEscapes[match]);
};

/**
 *
 *
 * @param {*} arr
 */
const transposeArray = arr => arr[0].map((col, i) => arr.map(row => row[i]));
const toArray = arr => (arr instanceof Array ? arr : [arr]);
const extendsClass = (cls, extendsFrom, found) => {
    if (!cls) {
        return false;
    }
    const prototype = cls.prototype;
    if (prototype instanceof extendsFrom) {
        found = true;
    } else {
        found = extendsClass(prototype, extendsFrom, found);
    }
    return found;
};

/**
 *
 * @param {*} dm1
 * @param {*} dm2
 */
const concatModels = (dm1, dm2) => {
    const dataObj1 = dm1.getData();
    const dataObj2 = dm2.getData();
    const data1 = dataObj1.data;
    const data2 = dataObj2.data;
    const schema1 = dataObj1.schema;
    const schema2 = dataObj2.schema;
    const tuples1 = {};
    const tuples2 = {};
    const commonTuples = {};
    for (let i = 0; i < data1.length; i++) {
        for (let ii = 0; ii < data2.length; ii++) {
            const row1 = data1[i];
            const row2 = data2[ii];
            const dim1Values = row1.filter((d, idx) => schema1[idx].type === datamodel__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);
            const dim2Values = row2.filter((d, idx) => schema2[idx].type === datamodel__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);
            const allDimSame = dim1Values.every(value => dim2Values.indexOf(value) !== -1);
            if (allDimSame) {
                const key = dim1Values.join();
                !commonTuples[key] && (commonTuples[key] = {});
                row1.forEach((value, idx) => {
                    commonTuples[key][schema1[idx].name] = value;
                });
                row2.forEach((value, idx) => {
                    commonTuples[key][schema2[idx].name] = value;
                });
            } else {
                const dm1Key = dim1Values.join();
                const dm2Key = dim2Values.join();
                if (!commonTuples[dm1Key] && !commonTuples[dm2Key]) {
                    !tuples1[dm1Key] && (tuples1[dm1Key] = {});
                    !tuples2[dm2Key] && (tuples2[dm2Key] = {});
                    row1.forEach((value, idx) => {
                        tuples1[dm1Key][schema1[idx].name] = value;
                    });
                    row2.forEach((value, idx) => {
                        tuples2[dm2Key][schema2[idx].name] = value;
                    });
                }
            }
        }
    }

    const commonSchema = [...schema1, ...schema2.filter(s2 => schema1.findIndex(s1 => s1.name === s2.name) === -1)];
    const data = [...Object.values(tuples1), ...Object.values(tuples2), ...Object.values(commonTuples)];
    return [data, commonSchema];
};

const getSymbol = type => Object(d3_shape__WEBPACK_IMPORTED_MODULE_2__["symbol"])().type(symbolFns[type]);

const stackOrders = {
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["ORDER_NONE"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOrderNone"],
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["ORDER_ASCENDING"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOrderAscending"],
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["ORDER_DESCENDING"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOrderDescending"]
};
const stackOffsets = {
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["OFFSET_DIVERGING"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOffsetDiverging"],
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["OFFSET_NONE"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOffsetNone"],
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["OFFSET_EXPAND"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOffsetExpand"],
    [_enums_stack_config__WEBPACK_IMPORTED_MODULE_11__["OFFSET_WIGGLE"]]: d3_shape__WEBPACK_IMPORTED_MODULE_2__["stackOffsetWiggle"]
};

// eslint-disable-next-line require-jsdoc
const stack = params => Object(d3_shape__WEBPACK_IMPORTED_MODULE_2__["stack"])().keys(params.keys).offset(stackOffsets[params.offset])
                .order(stackOrders[params.order])(params.data);

/**
 * Groups the data into a hierarchical tree structure based on one or more fields.
 * @param { Object } params Configuration properties for nesting data
 * @param { Array.<Array> } params.data Data which needs to be grouped
 * @param { Array.<number> } params.keys Field indices by which the data will be grouped
 * @return { Array.<Object> } Grouped data array
 */
const nestCollection = (params) => {
    const nestFn = Object(d3_collection__WEBPACK_IMPORTED_MODULE_4__["nest"])();
    params.keys.forEach(key => nestFn.key(d => d[key]));
    return nestFn.entries(params.data);
};

const pathInterpolators = {
    curveLinear: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveLinear"],
    curveStepAfter: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStepAfter"],
    curveStepBefore: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStepBefore"],
    curveStep: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStep"],
    curveCatmullRom: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveCatmullRom"],
    stepAfter: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStepAfter"],
    catmullRom: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveCatmullRom"],
    step: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStep"],
    stepBefore: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStepBefore"],
    linear: d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveLinear"]
};

const Symbols = {
    axisLeft: d3_axis__WEBPACK_IMPORTED_MODULE_1__["axisLeft"],
    axisRight: d3_axis__WEBPACK_IMPORTED_MODULE_1__["axisRight"],
    axisTop: d3_axis__WEBPACK_IMPORTED_MODULE_1__["axisTop"],
    axisBottom: d3_axis__WEBPACK_IMPORTED_MODULE_1__["axisBottom"],
    line: d3_shape__WEBPACK_IMPORTED_MODULE_2__["line"],
    area: d3_shape__WEBPACK_IMPORTED_MODULE_2__["area"],
    pie: d3_shape__WEBPACK_IMPORTED_MODULE_2__["pie"],
    arc: d3_shape__WEBPACK_IMPORTED_MODULE_2__["arc"],
    nest: d3_collection__WEBPACK_IMPORTED_MODULE_4__["nest"]
};

const Scales = {
    band: d3_scale__WEBPACK_IMPORTED_MODULE_3__["scaleBand"]
};

const getSmallestDiff = (points) => {
    points = points.sort((a, b) => a - b);
    let minDiff = points[1] - points[0];
    for (let i = 2; i < points.length; i++) {
        minDiff = Math.min(minDiff, points[i] - points[i - 1]);
    }

    return minDiff;
};

const timeFormats = {
    millisecond: '%A, %b %e, %H:%M:%S.%L',
    second: '%A, %b %e, %H:%M:%S',
    minute: '%A, %b %e, %H:%M',
    hour: '%A, %b %e, %H:%M',
    day: '%A, %b %e, %Y',
    month: '%B %Y',
    year: '%Y'
};

const timeDurations = [
    ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'],
    [1, 1000, 60000, 3600000, 86400000, 2592000000, 31536000000]
];

const getNearestInterval = (interval) => {
    const index = getClosestIndexOf(timeDurations[1], interval);
    return timeDurations[0][index];
};

const formatTemporal = (value, interval) => {
    const nearestInterval = getNearestInterval(interval);
    return datamodel__WEBPACK_IMPORTED_MODULE_0__["DateTimeFormatter"].formatAs(value, timeFormats[nearestInterval]);
};

const temporalFields = (dataModel) => {
    const filteredFields = {};
    Object.entries(dataModel.getFieldspace().getDimension()).forEach(([fieldName, fieldObj]) => {
        if (fieldObj.subtype() === TEMPORAL) {
            filteredFields[fieldName] = fieldObj;
        }
    });
    return filteredFields;
};

const require = (lookupWhat, lookupDetails) => ({
    resolvable: (store) => {
        const lookupTarget = store[lookupWhat];
        const depArr = lookupDetails.slice(0, lookupDetails.length - 1);
        const fn = lookupDetails[lookupDetails.length - 1]; // fn

        const deps = depArr.map(str => lookupTarget[str]);
        return {
            fn: fn(...deps),
            depArr
        };
    }
});

const nextAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
    function (callback) {
        setTimeout(callback, 16);
    };

const getValueParser = config => (val) => {
    if (val instanceof InvalidAwareTypes) {
        return val in config ? config[val] : `${val}`;
    }
    return val;
};

const retrieveNearestGroupByReducers = (dataModel, ...measureFieldNames) => {
    const filteredReducers = {};
    if (dataModel instanceof datamodel__WEBPACK_IMPORTED_MODULE_0___default.a) {
        const derivations = [...dataModel.getDerivations().reverse(), ...dataModel.getAncestorDerivations().reverse()];
        const nearestReducers = defaultValue(
            getObjProp(derivations.find(derv => derv.op === datamodel__WEBPACK_IMPORTED_MODULE_0__["DM_DERIVATIVES"].GROUPBY), 'criteria'), {});

        const measures = dataModel.getFieldspace().getMeasure();
        measureFieldNames = measureFieldNames.length ? measureFieldNames : Object.keys(measures);
        measureFieldNames.forEach((measureName) => {
            if (nearestReducers[measureName]) {
                filteredReducers[measureName] = nearestReducers[measureName];
            } else {
                const measureField = measures[measureName];
                if (measureField) {
                    filteredReducers[measureName] = measureField.defAggFn();
                }
            }
        });
    }
    return filteredReducers;
};

const retrieveFieldDisplayName = (dm, fieldName) => dm.getFieldspace().fieldsObj()[fieldName].displayName();
/**
 * Fetches the nearest sort operation details by traversing the chain of parent DataModels
 * @param {Object} dataModel Instance of DataModel
 *
 * @return {Array|null} sort criteria, null if no sort operation found
 */
const nearestSortingDetails = (dataModel) => {
    const allDerivations = [...dataModel.getAncestorDerivations(), ...dataModel.getDerivations()];
    const nearestSortDerivation = allDerivations.reverse().find(derivation => derivation.op === datamodel__WEBPACK_IMPORTED_MODULE_0__["DM_DERIVATIVES"].SORT);

    return nearestSortDerivation ? nearestSortDerivation.criteria : null;
};

/**
 * Map containing key, value sortingOrder pairs
 */
const sortOrderMap = {
    [_enums__WEBPACK_IMPORTED_MODULE_10__["SORT_ORDER_ASCENDING"]]: (firstVal, secondVal) => firstVal.localeCompare(secondVal),
    [_enums__WEBPACK_IMPORTED_MODULE_10__["SORT_ORDER_DESCENDING"]]: (firstVal, secondVal) => secondVal.localeCompare(firstVal)
};

/**
 * Sort categorical field based on it's sorting order
 * @param {string} sortOrder Order by which field is to be sorted (asc or desc or func)
 * @param {string} firstVal First sort parameter
 * @param {string} secondVal Second sort parameter
 * @return {number} position|null if sort order is invalid
*/
const sortCategoricalField = (sortOrder, firstVal, secondVal) => {
    const sortOrderType = typeof sortOrder;

    if (sortOrderType === FUNCTION) {
        return sortOrder(firstVal, secondVal);
    } else if (sortOrderType === STRING) {
        if (!sortOrderMap[sortOrder]) return null;
        return sortOrderMap[sortOrder](firstVal, secondVal);
    }
    return null;
};

const intersect = (arr1, arr2, accessors = [v => v, v => v]) => {
    const [fn1, fn2] = accessors;
    const set = new Set(arr2.map(v => fn2(v)));
    return arr1.filter(value => set.has(fn1(value)));
};

const partition = (array, filterFn) => array.reduce((acc, v, i) => {
    const pass = filterFn(v, i, array);

    pass ? acc[0].push(v) : acc[1].push(v);
    return acc;
}, [[], []]);

const mix = (superclass) => ({
    with: (...mixins) => {
        return mixins.reduce((cls, mixin) => mixin(cls), superclass);
    }
});




/***/ }),

/***/ "./packages/muze-utils/src/enums/common-props.js":
/*!*******************************************************!*\
  !*** ./packages/muze-utils/src/enums/common-props.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const CommonProps = {
    ACTION_INF: 'actionInf',
    ON_LAYER_DRAW: 'onLayerDraw',
    MATRIX_CREATED: 'matrixCreated'
};

/* harmony default export */ __webpack_exports__["default"] = (CommonProps);


/***/ }),

/***/ "./packages/muze-utils/src/enums/constants.js":
/*!****************************************************!*\
  !*** ./packages/muze-utils/src/enums/constants.js ***!
  \****************************************************/
/*! exports provided: COORD_TYPES, DATA_TYPE, SORT_ORDER_ASCENDING, SORT_ORDER_DESCENDING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COORD_TYPES", function() { return COORD_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_TYPE", function() { return DATA_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SORT_ORDER_ASCENDING", function() { return SORT_ORDER_ASCENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SORT_ORDER_DESCENDING", function() { return SORT_ORDER_DESCENDING; });
const COORD_TYPES = {
    POLAR: 'polar',
    CARTESIAN: 'cartesian'
};
const DATA_TYPE = {
    FUNCTION: 'function',
    STRING: 'string',
    NUMBER: 'number',
    BOOLEAN: 'Boolean'
};
const SORT_ORDER_ASCENDING = 'asc';
const SORT_ORDER_DESCENDING = 'desc';


/***/ }),

/***/ "./packages/muze-utils/src/enums/index.js":
/*!************************************************!*\
  !*** ./packages/muze-utils/src/enums/index.js ***!
  \************************************************/
/*! exports provided: ReservedFields, CommonProps, COORD_TYPES, DATA_TYPE, SORT_ORDER_ASCENDING, SORT_ORDER_DESCENDING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reserved_fields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reserved-fields */ "./packages/muze-utils/src/enums/reserved-fields.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReservedFields", function() { return _reserved_fields__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _common_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common-props */ "./packages/muze-utils/src/enums/common-props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CommonProps", function() { return _common_props__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./packages/muze-utils/src/enums/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COORD_TYPES", function() { return _constants__WEBPACK_IMPORTED_MODULE_2__["COORD_TYPES"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DATA_TYPE", function() { return _constants__WEBPACK_IMPORTED_MODULE_2__["DATA_TYPE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SORT_ORDER_ASCENDING", function() { return _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_ORDER_ASCENDING"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SORT_ORDER_DESCENDING", function() { return _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_ORDER_DESCENDING"]; });






/***/ }),

/***/ "./packages/muze-utils/src/enums/namespace.js":
/*!****************************************************!*\
  !*** ./packages/muze-utils/src/enums/namespace.js ***!
  \****************************************************/
/*! exports provided: UNIT_GLOBAL_NAMESPACE, UNIT_LOCAL_NAMESPACE, LAYER_LOCAL_NAMESPACE, LAYER_GLOBAL_NAMESPACE, GROUP_GLOBAL_NAMESPACE, GROUP_LOCAL_NAMESPACE, CANVAS_LOCAL_NAMESPACE, CANVAS_GLOBAL_NAMESPACE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_GLOBAL_NAMESPACE", function() { return UNIT_GLOBAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_LOCAL_NAMESPACE", function() { return UNIT_LOCAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYER_LOCAL_NAMESPACE", function() { return LAYER_LOCAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYER_GLOBAL_NAMESPACE", function() { return LAYER_GLOBAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP_GLOBAL_NAMESPACE", function() { return GROUP_GLOBAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP_LOCAL_NAMESPACE", function() { return GROUP_LOCAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LOCAL_NAMESPACE", function() { return CANVAS_LOCAL_NAMESPACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_GLOBAL_NAMESPACE", function() { return CANVAS_GLOBAL_NAMESPACE; });
const UNIT_GLOBAL_NAMESPACE = 'app.units';
const UNIT_LOCAL_NAMESPACE = 'local.units';
const LAYER_LOCAL_NAMESPACE = 'local.layers';
const LAYER_GLOBAL_NAMESPACE = 'app.layers';
const GROUP_GLOBAL_NAMESPACE = 'app.group';
const GROUP_LOCAL_NAMESPACE = 'local.group';
const CANVAS_LOCAL_NAMESPACE = 'local.canvas';
const CANVAS_GLOBAL_NAMESPACE = 'app.canvas';



/***/ }),

/***/ "./packages/muze-utils/src/enums/reserved-fields.js":
/*!**********************************************************!*\
  !*** ./packages/muze-utils/src/enums/reserved-fields.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const ReservedFields = {
    ROW_ID: '__id__'
};

/* harmony default export */ __webpack_exports__["default"] = (ReservedFields);


/***/ }),

/***/ "./packages/muze-utils/src/enums/stack-config.js":
/*!*******************************************************!*\
  !*** ./packages/muze-utils/src/enums/stack-config.js ***!
  \*******************************************************/
/*! exports provided: ORDER_ASCENDING, ORDER_DESCENDING, ORDER_NONE, OFFSET_DIVERGING, OFFSET_NONE, OFFSET_EXPAND, OFFSET_WIGGLE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER_ASCENDING", function() { return ORDER_ASCENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER_DESCENDING", function() { return ORDER_DESCENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER_NONE", function() { return ORDER_NONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OFFSET_DIVERGING", function() { return OFFSET_DIVERGING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OFFSET_NONE", function() { return OFFSET_NONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OFFSET_EXPAND", function() { return OFFSET_EXPAND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OFFSET_WIGGLE", function() { return OFFSET_WIGGLE; });
const ORDER_ASCENDING = 'ascending';
const ORDER_DESCENDING = 'descending';
const ORDER_NONE = 'none';
const OFFSET_DIVERGING = 'diverging';
const OFFSET_NONE = 'none';
const OFFSET_EXPAND = 'expand';
const OFFSET_WIGGLE = 'wiggle';


/***/ }),

/***/ "./packages/muze-utils/src/index.js":
/*!******************************************!*\
  !*** ./packages/muze-utils/src/index.js ***!
  \******************************************/
/*! exports provided: InvalidAwareTypes, DataModel, ReservedFields, CommonProps, COORD_TYPES, STATE_NAMESPACES, scales, colorSchemes, getNearestValue, getValueParser, transformColors, detectColor, hslToRgb, rgbToHsv, hexToHsv, hsvToRgb, escapeHTML, angleToRadian, generateGetterSetters, getArraySum, ERROR_MSG, interpolator, colorInterpolator, numberInterpolator, piecewiseInterpolator, reqAnimFrame, cancelAnimFrame, nextAnimFrame, getMax, getMin, getDomainFromData, getUniqueId, mergeRecursive, unionDomain, replaceCSSPrefix, symbolFns, defaultValue, easeFns, clone, interpolateArray, getMinPoint, getMaxPoint, getClosestIndexOf, registerListeners, Voronoi, checkExistence, sanitizeIP, getMinDiff, capitalizeFirst, getWindow, getQualifiedClassName, getDependencyOrder, objectIterator, intSanitizer, enableChainedTransaction, isHTMLElem, isEqual, isSimpleObject, nextFrame, getObjProp, getDataModelFromIdentifiers, getDataModelFromRange, transposeArray, toArray, extendsClass, concatModels, assembleModelFromIdentifiers, isValidValue, nestCollection, stack, getSymbol, Scales, Symbols, pathInterpolators, hslInterpolator, getSmallestDiff, require, formatTemporal, nearestSortingDetails, createSelection, temporalFields, retrieveNearestGroupByReducers, retrieveFieldDisplayName, sanitizeDomainWhenEqual, sortCategoricalField, intersect, partition, mix, selectElement, makeElement, applyStyle, addClass, removeClass, appendElement, setAttrs, setStyles, createElement, createElements, clipElement, getElementsByClassName, getMousePos, getEvent, getD3Drag, getSmartComputedStyle, getClientPoint, hasTouch, Store, transactor, timeMillisecond, timeSecond, timeMinute, timeHour, timeDay, timeWeek, timeMonth, timeYear, Smartlabel, dataSelect, LifeCycleManager, DimensionSubtype, FieldType, MeasureSubtype, DateTimeFormatter, DM_DERIVATIVES, GROUP_BY_FUNCTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvalidAwareTypes", function() { return InvalidAwareTypes; });
/* harmony import */ var datamodel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datamodel */ "../datamodel/dist/datamodel.js");
/* harmony import */ var datamodel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datamodel__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "DataModel", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _scales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scales */ "./packages/muze-utils/src/scales.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "scales", function() { return _scales__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _color_schemes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color-schemes */ "./packages/muze-utils/src/color-schemes.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "colorSchemes", function() { return _color_schemes__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _enums_namespace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums/namespace */ "./packages/muze-utils/src/enums/namespace.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "STATE_NAMESPACES", function() { return _enums_namespace__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums */ "./packages/muze-utils/src/enums/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReservedFields", function() { return _enums__WEBPACK_IMPORTED_MODULE_4__["ReservedFields"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CommonProps", function() { return _enums__WEBPACK_IMPORTED_MODULE_4__["CommonProps"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COORD_TYPES", function() { return _enums__WEBPACK_IMPORTED_MODULE_4__["COORD_TYPES"]; });

/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common-utils */ "./packages/muze-utils/src/common-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getNearestValue", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getNearestValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getValueParser", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getValueParser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformColors", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["transformColors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectColor", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["detectColor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hslToRgb", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["hslToRgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgbToHsv", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["rgbToHsv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexToHsv", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["hexToHsv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsvToRgb", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["hsvToRgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escapeHTML", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["escapeHTML"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "angleToRadian", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["angleToRadian"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateGetterSetters", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["generateGetterSetters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getArraySum", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getArraySum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ERROR_MSG", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["ERROR_MSG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["interpolator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colorInterpolator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["colorInterpolator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberInterpolator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["numberInterpolator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewiseInterpolator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["piecewiseInterpolator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reqAnimFrame", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["reqAnimFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cancelAnimFrame", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["cancelAnimFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextAnimFrame", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["nextAnimFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMax", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMin", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getMin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDomainFromData", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getDomainFromData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUniqueId", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getUniqueId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeRecursive", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["mergeRecursive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unionDomain", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["unionDomain"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "replaceCSSPrefix", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["replaceCSSPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolFns", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["symbolFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultValue", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["defaultValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeFns", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["easeFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["interpolateArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMinPoint", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getMinPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMaxPoint", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getMaxPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getClosestIndexOf", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getClosestIndexOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerListeners", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["registerListeners"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Voronoi", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["Voronoi"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkExistence", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["checkExistence"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sanitizeIP", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["sanitizeIP"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMinDiff", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getMinDiff"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "capitalizeFirst", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["capitalizeFirst"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getWindow", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getQualifiedClassName", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getQualifiedClassName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDependencyOrder", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getDependencyOrder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objectIterator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["objectIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intSanitizer", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["intSanitizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableChainedTransaction", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["enableChainedTransaction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isHTMLElem", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["isHTMLElem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["isEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSimpleObject", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["isSimpleObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["nextFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getObjProp", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getObjProp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDataModelFromIdentifiers", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getDataModelFromIdentifiers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDataModelFromRange", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getDataModelFromRange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transposeArray", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["transposeArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["toArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendsClass", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["extendsClass"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatModels", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["concatModels"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assembleModelFromIdentifiers", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["assembleModelFromIdentifiers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidValue", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["isValidValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nestCollection", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["nestCollection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSymbol", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getSymbol"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scales", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["Scales"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Symbols", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["Symbols"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathInterpolators", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["pathInterpolators"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hslInterpolator", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["hslInterpolator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSmallestDiff", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["getSmallestDiff"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "require", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["require"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatTemporal", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["formatTemporal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nearestSortingDetails", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["nearestSortingDetails"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSelection", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["createSelection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "temporalFields", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["temporalFields"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retrieveNearestGroupByReducers", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["retrieveNearestGroupByReducers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retrieveFieldDisplayName", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["retrieveFieldDisplayName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sanitizeDomainWhenEqual", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["sanitizeDomainWhenEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortCategoricalField", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["sortCategoricalField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["intersect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["partition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return _common_utils__WEBPACK_IMPORTED_MODULE_5__["mix"]; });

/* harmony import */ var _renderer_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer-utils */ "./packages/muze-utils/src/renderer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectElement", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["selectElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeElement", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["makeElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyle", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["applyStyle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["addClass"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeClass", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["removeClass"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "appendElement", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["appendElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setAttrs", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["setAttrs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setStyles", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["setStyles"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["createElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElements", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["createElements"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipElement", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["clipElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getElementsByClassName", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getElementsByClassName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMousePos", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getMousePos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEvent", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getD3Drag", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getD3Drag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSmartComputedStyle", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getSmartComputedStyle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getClientPoint", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["getClientPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasTouch", function() { return _renderer_utils__WEBPACK_IMPORTED_MODULE_6__["hasTouch"]; });

/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./store */ "./packages/muze-utils/src/store.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return _store__WEBPACK_IMPORTED_MODULE_7__["Store"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transactor", function() { return _store__WEBPACK_IMPORTED_MODULE_7__["transactor"]; });

/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./packages/muze-utils/node_modules/d3-time/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeMinute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeHour"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeWeek"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return d3_time__WEBPACK_IMPORTED_MODULE_8__["timeYear"]; });

/* harmony import */ var fusioncharts_smartlabel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fusioncharts-smartlabel */ "./packages/muze-utils/node_modules/fusioncharts-smartlabel/lib/SmartlabelManager.js");
/* harmony import */ var fusioncharts_smartlabel__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fusioncharts_smartlabel__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Smartlabel", function() { return fusioncharts_smartlabel__WEBPACK_IMPORTED_MODULE_9___default.a; });
/* harmony import */ var _DataSystem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DataSystem */ "./packages/muze-utils/src/DataSystem/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dataSelect", function() { return _DataSystem__WEBPACK_IMPORTED_MODULE_10__["dataSelect"]; });

/* harmony import */ var _lifecycle_manager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lifecycle-manager */ "./packages/muze-utils/src/lifecycle-manager/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LifeCycleManager", function() { return _lifecycle_manager__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DimensionSubtype", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FieldType", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["FieldType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeasureSubtype", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateTimeFormatter", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["DateTimeFormatter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DM_DERIVATIVES", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["DM_DERIVATIVES"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GROUP_BY_FUNCTIONS", function() { return datamodel__WEBPACK_IMPORTED_MODULE_0__["GROUP_BY_FUNCTIONS"]; });






const InvalidAwareTypes = datamodel__WEBPACK_IMPORTED_MODULE_0___default.a.InvalidAwareTypes;


























/***/ }),

/***/ "./packages/muze-utils/src/lifecycle-manager/event-list.js":
/*!*****************************************************************!*\
  !*** ./packages/muze-utils/src/lifecycle-manager/event-list.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const events = [
    'initialized',
    'beforeupdate',
    'updated',
    'beforedraw',
    'drawn',
    'beforeremove',
    'removed',
    'animationend'
];

const compositions = [
    'canvas',
    'unit',
    'layer',
    'axis',
    'facet-headers',
    'legend',
    'caption'
];

const EVENT_LIST = [];

compositions.forEach((composition) => {
    events.forEach((event) => {
        EVENT_LIST.push(`${composition}.${event}`);
    });
});

/* harmony default export */ __webpack_exports__["default"] = (EVENT_LIST);


/***/ }),

/***/ "./packages/muze-utils/src/lifecycle-manager/helper.js":
/*!*************************************************************!*\
  !*** ./packages/muze-utils/src/lifecycle-manager/helper.js ***!
  \*************************************************************/
/*! exports provided: createPromise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPromise", function() { return createPromise; });
/**
 * Creates a new promise when the given promise is resolved. This needs to be done so that after the lifecycle event
 * is completed, then again when the event gets completed, then a new promise gets resolved.
 *
 * @param {Promise} promise Instance of promise
 * @param {string} eventName name of event
 * @param {LifeCycleManager} context Instance of lifecyclemanager
 */
const createPromise = (promise, eventName, context) => {
    promise.then(() => {
        const prm = context._makeNotifierPromise(eventName);
        context._promises.set(eventName, prm);
        createPromise(prm, eventName, context);
    });
};


/***/ }),

/***/ "./packages/muze-utils/src/lifecycle-manager/index.js":
/*!************************************************************!*\
  !*** ./packages/muze-utils/src/lifecycle-manager/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lifecycle_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lifecycle-manager */ "./packages/muze-utils/src/lifecycle-manager/lifecycle-manager.js");


/* harmony default export */ __webpack_exports__["default"] = (_lifecycle_manager__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./packages/muze-utils/src/lifecycle-manager/lifecycle-manager.js":
/*!************************************************************************!*\
  !*** ./packages/muze-utils/src/lifecycle-manager/lifecycle-manager.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LifeCycleManager; });
/* harmony import */ var _event_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-list */ "./packages/muze-utils/src/lifecycle-manager/event-list.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze-utils/src/lifecycle-manager/helper.js");



/**
 * At first call it accepts one function
 * calling it second time accepts notification object.
 * notification object then called with first accepted function
 *
 * @param {Function} resolveFn a promise's resolve function
 * @return {Function} a function to accept notification object
 */
const resolver = resolveFn => notification => resolveFn(notification);

/**
 * Checks if the property string is present in the source object
 *
 * @param {Object} source source object whom you want to check the property
 * @param {string} property key name that need to be checked
 * @return {boolean} returns true if the property found in the source object
 */
const hasOwn = (source, property) => Object.prototype.hasOwnProperty.call(source, property);

/**
 * LifeCycleManager which goes as a dependendecy to a muze
 * it accepts notification from the entire library throughout
 * the exeecution life
 *
 * @export
 * @class LifeCycleManager
 */
class LifeCycleManager {

    /**
     * Creates an instance of LifeCycleManager.
     * @memberof LifeCycleManager
     */
    constructor () {
        this._eventList = _event_list__WEBPACK_IMPORTED_MODULE_0__["default"];
        this._promises = new Map();
        this._notifiers = {};
        this._lifeCycles = {};
        this._unreleasedLifeCycles = {};
        this._boot();
    }

    /**
     * Fills all the notifiers with resolver callback
     *
     * @memberof LifeCycleManager
     */
    _boot () {
        this._notifiers = this._eventList.reduce((acc, name) => {
            acc[name] = resolver;
            return acc;
        }, {});
        this._preparePromises();
    }

    /**
     * Public method which gives the promise corresponding
     * to the event name
     *
     * @param {string} eventName name of the event like `canvas.drawn`
     * @return {promise} promise that is passed to the user
     * @memberof LifeCycleManager
     */
    retrieve (eventName) {
        return this._promises.get(eventName);
    }

    /**
     * Creates a promise that will be passed to user's callback
     *
     * @param {string} eventName name of the event like `canvas.drawn`
     * @return {promise} a pending promise waiting for resolve to be called
     * @memberof LifeCycleManager
     */
    _makeNotifierPromise (eventName) {
        return new Promise((resolve) => {
            this._notifiers[eventName] = resolver(resolve);
        });
    }

    /**
     * Prepares the promise map with pending promises
     * all the promises are in a pending state where their's
     * resolve function waiting to be called with notification object
     * @memberof LifeCycleManager
     */
    _preparePromises () {
        this._eventList.forEach((eventName) => {
            const promise = this._makeNotifierPromise(eventName);
            this._promises.set(eventName, promise);
            Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createPromise"])(promise, eventName, this);
        });
    }

    /**
     * Resolves the promise with notification object
     *
     * @param {string} eventName name of the event in the system
     * @param {Object} notification notification object
     * @param {string} notification.formalName name of the sender creating the notification
     * @param {Object} notification.client instance or array of instances sending the notification
     * @param {string} notification.action the stage name when the event happened like `beforedraw`
     *
     * @memberof LifeCycleManager
     */
    _resolvePromise (eventName, notification) {
        this._notifiers[eventName](notification);
    }

    /**
     * Public method which is being called by different
     * subcompoents of the system at different execution atages
     * @param {Object} notification notification object
     * @param {string} notification.formalName name of the sender creating the notification
     * @param {Object} notification.client instance or array of instances sending the notification
     * @param {string} notification.action the stage name when the event happened like `beforedraw`
     * @memberof LifeCycleManager
     */
    notify (notification) {
        // get the composition name from notification
        // or from static formalName() method
        const composition = notification.formalName || notification.client.constructor.formalName();
        notification.formalName = composition;
        this._releasePromisesFromCache();
        this._notify(composition, notification);
    }

    /**
     * Notify user the with promsie in a callback
     * if callback not found then cache it
     *
     * @param {string} composition
     * @param {Object} notification notification object
     * @param {string} notification.formalName name of the sender creating the notification
     * @param {Object} notification.client instance or array of instances sending the notification
     * @param {string} notification.action the stage name when the event happened like `beforedraw`
     * @memberof LifeCycleManager
     */
    _notify (composition, notification) {
        const stage = notification.action;
        const eventName = `${composition}.${stage}`;

        // resolves promise with the notification object
        this._resolvePromise(eventName, notification);

        // get the promise from the promise map
        const promise = this.retrieve(eventName);

        if (this._lifeCycles[composition]) {
            if (this._lifeCycles[composition][stage]) {
                // if user given call back exists, then call with promise
                this._callLifeCycleCallback(composition, stage, promise);
            } else {
                // otherwise cache the promise
                this._cachePromise(composition, stage, promise);
            }
        } else {
            this._cachePromise(composition, stage, promise);
        }
    }

    /**
     * Calls the user's callback with callback
     *
     * @param {string} composition name of the compositon like `canvas`
     * @param {string} stage the stage name when the event happened like `beforedraw`
     * @param {promise} promise promise that is passed to the user
     * @memberof LifeCycleManager
     */
    _callLifeCycleCallback (composition, stage, promise) {
        const eventName = `${composition}.${stage}`;
        this._lifeCycles[composition][stage](promise);
        this._resetTargetPromise(eventName);
    }

    /**
     * Try to clear the cached promsies once we have
     * macthed callbacks from the user
     *
     * @memberof LifeCycleManager
     */
    _releasePromisesFromCache () {
        const compositions = Object.keys(this._unreleasedLifeCycles);
        compositions.forEach((composition) => {
            const stages = Object.keys(this._unreleasedLifeCycles[composition]);
            stages.forEach((stage) => {
                if (this._lifeCycles[composition]) {
                    if (this._lifeCycles[composition][stage]) {
                        // take the promise from unreleased lifeCycles
                        const promise = this._unreleasedLifeCycles[composition][stage];
                        // call the user given callback with that promise
                        this._callLifeCycleCallback(composition, stage, promise);
                        // delete promise from unreleased lifeCycles
                        delete this._unreleasedLifeCycles[composition][stage];
                    }
                }
            });
        });
    }

    /**
     * Cache the promise in the map. This cache
     * then get consumed if we get user callbacks
     * @param {string} composition name of the compositon like `canvas`
     * @param {string} stage the stage name when the event happened like `beforedraw`
     * @param {promise} promise promise that is passed to the user
     * @memberof LifeCycleManager
     */
    _cachePromise (composition, stage, promise) {
        if (!hasOwn(this._unreleasedLifeCycles, composition)) {
            this._unreleasedLifeCycles[composition] = {};
        }

        if (!hasOwn(this._unreleasedLifeCycles[composition], stage)) {
            this._unreleasedLifeCycles[composition][stage] = {};
        }
        this._unreleasedLifeCycles[composition][stage] = promise;
    }

    /**
     * It register's the callbacks gievn the user
     *
     * @param {Object} [lifeCycles={}] a object with list of callbacks
     * @memberof LifeCycleManager
     */
    register (lifeCycles = {}) {
        this._lifeCycles = lifeCycles;
        // as we get all the callbacks, try to call them
        // from unreleased promise map
        this._releasePromisesFromCache();
    }

    /**
     * Reset the promise into pending state
     *
     * @param {string} eventName name of the event happening
     * @memberof LifeCycleManager
     */
    _resetTargetPromise (eventName) {
        setTimeout(() => {
            this._notifiers[eventName] = resolver;
            this._promises.set(eventName, this._makeNotifierPromise(eventName));
        }, 0);
    }
}


/***/ }),

/***/ "./packages/muze-utils/src/renderer-utils.js":
/*!***************************************************!*\
  !*** ./packages/muze-utils/src/renderer-utils.js ***!
  \***************************************************/
/*! exports provided: hasTouch, selectElement, makeElement, applyStyle, addClass, removeClass, appendElement, setAttrs, setStyles, createElement, createElements, clipElement, getElementsByClassName, getMousePos, getEvent, getD3Drag, getSmartComputedStyle, getClientPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasTouch", function() { return hasTouch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectElement", function() { return selectElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeElement", function() { return makeElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyStyle", function() { return applyStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeClass", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendElement", function() { return appendElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttrs", function() { return setAttrs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStyles", function() { return setStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElements", function() { return createElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipElement", function() { return clipElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementsByClassName", function() { return getElementsByClassName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMousePos", function() { return getMousePos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEvent", function() { return getEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getD3Drag", function() { return getD3Drag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSmartComputedStyle", function() { return getSmartComputedStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClientPoint", function() { return getClientPoint; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./packages/muze-utils/node_modules/d3-selection/src/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./packages/muze-utils/node_modules/d3-drag/src/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-transition */ "./packages/muze-utils/node_modules/d3-transition/src/index.js");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common-utils */ "./packages/muze-utils/src/common-utils.js");




/**
 * This function takes a raw DOM element or
 * a string and returns a d3 selection of that element.
 *
 * @param {HTMLElement | string} element The element to wrap in d3 selection.
 * @return {Selection} Instance of d3 selection.
 */
const selectElement = element => Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(element);

/**
 * It creates a new d3 element on the parent element
 * @param  {Selection} parent Element to which the element is to be appended
 * @param  {Object} elemType Type of the new element
 * @param  {Array} data Data for the new element
 * @param  {Object} selector classname/id/tagname for the element
 * @return {HTMLElement} Newly Created Element
 */
const makeElement = (parent, elemType, data, selector, callbacks = {}, keyFn) => {
    if ((parent instanceof HTMLElement || parent instanceof SVGElement)) {
        parent = selectElement(parent);
    }

    const selectorVal = selector ? selector[0] : null;
    let selectorType = null;
    let actualSelector = null;
    let element = null;
    let enterSel = null;
    let mergeSel = null;
    let filter;
    if (selectorVal) {
        if (selectorVal === '#') {
            selectorType = 'id';
            actualSelector = selector;
        } else {
            selectorType = 'class';
            actualSelector = selector[0] === '.' ? selector : `.${selector}`;
        }
    } else {
        actualSelector = elemType;
        filter = true;
    }
    element = parent.selectAll(actualSelector);

    filter && (element = element.filter(function () {
        return this.parentNode === parent.node();
    }));
    element = element.data(data, keyFn);

    enterSel = element.enter()
                            .append(elemType || 'div');
    callbacks.enter && enterSel.each(function (...params) {
        callbacks.enter(selectElement(this), ...params);
    });

    mergeSel = enterSel.merge(element);
    callbacks.update && mergeSel.each(function (...params) {
        callbacks.update(selectElement(this), ...params);
    });
    if (selectorType === 'class') {
        mergeSel.classed(selectorVal === '.' ? selector.substring(1, selector.length) : selector, true);
    } else if (selectorType === 'id') {
        mergeSel.attr('id', selector.substring(1, selector.length));
    }
    const exitSel = element.exit();

    if (callbacks.exit) {
        exitSel.each(function (...params) {
            callbacks.exit(selectElement(this), ...params);
        });
    } else {
        exitSel.remove();
    }
    return mergeSel;
};

/**
 * This function applies styles to an element
 *  @param  {Object} elem Element Selection
 * @param  {Object} styleObj Style Object to be applied
 * @return {Element} Newly Created Element
*/
const applyStyle = (elem, styleObj) => {
    Object.entries(styleObj).forEach((d) => {
        elem.style(d[0], d[1]);
    }, undefined);
    return elem;
};

/**
 * This function appends a dom element in another element.
 * @param {HTMLElement | SVGElement} element1 The element in which to append the second element
 * @param {HTMLElement | SVGElement} element2 The element which will be appended.
 */
const appendElement = (element1, element2) => {
    element1.appendChild(element2);
};

/**
 * Sets the attributes to the element.
 * @param {HTMLElement | SVGElement} element Element on which attributes will be applied
 * @param {Object} attrs Attributes which need to be applied
 */
const setElementAttrs = (element, attrs) => {
    for (const key in attrs) {
        if ({}.hasOwnProperty.call(attrs, key)) {
            element.attr(key, attrs[key]);
        }
    }
};

/**
 * Sets attributes in the svg or html element
 * @param {SVGElement | HTMLElement} element The element on which attrs will be applied
 * @param {Array.<Object>} attrs Array of attributes
 * @param {string} className className of elements to select.
 * @return {SVGElement | HTMLElement} SVGElement or html element.
 */
const setAttrs = (element, attrs, className) => {
    if (!(element instanceof d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])) {
        element = selectElement(element);
    }
    className !== undefined ? element.selectAll(`.${className}`).each(function () {
        setElementAttrs(Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(this), attrs);
    }) : setElementAttrs(element, attrs);
    return element;
};

/**
 * Adds a css class to elements which passes the filter function.If filter function is not given,
 * then all elements will be applied the class.
 * @param {HTMLElement | SVGElement} element element
 * @param {string} className css class
 * @param {string} selector css selector
 * @param {Function} filterFn filter method.
 */
const addClass = (element, className, selector, filterFn) => {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(element).selectAll(selector).each(function (data) {
        const elem = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
        filterFn ? filterFn(data) && elem.classed(className, true) :
                elem.classed(className, true);
    });
};

/**
 * Removes the css class from elements which passes the filter function.If filter function is not given,
 * then all elements will be applied the class.
 * @param {HTMLElement | SVGElement} element element
 * @param {string} className css class
 * @param {string} selector css selector
 * @param {Function} filterFn filter method.
 */
const removeClass = (element, className, selector, filterFn) => {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(element).selectAll(selector).each(function (data) {
        const elem = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
        filterFn ? filterFn(data) && elem.classed(className, false) :
                elem.classed(className, false);
    });
};

/**
 * Sets styles in the svg or html element
 * @param {SVGElement | HTMLElement} element The element on which styles will be applied
 * @param {Array.<Object>} styles Array of style attributes
 * @return {SVGElement | HTMLElement} SVGElement or html element.
 */
const setStyles = (element, styles) => {
    if (!(element instanceof d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])) {
        element = selectElement(element);
    }
    for (const key in styles) {
        if ({}.hasOwnProperty.call(styles, key)) {
            element.style(key, styles[key]);
        }
    }
    return element;
};

/**
 * Creates svg or html elements by binding data to the selection.Removes extra elements
 * on exit.
 * @param {Object} params Parameter object
 * @param {SVGElement | HTMLElement} params.container Container element where all elements will be appended
 * @param {string} params.selector Selector by which elements will be selected from dom
 * @param {string} params.append Append tag
 * @param {Function} params.each Function which will be executed for each data point and element.
 */
const createElements = (params) => {
    const container = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(params.container);
    let data;
    let sel;

    data = params.data;
    if (typeof data === 'number') {
        data = Array(data).fill().map((d, i) => i);
    }
    sel = container.selectAll(params.selector).data(data);

    sel = container.selectAll(params.selector).filter(function () {
        return this.parentNode === container.node();
    }).data(params.data);

    const selectionMerge = sel.enter().append(params.append).merge(sel).each(function (d, i) {
        params.each(d, Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(this), i);
    });

    selectionMerge.attr('class', params.className || '');
    sel.exit().remove();
};

/**
 * Clips an element with given measurement. Basically it is used to hide overflowing portions
 * of any element.
 * @param {SVGElement} container svg element which needs to be clipped.
 * @param {Object} measurement Dimensions of the clipped rectangle.
 * @param {string} id Unique id of the clip element
 */
const clipElement = (container, measurement, id) => {
    const clipPathElement = makeElement(Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(container), 'clipPath', [1], `#${id}`);
    const clipPathRect = makeElement(clipPathElement, 'rect', [1]);
    clipPathRect.attr('x', measurement.x)
                    .attr('y', measurement.x)
                    .attr('width', measurement.width)
                    .attr('height', measurement.height);
    clipPathElement.attr('clip-path', `url(#${id})`);
};

/**
 * Returns the element of the corresponding classname.
 * @param {HTMLElement | SVGElement} node html or svg node element.
 * @param {string} className css class to be applied.
 * @return {HTMLElement | SVGElement} html or svg element.
 */
const getElementsByClassName = (node, className) => Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(node).selectAll(className).nodes();

/**
 * Gets the mouse position relative to an svg type of element
 * @param {SVGElement} element Any svg element like rect, circle, etc.
 * @param {Event} event Event object.
 * @return {Object} x and y position relative to the container element passed.
 */
const getMousePos = (element, event) => {
    const boundingClientRect = element.getBoundingClientRect();
    return {
        x: event.x - boundingClientRect.x,
        y: event.y - boundingClientRect.y
    };
};

const getClientPoint = (...params) => {
    const pos = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["clientPoint"])(...params);
    return {
        x: pos[0],
        y: pos[1]
    };
};

/** This function appends a dom element in another element.
 * @param {Object} tag The tag name of the element to append
 * @param {Object} mount Mount point fo the element
 * @return {Object} selection of the appended element
 */
const createElement = (tag, mount) => Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(mount).append(tag).node();

/**
 * Gets the d3 event function
 * @return {Object} d3 event
 */
const getEvent = () => d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"];

/**
 * Gets the d3 drag function
 * @return {Object} d3 drag
 */
const getD3Drag = () => d3_drag__WEBPACK_IMPORTED_MODULE_1__["drag"];

const getSmartComputedStyle = (group, css) => {
    let textEl;
    const testText = 'W';
    const mandatoryStyle = {
        'fill-opacity': 0
    };
    const className = typeof css === 'string' ? css : (css instanceof Array ? css.join(' ') : undefined);

    if (group.node() instanceof HTMLElement) {
        textEl = group.append('div').html(testText);
    } else {
        textEl = group.append('text').text(testText);
    }

    if (className) {
        textEl.attr('class', className);
    } else if (typeof css === 'object') {
        delete css['fill-opacity'];
        Object(_common_utils__WEBPACK_IMPORTED_MODULE_3__["mergeRecursive"])(mandatoryStyle, css);
    }

    textEl.style(mandatoryStyle);
    const computedStyle = window.getComputedStyle(textEl.node());
    const styleForSmartLabel = {
        fontSize: computedStyle.fontSize,
        fontFamily: computedStyle.fontFamily,
        fontWeight: computedStyle.fontWeight,
        fontStyle: computedStyle.fontStyle
    };

    textEl.remove();

    return styleForSmartLabel;
};

const hasTouch = () => 'ontouchstart' in document.documentElement;




/***/ }),

/***/ "./packages/muze-utils/src/scales.js":
/*!*******************************************!*\
  !*** ./packages/muze-utils/src/scales.js ***!
  \*******************************************/
/*! exports provided: scaleLinear, scaleThreshold, scaleLog, scalePow, scaleIdentity, scaleOrdinal, scaleSequential, scaleQuantize, scaleQuantile, schemeCategory10, schemeCategory20, schemeCategory20b, scaleBand, scaleTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-scale */ "./packages/muze-utils/node_modules/d3-scale/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleThreshold"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scalePow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleIdentity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleOrdinal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleSequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleQuantize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleQuantile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["schemeCategory10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["schemeCategory20"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory20b", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["schemeCategory20b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleBand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_0__["scaleTime"]; });

/**
 * This file exports functions to create or modify the scale of a plot.
 */



/***/ }),

/***/ "./packages/muze-utils/src/store.js":
/*!******************************************!*\
  !*** ./packages/muze-utils/src/store.js ***!
  \******************************************/
/*! exports provided: Store, transactor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transactor", function() { return transactor; });
/* harmony import */ var hyperdis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hyperdis */ "./packages/muze-utils/node_modules/hyperdis/dist/hyperdis.js");
/* harmony import */ var hyperdis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hyperdis__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common-utils */ "./packages/muze-utils/src/common-utils.js");



const initProp = (obj, props, val = () => ({})) => {
    props.forEach((prop) => {
        if (!obj[prop]) {
            obj[prop] = val();
        }
        obj = obj[prop];
    });
    return obj;
};

const fetchPropValues = (propNames, params, deps) => params.map((param, i) => {
    const prop = propNames[i];

    return param.map(val => (val === undefined || val === null ? val : val[deps[prop]]));
});

const addListenerToNamespace = (namespaceInf, fn, context) => {
    let key = namespaceInf.key;
    const namespace = namespaceInf.id;
    const listeners = context._listeners;

    if (namespace) {
        !listeners.get(namespace) && (listeners.set(namespace, new Map()));
        const namespaceListeners = listeners.get(namespace);

        if (!key) {
            key = namespaceListeners.size;
        }
        namespaceListeners.set(key, fn);
    } else {
        key = key || listeners.size;
        listeners.set(key, fn);
    }
};

const setContexts = (contexts, propObj, contextMap) => {
    for (const key of propObj.keys()) {
        contexts[key] = {
            context: contextMap[key],
            deps: propObj.get(key).depProps
        };
    }
    return contexts;
};

const registerPropInMaps = (store, props, namespaceInf, type) => {
    const {
        _registeredListeners: registeredListeners,
        _propListenerMap: propListenerMap
    } = store;
    const {
        subNamespace,
        namespace: ns
    } = namespaceInf;

    initProp(registeredListeners, [ns]);
    props.forEach((prop) => {
        const subNamespaces = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(registeredListeners, ns, prop, 'subNamespace'), []);
        let fns = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(propListenerMap, prop, type, 'fns'), 0);

        fns++;
        subNamespace && subNamespaces.push(subNamespace);
        registeredListeners[ns][prop] = {
            subNamespace: subNamespaces,
            allProps: props,
            subNamespaces: {}
        };
        initProp(propListenerMap, [prop, type]);
        propListenerMap[prop][type] = {
            fns,
            _fnCount: fns
        };
    });
};

const registerListener = (context, type, ...options) => {
    const [propList, callBack, instantCall, namespaceInf = {}] = options;
    let props = propList;

    if (!Array.isArray(propList)) {
        props = [propList];
    }

    const { namespace: ns } = namespaceInf;
    const callbackFn = ((propNames, namespaceVal) => (...params) => {
        const { _savedCommits: commits, _propListenerMap: propListenerMap } = context;

        if (!propNames.some(prop => Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(propListenerMap, prop, 'disabled'))) {
            if (namespaceVal) {
                const listenersObj = context._registeredListeners[namespaceVal];
                const contextMap = context._contextMap[namespaceVal];
                const contextsObj = {};

                propNames.forEach((prop) => {
                    const commitsObj = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(commits, prop, type), {});
                    const listeners = listenersObj[prop].subNamespaces;
                    const propDeps = propListenerMap[prop][type];

                    for (const nm in commitsObj) {
                        const fnInf = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(propDeps[nm], { fns: 0 });
                        let { fns } = fnInf;

                        if (fns > 0) {
                            setContexts(contextsObj, listeners[nm], contextMap);
                            fns--;
                        }

                        if (fns <= 0) {
                            delete commitsObj[nm];
                        }
                        fnInf.fns = fns;
                    }
                });
                for (const key in contextsObj) {
                    const obj = contextsObj[key];

                    callBack(obj.context, ...fetchPropValues(propNames, params, obj.deps));
                }
            } else {
                callBack(...params);
            }
        }
    })(props, ns, type);

    const fn = context.model[type](props, callbackFn, instantCall);

    if (ns) {
        registerPropInMaps(context, props, namespaceInf, type);
    }
    addListenerToNamespace(namespaceInf, fn, context);
};

const retrieveNamespaces = (names, key) => {
    if (names instanceof Object) {
        return [names[key]];
    } else if (names instanceof Array) {
        return names;
    }
    return [names];
};

const createMap = () => new Map();

const listenerTypes = ['next', 'on'];

const removePropValue = (context, map, propInf) => {
    const { subNamespace: sns, prop, propListenerMap } = propInf;
    const propObj = propListenerMap[prop];

    listenerTypes.forEach((type) => {
        if (type in propObj) {
            delete propObj[type][sns];
        }
    });
    if (map.has(sns)) {
        const value = context.get(prop);

        if (value instanceof Object && sns in value) {
            delete value[sns];
        }
        map.delete(sns);
    }
};

/**
 * Methods to handle changes to table configuration and reactivity are handled by this
 * class.
 */
/**
 *  Common store class
 *
 * @class Store
 */
class Store {
    /**
     * Creates an instance of Store.
     * @param {Object} config The object to create the state store with.
     * @memberof Store
     */
    constructor (config) {
        // create reactive model
        this.model = hyperdis__WEBPACK_IMPORTED_MODULE_0___default.a.create(config);
        this._listeners = new Map();
        this._registeredListeners = {};
        this._contextMap = {};
        this._commits = {};
        this._savedCommits = {};
        this._queuedProps = {};
        this._propListenerMap = {};
        this._locked = false;
    }

    lockModel () {
        this.model.lock();
        this._locked = true;
        return this;
    }

    unlockModel () {
        this._locked = false;
        this.model.unlock();
        return this;
    }

    /**
     * This method returns a plain JSON object
     * with all the fields in the state store.
     *
     * @return {Object} Serialized representation of state store.
     * @memberof Store
     */
    serialize () {
        return this.model.serialize();
    }

    lockCommits (props) {
        props.forEach((prop) => {
            this._commits[prop] = {
                locked: true,
                queue: []
            };
        });
        return this;
    }

    unlockCommits (props) {
        const commitsObj = this._commits;

        this.lockModel();
        props.forEach((prop) => {
            commitsObj[prop].locked = false;
            const queuedProps = {};
            const { queue } = commitsObj[prop];

            queue.forEach((params) => {
                const [propName, value, namespace] = params;

                if (namespace) {
                    const propObj = initProp(queuedProps, [propName, namespace]);

                    Object.assign(propObj, value);
                }
            });
            queue.forEach((params) => {
                const [propName, value, namespace] = params;

                this.commit(propName, propName in queuedProps ? queuedProps[propName][namespace] : value,
                    namespace);
            });
            delete commitsObj[prop];
        });
        this.unlockModel();
        return this;
    }

    addSubNamespace (sns, namespace, context) {
        // Get all the listeners registered by the component
        const listeners = this._registeredListeners[namespace];
        const propListenerMap = this._propListenerMap;

        initProp(this._contextMap, [namespace]);
        this._contextMap[namespace][sns] = context;
        for (const key in listeners) {
            const obj = listeners[key];
            const propObj = propListenerMap[key];
            const propFns = listenerTypes.reduce((acc, type) => {
                const val = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(propObj, type, 'fns'), 0);
                val && (acc[type] = val);
                return acc;
            }, {});
            const { allProps, subNamespaces, subNamespace } = obj;
            const snsArr = subNamespace.length ? subNamespace : [sns];

            snsArr.forEach((ns) => {
                const nsObj = ns instanceof Function ? ns(context) : ns;
                const names = retrieveNamespaces(nsObj, key);
                const depProps = allProps.reduce((acc, prop) => {
                    acc[prop] = ns instanceof Function ? nsObj[prop] : ns;
                    return acc;
                }, {});

                names.forEach((nm) => {
                    initProp(subNamespaces, [nm], createMap).set(sns, {
                        depProps
                    });

                    for (const type in propFns) {
                        initProp(propObj, [type, nm]);
                        const fns = propFns[type];

                        propObj[type][nm] = {
                            fns,
                            _fnCount: fns
                        };
                    }
                });
            });
        }
        return this;
    }

    /**
     * This method is used to update the value of a property in the state store.
     *
     * @param {string} propName The name of the property.
     * @param {number} value The new value of the property.
     * @memberof Store
     */
    commit (propName, value, namespace, disableListener = false) {
        let sanitizedVal = value;
        const commits = this._commits;
        const savedCommits = this._savedCommits;
        const locked = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(commits, propName, 'locked');
        const propListenerMap = this._propListenerMap[propName] || {};

        propListenerMap.disabled = disableListener;

        if (locked) {
            commits[propName].queue.push([propName, value, namespace]);
            return this;
        }

        if (namespace) {
            if (this._locked) {
                const queuedProps = initProp(this._queuedProps, [propName]);
                queuedProps[namespace] = value;
                sanitizedVal = queuedProps;
            } else {
                sanitizedVal = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(this.get(propName), {});
                sanitizedVal[namespace] = value;
            }

            listenerTypes.forEach((type) => {
                initProp(savedCommits, [propName, type]);
                savedCommits[propName][type][namespace] = true;
                if (Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(propListenerMap, type, namespace)) {
                    propListenerMap[type][namespace].fns = propListenerMap[type][namespace]._fnCount;
                }
            });
        }

        this.model.prop(propName, sanitizedVal);
        return this;
    }

    /**
     * This method is used to register a callback that will execute
     * when one or more properties change.
     *
     * @param {string | Array} propNames name of property or array of props.
     * @param {Function} callBack The callback to execute.
     * @memberof Store
     */
    /* istanbul ignore next */registerChangeListener (...params) {
        registerListener(this, 'next', ...params);
        return this;
    }

    /**
     * This method is used to register a callback that will execute
     * when one or more properties change.
     *
     * @param {string | Array} propNames name of property or array of props.
     * @param {Function} callBack The callback to execute.
     * @memberof Store
     */
    /* istanbul ignore next */ registerImmediateListener (...params) {
        registerListener(this, 'on', ...params);
    }

    /**
     * This method is used to get the name of the property
     * from the state store.
     *
     * @param {string} propName The name of the field in state store.
     * @return {any} The value of the field.
     * @memberof Store
     */
    get (propName, subNamespace) {
        const value = this.model.prop(propName);
        return subNamespace ? value && value[subNamespace] : value;
    }

    /**
     * This method is used to register a computed property that is computed every time
     * the store value changes.
     *
     * @param {string} propName The name of the property to create.
     * @param {Function} callBack The function to execute when depemdent props change.
     * @memberof Store
     */
    computed (propName, callBack) {
        return this.model.calculatedProp(propName, callBack);
    }

    append (...params) {
        this.model.append(...params);
        return this;
    }

    unsubscribeAll () {
        Object.values(this._listeners).forEach(fn => fn());
        return this;
    }

    unsubscribe (namespaceInf = {}) {
        const { id, key } = namespaceInf;
        const listenersMap = this._listeners;
        const listeners = listenersMap.get(id);

        if (key) {
            const fn = listenersMap.get(key);

            fn && fn();
        } else {
            for (const fn of listeners.values()) {
                fn();
            }
            listenersMap.set(id, []);
        }
        return this;
    }

    removeSubNamespace (subNamespace, namespace) {
        const {
            _registeredListeners: listenerMap,
            _contextMap: contextMap,
            _propListenerMap: propListenerMap
        } = this;
        const listenersObj = listenerMap[namespace];

        for (const prop in listenersObj) {
            const { subNamespaces } = listenersObj[prop];
            const propInf = {
                subNamespace,
                prop,
                propListenerMap
            };

            if (subNamespaces[subNamespace]) {
                removePropValue(this, subNamespaces[subNamespace], propInf);
                delete subNamespaces[subNamespace];
            } else {
                for (const ns in subNamespaces) {
                    const snsMap = subNamespaces[ns];

                    removePropValue(this, snsMap, propInf);
                    if (!snsMap.size) {
                        delete subNamespaces[ns];
                    }
                }
            }
        }
        delete contextMap[namespace][subNamespace];
        return this;
    }
}

/**
 * Setter getter creator from config
 * Format
 *  PROPERTRY_NAME: {
 *      value: // default value of the property,
 *      meta: {
 *          typeCheck: // The setter value will be checked using this. If the value is function then the setter value
 *                     // is passed as args. (Optional)
 *          typeExpected: // The output of typecheck action will be tested against this. Truthy value will set the
 *                       // value to the setter
 *          sanitization: // Need for sanitization before type is checked
 *      }
 *  }
 *
 * @param {Object} holder an empty object on which the getters and setters will be mounted
 * @param {Object} options options config based on which the getters and setters are determined.
 * @param {Hyperdis} model optional model to attach the property. If not sent new moel is created.
 * @return {Array}
 */
const transactor = (holder, options, model, namespaceInf = {}) => {
    let conf;
    const store = model instanceof Store ? model : new Store({});
    const stateProps = {};
    const { namespace, subNamespace } = namespaceInf;

    for (const prop in options) {
        if ({}.hasOwnProperty.call(options, prop)) {
            conf = options[prop];
            const nameSpaceProp = namespace ? `${namespace}.${prop}` : prop;

            if (subNamespace) {
                const value = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["defaultValue"])(store.get(nameSpaceProp), {});
                value[subNamespace] = conf.value;
                stateProps[nameSpaceProp] = value;
            } else {
                stateProps[prop] = conf.value;
            }

            holder[prop] = ((context, meta, nsProp) => (...params) => {
                const paramsLen = params.length;
                if (paramsLen) {
                    const { takesMultipleParams = false } = meta || {};
                    // If parameters are passed then it's a setter
                    let val = takesMultipleParams ? params : params[0];

                    if (meta) {
                        let values;
                        const prevVal = context.get(nsProp, subNamespace);
                        const { sanitization, typeCheck, typeExpected } = meta;
                        if (typeof sanitization === 'function') {
                            // Sanitize if required
                            val = sanitization(val, prevVal, holder);
                        }

                        // Checking if a setter is valid
                        if (typeof typeCheck === 'function') {
                            const typeCheckResult = typeCheck(val);

                            if (typeCheckResult) {
                                values = val;
                            }
                        } else if (typeof typeCheck === 'string' && typeCheck === 'constructor') {
                            if (val && val.constructor.name === typeExpected) {
                                values = val;
                            }
                        } else {
                            values = val;
                        }

                        const preset = meta.preset;
                        const oldValues = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__["toArray"])(context.get(nsProp, subNamespace));
                        preset && preset(values, holder);
                        if (takesMultipleParams) {
                            oldValues.forEach((value, i) => {
                                if (values[i] === undefined) {
                                    values[i] = value;
                                }
                            });
                        }
                        values && context.commit(nsProp, values, subNamespace);
                    } else {
                        context.commit(nsProp, val, subNamespace);
                    }
                    return holder;
                }
                // No parameters are passed hence its a getter
                return context.get(nsProp, subNamespace);
            })(store, conf.meta, nameSpaceProp, Array.isArray(conf.value));
        }
    }

    if (subNamespace) {
        for (const key in stateProps) {
            store.commit(key, stateProps[key][subNamespace], subNamespace);
        }
    } else if (namespace === undefined) {
        store.append(stateProps);
    } else {
        store.append(namespace, stateProps);
    }

    return [holder, store];
};


/***/ }),

/***/ "./packages/muze/package.json":
/*!************************************!*\
  !*** ./packages/muze/package.json ***!
  \************************************/
/*! exports provided: name, private, version, description, homepage, author, license, contributors, main, keywords, repository, dependencies, default */
/***/ (function(module) {

module.exports = {"name":"muze","private":true,"version":"1.2.1","description":"Composable visualisation library for web with a data-first approach","homepage":"https://muzejs.org","author":"Muzejs.org (https://muzejs.org/)","license":"MIT","contributors":[{"name":"Akash Ghoswami","email":"akashgoswami90s@gmail.com"},{"name":"Ranajit Banerjee","email":"ranajit.113124@gmail.com","url":"https://github.com/ranajitbanerjee"},{"name":"Mridul Meharia","email":"mehariamridul@gmail.com","url":"https://github.com/mridulmeh"},{"name":"Subhash Haldar"},{"name":"Sandeep Acharya"},{"name":"Rousan Ali","email":"rousanali786@gmail.com","url":"https://rousan.io"},{"name":"Ujjal Kumar Dutta","email":"duttaujjalkumar@live.com"}],"main":"src/index.js","keywords":["muze","svg","vector","graphics","data-visualization","visualization","renderer","fusioncharts","relational","algebra","relation"],"repository":{"type":"git","url":"https://github.com/chartshq/muze"},"dependencies":{"@chartshq/layout":"^1.0.0","@chartshq/muze-firebolt":"^1.0.0","@chartshq/muze-legend":"^1.0.0","muze-utils":"^1.0.0","@chartshq/visual-cell":"^1.0.0","@chartshq/visual-group":"^1.0.0","@chartshq/visual-layer":"^1.0.0","@chartshq/visual-unit":"^1.0.0"}};

/***/ }),

/***/ "./packages/muze/src/action-model.js":
/*!*******************************************!*\
  !*** ./packages/muze/src/action-model.js ***!
  \*******************************************/
/*! exports provided: actionModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionModel", function() { return actionModel; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const defaultPolicy = (registrableComponents) => {
    const aliases = registrableComponents.map(comp => comp.alias());
    return {
        behaviours: {
            '*': (propagationPayload) => {
                const propagationCanvas = propagationPayload.sourceCanvas;
                return propagationCanvas ? aliases.indexOf(propagationCanvas) !== -1 : true;
            }
        }
    };
};

const listenerFn = (canvas, fn) => () => {
    const valueMatrix = canvas.composition().visualGroup.matrixInstance().value;
    valueMatrix.each(cell => fn(cell.valueOf().firebolt()));
};

const canvasIterator = (canvases, iteratorFn, cFn) => {
    canvases.forEach((canvas) => {
        const matrix = canvas.composition().visualGroup.matrixInstance().value;
        matrix.each(cell => iteratorFn(cell.valueOf().firebolt()));
        cFn && cFn(canvas);
        // Also register actions on canvas update
        const throwback = canvas._throwback;

        throwback.registerImmediateListener([muze_utils__WEBPACK_IMPORTED_MODULE_0__["CommonProps"].MATRIX_CREATED],
            listenerFn(canvas, iteratorFn));
    });
};

const registerActions = (context, type, fnName, deps) => {
    const canvases = context._registrableComponents;

    canvases.forEach((canvas) => {
        const vGroup = canvas.composition().visualGroup;

        vGroup.resolver().setFireboltDependencies(type, deps);
        canvas.firebolt()[fnName](deps);
    });
};

/**
 * This class is initiated only once in lifecycle and is reponsible for regisration of physical and behavioural
 * actions and side effects and the mapping between them.
 *
 * To get the instance of action model
 * ```
 *  const ActionModel = muze.ActionModel;
 * ```
 *
 * @public
 * @module ActionModel
 */
class ActionModel {
    constructor () {
        this._registrableComponents = [];
    }

    /**
     * Takes an array of canvases on which the physical and behavioural actions will get registered.
     *
     * @public
     * @param  {Canvas} components Array of canvases
     *
     * @return {ActionModel} Instance of action model.
     */
    for (...components) {
        this._registrableComponents = components;
        return this;
    }

    /**
     * Registers physical actions on the canvases. It takes an object with key as the name of action and value having
     * the definition of the action.
     *
     * To register a {@link PhysicalAction},
     * ```
     *  const ActionModel = muze.ActionModel;
     *  ActionModel
     *       // Physical actions will be registered on these canvases.
     *      .for(canvas)
     *      .registerPhysicalActions({
     *          // Key is the name of physical action.
     *          ctrlClick: (firebolt) => (targetEl, behaviours) => {
     *              targetEl.on('click', function (data) {
     *                  const event = utils.getEvent();
     *                  const pos = utils.getClientPoint(event, this);
     *                  // Get the data point nearest to the mouse position.
     *                  const nearestPoint = firebolt.context.getNearestPoint(pos, {
     *                      data
     *                  });
     *                  // Prepare the payload
     *                  const payload = {
     *                      criteria: nearestPoint.id
     *                  };
     *                  behaviours.forEach((behaviour) => firebolt.dispatchBehaviour(behaviour, payload));
     *              });
     *          }
     *      });
     * ```
     * @public
     *
     * @param {Object} action Names of physical actions and their definitions.
     *
     * @return {ActionModel} Instance of the action model.
     */
    registerPhysicalActions (action) {
        registerActions(this, 'physicalActions', 'registerPhysicalActions', action);
        return this;
    }

    /**
     * Registers behavioural actions on the canvases. It takes definitions of the behavioural actions and registers
     * them on the canvases. Every behavioural action must inherit the {@link GenericBehaviour} class.
     *
     * To register a behavioural action
     * ```
     *  // Define a new behavioural action
     *  class SingleSelectBehaviour extends GenericBehaviour {
     *      static formalName () {
     *          return 'singleSelect';
     *      }
     *
     *      setSelectionSet (addSet, selectionSet) {
     *          if (addSet === null) {
     *              selectionSet.reset();
     *          } else if (addSet.length) {
     *              const existingAddSet = selectionSet.getExistingEntrySet(addSet);
     *              if (existingAddSet.length){
     *                  selectionSet.reset();
     *              } else {
     *               selectionSet.add(addSet);
     *              }
     *          } else {
     *              selectionSet.reset();
     *          }
     *      }
     * }
     * muze.ActionModel.registerBehaviouralActions(SingleSelectBehaviour);
     * ```
     *
     * @public
     *
     * @param {GenericBehaviour} actions Definition of behavioural actions.
     *
     * @return {ActionModel} Instance of action model.
     */
    registerBehaviouralActions (...actions) {
        registerActions(this, 'behaviouralActions', 'registerBehaviouralActions', actions);
        return this;
    }

    /**
     * Registers the mapping of physical and behavioural actions. This mapping is used to establish which behavioural
     * actions should be dispatched on any triggering of physical actions.
     *
     * To map physical actions with behavioural actions,
     * ```
     *  muze.ActionModel.registerPhysicalBehaviouralMap({
     *      ctrlClick: {
     *          behaviours: ['select'] // This array must be the formal names of the behavioural actions.
     *      }
     *  });
     * ```
     *
     * @public
     * @param {Object} map Contains the physical and behavioural action map.
     * ```
     *   {
     *      // Name of the physical action
     *      click: {
     *          // Target element selector. This is an optional field. If not passed, then by default takes the
     *          // container element of visual unit.
     *          target: '.muze-layers-area path',
     *          // Behaviours which should be dispatched on triggering of the mapped physical action.
     *          behaviours: ['select']
     *      }
     *   }
     * ```
     *
     * @return {ActionModel} Instance of action model.
     */
    registerPhysicalBehaviouralMap (map) {
        canvasIterator(this._registrableComponents, (firebolt) => {
            firebolt.registerPhysicalBehaviouralMap(map);
        }, (canvas) => {
            canvas.firebolt().registerPhysicalBehaviouralMap(map);
        });
        return this;
    }

    /**
     * Registers what behaviour to propagate on dispatch of a certain behavioural action. By default, when any
     * behavioural action is dispatched, then the same behavioural action gets propagated to all the other canvases.
     * This can be changed using this api.
     *
     * To register what behaviour should be propagated on dispatch of any behavioural action,
     * ```
     *  ActionModel.for(canvas1, canvas2).registerPropagationBehaviourMap({
     *      select: 'filter',
     *      brush: 'filter'
     *  });
     * ```
     *
     * @public
     * @param {Object} map Propagation behaviour map.
     *
     * @return {ActionModel} Instance of action model.
     */
    registerPropagationBehaviourMap (map) {
        canvasIterator(this._registrableComponents, (firebolt) => {
            firebolt.registerPropagationBehaviourMap(map);
        }, (canvas) => {
            canvas.firebolt().registerPropagationBehaviourMap(map);
        });

        return this;
    }

    /**
     * Registers the mapping of side effects and behavioural actions. It takes an object which contains key as the
     * name of behavioural action and the side effects which will be linked to it.
     *
     * To map side effects to select behaviour,
     * ```
     *  muze.ActionModel.mapSideEffects({
     *      select: ['infoBox'] // This array must be the formal names of the side effects
     *  });
     * ```
     *
     * To map side effects to select behaviour, but disable all the default side effects attached with this behaviour,
     * ```
     *  muze.ActionModel.mapSideEffects({
     *      select: {
     *          effects: ['infoBox'],
     *          preventDefaultActions: true
     *      }
     *  });
     * @public
     * @param {Object} map Mapping of behavioural actions and side effects.
     * ```
     *     {
     *          select: ['infoBox']
     *     }
     * ```
     * @return {ActionModel} Instance of action model.
     */
    mapSideEffects (map) {
        canvasIterator(this._registrableComponents, (firebolt) => {
            firebolt.mapSideEffects(map);
        }, (canvas) => {
            canvas.firebolt().mapSideEffects(map);
        });
        return this;
    }

    /**
     * Registers the side effects on the registered canvases. It takes definitions of side effects and registers them
     * on the canvases. Every side effect must inherit the base class {@link GenericSideEffect} or
     * {@link SpawnableSideEffect} or {@link SurrogateSideEffect} class.
     *
     * ```
     * // Define a custom side effect
     *  class InfoBox extends SpawnableSideEffect {
     *      static formalName () {
     *          return 'infoBox';
     *      }
     *
     *      apply (selectionSet) {
     *      }
     *  }
     *  muze.ActionModel.registerSideEffects(InfoBox);
     * ```
     * @public
     * @param  {GenericSideEffect} sideEffects Definition of side effects.
     *
     * @return {ActionModel} Instance of action model.
     */
    registerSideEffects (...sideEffects) {
        registerActions(this, 'sideEffects', 'registerSideEffects', sideEffects);
        return this;
    }

    /**
     * Breaks the link between behavioural actions and physical actions. It takes an array of behavioural action
     * and it's physical action.
     *
     * To dissociate behavioural actions from physical actions
     * ```
     *  muze.ActionModel.dissociateBehaviour(['select', 'click'], ['highlight', 'hover']);
     * ```
     * @public
     * @param  {Array} maps Array of behavioural action and physical action.
     *
     * @return {ActionModel} Instance of action model.
     */
    dissociateBehaviour (...maps) {
        canvasIterator(this._registrableComponents, (firebolt) => {
            maps.forEach(val => firebolt.dissociateBehaviour(val[0], val[1]));
        }, (canvas) => {
            maps.forEach(val => canvas.firebolt().dissociateBehaviour(val[0], val[1]));
        });
        return this;
    }

    /**
     * Breaks the link between side effects and behavioural actions. It takes an array of formal names of the side
     * effects and it's linked behavioural action.
     *
     * To dissociate side effects from behavioural actions
     * ```
     *  muze.ActionModel.dissociateSideEffect(['crossline', 'highlight'], ['selectionBox', 'brush']);
     * ```
     * @public
     * @param  {Array} maps Array of side effects and behavioural actions.
     *
     * @return {ActionModel} Instance of action model.
     */
    dissociateSideEffect (...maps) {
        canvasIterator(this._registrableComponents, (firebolt) => {
            maps.forEach(val => firebolt.dissociateSideEffect(val[0], val[1]));
        }, (canvas) => {
            maps.forEach(val => canvas.firebolt().dissociateSideEffect(val[0], val[1]));
        });
        return this;
    }

    /**
     * By default cross interactivity is disabled between canvases. This enables cross interaction between the canvases
     * so that any action happening in one canvas gets dispatched on other canvases as well. An optional policy can also
     * be passed in this method. The policy can be used to control on which canvases the behavioural actions and
     * side effects gets dispatched.
     *
     * To just enable cross interactivity between two canvases,
     * ```
     *  ActionModel.for(canvas1, canvas2)
     *      .enableCrossInteractivity();
     * ```
     *
     * To enable cross interactivity but enable any behavioural action only when it is triggered from canvas1.
     * ```
     *  ActionModel.for(canvas1, canvas2)
     *      .enableCrossInteractivity({
     *          behaviours: {
     *              // Here * stands for any behavioural action name. We can also give any name of behavioural action
     *              // in place of this.
     *              '*': (propPayload, context) => {
     *                  return propPayload.sourceCanvas === canvas1.alias();
     *              }
     *          }
     *      });
     * ```
     *
     * To enable cross interactivity but enable tooltip effect if the action is propagated from canvas1,
     * ```
     *  ActionModel.for(canvas1, canvas2)
     *      .enableCrossInteractivity({
     *          sideEffects: {
     *              tooltip: (propPayload, context) => {
     *                  return propPayload.sourceCanvas === canvas1.alias();
     *              }
     *          }
     *      });
     * ```
     * @public
     * @param {Object} policy Policy definition.
     *
     * @return {ActionModel} Instance of action model.
     */
    enableCrossInteractivity (policy = {}) {
        const registrableComponents = this._registrableComponents;
        const mergedPolicy = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, defaultPolicy(registrableComponents)), policy);

        registrableComponents.forEach((canvas) => {
            canvas.firebolt().crossInteractionPolicy(mergedPolicy);
        });

        return this;
    }
}

const actionModel = (() => new ActionModel())();


/***/ }),

/***/ "./packages/muze/src/canvas/app-state.js":
/*!***********************************************!*\
  !*** ./packages/muze/src/canvas/app-state.js ***!
  \***********************************************/
/*! exports provided: APP_INITIAL_STATE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "APP_INITIAL_STATE", function() { return APP_INITIAL_STATE; });
const APP_INITIAL_STATE = {
    app: {
        group: {},
        units: {},
        layers: {},
        canvas: {}
    },
    local: {
        canvas: {},
        group: {},
        units: {},
        layers: {}
    }
};



/***/ }),

/***/ "./packages/muze/src/canvas/canvas.js":
/*!********************************************!*\
  !*** ./packages/muze/src/canvas/canvas.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Canvas; });
/* harmony import */ var _chartshq_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/layout */ "./packages/layout/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _transaction_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction-support */ "./packages/muze/src/transaction-support.js");
/* harmony import */ var _layout_maker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layout-maker */ "./packages/muze/src/canvas/layout-maker.js");
/* harmony import */ var _local_options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./local-options */ "./packages/muze/src/canvas/local-options.js");
/* harmony import */ var _firebolt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./firebolt */ "./packages/muze/src/canvas/firebolt/index.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../options */ "./packages/muze/src/options.js");
/* harmony import */ var _app_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./app-state */ "./packages/muze/src/canvas/app-state.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./helper */ "./packages/muze/src/canvas/helper.js");











/**
 * Canvas is a logical component which houses a visualization by taking multiple variable in different encoding channel.
 * Canvas manages lifecycle of many other logical component and exposes one consistent interface for creation of chart.
 * Canvas is intialized from environment with settings from environment and singleton dependencies.
 *
 * To create an instance of canvas
 * ```
 *  const env = Muze();
 *  const canvas = env.canvas()
 * ```
 *
 *
 * @class
 * @public
 * @module Canvas
 */
class Canvas extends _transaction_support__WEBPACK_IMPORTED_MODULE_4__["default"] {

    /**
     * Creates reactive property accessors.
     * - data
     * - height
     * - width
     * - config
     * This configs are retrieved from options.
     */
    constructor (globalDependencies) {
        super();

        this._allOptions = Object.assign({}, _options__WEBPACK_IMPORTED_MODULE_8__["default"], _local_options__WEBPACK_IMPORTED_MODULE_6__["localOptions"]);
        this._registry = {};
        this._composition = {};
        this._cachedProps = {};
        this._alias = null;
        this._renderedResolve = null;
        this._renderedPromise = new Promise((resolve) => {
            this._renderedResolve = resolve;
        });
        this._composition.layout = new _chartshq_layout__WEBPACK_IMPORTED_MODULE_0__["GridLayout"]();
        this._store = new muze_utils__WEBPACK_IMPORTED_MODULE_1__["Store"](_app_state__WEBPACK_IMPORTED_MODULE_9__["APP_INITIAL_STATE"]);

        this._throwback = new muze_utils__WEBPACK_IMPORTED_MODULE_1__["Store"]({
            [muze_utils__WEBPACK_IMPORTED_MODULE_1__["CommonProps"].MATRIX_CREATED]: false,
            [muze_utils__WEBPACK_IMPORTED_MODULE_1__["CommonProps"].ON_LAYER_DRAW]: null
        });

        // Setters and getters will be mounted on this. The object will be mutated.
        const namespace = muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].CANVAS_LOCAL_NAMESPACE;
        const allOptions = Object.assign({}, _options__WEBPACK_IMPORTED_MODULE_8__["default"], _local_options__WEBPACK_IMPORTED_MODULE_6__["localOptions"], _local_options__WEBPACK_IMPORTED_MODULE_6__["canvasOptions"]);

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["transactor"])(this, allOptions, this._store, {
            namespace
        });

        this.dependencies(Object.assign({}, globalDependencies, this._dependencies));
        this.firebolt(new _firebolt__WEBPACK_IMPORTED_MODULE_7__["default"](this, {
            behavioural: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["behaviouralActions"],
            physical: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["physicalActions"],
            physicalBehaviouralMap: {}
        }, _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["sideEffects"], _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["behaviourEffectMap"]));
        this.alias(`canvas-${Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getUniqueId"])()}`);
        this.title('', {});
        this.subtitle('', {});
        this.legend({});
        this.color({});
        this.shape({});
        this.size({});
        Object(_helper__WEBPACK_IMPORTED_MODULE_10__["setupChangeListener"])(this);
         // init layoutManager
        this._layoutManager = Object(_helper__WEBPACK_IMPORTED_MODULE_10__["createLayoutManager"])();
    }

    /**
     * Retrieves an instance of layout which is responsible for layouting. Layout is responsible for creating faceted
     * presentation using table layout.
     *
     * @public
     *
     * @return {GridLayout} Instance of layout attached to canvas.
     */
    layout (...params) {
        if (params.length) {
            return this;
        }
        return this.composition().layout;
    }

    /**
     * Retrieves the composition for a canvas
     *
     * @public
     *
     * @return {object} Instances of the components which canvas requires to draw the full visualization.
     *      ```
     *          {
     *              layout: // Instance of {@link GridLayout}
     *              legend: // Instance of {@link Legend}
     *              subtitle: // Instance of {@link TextCell} using which the title is rendered
     *              title: // Instance of {@link TextCell} using which the title is rendered
     *              visualGroup: // Instance of {@link visualGroup}
     *          }
     *      ```
     */
    composition (...params) {
        if (params.length) {
            return this;
        }
        return this._composition;
    }

    done () {
        return this._renderedPromise;
    }

    /**
     * Sets or gets the alias of the canvas. Alias is a name by which the canvas can be referred.
     *
     * When setter
     * @param {string} alias Name of the alias.
     *
     * @return {Canvas} Instance of the canvas.
     *
     * When getter
     *
     * @return {string} Alias of canvas.
     *
     * @public
     */
    alias (...params) {
        if (params.length) {
            const visualGroup = this.composition().visualGroup;
            this._alias = params[0];
            visualGroup && visualGroup.alias(this.alias());
            return this;
        }
        return this._alias;
    }

    /**
     * Creates an instance initiated with given settings.
     *
     * @param {Object} initialSettings Initial settings to be populated in the model
     * @param {Object} regEntry newly created instance with the initial settings
     * @param {Object} globalDependencies dependencies which will be created only once in the page
     *
     * @return {Object} newly created instance with the initial settings
     */
    static withSettings (initialSettings, regEntry, globalDependencies) {
        const instance = new Canvas(globalDependencies);

        for (const key in initialSettings) {
            instance[key](initialSettings[key]);
        }
        // set registry for instance
        instance.registry(regEntry);
        return instance;
    }

    /**
     *
     *
     * @static
     *
     * @memberof Canvas
     */
    static formalName () {
        return 'canvas';
    }

    /**
     * Returns the instance of firebolt associated with this canvas. The firebolt instance can be used to dispatch a
     * behaviour dynamically on the canvas. This firebolt does not handle any physical actions. It is just used to
     * propagate the action to all the visual units in it's composition.
     *
     * @public
     *
     * @return {GroupFireBolt} Instance of firebolt associated with canvas.
     */
    firebolt (...firebolt) {
        if (firebolt.length) {
            this._firebolt = firebolt[0];
            return this;
        }
        return this._firebolt;
    }

    /**
     * Registry peoperty accessor
     *
     * @param {Object} reg plain old javascript object keyvalue pairs. Key containing module name and value contains
     * module definition class. The reg object has to be flat object of level 1.
     */
    registry (...params) {
        if (params.length) {
            const components = Object.assign({}, params[0].components);
            const componentSubRegistry = Object.assign({}, params[0].componentSubRegistry);

            this._registry = { components, componentSubRegistry };
            const initedComponents = Object(_helper__WEBPACK_IMPORTED_MODULE_10__["initCanvas"])(this);
            // @todo is it okay to continue this tight behaviour? If not use a resolver to resolve diff component type.
            this._composition.visualGroup = initedComponents[0];
            Object(_helper__WEBPACK_IMPORTED_MODULE_10__["createGroupState"])(this);
            this.composition().visualGroup.alias(this.alias()).store(this._store);
            return this;
        }
        return this._registry;
    }

    /*
     * Prepare dependencies for top level elements
     */
    dependencies (...param) {
        if (param.length) {
            this._dependencies = param[0];
            return this;
        }
        // @todo prepare dependencies here.
        return this._dependencies;
    }

    /**
     *
     *
     * @param {*} lifeCycles
     *
     * @memberof Canvas
     */
    lifeCycle (lifeCycles) {
        const lifeCycleManager = this.dependencies().lifeCycleManager;
        if (lifeCycles) {
            lifeCycleManager.register(lifeCycles);
            return this;
        }
        return lifeCycleManager;
    }

    /**
     *
     *
     * @readonly
     * @memberof Canvas
     */
    legend (...params) {
        if (params.length) {
            return this;
        }
        return this.composition().legend;
    }

    /**
     * Returns a promise for various {@link LifecycleEvents} of the various components of canvas. The promise gets
     * resolved once the particular event gets completed.
     *
     * To use this,
     * ```
     *      canvas.once('layer.drawn').then(() => {
     *          // Do any post drawing work here.
     *      });
     * ```
     * @public
     *
     * @param {string} eventName Name of the lifecycle event.
     *
     * @return {Promise} A pending promise waiting for resolve to be called.
     */
    once (eventName) {
        const lifeCycleManager = this.dependencies().lifeCycleManager;
        return lifeCycleManager.retrieve(eventName);
    }

    /**
     * Internal function to trigger render, this method is cognizant of all the properties of the core modules and
     * establish a passive reactivity. Passive reactivity is not always a bad thing :)
     * @internal
     */
    render () {
        const mount = this.mount();
        // removeChild(mount);
        const lifeCycleManager = this.dependencies().lifeCycleManager;
        // Get render details including arrangement and measurement
        const renderDetails = Object(_layout_maker__WEBPACK_IMPORTED_MODULE_5__["getRenderDetails"])(this, mount);
        lifeCycleManager.notify({ client: this, action: 'beforedraw' });
        // Prepare the layout by triggering the matrix calculation
        Object(_layout_maker__WEBPACK_IMPORTED_MODULE_5__["prepareLayout"])(this.layout(), renderDetails);

        this._layoutManager.dimension({
            height: renderDetails.measurement.canvasHeight,
            width: renderDetails.measurement.canvasWidth
        });

        this._layoutManager.renderAt(mount);

        // Render each component
        Object(_layout_maker__WEBPACK_IMPORTED_MODULE_5__["renderLayout"])(this, renderDetails);

        Object(_helper__WEBPACK_IMPORTED_MODULE_10__["setLayoutInfForUnits"])(this);

        // setLabelRotation
        Object(_helper__WEBPACK_IMPORTED_MODULE_10__["setLabelRotationForAxes"])(this);
    }

    /**
     * Returns the instances of x axis of the canvas. It returns the instances in a two dimensional array form.
     *
     * ```
     *   // The first element in the sub array represents the top axis and the second element represents the bottom
     *   // axis.
     *   [
     *      [X1, X2],
     *      [X3, X4]
     *   ]
     * ```
     * @public
     *
     * @return {Array.<Array>} Instances of x axis.
     */
    xAxes () {
        return this.composition().visualGroup.getAxes('x');
    }

    /**
     * Returns the instances of y axis of the canvas. It returns the instances in a two dimensional array form.
     *
     * ```
     *   // The first element in the sub array represents the left axis and the second element represents the right
     *   // axis.
     *   [
     *      [Y1, Y2],
     *      [Y3, Y4]
     *   ]
     * ```
     * @public
     * @return {Array.<Array>} Instances of y axis.
     */
    yAxes () {
        return this.composition().visualGroup.getAxes('y');
    }

    /**
     * Returns all the retinal axis of the canvas. Color, shape and size axis are combinedly called retinal axis.
     *
     * @public
     * @return {Object} Instances of retinal axis.
     *          ```
     *              {
     *                  color: [ColorAxis], // Array of color axis.
     *                  shape: [ShapeAxis], // Array of shape axis.
     *                  size: [SizeAxis] // Array of size axis.
     *              }
     *          ```
     */
    getRetinalAxes () {
        const visualGroup = this.composition().visualGroup;
        return visualGroup.getAxes(_constants__WEBPACK_IMPORTED_MODULE_3__["RETINAL"]);
    }

    mount (...params) {
        if (params.length) {
            let value = params[0];
            if (typeof params[0] === 'string') {
                value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["selectElement"])(params[0]).node();
            }
            this._mount = value;
            return this;
        }
        return this._mount;
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/component-resolver.js":
/*!********************************************************!*\
  !*** ./packages/muze/src/canvas/component-resolver.js ***!
  \********************************************************/
/*! exports provided: arrangeComponents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrangeComponents", function() { return arrangeComponents; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");


/**
 *
 *
 * @param {*} context
 *
 */
const arrangeComponents = (context) => {
    const legendConfig = context.config().legend;
    const titleConfig = context.title()[1];
    const subtitleConfig = context.subtitle()[1];
    const titleLayouts = {
        [`${_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}-${_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}`]: [_constants__WEBPACK_IMPORTED_MODULE_0__["TITLE"], _constants__WEBPACK_IMPORTED_MODULE_0__["SUB_TITLE"], _constants__WEBPACK_IMPORTED_MODULE_0__["GROUP"]],
        [`${_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}-${_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}`]: [_constants__WEBPACK_IMPORTED_MODULE_0__["GROUP"], _constants__WEBPACK_IMPORTED_MODULE_0__["SUB_TITLE"], _constants__WEBPACK_IMPORTED_MODULE_0__["TITLE"]],
        [`${_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}-${_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}`]: [_constants__WEBPACK_IMPORTED_MODULE_0__["TITLE"], _constants__WEBPACK_IMPORTED_MODULE_0__["GROUP"], _constants__WEBPACK_IMPORTED_MODULE_0__["SUB_TITLE"]],
        [`${_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]}-${_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]}`]: [_constants__WEBPACK_IMPORTED_MODULE_0__["SUB_TITLE"], _constants__WEBPACK_IMPORTED_MODULE_0__["GROUP"], _constants__WEBPACK_IMPORTED_MODULE_0__["TITLE"]]
    };
    const legendLayouts = [
        [_constants__WEBPACK_IMPORTED_MODULE_0__["LEGEND"], _constants__WEBPACK_IMPORTED_MODULE_0__["LAYOUT"]],
        [_constants__WEBPACK_IMPORTED_MODULE_0__["LAYOUT"], _constants__WEBPACK_IMPORTED_MODULE_0__["LEGEND"]]
    ];
    const titlePosition = titleConfig.position || _constants__WEBPACK_IMPORTED_MODULE_0__["TOP"];
    const subtitlePosition = subtitleConfig.position || _constants__WEBPACK_IMPORTED_MODULE_0__["TOP"];

    return {
        headers: titleLayouts[`${titlePosition}-${subtitlePosition}`],
        legends: legendConfig.position === _constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"] || legendConfig.position === _constants__WEBPACK_IMPORTED_MODULE_0__["TOP"] ?
        legendLayouts[0] : legendLayouts[1]
    };
};


/***/ }),

/***/ "./packages/muze/src/canvas/component-wrapper-maker.js":
/*!*************************************************************!*\
  !*** ./packages/muze/src/canvas/component-wrapper-maker.js ***!
  \*************************************************************/
/*! exports provided: componentWrapperMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentWrapperMaker", function() { return componentWrapperMaker; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _components_headerComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/headerComponent */ "./packages/muze/src/canvas/components/headerComponent.js");
/* harmony import */ var _components_legendComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/legendComponent */ "./packages/muze/src/canvas/components/legendComponent.js");
/* harmony import */ var _components_scroll_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/scroll-component */ "./packages/muze/src/canvas/components/scroll-component.js");
/* harmony import */ var _components_grid_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/grid-component */ "./packages/muze/src/canvas/components/grid-component.js");
/* harmony import */ var _components_message_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/message-component */ "./packages/muze/src/canvas/components/message-component.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./defaults */ "./packages/muze/src/canvas/defaults.js");
/* harmony import */ var _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../layout/src/enums/constants */ "./packages/layout/src/enums/constants.js");









// Mapping between types of headers and their required configs for wrapper creation
const headerMap = {
    title: {
        headerCell: 'titleCell',
        configType: _defaults__WEBPACK_IMPORTED_MODULE_6__["TITLE_CONFIG"]
    },
    subtitle: {
        headerCell: 'subtitleCell',
        configType: _defaults__WEBPACK_IMPORTED_MODULE_6__["SUB_TITLE_CONFIG"]
    }
};

// Mapping of header alignment values
const headerAlignmentMap = {
    [_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: _constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"],
    [_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: _constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"],
    [_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__["CENTER"]]: _constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL_CENTER"]
};

/**
 * returns if data is Valid
 *
 *
 * @param {Object} params object where data has to be checked for validity
 * @return {Boolean} Returns true if all of the params are valid
 */
const checkParamsValidation = params => Object.keys(params).every((param => params[param]));

/**
 * returns if message Component is needed or not
 *
 *
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @return {Boolean} Returns if grid is present
 */
const isGridPresent = (renderDetails) => {
    const { rows, columns, values } = renderDetails.components;
    return checkParamsValidation({ rows, columns, values });
};

/**
 * Creates the wrapper for the header, i.e., title and subtitle to be used in the tree layout
 *
 *
 * @param {string} headerType type of header: title/subtite
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @return {Instance} Returns the respective wrappers
 */
const createHeaderWrapper = (headerType, layoutManager, renderDetails) => {
    let wrapper = null;

    const { components, layoutConfig } = renderDetails;
    const { headerCell, configType } = headerMap[headerType];
    const target = { target: _defaults__WEBPACK_IMPORTED_MODULE_6__["CANVAS"] };

    if (components.headers && components.headers[headerCell]) {
        let headerConfig = layoutConfig[headerType];
        const header = components.headers[headerCell];

        headerConfig = Object.assign({}, headerConfig, {
            classPrefix: layoutConfig.classPrefix,
            ...target,
            alignWith: `${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__["ROW_MATRIX_INDEX"][0]}-${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__["COLUMN_MATRIX_INDEX"][1]}`,
            alignment: headerAlignmentMap[headerConfig.align],
            className: configType.className
        });

        const wrapperParams = {
            name: headerType,
            component: header,
            config: headerConfig
        };

        const existingComponent = layoutManager.getComponent(headerType);
        if (existingComponent) {
            wrapper = existingComponent
                        .updateWrapper(wrapperParams);
        } else {
            wrapper = new _components_headerComponent__WEBPACK_IMPORTED_MODULE_1__["default"](wrapperParams);
        }
    }
    return wrapper;
};

/**
 * Creates the wrapper for the grid layout to be used in the tree layout
 *
 *
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {GridLayout} canvas canvas instance
 * @return {Instance} Returns the respective wrappers
 */
const createMessageWrapper = (layoutManager, canvas, renderDetails, renderGrid) => {
    const headerValues = Object.values(renderDetails.components.headers);
    let sum = 0;
    let messageWrapper = null;

    for (const val of headerValues) {
        sum += val.logicalSpace().height;
    }

    if (!renderGrid) {
        const defaultDimensions = { height: canvas.height() - sum, width: canvas.width() };
        const gridComponent = layoutManager.getComponent(_constants__WEBPACK_IMPORTED_MODULE_0__["GRID"]);
        const { height, width } = (gridComponent && gridComponent.getBoundBox()) || defaultDimensions;
        const target = { target: _defaults__WEBPACK_IMPORTED_MODULE_6__["CANVAS"] };
        const config = {
            ...target,
            dimensions: { height, width },
            message: _constants__WEBPACK_IMPORTED_MODULE_0__["NO_DATA_MESSAGE"],
            classPrefix: _defaults__WEBPACK_IMPORTED_MODULE_6__["MESSAGE_CONFIG"],
            position: _constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]
        };
        const wrapperParams = {
            name: _constants__WEBPACK_IMPORTED_MODULE_0__["MESSAGE"],
            component: null,
            config
        };
        const existingComponent = layoutManager.getComponent(_constants__WEBPACK_IMPORTED_MODULE_0__["MESSAGE"]);

        if (existingComponent) {
            messageWrapper = existingComponent.updateWrapper(wrapperParams);
        } else {
            messageWrapper = new _components_message_component__WEBPACK_IMPORTED_MODULE_5__["default"](wrapperParams);
        }
        return messageWrapper;
    }
    return null;
};

// Mapping between types of scrollBars and their required configs for wrapper creation
const scrollBarMap = config => ({
    vertical: {
        componentName: 'verticalScrollBar',
        width: 'thickness',
        height: 'layoutBasedMeasure',
        layoutBasedMeasure: _constants__WEBPACK_IMPORTED_MODULE_0__["HEIGHT"],
        viewMeasure: 'viewHeight',
        rowAlign: 1,
        colAlign: config.align === 'right' ? 2 : 0,
        position: config.align,
        alignment: _constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]
    },
    horizontal: {
        componentName: 'horizontalScrollBar',
        width: 'layoutBasedMeasure',
        layoutBasedMeasure: _constants__WEBPACK_IMPORTED_MODULE_0__["WIDTH"],
        viewMeasure: 'viewWidth',
        height: 'thickness',
        rowAlign: config.align === 'top' ? 0 : 2,
        colAlign: 1,
        position: config.align,
        alignment: _constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]
    }
});

/**
 * Creates the wrapper for the scroller, i.e., horizontal and vertical to be used in the tree layout
 *
 *
 * @param {string} scrollBarType type of scrollbar: horizontal/vertical
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @param {GridLayout} grid Instance of the grid layout
 * @return {Instance} Returns the respective wrappers
 */
const createScrollBarWrapper = (scrollBarType, layoutManager, renderDetails, grid, renderGrid) => {
    if (renderGrid) {
        let scrollBarWrapper = null;
        const { layoutConfig } = renderDetails;
        const target = { target: _defaults__WEBPACK_IMPORTED_MODULE_6__["CANVAS"] };
        const { scrollBar } = layoutConfig;
        const { layoutDimensions } = grid.viewInfo();
        const {
            actualCenterMeasures,
            unitHeights,
            unitWidths
        } = layoutDimensions;
        const {
            componentName, layoutBasedMeasure, width, height, rowAlign, colAlign,
            viewMeasure, position, alignment
        } = scrollBarMap(scrollBar[scrollBarType])[scrollBarType];
        const dimensions = {
            thickness: scrollBar.thickness,
            layoutBasedMeasure: layoutDimensions[viewMeasure][1]
        };
        const isScroll = grid.scrollInfo()[scrollBarType];
        const totalLength = actualCenterMeasures[layoutBasedMeasure];
        const viewLength = layoutDimensions[viewMeasure][1];

        const scrollConfig = Object.assign({}, {
            classPrefix: layoutConfig.classPrefix,
            ...target,
            scrollBarComponentConfig: {
                ...scrollBar,
                classPrefix: layoutConfig.classPrefix
            },

            type: scrollBarType,
            alignWith: `${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__["ROW_MATRIX_INDEX"][rowAlign]}-${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_7__["COLUMN_MATRIX_INDEX"][colAlign]}`,
            alignment,
            position
        });

        const wrapperParams = {
            name: componentName,
            config: scrollConfig,
            dimensions: {
                width: dimensions[width],
                height: dimensions[height],
                totalLength,
                viewLength,
                unitHeights,
                unitWidths
            }
        };

        const existingComponent = layoutManager.getComponent(componentName);

        if (!isScroll) {
            existingComponent && existingComponent.remove();
            return null;
        }

        if (existingComponent) {
            scrollBarWrapper = existingComponent
                                    .updateWrapper(wrapperParams);
        } else {
            scrollBarWrapper = new _components_scroll_component__WEBPACK_IMPORTED_MODULE_3__["default"](wrapperParams);
        }

        return scrollBarWrapper;
    }
    return null;
};

/**
 * Creates the wrapper for the legend to be used in the tree layout
 *
 *
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @return {Instance} Returns the respective wrappers
 */
const createLegendWrapper = (layoutManager, renderDetails, renderGrid) => {
    if (renderGrid) {
        let legendWrapper = null;
        const { components, layoutConfig, measurement } = renderDetails;
        const target = { target: _defaults__WEBPACK_IMPORTED_MODULE_6__["CANVAS"] };

        if (components.legends && components.legends.length) {
            const legendConfig = { ...layoutConfig.legend, ...target, measurement };
            const wrapperParams = {
                name: _constants__WEBPACK_IMPORTED_MODULE_0__["LEGEND"],
                component: components.legends,
                config: legendConfig
            };

            const existingComponent = layoutManager.getComponent(_constants__WEBPACK_IMPORTED_MODULE_0__["LEGEND"]);

            if (existingComponent) {
                legendWrapper = existingComponent
                        .updateWrapper(wrapperParams);
            } else {
                legendWrapper = new _components_legendComponent__WEBPACK_IMPORTED_MODULE_2__["default"](wrapperParams);
            }
        }
        return legendWrapper;
    }
    return null;
};

/**
 * Creates the wrapper for the grid layout to be used in the tree layout
 *
 *
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @param {GridLayout} grid Instance of the grid layout
 * @return {Instance} Returns the respective wrappers
 */
const gridLayoutWrapper = (layoutManager, renderDetails, grid, renderGrid) => {
    if (renderGrid) {
        let gridWrapper = null;
        const target = { target: _defaults__WEBPACK_IMPORTED_MODULE_6__["CANVAS"] };
        const { layoutConfig } = renderDetails;

        const config = {
            ...target,
            pagination: layoutConfig.pagination,
            classPrefix: layoutConfig.classPrefix,
            dimensions: { height: 0, width: 0 }
        };
        const wrapperParams = {
            name: _constants__WEBPACK_IMPORTED_MODULE_0__["GRID"],
            component: grid,
            config
        };
        const existingComponent = layoutManager.getComponent(_constants__WEBPACK_IMPORTED_MODULE_0__["GRID"]);
        if (existingComponent) {
            gridWrapper = existingComponent
                        .updateWrapper(wrapperParams);
        } else {
            gridWrapper = new _components_grid_component__WEBPACK_IMPORTED_MODULE_4__["default"](wrapperParams);
        }
        return gridWrapper;
    }
    return null;
};
/**
 * Responsible for providing the wrapper creators for every component in Muze.
 * This function, when called, returns the set of components and their respective wrappers.
 *
 *
 *
 * @param {LayoutManager} layoutManager instance of Layout Manager which manages the layouting of the components
 * @param {GridLayout} grid Instance of the grid layout
 * @param {Object} renderDetails Extra details required for rendering the headers
 * @return {Instance} Returns the respective wrappers for each component
 */
const componentWrapperMaker = (canvas, grid, renderDetails) => {
    const layoutManager = canvas._layoutManager;
    const renderGrid = isGridPresent(renderDetails);
    return {
        title: createHeaderWrapper(_constants__WEBPACK_IMPORTED_MODULE_0__["TITLE"], layoutManager, renderDetails),
        subtitle: createHeaderWrapper(_constants__WEBPACK_IMPORTED_MODULE_0__["SUB_TITLE"], layoutManager, renderDetails),
        message: createMessageWrapper(layoutManager, canvas, renderDetails, renderGrid),
        legend: createLegendWrapper(layoutManager, renderDetails, renderGrid),
        grid: gridLayoutWrapper(layoutManager, renderDetails, grid, renderGrid),
        verticalScrollBar: createScrollBarWrapper(_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL"], layoutManager, renderDetails, grid, renderGrid),
        horizontalScrollBar: createScrollBarWrapper(_constants__WEBPACK_IMPORTED_MODULE_0__["HORIZONTAL"], layoutManager, renderDetails, grid, renderGrid)
    };
};


/***/ }),

/***/ "./packages/muze/src/canvas/components/grid-component.js":
/*!***************************************************************!*\
  !*** ./packages/muze/src/canvas/components/grid-component.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridComponent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");
/* harmony import */ var _matrix_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix-component */ "./packages/muze/src/canvas/components/matrix-component.js");
/* harmony import */ var _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../layout/src/enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/constants */ "./packages/muze/src/enums/constants.js");






/**
 * Based on the type of scroll, it changes the scrollLeft/scrollTop property of the specific
 * elements based on the scroll distance provided
 *
 *
 */
const applyScrollAction = (elem, classPrefix, scollDistance, type) => {
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(elem)
                    .selectAll(`.${classPrefix}-grid`)
                    .property(type, scollDistance);
};

/**
 * Applies the action of the scroll by actually scrolling the respective matrices based on the
 * type of scroll. It returns a function which has both the scroll methods available
 *
 * @return {Object} contains the horizontal and vertical scroll actions on the grid component
 */
const scrollActionApplier = (movement, context) => {
    const classPrefix = context.params.config.classPrefix;

    return {
        horizontal: () => {
            [0, 1, 2].forEach(e =>
                applyScrollAction(`#${context.component[e][1].renderAt()}`, classPrefix, movement, 'scrollLeft'));
        },
        vertical: () => {
            [0, 1, 2].forEach(e =>
                applyScrollAction(`#${context.component[1][e].renderAt()}`, classPrefix, movement, 'scrollTop'));
        }
    };
};

class GridComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor (params) {
        super(params.name, params.config.dimensions, 0);
        this.gridComponents = [];
        this.setParams(params);
    }

    sanitizeGrid () {
        let height = 0;
        let width = 0;
        const { viewMatricesInfo, layoutDimensions } = this.component.viewInfo();
        const scrollInfo = this.component.scrollInfo();
        const {
            viewHeight,
            viewWidth,
            unitHeights,
            unitWidths
        } = layoutDimensions;

        for (let i = 0; i < 3; i++) {
            if (!(this.gridComponents.length && this.gridComponents[i] instanceof Array)) {
                this.gridComponents[i] = [];
            }
            for (let j = 0; j < 3; j++) {
                const matrixDim = {
                    height: viewHeight[i],
                    width: viewWidth[j],
                    unitHeights,
                    unitWidths
                };
                const matrix = viewMatricesInfo.matrices[`${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ROW_MATRIX_INDEX"][i]}`][j];
                const matrixName = `${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ROW_MATRIX_INDEX"][i]}-${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLUMN_MATRIX_INDEX"][j]}`;
                const matrixConfig = {
                    dimensions: matrixDim,
                    border: layoutDimensions.border,
                    classPrefix: this.params.config.classPrefix,
                    scrollInfo,
                    row: _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ROW_MATRIX_INDEX"][i],
                    column: j
                };
                if (this.gridComponents[i][j] instanceof _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                    this.gridComponents[i][j].updateWrapper({
                        name: matrixName,
                        component: matrix,
                        config: matrixConfig
                    });
                } else {
                    const matrixWrapper = new _matrix_component__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        name: matrixName,
                        component: matrix,
                        config: matrixConfig
                    });
                    this.gridComponents[i].push(matrixWrapper);
                }
                if (i === 0) {
                    width += matrixDim.width;
                }
                if (j === 0) {
                    height += matrixDim.height;
                }
            }
        }
        this.boundBox({ height, width });

        this.component = this.gridComponents;
        this.allComponents = this.gridComponents;
    }

    scrollBarManager (...manager) {
        if (manager.length) {
            this._scrollBarManager = manager[0];
            return this;
        }
        return this._scrollBarManager;
    }

    /**
     * Attaches a mousewheel listener to the center matrix, based on which the scrolling can occur.
     * It uses the scroll component to change the position of the scroller, which ultimately scrolls the center matrix
     *
     *
     * @return {GridComponent} Instance of the GridComponent
     */
    attachScrollListener () {
        const scrollBarManager = this.scrollBarManager();
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(`#${this.component[1][1].renderAt()}`)
            .on('wheel', () => {
                const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
                const {
                    wheelDeltaX,
                    wheelDeltaY
                } = event;

                // Scrolling horizontally
                if (wheelDeltaX !== 0 && Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {
                    scrollBarManager.preventBrowserScroll('horizontal', event)
                        .triggerScrollBarAction('horizontal', wheelDeltaX / _enums_constants__WEBPACK_IMPORTED_MODULE_4__["WHEEL_DELTA_MODIFIER"]);
                }

                // Scrolling Vertically
                if (wheelDeltaY !== 0 && Math.abs(wheelDeltaX) < Math.abs(wheelDeltaY)) {
                    scrollBarManager.preventBrowserScroll('vertical', event)
                        .triggerScrollBarAction('vertical', wheelDeltaY / _enums_constants__WEBPACK_IMPORTED_MODULE_4__["WHEEL_DELTA_MODIFIER"]);
                }
            });
        return this;
    }

    performScrollAction (direction, movedView) {
        scrollActionApplier(movedView, this)[direction]();
        return this;
    }

    getBoundBox () {
        const { top, left } = this.component[0][0].boundBox();
        const { height, width } = this.boundBox();

        return {
            top,
            left,
            height,
            width
        };
    }

    updateWrapper (params) {
        this.name(params.name);
        this.boundBox(params.config.dimensions);
        this.setParams(params);
        return this;
    }

    setParams (params) {
        this.component = params.component;
        this.params = params;
        this.target(params.config.target);
        this.className(params.config.className);
        this.sanitizeGrid();
        return this;
    }

    attachListener () {
        this.attachScrollListener();
        return this;
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/components/headerComponent.js":
/*!****************************************************************!*\
  !*** ./packages/muze/src/canvas/components/headerComponent.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HeaderComponent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants */ "./packages/muze/src/constants.js");




class HeaderComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor (params) {
        super(params.name, params.component.getLogicalSpace(), 0);
        this.setParams(params);
    }

    renderHeader (container) {
        const layoutConfig = this.params.config;
        container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
        const { align } = layoutConfig;
        const sel = container
          .selectAll(`.${layoutConfig.classPrefix}-inner-container`)
          .data([this.name]);
        sel.exit().remove();
        const selEnter = sel.enter().append('div');

        const cont = selEnter.merge(sel);
        cont.classed(`${layoutConfig.classPrefix}-inner-container`, true);
        const { height, width } = this.boundBox();
        this.component.setAvailableSpace(width, height);

        this.component && this.component.render(cont.node());

        cont.selectAll('div').classed(`${layoutConfig.classPrefix}-inner-content`, true);
        cont.style('width', `${100}%`);

        if (layoutConfig && this.component) {
            cont.style('float', _constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"])
                            .style('text-align', align);
                            // .style(`padding-${position === TOP ? BOTTOM : TOP}`, `${padding}px`);
        }
    }

    draw (container) {
        this.renderHeader(container || document.getElementById(this.renderAt()));
    }

    updateWrapper (params) {
        this.setParams(params);
        this.name(params.name);
        this.boundBox(params.component.getLogicalSpace());
        return this;
    }

    setParams (params) {
        this.component = params.component;
        this.params = params;
        this.target(params.config.target);
        this.position(params.config.position);
        this.className(params.config.className);
        this.alignWith(params.config.alignWith);
        this.alignment(params.config.alignment);
    }

    setSpatialConfig (conf) {
        this.boundBox({ top: conf.y,
            left: conf.x,
            width: conf.width,
            height: conf.height });
        this.renderAt(conf.renderAt);
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/components/legendComponent.js":
/*!****************************************************************!*\
  !*** ./packages/muze/src/canvas/components/legendComponent.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LegendComponent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../layout/src/enums/constants */ "./packages/layout/src/enums/constants.js");





function defaultAlignmentHelper (position) {
    let alignment = null;
    const alignWith = `${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ROW_MATRIX_INDEX"][1]}-${_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLUMN_MATRIX_INDEX"][1]}`;
    switch (position) {
    case _constants__WEBPACK_IMPORTED_MODULE_2__["TOP"]:
    case _constants__WEBPACK_IMPORTED_MODULE_2__["BOTTOM"]:
        alignment = _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL_CENTER"];
        break;
    case _constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"]:
    case _constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"]:
        alignment = _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL_CENTER"];
        break;
    default:
        alignment = _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL_CENTER"];
    }
    return { alignment, alignWith };
}
class LegendComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor (params) {
        super(params.name, params.config.measurement.legendSpace, 0);
        this.setParams(params);
    }

    renderLegend (container) {
        container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
        const sectionComponents = [];
        const { position, classPrefix } = this.params.config;
        const legendMount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', [this.components],
                                        `${classPrefix}-inner-content`, {}, d => d);
        legendMount.classed(`${classPrefix}-legend`, true);
        const align = (position === _constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"] || position === _constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"]) ? _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"] : _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"];
        const legWidth = this.newDimensions.width;
        const legHeight = this.newDimensions.height;

        [container, legendMount].forEach((elem) => {
            elem.style('width', `${Math.floor(legWidth)}px`)
                            .style('height', `${legHeight}px`)
                            .style('float', _constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"]);
        });

        if (align === _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"]) {
            let sections = -1;
            let currHeight = legHeight;
            let currWidth = 0;

            this.components.forEach((legendInfo) => {
                const leg = legendInfo.legend;
                if (leg.measurement().height > currHeight) {
                    sections++;
                    currWidth = 0;
                    currHeight = legHeight;
                } else {
                    sections < 0 && sections++;
                }
                sectionComponents[sections] = sectionComponents[sections] || [];
                currHeight -= Math.min(leg.measurement().height, currHeight);
                currWidth = Math.max(Math.min(leg.measurement().width, leg.measurement().maxWidth), currWidth);
                sectionComponents[sections].push({
                    legend: leg,
                    legendHeight: legHeight,
                    legendWidth: currWidth
                });
            });

            const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendMount, ['div'], sectionComponents, `${classPrefix}-legend-section`);
            // mount.each((d, i) => selectElement(this).classed(`${classPrefix}-legend-section-${i}`, true));
            mount.classed(`${classPrefix}-legend-vertical-section`, true)
                            .style('width', d => `${d[0].legendWidth}px`);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, ['div'], d => d, `${classPrefix}-legend-components`, {}, d => d.legend.id())
                            .each(function (d) {
                                d.legend.mount(this);
                            })
                            .style('width', d => `${d.legendWidth}px`);
        } else {
            const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(legendMount, 'div', [1], `${classPrefix}-legend-section`);
            mount.classed(`${classPrefix}-legend-horizontal-section`, true);
            mount.classed(`${classPrefix}-legend-section-${0}`, true)
                            .style('width', `${legWidth}px`);

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'div', this.components, `${classPrefix}-legend-components`, {}, d => d.legend.id())
                            .each(function (d) { d.legend.mount(this); })
                            .style('width', d => `${d.legend.measurement().width}px`);
        }
    }

    draw (container) {
        this.renderLegend(container || document.getElementById(this.renderAt()));
    }

    updateWrapper (params) {
        this.name(params.name);
        this.boundBox(params.config.measurement.legendSpace);
        this.setParams(params);
        return this;
    }

    setParams (params) {
        this.components = params.component;
        this.params = params;
        this.target(params.config.target);
        this.position(params.config.position);
        const { alignWith, alignment } = defaultAlignmentHelper(params.config.position);
        this.className(params.config.className);
        this.alignWith(params.config.alignWith || alignWith);
        this.alignment(params.config.alignment || alignment);
    }

}


/***/ }),

/***/ "./packages/muze/src/canvas/components/matrix-component.js":
/*!*****************************************************************!*\
  !*** ./packages/muze/src/canvas/components/matrix-component.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixComponent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _layout_src_grid_layout_span_maker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../layout/src/grid-layout/span-maker */ "./packages/layout/src/grid-layout/span-maker.js");
/* harmony import */ var _layout_src_grid_layout_border_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../layout/src/grid-layout/border-helper */ "./packages/layout/src/grid-layout/border-helper.js");
/* harmony import */ var _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../layout/src/enums/constants */ "./packages/layout/src/enums/constants.js");
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants */ "./packages/muze/src/constants.js");








const renderPlaceholders = (cells) => {
    // Rendering content within placeholders
    cells.each(function (cell) {
        cell.placeholder.render(this);
    });
};

class MatrixComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_4__["default"] {

    constructor (params) {
        super(params.name, params.config.dimensions, 0);
        this.setParams(params);
        this.className(params.config.className);
    }

    applyScroll (container) {
        const row = this.params.config.row;
        const column = this.params.config.column;
        const { horizontal, vertical } = this.params.config.scrollInfo;
        container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["OVERFLOW"], _constants__WEBPACK_IMPORTED_MODULE_5__["VISIBLE"]);
        container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["WIDTH"], _constants__WEBPACK_IMPORTED_MODULE_5__["AUTO"]);
        container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["HEIGHT"], _constants__WEBPACK_IMPORTED_MODULE_5__["AUTO"]);

        if (horizontal && column === 1) {
            container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["OVERFLOW"], _constants__WEBPACK_IMPORTED_MODULE_5__["HIDDEN"]);
            container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["WIDTH"], '100%');
        }

        if (vertical && row === _layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["CENTER"]) {
            container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["OVERFLOW"], _constants__WEBPACK_IMPORTED_MODULE_5__["HIDDEN"]);
            container.style(_constants__WEBPACK_IMPORTED_MODULE_5__["HEIGHT"], '100%');
        }
    }

    renderMatrix (mountPoint) {
        // Creating containers for each matrix individually
        const classPrefix = this.params.config.classPrefix;
        const row = this.params.config.row;
        const column = this.params.config.column;
        const dimensions = this.params.config.dimensions;
        const border = this.params.config.border;

        // Creating containers for each matrix individually
        const containerForMatrix = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mountPoint, 'div', [1], `${classPrefix}-grid-${row}-${column + 1}`)
            .classed(`${classPrefix}-grid-${row}`, true)
            .classed(`${classPrefix}-grid`, true);

        this.applyScroll(containerForMatrix);

        const {
            viewMatrix,
            spans
        } = Object(_layout_src_grid_layout_span_maker__WEBPACK_IMPORTED_MODULE_1__["cellSpanMaker"])(this.component, row, column);

        // Rendering the table components
        const { cells } = this.renderTable(containerForMatrix, `${classPrefix}-grid`, viewMatrix);

        Object(_layout_src_grid_layout_span_maker__WEBPACK_IMPORTED_MODULE_1__["applySpans"])(cells, spans, { dimensions, border }, `${row}-${column}`);
        renderPlaceholders(cells);

        cells.exit().each((cell) => {
            cell.placeholder.remove();
        });

        Object(_layout_src_grid_layout_border_helper__WEBPACK_IMPORTED_MODULE_2__["applyBorders"])(cells, border, row, column);
    }

    renderTable (mount, className, rowData) {
        const table = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'table', ['layout'], `${className}-table`);
        const body = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(table, 'tbody', ['layout'], `${className}-body`);
        const rows = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(body, 'tr', rowData, `${className}-tr`);
        const cells = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(rows, 'td', (d, i) => d.filter(e => e !== null).map(e =>
                                  ({ placeholder: e, rowIndex: i })), `${className}-td`, {}, key => key.placeholder.id);

        return { table, body, rows, cells };
    }

    draw (container) {
        this.renderMatrix(container || document.getElementById(this.renderAt()));
    }

    updateWrapper (params) {
        this.name(params.name);
        this.boundBox(params.config.dimensions);
        this.setParams(params);
        return this;
    }

    setParams (params) {
        this.component = params.component;
        this.params = params;
        this.target(params.config.target);
        this.position(_layout_src_enums_constants__WEBPACK_IMPORTED_MODULE_3__["TOP"]);
        this.className(params.config.className);
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/components/message-component.js":
/*!******************************************************************!*\
  !*** ./packages/muze/src/canvas/components/message-component.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MessageComponent; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");



class MessageComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor (params) {
        super(params.name, params.config.dimensions, 0);
        this.setParams(params);
    }

    render (container) {
        const parent = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);

        const { config } = this.params;
        const { className } = config.classPrefix;

        const node = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(parent, 'div', [1], className);
        const { height, width } = config.dimensions;
        const { message } = config;

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(node, { width: `${width}px`, height: `${height}px` });

        const child = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(node, 'div', [1], `${className}-child`);
        const textElement = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(child, 'text', [1]);

        textElement.html(message);
    }

    draw (container) {
        this.render(container || document.getElementById(this.renderAt()));
    }

    updateWrapper (params) {
        this.name(params.name);
        this.boundBox(params.config.dimensions);
        this.setParams(params);
        return this;
    }

    setParams (params) {
        const { target, className } = params.config;
        this.component = params.component;
        this.params = params;
        this.target(target);
        this.className(className);
        this.position(params.config.position);
        return this;
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/components/muze-chart-component.js":
/*!*********************************************************************!*\
  !*** ./packages/muze/src/canvas/components/muze-chart-component.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MuzeComponent; });
/* harmony import */ var _layout_src_tree_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../layout/src/tree-layout */ "./packages/layout/src/tree-layout/index.js");


class MuzeComponent extends _layout_src_tree_layout__WEBPACK_IMPORTED_MODULE_0__["LayoutComponent"] {
    getLogicalSpace () {
        const { width, height } = this.boundBox();
        return { width, height };
    }

    setSpatialConfig (conf) {
        this.boundBox({ top: conf.y, left: conf.x });
        this.newDimensions = {
            width: conf.width,
            height: conf.height
        };
        this.renderAt(conf.renderAt);
    }

    getBoundBox () {
        return this.boundBox();
    }

    updateWrapper () {
        throw Error('Update is not implemented');
    }

    setParams () {
        throw Error('set params is not implemented');
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/helper.js":
/*!************************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/helper.js ***!
  \************************************************************************/
/*! exports provided: getUnitPositions, createScrollBarArrow, createScrollBarRect, applyRectClick, registerListeners, scrollContainerHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnitPositions", function() { return getUnitPositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createScrollBarArrow", function() { return createScrollBarArrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createScrollBarRect", function() { return createScrollBarRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyRectClick", function() { return applyRectClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerListeners", function() { return registerListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollContainerHelper", function() { return scrollContainerHelper; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _scroll_bar_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scroll-bar.scss */ "./packages/muze/src/canvas/components/scroll-bar-maker/scroll-bar.scss");
/* harmony import */ var _scroll_bar_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_scroll_bar_scss__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ "./packages/muze/src/constants.js");




const d3Drag = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getD3Drag"])();

const arrowSizeMap = {
    left: _constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"],
    right: _constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"],
    top: _constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"],
    bottom: _constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"]
};

const getUnitPositions = (unitMeasures, totalLength, viewLength) => {
    let currentLen = 0;
    const measures = unitMeasures.primary && unitMeasures.primary.length ?
        unitMeasures.primary : unitMeasures.secondary;

    return measures.map((e) => {
        const unitPosition = currentLen * 100 / (totalLength - viewLength);
        currentLen += e;
        return unitPosition;
    });
};

const createScrollBarArrow = (mount, type, config) => {
    const {
        classPrefix,
        thickness
    } = config;
    const arrow = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'div', [type], `${classPrefix}-scroll-arrow-${type}`);

    arrow.classed(`${classPrefix}-scroll-arrow`, true);
    arrow.style(arrowSizeMap[type], `${thickness}px`);

    const chevron = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(arrow, 'div', [1], `${classPrefix}-scroll-arrow-chevron`);

    chevron.attr('id', `${classPrefix}-scroll-arrow-chevron-${type}`);

    return arrow;
};

const createScrollBarRect = (mount, config) => {
    const {
        classPrefix
    } = config;
    const rect = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'div', [1], `${classPrefix}-scroll-rect`);
    const mover = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(rect, 'div', [1], `${classPrefix}-scroll-mover`);

    return { rect, mover };
};

const applyRectClick = (scrollMaker, moverRect) => {
    const {
        rect
    } = moverRect;

    rect.on('click', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
        scrollMaker.emptyScrollAreaClick(event);
    });
};

const applyMoverDrag = (scrollMaker, moverRect) => {
    let startPos = {};
    let moverStartPos = 0;
    let rectStartPos = 0;
    let endPos = {};
    const {
        mover,
        rect
    } = moverRect;

    mover.call(d3Drag()
                    .on('start', () => {
                        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();

                        moverStartPos = mover.node().getBoundingClientRect();
                        rectStartPos = rect.node().getBoundingClientRect();
                        startPos = {
                            x: event.x,
                            y: event.y
                        };
                    })
                    .on('drag', () => {
                        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();
                        const window = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getWindow"])();

                        endPos = {
                            x: event.x,
                            y: event.y
                        };
                        const distanceMoved = {
                            x: endPos.x - startPos.x,
                            y: endPos.y - startPos.y
                        };
                        const actualPosition = {
                            x: moverStartPos.x + distanceMoved.x - rectStartPos.x + window.pageXOffset,
                            y: moverStartPos.y + distanceMoved.y - rectStartPos.y + window.pageYOffset
                        };

                        scrollMaker.changeMoverPosition(actualPosition);
                    }));
};

const applyScrollMouseDownAction = (moverRect, scrollMaker, speed) => {
    const {
        mover,
        rect
    } = moverRect;
    const { x, y } = mover.node().getBoundingClientRect();
    const { x: rectX, y: rectY } = rect.node().getBoundingClientRect();

    scrollMaker.changeMoverPosition({ x: x - rectX + speed, y: y - rectY + speed });
};

const registerListenerOnArrow = (scrollMaker, moverRect, arrowType, speed) => {
    let timer = '';
    const arrow = scrollMaker._components[arrowType];
    const isTouchDevice = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["hasTouch"])();

    arrow.on(isTouchDevice ? 'touchstart' : 'mousedown', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();

        event.preventDefault();

        timer = setInterval(() => {
            applyScrollMouseDownAction(moverRect, scrollMaker, speed);
        }, 100);
    }).on(isTouchDevice ? 'touchend' : 'mouseup', () => {
        const event = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getEvent"])();

        event.preventDefault();

        clearInterval(timer);
    }).on('click', () => {
        applyScrollMouseDownAction(moverRect, scrollMaker, speed);
    });
};

const registerListeners = (scrollMaker) => {
    const {
        moverRect
    } = scrollMaker._components;

    const speed = scrollMaker.config().speed;

    registerListenerOnArrow(scrollMaker, moverRect, 'prevArrow', -speed);
    applyMoverDrag(scrollMaker, moverRect);
    applyRectClick(scrollMaker, moverRect);
    registerListenerOnArrow(scrollMaker, moverRect, 'nextArrow', speed);
};

const scrollContainerHelper = (mountPoint, config, dimensions, type) => {
    const {
        classPrefix
    } = config;
    const scrollBarContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mountPoint), 'div', [1], `#${classPrefix}-scroll-bar-${type}`);

    scrollBarContainer.classed(`${classPrefix}-scroll-bar`, true);
    scrollBarContainer.style(_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], `${dimensions.width}px`);
    scrollBarContainer.style(_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], `${dimensions.height}px`);
    return scrollBarContainer;
};



/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/horizontal-scroll-maker.js":
/*!*****************************************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/horizontal-scroll-maker.js ***!
  \*****************************************************************************************/
/*! exports provided: HorizontalScrollMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalScrollMaker", function() { return HorizontalScrollMaker; });
/* harmony import */ var _scroll_maker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scroll-maker */ "./packages/muze/src/canvas/components/scroll-bar-maker/scroll-maker.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze/src/canvas/components/scroll-bar-maker/helper.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ "./packages/muze/src/constants.js");




class HorizontalScrollMaker extends _scroll_maker__WEBPACK_IMPORTED_MODULE_0__["ScrollMaker"] {

    /**
     * Describes the type of the ScrollMaker
     *
     * @public
     *
     * @return {String} Returns the type of scroll maker: horizontal
     */
    static type () {
        return _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"];
    }

    createScroll (mountPoint, dimensions = this.logicalSpace()) {
        const config = this.config();
        const { scrollBarContainer } = super.createScroll(mountPoint, config, dimensions);
        const prevArrow = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarArrow"])(scrollBarContainer, 'left', config);
        const moverRect = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarRect"])(scrollBarContainer, config);
        const nextArrow = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarArrow"])(scrollBarContainer, 'right', config);
        const {
            mover,
            rect
        } = moverRect;

        const { height, width, totalLength, viewLength, unitWidths } = this.logicalSpace();
        const scrollBarWithouArrowLength = width - height * 2;

        rect.style(_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], `${dimensions.width - height * 2}px`);
        rect.style(_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], `${100}%`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], `${(viewLength * scrollBarWithouArrowLength) / totalLength}px`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], `${100}%`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"], `${0}px`);

        this._components = {
            prevArrow,
            nextArrow,
            moverRect,
            scrollBarContainer
        };
        this._scrollBarWithouArrowLength = scrollBarWithouArrowLength;
        this.unitPositions(Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getUnitPositions"])(unitWidths, totalLength, viewLength));
        this.registerListeners();
    }

    emptyScrollAreaClick (event) {
        const {
            mover,
            rect
        } = this._components.moverRect;
        const speed = this.config().speed;
        const { x, y } = mover.node().getBoundingClientRect();
        const { x: rectX, y: rectY } = rect.node().getBoundingClientRect();
        let positionAdjuster = speed * 10;
        if (event.x < x) {
            positionAdjuster = -speed * 10;
        }
        this.changeMoverPosition({ x: x - rectX + positionAdjuster, y: y - rectY + positionAdjuster });
    }

    changeMoverPosition (newPosition) {
        let currentPos;
        const {
            mover,
            rect
        } = this._components.moverRect;
        const rectStartPos = rect.node().getBoundingClientRect();
        const moverPos = mover.node().getBoundingClientRect();
        const {
            totalLength
         } = this.logicalSpace();

        if (newPosition.x < 0) {
            currentPos = 0;
        } else if (newPosition.x + moverPos.width > rectStartPos.width) {
            currentPos = rectStartPos.width - moverPos.width;
        } else {
            currentPos = newPosition.x;
        }

        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"], `${currentPos}px`);
        const totalDistance = this._scrollBarWithouArrowLength;
        const movedViewLength = (currentPos * totalLength) / totalDistance;

        this.manager().performAttachedScrollFunction(this.constructor.type(), movedViewLength);
    }

    scrollDeltaTo (delta) {
        const {
            mover,
            rect
        } = this._components.moverRect;
        const moverPos = mover.node().getBoundingClientRect();
        const rectStartPos = rect.node().getBoundingClientRect();

        this.changeMoverPosition({ y: 0, x: moverPos.x - rectStartPos.x - delta });
        return this;
    }

    /**
     * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
     *
     * @public
     *
     * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
     * @return {HorizontalScrollMaker} Instance of the HorizontalScrollMaker
     */
    scrollTo (scrollPercentage) {
        const {
            mover
        } = this._components.moverRect;
        const moverPos = mover.node().getBoundingClientRect();
        const movement = (scrollPercentage * (this._scrollBarWithouArrowLength - moverPos.width)) / 100;

        this.changeMoverPosition({ y: 0, x: movement });
        return this;
    }

}



/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/props.js":
/*!***********************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/props.js ***!
  \***********************************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const PROPS = {

    config: {
        sanitization: (context, value) => {
            value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._config, value);
            return value;
        }
    },
    manager: {},
    unitPositions: {},
    logicalSpace: {}
};



/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/scroll-bar.scss":
/*!******************************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/scroll-bar.scss ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/scroll-maker.js":
/*!******************************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/scroll-maker.js ***!
  \******************************************************************************/
/*! exports provided: ScrollMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollMaker", function() { return ScrollMaker; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze/src/canvas/components/scroll-bar-maker/helper.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./props */ "./packages/muze/src/canvas/components/scroll-bar-maker/props.js");




class ScrollMaker {

    constructor () {
        this._components = {};
        this._logicalSpace = {};
        this._attachedScrollAction = () => {};
        this._config = {
            thickness: 10,
            speed: 2
        };
        this._unitPositions = null;

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_2__["PROPS"]);
    }

    static type () {
        throw new muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"]('Method not implemented');
    }

    emptyScrollAreaClick () {
        throw new muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"]('Method not implemented');
    }

    changeMoverPosition () {
        throw new muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"]('Method not implemented');
    }

    scrollTo () {
        throw new muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"]('Method not implemented');
    }

    scrollDeltaTo () {
        throw new muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"]('Method not implemented');
    }

    createScroll (mountPoint) {
        const config = this.config();

        return {
            scrollBarContainer: Object(_helper__WEBPACK_IMPORTED_MODULE_1__["scrollContainerHelper"])(mountPoint, config, this.logicalSpace(), this.constructor.type())
        };
    }

    attachScrollAction (externalScrollAction) {
        this._attachedScrollAction = externalScrollAction;
        return this;
    }

    detachScrollAction () {
        this._attachedScrollAction = () => {};
        return this;
    }

    getLogicalSpace () {
        return this.logicalSpace();
    }

    registerListeners () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_1__["registerListeners"])(this);
        return this;
    }

    remove () {
        this._components.scrollBarContainer.remove();
        return this;
    }
}



/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-bar-maker/vertical-scroll-maker.js":
/*!***************************************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-bar-maker/vertical-scroll-maker.js ***!
  \***************************************************************************************/
/*! exports provided: VerticalScrollMaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalScrollMaker", function() { return VerticalScrollMaker; });
/* harmony import */ var _scroll_maker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scroll-maker */ "./packages/muze/src/canvas/components/scroll-bar-maker/scroll-maker.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "./packages/muze/src/canvas/components/scroll-bar-maker/helper.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ "./packages/muze/src/constants.js");




class VerticalScrollMaker extends _scroll_maker__WEBPACK_IMPORTED_MODULE_0__["ScrollMaker"] {

    /**
     * Describes the type of the ScrollMaker
     *
     * @public
     *
     * @return {String} Returns the type of scroll maker: vertical
     */
    static type () {
        return _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"];
    }

    createScroll (mountPoint, dimensions = this.logicalSpace()) {
        const config = this.config();
        const { scrollBarContainer } = super.createScroll(mountPoint, dimensions);
        const prevArrow = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarArrow"])(scrollBarContainer, 'top', config);
        const moverRect = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarRect"])(scrollBarContainer, config);
        const nextArrow = Object(_helper__WEBPACK_IMPORTED_MODULE_1__["createScrollBarArrow"])(scrollBarContainer, 'bottom', config);
        const {
            mover,
            rect
        } = moverRect;
        const { height, width, totalLength, viewLength, unitHeights } = this.logicalSpace();
        const scrollBarWithouArrowLength = height - width * 2;

        rect.style(_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], `${scrollBarWithouArrowLength}px`);
        rect.style(_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], `${100}%`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["WIDTH"], `${100}%`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["HEIGHT"], `${(viewLength * scrollBarWithouArrowLength) / totalLength}px`);
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["TOP"], `${0}px`);

        this._components = {
            prevArrow,
            nextArrow,
            moverRect,
            scrollBarContainer
        };
        this._scrollBarWithouArrowLength = scrollBarWithouArrowLength;

        this.unitPositions(Object(_helper__WEBPACK_IMPORTED_MODULE_1__["getUnitPositions"])(unitHeights, totalLength, viewLength));
        this.registerListeners();
    }

    emptyScrollAreaClick (event) {
        const {
            mover,
            rect
        } = this._components.moverRect;
        const speed = this.config().speed;
        const { x, y } = mover.node().getBoundingClientRect();
        const { x: rectX, y: rectY } = rect.node().getBoundingClientRect();

        let positionAdjuster = speed * 10;
        if (event.y < y) {
            positionAdjuster = -speed * 10;
        }
        this.changeMoverPosition({ x: x - rectX + positionAdjuster, y: y - rectY + positionAdjuster });
    }

    changeMoverPosition (newPosition) {
        let currentPos;
        const {
            mover,
            rect
        } = this._components.moverRect;
        const {
            totalLength
         } = this.logicalSpace();
        const rectStartPos = rect.node().getBoundingClientRect();
        const moverPos = mover.node().getBoundingClientRect();

        if (newPosition.y < 0) {
            currentPos = 0;
        } else if (newPosition.y + moverPos.height > rectStartPos.height) {
            currentPos = rectStartPos.height - moverPos.height;
        } else {
            currentPos = newPosition.y;
        }
        mover.style(_constants__WEBPACK_IMPORTED_MODULE_2__["TOP"], `${currentPos}px`);
        const totalDistance = this._scrollBarWithouArrowLength;
        const movedViewLength = (currentPos * totalLength) / totalDistance;

        this.manager().performAttachedScrollFunction(this.constructor.type(), movedViewLength);
    }

    /**
     * Scrolls based on the actual pixel value provided. Since it's a delta change, the input will be
     * a delta between (-Infinity, Infinity), based on which the scroll will occur. Only a delta movement in
     * scroll occurs
     *
     * @public
     *
     * @param {number} delta Based on which the scroll will have a delta change in position
     * @return {VerticalScrollMaker} Instance of the VerticalScrollMaker
     */
    scrollDeltaTo (delta) {
        const {
            mover,
            rect
        } = this._components.moverRect;
        const moverPos = mover.node().getBoundingClientRect();
        const rectStartPos = rect.node().getBoundingClientRect();

        this.changeMoverPosition({ y: moverPos.y - rectStartPos.y - delta, x: 0 });
        return this;
    }

    /**
     * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
     *
     * @public
     *
     * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
     * @return {VerticalScrollMaker} Instance of the VerticalScrollMaker
     */
    scrollTo (scrollPercentage) {
        const {
            mover
        } = this._components.moverRect;
        const moverPos = mover.node().getBoundingClientRect();
        const movement = (scrollPercentage * (this._scrollBarWithouArrowLength - moverPos.height)) / 100;

        this.changeMoverPosition({ x: 0, y: movement });
        return this;
    }

}


/***/ }),

/***/ "./packages/muze/src/canvas/components/scroll-component.js":
/*!*****************************************************************!*\
  !*** ./packages/muze/src/canvas/components/scroll-component.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScrollComponent; });
/* harmony import */ var _muze_chart_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./muze-chart-component */ "./packages/muze/src/canvas/components/muze-chart-component.js");
/* harmony import */ var _scroll_bar_maker_horizontal_scroll_maker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scroll-bar-maker/horizontal-scroll-maker */ "./packages/muze/src/canvas/components/scroll-bar-maker/horizontal-scroll-maker.js");
/* harmony import */ var _scroll_bar_maker_vertical_scroll_maker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scroll-bar-maker/vertical-scroll-maker */ "./packages/muze/src/canvas/components/scroll-bar-maker/vertical-scroll-maker.js");




const scrollMakerMap = {
    horizontal: _scroll_bar_maker_horizontal_scroll_maker__WEBPACK_IMPORTED_MODULE_1__["HorizontalScrollMaker"],
    vertical: _scroll_bar_maker_vertical_scroll_maker__WEBPACK_IMPORTED_MODULE_2__["VerticalScrollMaker"]
};

/**
 * Scroll Component acts as a wrapper over the scoll bars created using the respective Scroll Makers
 * This provides a consistent API for layouting using the tree layout system.
 *
 *
 * @class
 * @public
 * @module ScrollComponent
 */
class ScrollComponent extends _muze_chart_component__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor (params) {
        const ScrollMaker = scrollMakerMap[params.config.type];

        params.component = new ScrollMaker();
        params.component.config(params.config.scrollBarComponentConfig);
        params.component.logicalSpace(params.dimensions);
        super(params.name, params.component.getLogicalSpace(), 0);
        this.setParams(params);
    }

    manager (...manager) {
        if (manager.length) {
            this.component.manager(manager[0]);
            return this;
        }
        return this.component.manager();
    }

    /**
     * Scrolls based on the actual pixel value provided. Since it's a delta change, the input will be
     * a delta between (-Infinity, Infinity), based on which the scroll will occur. Only a delta movement in
     * scroll occurs
     *
     * @public
     *
     * @param {number} delta Based on which the scroll will have a delta change in position
     * @return {ScrollComponent} Instance of the ScrollComponent
     */
    scrollDeltaTo (delta) {
        this.component.scrollDeltaTo(delta);
        return this;
    }

    /**
     * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
     *
     * @public
     *
     * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
     * @return {ScrollComponent} Instance of the ScrollComponent
     */
    scrollTo (scrollPercentage) {
        this.component.scrollTo(scrollPercentage);
        return this;
    }

    /**
     * Scrolls to the specific point in the page based on the unit index.
     * The input is provided as a number represting the index for the unit.
     * For vertical scroll, it's the row index that will be required.
     * For horizontal scroll, it's the column index that will be required
     *
     * @public
     *
     * @param {number} unitIndex Index of the unit appearing in the grid
     * @return {ScrollComponent} Instance of the ScrollComponent
     */
    scrollToUnitIndex (unitIndex) {
        const unitPositions = this.component.unitPositions();
        const sanitizedUnitIndex = Math.min(Math.max(0, unitIndex), unitPositions.length - 1);
        this.component.scrollTo(unitPositions[sanitizedUnitIndex]);
        return this;
    }

    /**
     * Provides the positions of the units(either horizontal or vertical based on the type
     * of scroll bar it wraps) relative to it's container. The position of the first unit starts at 0
     *
     *
     * @public
     *
     * @return {Array} Positions of units either horizontal or vertical
     */
    getScrollPositionsForUnits () {
        return this.component.unitPositions();
    }

    draw (container) {
        this.component.createScroll(container || document.getElementById(this.renderAt()));
        return this;
    }

    /**
     * Can be used to attach a scroll action whenever scrolling occurs in the canvas
     *
     * @public
     * @param {number} externalAction Action to be attached during scroll
     * @return {ScrollComponent} Instance of the ScrollComponent
     */
    attachScrollAction (externalAction) {
        this.component.attachScrollAction(externalAction);
        return this;
    }

    /**
     * Can be used to detach the scroll action already bound to the scroll bar
     *
     * @public
     * @return {ScrollComponent} Instance of the ScrollComponent
     */
    detachScrollAction () {
        this.component.detachScrollAction();
        return this;
    }

    updateWrapper (params) {
        this.name(params.name);
        this.component.config(params.config.scrollBarComponentConfig);
        this.component.logicalSpace(params.dimensions);
        this.boundBox(this.component.getLogicalSpace());
        this.setParams(params);
        return this;
    }

    setParams (params) {
        this.component = params.component || this.component;
        this.params = params;
        this.target(params.config.target);
        this.position(params.config.position);
        this.className(params.config.className);
        this.alignWith(params.config.alignWith);
        this.alignment(params.config.alignment);
    }

    remove () {
        this.component.remove();
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/defaults.js":
/*!**********************************************!*\
  !*** ./packages/muze/src/canvas/defaults.js ***!
  \**********************************************/
/*! exports provided: TITLE_CONFIG, SUB_TITLE_CONFIG, MESSAGE_CONFIG, CANVAS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TITLE_CONFIG", function() { return TITLE_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUB_TITLE_CONFIG", function() { return SUB_TITLE_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MESSAGE_CONFIG", function() { return MESSAGE_CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS", function() { return CANVAS; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");


const TITLE_CONFIG = {
    position: 'top',
    align: 'left',
    padding: 4,
    className: `${_constants__WEBPACK_IMPORTED_MODULE_0__["MUZE_PREFIX"]}-title-container`
};

const SUB_TITLE_CONFIG = {
    position: 'top',
    align: 'left',
    padding: 16,
    maxLines: 2,
    className: `${_constants__WEBPACK_IMPORTED_MODULE_0__["MUZE_PREFIX"]}-subtitle-container`
};

const MESSAGE_CONFIG = {
    className: `${_constants__WEBPACK_IMPORTED_MODULE_0__["MUZE_PREFIX"]}-message-container`
};

const CANVAS = 'canvas';


/***/ }),

/***/ "./packages/muze/src/canvas/firebolt/group-firebolt.js":
/*!*************************************************************!*\
  !*** ./packages/muze/src/canvas/firebolt/group-firebolt.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GroupFireBolt; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper */ "./packages/muze/src/canvas/helper.js");





const defaultInteractionPolicy = (valueMatrix, firebolt) => {
    const isMeasure = field => field.type() === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE;
    const canvas = firebolt.context;
    const visualGroup = canvas.composition().visualGroup;
    const xFields = [].concat(...visualGroup.getFieldsFromChannel('x'));
    const yFields = [].concat(...visualGroup.getFieldsFromChannel('y'));
    const colDim = xFields.every(field => field.type() === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);
    const fieldInf = visualGroup.resolver().getAllFields();
    const rowFacets = fieldInf.rowFacets;
    const colFacets = fieldInf.colFacets;
    valueMatrix.each((cell) => {
        const unitFireBolt = cell.valueOf().firebolt();
        if (!(xFields.every(isMeasure) && yFields.every(isMeasure))) {
            const facetFields = cell.valueOf().facetByFields()[0];
            const unitColFacets = facetFields.filter(d => colFacets.findIndex(v => v.equals(d)) !== -1);
            const unitRowFacets = facetFields.filter(d => rowFacets.findIndex(v => v.equals(d)) !== -1);
            let propFields;
            if (colDim) {
                propFields = unitColFacets.map(d => `${d}`);
            } else {
                propFields = unitRowFacets.map(d => `${d}`);
            }

            unitFireBolt.propagateWith('*', propFields, true);
        }
    });
};

const defaultCrossInteractionPolicy = {
    behaviours: {
        '*': (propagationPayload, context) => {
            const propagationCanvasAlias = propagationPayload.sourceCanvas;
            const canvasAlias = context.parentAlias();
            return propagationCanvasAlias ? canvasAlias === propagationCanvasAlias : true;
        }
    },
    sideEffects: {
        tooltip: (propagationPayload, context) => {
            const propagationUnit = propagationPayload.sourceUnit;
            const propagationCanvas = propagationPayload.sourceCanvas;
            const unitId = context.id();
            const canvasAlias = context.parentAlias();
            if (propagationCanvas) {
                return propagationCanvas !== canvasAlias ? true : unitId === propagationUnit;
            }
            return true;
        },
        selectionBox: () => false
    }
};

/**
 * This class is responsible for dispatching any behavioural action to all the visual units housed by the canvas.
 * It is created by {@link Canvas}. This class does not handle any physical actions. Physical actions get triggered
 * in {@link VisualUnit} which is managed by it's own firebolt instance. The firebolt instance of canvas only
 * propagates the action to all the visual units in it's composition.
 *
 * To get the firebolt instance of {@link Canvas}
 * ```
 *  const firebolt = canvas.firebolt();
 * ```
 *
 * @class GroupFireBolt
 * @public
 */
class GroupFireBolt extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__["Firebolt"] {
    constructor (...params) {
        super(...params);
        this._interactionPolicy = this.constructor.defaultInteractionPolicy();
        this.crossInteractionPolicy(this.constructor.defaultCrossInteractionPolicy());
    }

    static defaultInteractionPolicy () {
        return defaultInteractionPolicy;
    }

    static defaultCrossInteractionPolicy () {
        return defaultCrossInteractionPolicy;
    }

    interactionPolicy (...policy) {
        if (policy.length) {
            this._interactionPolicy = policy[0] || this.constructor.defaultInteractionPolicy();
            return this;
        }
        return this._interactionPolicy;
    }

    crossInteractionPolicy (...policy) {
        if (policy.length) {
            this._crossInteractionPolicy = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({},
                this.constructor.defaultCrossInteractionPolicy()), policy[0] || {});
            const context = this.context;
            Object(_helper__WEBPACK_IMPORTED_MODULE_2__["applyInteractionPolicy"])(this);
            context._throwback.registerImmediateListener([muze_utils__WEBPACK_IMPORTED_MODULE_0__["CommonProps"].MATRIX_CREATED], () => {
                Object(_helper__WEBPACK_IMPORTED_MODULE_2__["applyInteractionPolicy"])(this);
            });
            return this;
        }
        return this._crossInteractionPolicy;
    }

    /**
     * Dispatches a behavioural action with a payload. It takes the name of the behavioural action and a payload
     * object which contains the criteria aend an array of side effects which determines what side effects are
     * going to be shown in each visual unit of the canvas. It prepares the datamodel from the given criteria
     * and initiates a propagation from the datamodel of canvas. Then all the visual units of canvas which listens
     * to the propagation gets informed on which rows got selected and dispatches the behavioural action sent during
     * propagation.
     *
     * To dispatch a behavioural action on the canvas
     * ```
     *  // Get the firebolt instance of the canvas
     *  const firebolt = canvas.firebolt();
     *  // Dispatch a brush behaviour
     *  firebolt.dispatchBehaviour('brush', {
     *      // Selects all the rows with Horsepower having range between 100 and 200.
     *      criteria: {
     *          Horsepower: [100, 200]
     *      }
     *  });
     * // On dispatch of this behavioural action, a selection box gets created and plots gets faded out which are the
     * // default side effects mapped to this behavioural action.
     * ```
     *
     * ```
     * Additionally, it can also be passed an array of side effects in the payload.
     *  // Dispatch a select behaviour with only crossline as side effect.
     *  firebolt.dispatchBehaviour('select', {
     *      criteria: {
     *          Cylinders: ['8']
     *      },
     *      sideEffects: ['crossline']
     *  });
     * ```
     *
     * @public
     *
     * @param {string} behaviour Name of the behavioural action
     * @param {Object} payload Object which contains the interaction information.
     * @param {Object | Array.<Array>} payload.criteria Identifiers by which the selection happens.
     * @param {Array.<string|Object>} payload.sideEffects Side effects which needs to be shown.
     *
     * @return {GroupFireBolt} Instance of firebolt.
     */
    dispatchBehaviour (behaviour, payload) {
        const propPayload = Object.assign(payload);
        const criteria = propPayload.criteria;
        const data = this.context.composition().visualGroup.getGroupByData();
        const fieldsConfig = data.getFieldsConfig();
        const model = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDataModelFromIdentifiers"])(data, criteria);
        const behaviouralAction = this._actions.behavioural[behaviour];

        if (behaviouralAction) {
            const fields = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(criteria) ? Object.keys(criteria) : (criteria ? criteria[0] : []);
            const validFields = fields.filter(field => field in fieldsConfig);
            const mutates = behaviouralAction.constructor.mutates();
            const propConfig = {
                payload: propPayload,
                action: behaviour,
                criteria: model,
                sourceId: this.context.alias(),
                isMutableAction: mutates,
                propagateInterpolatedValues: validFields.every(field => fieldsConfig[field].def.type ===
                    muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE)
            };
            data.propagate(model, propConfig, true);
        }
        return this;
    }

    registerSideEffects (sideEffects) {
        for (const key in sideEffects) {
            this._sideEffectDefinitions[sideEffects[key].formalName()] = sideEffects[key];
        }
        return this;
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/firebolt/index.js":
/*!****************************************************!*\
  !*** ./packages/muze/src/canvas/firebolt/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group-firebolt */ "./packages/muze/src/canvas/firebolt/group-firebolt.js");


/* harmony default export */ __webpack_exports__["default"] = (_group_firebolt__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./packages/muze/src/canvas/helper.js":
/*!********************************************!*\
  !*** ./packages/muze/src/canvas/helper.js ***!
  \********************************************/
/*! exports provided: initCanvas, fixScrollBarConfig, setLayoutInfForUnits, dispatchProps, notifyAnimationEnd, setupChangeListener, applyInteractionPolicy, setLabelRotationForAxes, createGroupState, removeChild, createLayoutManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initCanvas", function() { return initCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixScrollBarConfig", function() { return fixScrollBarConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLayoutInfForUnits", function() { return setLayoutInfForUnits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchProps", function() { return dispatchProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notifyAnimationEnd", function() { return notifyAnimationEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupChangeListener", function() { return setupChangeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyInteractionPolicy", function() { return applyInteractionPolicy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLabelRotationForAxes", function() { return setLabelRotationForAxes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGroupState", function() { return createGroupState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChild", function() { return removeChild; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLayoutManager", function() { return createLayoutManager; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-group */ "./packages/visual-group/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _local_options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./local-options */ "./packages/muze/src/canvas/local-options.js");
/* harmony import */ var _layout_src_tree_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../layout/src/tree-layout */ "./packages/layout/src/tree-layout/index.js");






/**
 * Instantiate high level components. Canvas knows what all high level component it has.
 * @nice-to-have dynamic high level components.
 *  - Is it even required ?
 *  - Reactive to source (canvas) streaming ?
 * @param {*} context Canvas instance
 * @return {Object.<Array>} Arrays of Title, visualGroup, Legend
 */
const initCanvas = (context) => {
    const reg = context._registry.components;

    return [new reg.VisualGroup(context._registry, Object.assign({
        throwback: context._throwback
    }, context.dependencies()))];
};

const fixScrollBarConfig = (config) => {
    config.scrollBar.thickness = Math.min(50, Math.max(10, config.scrollBar.thickness));
    return config;
};

const setLayoutInfForUnits = (context) => {
    const layoutManager = context._layoutManager;
    const gridLayout = layoutManager.getComponent(_constants__WEBPACK_IMPORTED_MODULE_2__["GRID"]);
    const boundBox = gridLayout && gridLayout.getBoundBox();
    const valueMatrix = context.composition().visualGroup.matrixInstance().value;
    const parentContainer = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(`#${layoutManager.getRootNodeId()}`).node();
    valueMatrix.each((cell) => {
        cell.valueOf().parentContainerInf({
            el: parentContainer,
            dimensions: boundBox
        });
    });
};

/**
 *
 *
 * @memberof Canvas
 */
const dispatchProps = (context) => {
    const lifeCycleManager = context.dependencies().lifeCycleManager;
    lifeCycleManager.notify({ client: context, action: 'beforeupdate' });
    const visualGroup = context.composition().visualGroup;

    const allOptions = context._allOptions;
    for (const key in allOptions) {
        const value = context[key]();
        if (value !== null) {
            visualGroup[key] && visualGroup[key](value);
        }
    }
    const { invalidValues } = context.config();

    visualGroup.valueParser(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getValueParser"])(invalidValues));
    visualGroup.createMatrices();
    context._cachedProps = {};
    lifeCycleManager.notify({ client: context, action: 'initialized' });
    lifeCycleManager.notify({ client: context, action: 'updated' });
};

const equalityChecker = (props, params) => {
    let checker = () => false;
    return !props.every((option, i) => {
        switch (option) {
        case _constants__WEBPACK_IMPORTED_MODULE_2__["ROWS"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["COLUMNS"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["DETAIL"]:
            checker = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isEqual"])('Array');
            break;

        case _constants__WEBPACK_IMPORTED_MODULE_2__["SHAPE"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["SIZE"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["COLOR"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["DATA"]:
        case _constants__WEBPACK_IMPORTED_MODULE_2__["CONFIG"]:
            checker = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isEqual"])('Object');
            break;
        default:
            checker = () => true;
            break;
        }
        const oldVal = params[i][0];
        const newVal = params[i][1];

        return checker(oldVal, newVal);
    });
};

const updateChecker = (props, params) => props.every((option, i) => {
    const val = params[i][1];
    switch (option) {
    case _constants__WEBPACK_IMPORTED_MODULE_2__["ROWS"]:
    case _constants__WEBPACK_IMPORTED_MODULE_2__["COLUMNS"]:
        return val !== null;

    case _constants__WEBPACK_IMPORTED_MODULE_2__["DATA"]:
        return val && !val.isEmpty();

    default:
        return true;

    }
});

const notifyAnimationEnd = (context) => {
    const viewInfo = context.layout().viewInfo();
    const centerMatrix = viewInfo && viewInfo.viewMatricesInfo.matrices.center[1] || [];
    const promises = [];
    centerMatrix.forEach((cellArr) => {
        cellArr.forEach((cell) => {
            promises.push(cell.valueOf().done());
        });
    });
    const lifeCycleManager = context.lifeCycle();
    if (promises.length) {
        Promise.all(promises).then(() => {
            // Update life cycle
            lifeCycleManager.notify({ client: context, action: 'drawn' });
            const animDonePromises = [];

            centerMatrix.forEach((cellArr) => {
                cellArr.forEach((cell) => {
                    cell.valueOf().layers().forEach((layer) => {
                        animDonePromises.push(layer.animationDone());
                    });
                });
            });

            [context.xAxes(), context.yAxes()].forEach((axisArr) => {
                axisArr = axisArr || [];
                axisArr.forEach((axes) => {
                    axes.forEach((axisInst) => {
                        animDonePromises.push(axisInst.animationDone());
                    });
                });
            });

            Promise.all(animDonePromises).then(() => {
                lifeCycleManager.notify({ client: context, action: 'animationend' });
            });
        });
    } else {
        lifeCycleManager.notify({ client: context, action: 'animationend' });
    }
};

const setupChangeListener = (context) => {
    const store = context._store;

    const allOptions = Object.keys(context._allOptions);
    const props = [...allOptions, ...Object.keys(_local_options__WEBPACK_IMPORTED_MODULE_3__["canvasOptions"])];
    const nameSpaceProps = [...allOptions, ...Object.keys(_local_options__WEBPACK_IMPORTED_MODULE_3__["canvasOptions"])].map(prop =>
        `${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].CANVAS_LOCAL_NAMESPACE}.${prop}`);
    store.registerChangeListener(nameSpaceProps, (...params) => {
        const equalityProps = equalityChecker(props, params);
        const updateProps = updateChecker(props, params);
        // inform attached board to rerender
        if (equalityProps && context.mount()) {
            if (updateProps) {
                dispatchProps(context);
            } else {
                context.composition().visualGroup.remove();
            }
            context.render();
        }
        notifyAnimationEnd(context);
    }, true);
};

const applyInteractionPolicy = (firebolt) => {
    const canvas = firebolt.context;
    const visualGroup = canvas.composition().visualGroup;
    if (visualGroup) {
        const valueMatrix = visualGroup.matrixInstance().value;
        const interactionPolicy = firebolt._interactionPolicy;
        interactionPolicy(valueMatrix, firebolt);
        const crossInteractionPolicy = firebolt._crossInteractionPolicy;
        const behaviours = crossInteractionPolicy.behaviours;
        const sideEffects = crossInteractionPolicy.sideEffects;
        valueMatrix.each((cell) => {
            const unitFireBolt = cell.valueOf().firebolt();
            for (const key in behaviours) {
                unitFireBolt.changeBehaviourStateOnPropagation(key, behaviours[key]);
            }
            for (const key in sideEffects) {
                unitFireBolt.changeSideEffectStateOnPropagation(key, sideEffects[key]);
            }
        });
    }
};

/**
 * Sets the rotation for all x axes if any axis has the rotation config set in the
 * entire view
 *
 * @param {Array} columns Column cells that contain the axes cells
 */
const setLabelRotationForAxes = (context) => {
    let rotation = 0;

    const xAxes = context.xAxes() || [];

    (() => {
        for (let i = 0; i < xAxes.length; i++) {
            for (let j = 0; j < xAxes[i].length; j++) {
                const rotationVal = xAxes[i][j].renderConfig().labels.rotation;
                if (rotationVal && rotationVal !== 0) {
                    rotation = rotationVal;
                    return;
                }
            }
        }
    })();

    if (rotation) {
        xAxes.forEach((axes) => {
            axes.forEach((axis) => {
                axis.renderConfig({ labels: { rotation } });
                axis.smartTicks(axis.setTickConfig());
            });
        });
    }
};

const createGroupState = (context) => {
    const [globalState, localState] = _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_1__["VisualGroup"].getState();
    const store = context._store;
    store.append('app.group', globalState);
    store.append('local.group', localState);
};

const removeChild = (mount) => {
    while (mount.firstChild) {
        mount.removeChild(mount.firstChild);
    }
};

const createLayoutManager = () => {
    const layoutManager = new _layout_src_tree_layout__WEBPACK_IMPORTED_MODULE_4__["LayoutManager"]({
        className: 'muze-group-container'
    });
    return layoutManager;
};


/***/ }),

/***/ "./packages/muze/src/canvas/index.js":
/*!*******************************************!*\
  !*** ./packages/muze/src/canvas/index.js ***!
  \*******************************************/
/*! exports provided: Canvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas */ "./packages/muze/src/canvas/canvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Canvas", function() { return _canvas__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/muze/src/canvas/layout-maker.js":
/*!**************************************************!*\
  !*** ./packages/muze/src/canvas/layout-maker.js ***!
  \**************************************************/
/*! exports provided: prepareLayout, getRenderDetails, renderLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareLayout", function() { return prepareLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRenderDetails", function() { return getRenderDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLayout", function() { return renderLayout; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _component_resolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component-resolver */ "./packages/muze/src/canvas/component-resolver.js");
/* harmony import */ var _title_maker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./title-maker */ "./packages/muze/src/canvas/title-maker.js");
/* harmony import */ var _legend_maker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./legend-maker */ "./packages/muze/src/canvas/legend-maker.js");
/* harmony import */ var _component_wrapper_maker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./component-wrapper-maker */ "./packages/muze/src/canvas/component-wrapper-maker.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _scroll_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scroll-manager */ "./packages/muze/src/canvas/scroll-manager.js");








/**
 *
 *
 * @param {*} context
 *
 */
const prepareLayout = (layout, renderDetails) => {
    const { components, layoutConfig, measurement } = renderDetails;
    const {
        rows,
        columns,
        values,
        cornerMatrices
    } = components;
    const {
        topLeft,
        topRight,
        bottomLeft,
        bottomRight
    } = cornerMatrices;
    if (rows && columns) {
        layout.measurement(measurement)
                        .config(layoutConfig)
                        .matrices({
                            top: [topLeft, columns[0], topRight],
                            center: [rows[0], values, rows[1]],
                            bottom: [bottomLeft, columns[1], bottomRight]
                        })
                        .triggerReflow();
    }
};

/**
 *
 *
 * @param {*} context
 * @param {*} mount
 *
 */
const getRenderDetails = (context, mount) => {
    let layoutConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, context.config());
    // Get height width of the mount point
    let { height, width } = mount.getBoundingClientRect();
    const heightAttr = context.height();
    const widthAttr = context.width();
    const visGroup = context.composition().visualGroup;
    const {
        isColumnSizeEqual,
        isRowSizeEqual,
        priority,
        rows,
        columns,
        values
    } = visGroup.placeholderInfo();
    const {
        minWidth,
        minHeight,
        classPrefix,
        showHeaders,
        legend,
        pagination,
        scrollBar
    } = context.config();

    // Get title configuration
    const titleConfig = context.title()[1];
     // Get subtitle configuration
    const subtitleConfig = context.subtitle()[1];
    // Get legend position
    const legendPosition = legend.position;
    // Arrange components according to config
    const layoutArrangement = Object(_component_resolver__WEBPACK_IMPORTED_MODULE_1__["arrangeComponents"])(context);

    height = Math.floor(height);
    width = Math.floor(width);

    const availableHeightForCanvas = Math.max(heightAttr > 0 ? heightAttr : height, minHeight);
    const availableWidthForCanvas = Math.max(widthAttr > 0 ? widthAttr : width, minWidth);

    // Create headers and determine header height
    const { headers, headerHeight } = Object(_title_maker__WEBPACK_IMPORTED_MODULE_2__["createHeaders"])(context, availableHeightForCanvas, availableWidthForCanvas);

    // Create legends and determine legend space
    const legends = Object(_legend_maker__WEBPACK_IMPORTED_MODULE_3__["createLegend"])(context, headerHeight, availableHeightForCanvas, availableWidthForCanvas);
    context._composition.legend = {};
    legends.forEach((e) => {
        context._composition.legend[e.scaleType] = e.legend;
    });

    const legendSpace = Object(_legend_maker__WEBPACK_IMPORTED_MODULE_3__["getLegendSpace"])(legends, legend, availableHeightForCanvas, availableWidthForCanvas);
    const legendWidth = (legendPosition === _constants__WEBPACK_IMPORTED_MODULE_5__["LEFT"] || legendPosition === _constants__WEBPACK_IMPORTED_MODULE_5__["RIGHT"]) ? legendSpace.width : 0;
    const legendHeight = (legendPosition === _constants__WEBPACK_IMPORTED_MODULE_5__["TOP"] || legendPosition === _constants__WEBPACK_IMPORTED_MODULE_5__["BOTTOM"]) ? legendSpace.height : 0;

    // Set components for layouting
    const components = {
        headers,
        legends,
        canvases: [context],
        rows,
        columns,
        values,
        cornerMatrices: visGroup.cornerMatrices()
    };

    const measurement = {
        mountSpace: {
            height,
            width
        },
        headerHeight,
        legendSpace,
        canvasWidth: availableWidthForCanvas,
        canvasHeight: availableHeightForCanvas,
        width: availableWidthForCanvas - legendWidth,
        height: availableHeightForCanvas - headerHeight - legendHeight,
        minUnitHeight: context.minUnitHeight(),
        minUnitWidth: context.minUnitWidth()
    };
    layoutConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(layoutConfig, {
        classPrefix,
        showHeaders,
        border: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(visGroup.metaData().border, context.config().border),
        layoutArrangement,
        legend,
        buffer: scrollBar.thickness,
        pagination,
        title: titleConfig,
        subtitle: subtitleConfig,
        isColumnSizeEqual,
        isRowSizeEqual,
        mount,
        priority
    });
    return {
        layoutConfig,
        components,
        measurement
    };
};

const componentIndexes = {
    title: 0,
    subtitle: 1,
    legend: 2,
    verticalScrollBar: 3,
    horizontalScrollBar: 4,
    grid: 5,
    message: 6
};

const componentNames = {
    0: _constants__WEBPACK_IMPORTED_MODULE_5__["TITLE"],
    1: _constants__WEBPACK_IMPORTED_MODULE_5__["SUB_TITLE"],
    2: _constants__WEBPACK_IMPORTED_MODULE_5__["LEGEND"],
    3: _constants__WEBPACK_IMPORTED_MODULE_5__["VERTICAL_SCROLL_BAR"],
    4: _constants__WEBPACK_IMPORTED_MODULE_5__["HORIZONTAL_SCROLL_BAR"],
    5: _constants__WEBPACK_IMPORTED_MODULE_5__["GRID"],
    6: _constants__WEBPACK_IMPORTED_MODULE_5__["MESSAGE"]
};

const attachListeners = (componentWrappers) => {
    componentWrappers.forEach((componentWrapper) => {
        if (componentWrapper) {
            componentWrapper.attachListener();
        }
    });
};

/**
 * Responsible for creating a scroll manager that manages interactions between the grid
 * component and the scroll bar components
 *
 * @param {Array} componentWrappers Contains the wrappers for all the components
 * @param {Canvas} canvas Instance of the current canvas
 * @return {Array} Positions of units either horizontal or vertical
 */
const createScrollManager = (componentWrappers, canvas) => {
    const {
        horizontalScrollBar,
        verticalScrollBar,
        grid
    } = componentIndexes;

    const horizontalScrollWrapper = componentWrappers[horizontalScrollBar];
    const verticalScrollWrapper = componentWrappers[verticalScrollBar];
    const gridWrapper = componentWrappers[grid];
    const scrollBarManager = new _scroll_manager__WEBPACK_IMPORTED_MODULE_6__["ScrollManager"]();
    const scrollBarComponents = {};

    verticalScrollWrapper && (scrollBarComponents.vertical = verticalScrollWrapper);
    horizontalScrollWrapper && (scrollBarComponents.horizontal = horizontalScrollWrapper);

    scrollBarManager
                    .scrollBarComponents(scrollBarComponents)
                    .attachedComponents({
                        grid: gridWrapper
                    });
    canvas.composition().hScrollBar = horizontalScrollWrapper;
    canvas.composition().vScrollBar = verticalScrollWrapper;

    [horizontalScrollWrapper, verticalScrollWrapper].forEach((wrapper) => {
        wrapper && wrapper.manager(scrollBarManager);
    });

    gridWrapper.scrollBarManager(scrollBarManager);
};

const renderLayout = (canvas, renderDetails) => {
    const layoutManager = canvas._layoutManager;
    const gridLayout = canvas.layout();
    const {

        grid
    } = componentIndexes;

    // Get the component wrappers
    const compWrappers = Object(_component_wrapper_maker__WEBPACK_IMPORTED_MODULE_4__["componentWrapperMaker"])(canvas, gridLayout, renderDetails);
    const componentWrappers = Object.keys(componentIndexes).map(e => compWrappers[e]);
    const gridWrapper = componentWrappers[grid];
    if (gridWrapper) {
        createScrollManager(componentWrappers, canvas);
    }

    componentWrappers.forEach((componentWrapper, index) => {
        if (!componentWrapper) {
            const deleteElementName = componentNames[index];
            layoutManager.removeComponent(deleteElementName);
        }
    });
    layoutManager.registerComponents(componentWrappers).compute();
    attachListeners(componentWrappers);
};


/***/ }),

/***/ "./packages/muze/src/canvas/legend-maker.js":
/*!**************************************************!*\
  !*** ./packages/muze/src/canvas/legend-maker.js ***!
  \**************************************************/
/*! exports provided: legendCreator, legendInitializer, getLegendSpace, createLegend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legendCreator", function() { return legendCreator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legendInitializer", function() { return legendInitializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLegendSpace", function() { return getLegendSpace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLegend", function() { return createLegend; });
/* harmony import */ var _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-cell */ "./packages/visual-cell/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");




/**
 *
 *
 * @param {*} legendConfig
 * @param {*} canvases
 *
 */
const legendCreator = (canvas) => {
    let LegendCls;
    const dataset = [];
    const axes = canvas.getRetinalAxes();

    Object.entries(axes).forEach((axisInfo) => {
        const scale = axisInfo[1][0];
        const scaleType = axisInfo[0];
        const scaleProps = canvas[scaleType]();

        if (scaleProps.field && scale) {
            const {
                type,
                step
            } = scale.config();

            const stepMapper = typeof step === 'boolean' ? step : false;
            LegendCls = _constants__WEBPACK_IMPORTED_MODULE_2__["LEGEND_TYPE_MAP"][`${type}-${stepMapper}-${scaleType}`];
            dataset.push({
                scale,
                canvas,
                fieldName: scaleProps.field,
                title: Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["retrieveFieldDisplayName"])(canvas.data(), scaleProps.field),
                LegendCls,
                scaleType
            });
        }
    });

    return dataset;
};

/**
 *
 *
 * @param {*} legendConfig
 * @param {*} canvases
 * @param {*} measurement
 * @param {*} prevLegends
 *
 */
const legendInitializer = (legendConfig, canvas, measurement, prevLegends) => {
    const legends = [];
    const {
        height,
        width,
        headerHeight
    } = measurement;
    const {
        position,
        align
    } = legendConfig;

    const legendInfo = legendCreator(canvas);
    const { invalidValues } = canvas.config();

    const parser = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getValueParser"])(invalidValues);
    legendInfo.forEach((dataInfo, index) => {
        const legendMeasures = {};
        const {
                LegendCls,
                scale,
                fieldName,
                title: titleText,
                scaleType
            } = dataInfo;
        const config = legendConfig[scaleType] || {};
        const title = config.title || {};
        title.text = title.text || titleText;
        if (config.show) {
            config.position = position;
            config.align = align;
            let legend = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(prevLegends[scaleType], index);
            if (!legend) {
                legend = LegendCls.create({
                    labelManager: canvas._dependencies.smartlabel,
                    cells: {
                        AxisCell: _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["AxisCell"], TextCell: _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["TextCell"]
                    }
                });
            }
            legendMeasures.maxHeight = align === _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"] ? (height - headerHeight) : height * 0.2;
            legendMeasures.maxWidth = align === _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"] ? width : width * 0.2;
            legendMeasures.width = Math.min(legendMeasures.maxWidth, config.width);
            legendMeasures.height = Math.min(legendMeasures.maxHeight, config.height);

            [_constants__WEBPACK_IMPORTED_MODULE_2__["PADDING"], _constants__WEBPACK_IMPORTED_MODULE_2__["BORDER"], _constants__WEBPACK_IMPORTED_MODULE_2__["MARGIN"]].forEach((e) => {
                legendMeasures[e] = config[e];
            });
            const metaData = legend.metaData();
            if (metaData instanceof muze_utils__WEBPACK_IMPORTED_MODULE_1__["DataModel"]) {
                metaData.dispose();
            }
            legend.scale(scale)
                            .valueParser(parser)
                            .title(title)
                            .fieldName(fieldName)
                            .config(config)
                            .metaData(canvas.composition().visualGroup.getGroupByData().project([fieldName]))
                            .measurement(legendMeasures)
                            .canvasAlias(canvas.alias())
                            .setLegendMeasures();

            legends.push({ canvas, legend, scaleType });
        }
    });
    return legends;
};

/**
 *
 *
 * @param {*} legends
 * @param {*} legendConfig
 * @param {*} availableHeight
 * @param {*} availableWidth
 *
 */
const getLegendSpace = (legends, legendConfig, availableHeight, availableWidth) => {
    const legendMeasures = legends.map(legendInfo => legendInfo.legend.measurement());
    const legendSpace = { width: 0, height: 0 };

    legendMeasures.forEach((space) => {
        let height = 0;
        let width = 0;
        width = Math.min(space.width, space.maxWidth);
        height = Math.min(space.height, space.maxHeight);

        if (legendConfig.align === _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"]) {
            if (legendSpace.width + width > availableWidth) {
                legendSpace.width = availableWidth;
                legendSpace.height += height;
            } else {
                legendSpace.width += width;
                legendSpace.height = Math.max(legendSpace.height, height);
            }
        } else if (legendSpace.height + height > availableHeight) {
            legendSpace.height = height;
            legendSpace.width += width;
        } else {
            legendSpace.height += height;
            legendSpace.width = Math.max(legendSpace.width, width);
        }
    });
    if (legendConfig.align === _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"]) {
        legendSpace.width = availableWidth;
    }
    return legendSpace;
};

/**
 *
 *
 * @param {*} context
 * @param {*} headerHeight
 *
 */
const createLegend = (context, headerHeight, height, width) => {
    const measurement = {
        height,
        width,
        headerHeight
    };
    const { legend } = context.config();
    const { show, position } = legend;

    legend.classPrefix = context.config().classPrefix;
    const align = (position === _constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"] || position === _constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"]) ? _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"] : _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"];

    legend.show = show ? ((align === _constants__WEBPACK_IMPORTED_MODULE_2__["VERTICAL"] && width > 200) || (align === _constants__WEBPACK_IMPORTED_MODULE_2__["HORIZONTAL"] && height > 200)) : show;
    legend.align = align;
    return legendInitializer(legend, context, measurement, context.composition().legend || {});
};


/***/ }),

/***/ "./packages/muze/src/canvas/local-options.js":
/*!***************************************************!*\
  !*** ./packages/muze/src/canvas/local-options.js ***!
  \***************************************************/
/*! exports provided: localOptions, canvasOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localOptions", function() { return localOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canvasOptions", function() { return canvasOptions; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/muze/src/canvas/defaults.js");



/**
 * This is the local options semantics based on which setters getters are created and reactivity is initiated.
 * This local object is only valid for Canvas.
 * Canvas merges global and local object both to the model
 *
 * Format
 *  PROPERTRY_NAME: {
 *      value: // default value of the property,
 *      meta: {
 *          typeCheck: // The setter value will be checked using this. If the value is function then the setter value
 *                     // is passed as args.
 *          typeExpected: // The output of typecheck action will be tested against this. Truthy value will set the
 *                       // value to the setter
 *          sanitizaiton: // Need for sanitization before type is checked
 *      }
 *  }
 *
 * @module LocalOptions
 */

const localOptions = {
    [_constants__WEBPACK_IMPORTED_MODULE_1__["ROWS"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Array'
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMNS"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Array'
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["COLOR"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Object',
            sanitization: (config) => {
                if (typeof config === 'string' || !config) {
                    return {
                        field: config
                    };
                }
                return config;
            }
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["SHAPE"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Object',
            sanitization: (config) => {
                if (typeof config === 'string' || !config) {
                    return {
                        field: config
                    };
                }
                return config;
            }
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["SIZE"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Object',
            sanitization: (config) => {
                if (typeof config === 'string' || !config) {
                    return {
                        field: config
                    };
                }
                return config;
            }
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["DETAIL"]]: {
        value: [],
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Array'
        }
    },

    [_constants__WEBPACK_IMPORTED_MODULE_1__["LAYERS"]]: {
        value: [],
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Array'
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["TRANSFORM"]]: {
        value: null,
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Object'
        }
    }
};

const canvasOptions = {
    [_constants__WEBPACK_IMPORTED_MODULE_1__["TITLE"]]: {
        value: [null, null],
        meta: {
            takesMultipleParams: true,
            typeCheck: ([arg1, arg2]) => typeof arg1 === 'function' && typeof arg2 === 'object',
            sanitization: ([title, titleConfig]) => {
                let t = title;
                if (typeof title === 'string' || !title) {
                    t = () => title;
                }
                const defConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, _defaults__WEBPACK_IMPORTED_MODULE_2__["TITLE_CONFIG"]);
                return [t, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defConfig, titleConfig)];
            }
        }
    },
    [_constants__WEBPACK_IMPORTED_MODULE_1__["SUB_TITLE"]]: {
        value: [null, null],
        meta: {
            takesMultipleParams: true,
            typeCheck: ([arg1, arg2]) => typeof arg1 === 'function' && typeof arg2 === 'object',
            sanitization: ([subtitle, subtitleConfig]) => {
                let sub = subtitle;
                if (typeof subtitle === 'string' || !subtitle) {
                    sub = () => subtitle;
                }
                const defConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, _defaults__WEBPACK_IMPORTED_MODULE_2__["SUB_TITLE_CONFIG"]);
                return [sub, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defConfig, subtitleConfig)];
            }
        }
    }
};


/***/ }),

/***/ "./packages/muze/src/canvas/scroll-manager.js":
/*!****************************************************!*\
  !*** ./packages/muze/src/canvas/scroll-manager.js ***!
  \****************************************************/
/*! exports provided: ScrollManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollManager", function() { return ScrollManager; });
class ScrollManager {

    constructor () {
        this._scrollBarComponents = {};
        this._attachedComponents = {};
    }

    scrollBarComponents (...sbc) {
        if (sbc.length) {
            this._scrollBarComponents = sbc[0];
            return this;
        }
        return this._scrollBarComponents;
    }

    attachedComponents (...abc) {
        if (abc.length) {
            this._attachedComponents = abc[0];
            return this;
        }
        return this._attachedComponents;
    }

    preventBrowserScroll (type, event) {
        if (this.scrollBarComponents()[type]) {
        // Prevent default behaviour and stop propagating
            event.preventDefault();
            event.stopPropagation();
        }
        return this;
    }

    performAttachedScrollFunction (type, movedViewLength) {
        Object.values(this.attachedComponents()).forEach((e) => {
            e.performScrollAction(type, movedViewLength);
        });
        return this;
    }

    triggerScrollBarAction (type, delta) {
        this.scrollBarComponents()[type] && this.scrollBarComponents()[type].scrollDeltaTo(delta);
        return this;
    }
}


/***/ }),

/***/ "./packages/muze/src/canvas/title-maker.js":
/*!*************************************************!*\
  !*** ./packages/muze/src/canvas/title-maker.js ***!
  \*************************************************/
/*! exports provided: createHeaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHeaders", function() { return createHeaders; });
/* harmony import */ var _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-cell */ "./packages/visual-cell/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./packages/muze/src/constants.js");




/**
 *
 *
 * @param {*} rawContent
 *
 */
const resolveTitleSubTitleContent = (rawContent) => {
    if (typeof rawContent === 'function' && !rawContent._sanitize) {
        return rawContent();
    }
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["escapeHTML"])(rawContent());
};

/**
 *
 *
 * @param {*} config
 * @param {*} cellType
 * @param {*} labelManager
 * @param {*} prevCell
 *
 */
const headerCreator = (config, cellType, labelManager, prevCell) => {
    let margin = {};
    const {
        content,
        classPrefix,
        maxLines
    } = config;
    const cell = prevCell || new _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["TextCell"](
        {
            type: cellType === 'title' ? 'header' : 'text',
            className: `${classPrefix}-${cellType}-cell`
        }, {
            labelManager
        })
     .config({ maxLines }).minSpacing({ width: 0, height: 0 });

    cell.source(content);
    cell._minTickDiff = { height: 0, width: 0 };

    if (config.position === _constants__WEBPACK_IMPORTED_MODULE_2__["TOP"]) {
        margin = { top: 0, bottom: config.padding };
    } else {
        margin = { top: config.padding, bottom: 0 };
    }
    cell.config({ margin });

    return {
        height: cell.getLogicalSpace().height,
        cell
    };
};

/**
 *
 *
 * @param {*} config
 * @param {*} type
 * @param {*} labelManager
 * @param {*} cell
 *
 */
const createHeading = (config, type, labelManager, prevCell) => {
    if (!config) { return ''; }

    return headerCreator(
        config,
        type,
        labelManager,
        prevCell
    );
};

/**
 *
 *
 * @param {*} context
 */
const createHeaders = (context, canvasHeight, canvasWidth) => {
    let headerHeight = 0;
    const headers = {};
    const subtitle = context.subtitle();
    const isSubtitle = resolveTitleSubTitleContent(subtitle[0]);

    canvasHeight >= 200 && canvasWidth >= 200 && ['title', 'subtitle'].forEach((type) => {
        const headerOptions = context[type]();
        const content = resolveTitleSubTitleContent(headerOptions[0]);
        if (content) {
            const config = headerOptions[1];

            config.width = context.width();
            config.height = context.height();
            config.classPrefix = context.config().classPrefix;
            config.content = content;
            config.padding = (type === 'title' && !isSubtitle.length) ? subtitle[1].padding : config.padding;

            const { height, cell } = createHeading(config, type, context.dependencies().smartlabel,
                context[`${type}Cell`]);

            headers[`${type}Cell`] = cell;
            context._composition[type] = cell;
            headerHeight += height;
        }
    });
    return { headerHeight, headers };
};



/***/ }),

/***/ "./packages/muze/src/constants.js":
/*!****************************************!*\
  !*** ./packages/muze/src/constants.js ***!
  \****************************************/
/*! exports provided: ROWS, COLUMNS, DATA, COLOR, SHAPE, SIZE, DETAIL, LAYERS, TRANSFORM, INITIALIZED, SOURCE, WIDTH, HEIGHT, PADDING, BORDER, MARGIN, CONFIG, MOUNT, CANVAS_UPDATED, CLASSPREFIX, POLICIES, LEGEND, TITLE, SUB_TITLE, RESOLVE, DISCRETE, STEP_COLOR, GRADIENT, LINEAR, ORDINAL, MUZE_PREFIX, TITLE_TEMPLATE_NOT_ALLOWED_TAGS, LEGEND_TYPE_MAP, LEFT, RIGHT, BOTTOM, TOP, GROUP, LAYOUT, RETINAL, DIMENSION, MEASURE, VERTICAL, HORIZONTAL, HORIZONTAL_CENTER, VERTICAL_CENTER, HIDDEN, OVERFLOW, OVERFLOW_X, OVERFLOW_Y, AUTO, VISIBLE, VERTICAL_SCROLL_BAR, HORIZONTAL_SCROLL_BAR, GRID, MESSAGE, NO_DATA_MESSAGE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROWS", function() { return ROWS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMNS", function() { return COLUMNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA", function() { return DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPE", function() { return SHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIZE", function() { return SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DETAIL", function() { return DETAIL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERS", function() { return LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INITIALIZED", function() { return INITIALIZED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SOURCE", function() { return SOURCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PADDING", function() { return PADDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER", function() { return BORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARGIN", function() { return MARGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNT", function() { return MOUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_UPDATED", function() { return CANVAS_UPDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLICIES", function() { return POLICIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEGEND", function() { return LEGEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TITLE", function() { return TITLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUB_TITLE", function() { return SUB_TITLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVE", function() { return RESOLVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DISCRETE", function() { return DISCRETE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEP_COLOR", function() { return STEP_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRADIENT", function() { return GRADIENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDINAL", function() { return ORDINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MUZE_PREFIX", function() { return MUZE_PREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TITLE_TEMPLATE_NOT_ALLOWED_TAGS", function() { return TITLE_TEMPLATE_NOT_ALLOWED_TAGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEGEND_TYPE_MAP", function() { return LEGEND_TYPE_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP", function() { return GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYOUT", function() { return LAYOUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RETINAL", function() { return RETINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIMENSION", function() { return DIMENSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASURE", function() { return MEASURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL", function() { return VERTICAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL", function() { return HORIZONTAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL_CENTER", function() { return HORIZONTAL_CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_CENTER", function() { return VERTICAL_CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HIDDEN", function() { return HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OVERFLOW", function() { return OVERFLOW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OVERFLOW_X", function() { return OVERFLOW_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OVERFLOW_Y", function() { return OVERFLOW_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTO", function() { return AUTO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VISIBLE", function() { return VISIBLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_SCROLL_BAR", function() { return VERTICAL_SCROLL_BAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HORIZONTAL_SCROLL_BAR", function() { return HORIZONTAL_SCROLL_BAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID", function() { return GRID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MESSAGE", function() { return MESSAGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_DATA_MESSAGE", function() { return NO_DATA_MESSAGE; });
/* harmony import */ var _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-legend */ "./packages/muze-legend/src/index.js");


/**
 * Contants to be used as attr
 */
const ROWS = 'rows';
const COLUMNS = 'columns';
const DATA = 'data';
const COLOR = 'color';
const SHAPE = 'shape';
const SIZE = 'size';
const DETAIL = 'detail';
const LAYERS = 'layers';
const TRANSFORM = 'transform';
const INITIALIZED = 'isInitialized';
const SOURCE = 'source';
const WIDTH = 'width';
const HEIGHT = 'height';
const PADDING = 'padding';
const BORDER = 'border';
const MARGIN = 'margin';
const CONFIG = 'config';
const MOUNT = 'mount';
const CANVAS_UPDATED = 'canvasUpdated';
const CLASSPREFIX = 'classPrefix';
const POLICIES = '_policies';
const LEGEND = 'legend';
const TITLE = 'title';
const SUB_TITLE = 'subtitle';
const RESOLVE = 'resolve';
const DISCRETE = 'discrete';
const STEP_COLOR = 'step-color';
const GRADIENT = 'gradient';
const LINEAR = 'linear';
const ORDINAL = 'ordinal';
const MUZE_PREFIX = 'muze';

const TITLE_TEMPLATE_NOT_ALLOWED_TAGS = [
    'script',
    'style'
];

const LEGEND_TYPE_MAP = {
    [`${ORDINAL}-${true}-${COLOR}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${ORDINAL}-${true}-${SIZE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${ORDINAL}-${true}-${SHAPE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${ORDINAL}-${false}-${COLOR}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${ORDINAL}-${false}-${SHAPE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${ORDINAL}-${false}-${SIZE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${LINEAR}-${false}-${SIZE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${LINEAR}-${true}-${SIZE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${LINEAR}-${false}-${SHAPE}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["DiscreteLegend"],
    [`${LINEAR}-${true}-${COLOR}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["StepLegend"],
    [`${LINEAR}-${false}-${COLOR}`]: _chartshq_muze_legend__WEBPACK_IMPORTED_MODULE_0__["GradientLegend"]
};

const LEFT = 'left';
const RIGHT = 'right';
const BOTTOM = 'bottom';
const TOP = 'top';
const GROUP = 'group';
const LAYOUT = 'layout';
const RETINAL = 'retinal';
const DIMENSION = 'dimension';
const MEASURE = 'measure';
const VERTICAL = 'vertical';
const HORIZONTAL = 'horizontal';
const HORIZONTAL_CENTER = 'h-center';
const VERTICAL_CENTER = 'v-center';
const HIDDEN = 'hidden';
const OVERFLOW = 'overflow';
const OVERFLOW_X = 'overflow-x';
const OVERFLOW_Y = 'overflow-y';
const AUTO = 'auto';
const VISIBLE = 'visible';
const VERTICAL_SCROLL_BAR = 'verticalScrollBar';
const HORIZONTAL_SCROLL_BAR = 'horizontalScrollBar';
const GRID = 'grid';
const MESSAGE = 'message';
const NO_DATA_MESSAGE = 'No data to display';



/***/ }),

/***/ "./packages/muze/src/default-registry.js":
/*!***********************************************!*\
  !*** ./packages/muze/src/default-registry.js ***!
  \***********************************************/
/*! exports provided: COMPONENTS, SUBREGISTRIES, INTERFACES, registry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPONENTS", function() { return COMPONENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUBREGISTRIES", function() { return SUBREGISTRIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERFACES", function() { return INTERFACES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registry", function() { return registry; });
/* harmony import */ var _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-cell */ "./packages/visual-cell/src/index.js");
/* harmony import */ var _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-unit */ "./packages/visual-unit/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chartshq/visual-group */ "./packages/visual-group/src/index.js");





const COMPONENTS = {
    [_chartshq_visual_group__WEBPACK_IMPORTED_MODULE_3__["VisualGroup"].formalName()]: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_3__["VisualGroup"],
    [_chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["VisualUnit"].formalName()]: _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["VisualUnit"]
};

const SUBREGISTRIES = {
    cellRegistry: _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["cellRegistry"],
    layerRegistry: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["layerRegistry"]
};
const INTERFACES = {
    SimpleGroup: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_3__["SimpleGroup"],
    SimpleCell: _chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["SimpleCell"]
};

const componentRegistry = (components = COMPONENTS) => {
    const reg = Object.assign({}, components);

    return {
        register: (cls) => {
            const key = cls.formalName();
            reg[key] = cls;
            return componentRegistry;
        },
        get: () => reg
    };
};

const registry = {
    components: componentRegistry(COMPONENTS),
    cellRegistry: Object(_chartshq_visual_cell__WEBPACK_IMPORTED_MODULE_0__["cellRegistry"])(),
    layerRegistry: Object(_chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["layerRegistry"])()
};


/***/ }),

/***/ "./packages/muze/src/defaults.js":
/*!***************************************!*\
  !*** ./packages/muze/src/defaults.js ***!
  \***************************************/
/*! exports provided: DEFAULT_CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
const DEFAULT_CONFIG = {
    classPrefix: 'muze',
    interaction: {
        sideEffect: 'individual'
    },
    pagination: 'scroll',
    scrollBar: {
        thickness: 10,
        speed: 2,
        vertical: {
            align: 'right'
        },
        horizontal: {
            align: 'bottom'
        }
    },
    legend: {
        position: 'right',
        color: {
            show: true,
            padding: 1,
            margin: 3,
            border: 1,
            height: 20,
            width: 20
        },
        shape: {
            show: true,
            padding: 1,
            margin: 3,
            border: 1,
            height: 20,
            width: 20
        },
        size: {
            show: true,
            padding: 1,
            margin: 3,
            border: 1,
            height: 20,
            width: 20
        }
    },
    showHeaders: false,
    minWidth: 100,
    minHeight: 100,
    facet: {
        rows: {
            minCharacters: 3
        },
        columns: {
            maxLines: 2,
            verticalAlign: 'middle',
            minCharacters: 1
        }
    },
    border: {
        style: 'solid',
        color: '#d6d6d6',
        width: 2,
        collapse: true,
        spacing: 0
    },
    autoGroupBy: {
        disabled: false
    },
    invalidValues: {},
    sort: {}
};


/***/ }),

/***/ "./packages/muze/src/enums/constants.js":
/*!**********************************************!*\
  !*** ./packages/muze/src/enums/constants.js ***!
  \**********************************************/
/*! exports provided: SIDE_EFFECT_COMMON, SIDE_EFFECT_INDIVIDUAL, TOOLTIP_CONSOLIDATED, TOOLTIP_FRAGMENTED, WHEEL_DELTA_MODIFIER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIDE_EFFECT_COMMON", function() { return SIDE_EFFECT_COMMON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIDE_EFFECT_INDIVIDUAL", function() { return SIDE_EFFECT_INDIVIDUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_CONSOLIDATED", function() { return TOOLTIP_CONSOLIDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_FRAGMENTED", function() { return TOOLTIP_FRAGMENTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WHEEL_DELTA_MODIFIER", function() { return WHEEL_DELTA_MODIFIER; });
const SIDE_EFFECT_COMMON = 'common';
const SIDE_EFFECT_INDIVIDUAL = 'individual';
const TOOLTIP_CONSOLIDATED = 'consolidated';
const TOOLTIP_FRAGMENTED = 'fragmented';
const WHEEL_DELTA_MODIFIER = 30;


/***/ }),

/***/ "./packages/muze/src/index.js":
/*!************************************!*\
  !*** ./packages/muze/src/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Muze = __webpack_require__(/*! ./muze */ "./packages/muze/src/muze.js");

module.exports = Muze.default ? Muze.default : Muze;


/***/ }),

/***/ "./packages/muze/src/muze.js":
/*!***********************************!*\
  !*** ./packages/muze/src/muze.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-unit */ "./packages/visual-unit/src/index.js");
/* harmony import */ var _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-group */ "./packages/visual-group/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ "./packages/muze/package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./packages/muze/package.json", 1);
/* harmony import */ var _operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./operators */ "./packages/muze/src/operators.js");
/* harmony import */ var _action_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./action-model */ "./packages/muze/src/action-model.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./options */ "./packages/muze/src/options.js");
/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./canvas */ "./packages/muze/src/canvas/index.js");
/* harmony import */ var _default_registry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./default-registry */ "./packages/muze/src/default-registry.js");
/* harmony import */ var _muze_scss__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./muze.scss */ "./packages/muze/src/muze.scss");
/* harmony import */ var _muze_scss__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_muze_scss__WEBPACK_IMPORTED_MODULE_11__);
















// Cache singleton instances which should be included only once in a page
const globalCache = {};
const defaultRegistry = _default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"].components;

const overrideRegistryDefinitions = (overrideRegistry, registry) => {
    overrideRegistry.forEach((def) => {
        registry.register(def);
    });
};

/**
 * Entry point to renderer. Initializes an environment with settings and registries for canvas. This is a simple wrapper
 * over {@link Canvas} which enables common configuration passing to multiple such canvases.
 *
 * Everytime `muze()` is called it creates an environment. These environment supports subset of APIs of Canvas. If
 * common configuration is used to render multiple canvases then it can be set directly in the env. Like if data is
 * common across all the visulization then its better to set the data in env. When a canvas is created it receives all
 * those configuration from env.
 *
 * ```
 *  // Creates an environment
 *  const env = muze()
 *  // Set data property in environment, so that all the canvas created from the same environment gets this data
 *  // automatically
 *  env.data(dm);
 *  // Creates canvas, by default env pushes data to canvas instance
 *  const canvas = env.canvas();
 * ```
 *
 * If a property is set on both environment and canvas instance, property set on canvas instance gets more priority.
 *
 * @public
 * @module muze
 * @namespace Muze
 *
 * @return {Env} Instance of an environment
 */
const muze = () => {
    // Setters and getters will be mounted on this. Object will be mutated.
    const [env, globalStore] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["transactor"])({}, _options__WEBPACK_IMPORTED_MODULE_8__["default"]);
    const components = Object.assign({}, _default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"].components.get());
    const componentSubRegistryDef = Object.assign({}, _default_registry__WEBPACK_IMPORTED_MODULE_10__["SUBREGISTRIES"]);

    const componentSubRegistry = {};

    for (const prop in componentSubRegistryDef) {
        componentSubRegistry[prop] = componentSubRegistryDef[prop](_default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"][prop].get());
    }

    // Apart form the setter getter, an instance method is injected to create real renderer instances
    env.canvas = () => {
        // Create a canvas instance with this settings
        const settings = globalStore.serialize();
        const canvas = _canvas__WEBPACK_IMPORTED_MODULE_9__["Canvas"].withSettings(settings, { /* registry */
            components,
            componentSubRegistry
        }, env.globalDependencies());

        // Whenever settings is changed canvas is updated
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["enableChainedTransaction"])(globalStore, canvas, Object.keys(settings));

        return canvas;
    };

    // Global dependencies for for compositions. Only one copy of the same should be in the page
    env.globalDependencies = () => {
        if (!globalCache.smartlabel) {
            globalCache.smartlabel = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["Smartlabel"](1, 'body');
        }
        return {
            smartlabel: globalCache.smartlabel,
            lifeCycleManager: new muze_utils__WEBPACK_IMPORTED_MODULE_0__["LifeCycleManager"]()
        };
    };

    // Retrieves global settings. This getter is readonly so that user can't change this as change should happen
    // only from setter to avoid unwanted sync issues.
    env.settings = () => globalStore.serialize();

    env.registry = (...overrideRegistry) => {
        // Selectively copy the properties from COMPONENTS
        if (overrideRegistry.length) {
            overrideRegistry.forEach((def) => {
                const prop = def.formalName();
                if (prop in defaultRegistry) {
                    components[prop] = def;
                }
            });
            return env;
        }
        return components;
    };

    env.cellRegistry = (...overrideRegistry) => {
        const cellRegistry = componentSubRegistry.cellRegistry;
        if (overrideRegistry.length) {
            overrideRegistryDefinitions(overrideRegistry, cellRegistry);
            return env;
        }
        return cellRegistry.get();
    };

    env.layerRegistry = (...overrideRegistry) => {
        const layerRegistry = componentSubRegistry.layerRegistry;
        if (overrideRegistry.length) {
            overrideRegistryDefinitions(overrideRegistry, layerRegistry);
            return env;
        }
        return layerRegistry.get();
    };

    return env;
};

muze.registry = {
    components: _default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"].components,
    cells: _default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"].cellRegistry,
    layers: _default_registry__WEBPACK_IMPORTED_MODULE_10__["registry"].layerRegistry
};

muze.Components = {
    VisualLayer: {
        layers: {
            BaseLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["BaseLayer"],
            LineLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["LineLayer"],
            TextLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["TextLayer"],
            TickLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["TickLayer"],
            PointLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["PointLayer"],
            SimpleLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["SimpleLayer"],
            AreaLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["AreaLayer"],
            ArcLayer: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["ArcLayer"]
        },
        helpers: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["helpers"],
        enums: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["enums"],
        layerMixins: _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["layerMixins"]
    },
    VisualUnit: {
        cls: _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["VisualUnit"],
        helpers: _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["helpers"],
        enums: _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["enums"],
        UnitFireBolt: _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["UnitFireBolt"]
    },
    VisualGroup: {
        cls: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__["VisualGroup"],
        Encoders: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__["Encoders"],
        encoderHelpers: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__["encoderHelpers"],
        groupUtils: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__["groupUtils"],
        enums: _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_2__["enums"]
    }
};

const SideEffects = {
    sideEffects: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["sideEffects"],
    standards: {
        SurrogateSideEffect: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["SurrogateSideEffect"],
        SpawnableSideEffect: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["SpawnableSideEffect"],
        GenericSideEffect: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["GenericSideEffect"]
    }
};

const Behaviours = {
    behaviouralActions: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["behaviouralActions"],
    standards: {
        GenericBehaviour: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["GenericBehaviour"],
        PersistentBehaviour: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["PersistentBehaviour"],
        VolatileBehaviour: _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_3__["VolatileBehaviour"]
    }
};

muze.DataModel = muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"];
muze.version = _package_json__WEBPACK_IMPORTED_MODULE_5__.version;
muze.SideEffects = SideEffects;
muze.ActionModel = _action_model__WEBPACK_IMPORTED_MODULE_7__["actionModel"];
muze.layerFactory = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_4__["layerFactory"];
muze.Operators = _operators__WEBPACK_IMPORTED_MODULE_6__;
muze.Behaviours = Behaviours;
muze.utils = muze_utils__WEBPACK_IMPORTED_MODULE_0__;
muze.Model = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["Store"]().model.constructor;
/* harmony default export */ __webpack_exports__["default"] = (muze);


/***/ }),

/***/ "./packages/muze/src/muze.scss":
/*!*************************************!*\
  !*** ./packages/muze/src/muze.scss ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/muze/src/operators.js":
/*!****************************************!*\
  !*** ./packages/muze/src/operators.js ***!
  \****************************************/
/*! exports provided: share, html */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "share", function() { return share; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return html; });
/* harmony import */ var _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-group */ "./packages/visual-group/src/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/muze/src/constants.js");



/**
 * This method creates a new composed variable instance from multiple variables. This is required when we have multiple
 * variables on a single axis and the union of domain of all the variables needs to be set on the axis.
 *
 * To create a new composed variable from multiple fields,
 * ```
 *  const sharedVar = share('open', 'high', 'low', 'close');
 *  canvas.rows([sharedVar])
 *      .columns(['date']);
 * ```
 *
 * @module Operators
 * @public
 * @function share
 * @param {Array} vars Variable names.
 *
 * @return {ComposedVars} Instance of composed variable
 */
const share = (...vars) => new _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_0__["ComposedVars"](...vars.map(variable => new _chartshq_visual_group__WEBPACK_IMPORTED_MODULE_0__["SimpleVariable"](variable)));

/**
 *
 *
 * @param {*} node
 *
 */
function treeShakeNode (node) {
    if (node.nodeType !== Node.ELEMENT_NODE) { return; }

    if (_constants__WEBPACK_IMPORTED_MODULE_1__["TITLE_TEMPLATE_NOT_ALLOWED_TAGS"].indexOf(node.tagName.toLowerCase()) !== -1) {
        node.parentNode.removeChild(node);
    } else {
        for (const childNode of node.childNodes) {
            treeShakeNode(childNode);
        }
    }
}

/**
 * A string template tagged function which sanitizes input html formatted string according to the allowed html tags.
 * This is used to render html in canvas components like title and tooltip.
 *
 * To render html in canvas components,
 * ```
 *     canvas.title(html`<span style=font-size:20px;>TITLE</span>`);
 * ```
 *
 * @public
 * @module Operators
 * @function html
 * @param {Array.<string>} strings - The string parts of the template.
 * @param {Array} exps - The list of evaluated expression values.
 *
 * @return {Function} Returns a function which returns the sanitized html string.
 */
function html (strings, ...exps) {
    let htmlCode = '';
    const expLn = exps.length;
    let i = 0;

    for (; i < expLn; ++i) {
        htmlCode += strings[i] + exps[i];
    }
    htmlCode += strings[i];

    const frag = document.createDocumentFragment();
    const wrapper = document.createElement('div');

    frag.appendChild(wrapper);
    wrapper.innerHTML = htmlCode;

    treeShakeNode(wrapper);
    const { innerHTML } = wrapper;

    return () => innerHTML;
}


/***/ }),

/***/ "./packages/muze/src/options.js":
/*!**************************************!*\
  !*** ./packages/muze/src/options.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _canvas_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas/helper */ "./packages/muze/src/canvas/helper.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./packages/muze/src/defaults.js");
/**
 * This is the global options semantics based on which setters getters are created and reactivity is initiated.
 * Format
 *  PROPERTRY_NAME: {
 *      value: // default value of the property,
 *      meta: {
 *          typeCheck: // The setter value will be checked using this. If the value is function then the setter value
 *                     // is passed as args.
 *          typeExpected: // The output of typecheck action will be tested against this. Truthy value will set the
 *                       // value to the setter
 *          sanitizaiton: // Need for sanitization before type is checked
 *      }
 *  }
 * @module GlobalOptions
 */





/* harmony default export */ __webpack_exports__["default"] = ({
    data: {
        value: null,
        meta: {
            typeCheck: d => d instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"]
        }
    },
    width: {
        value: 0,
        meta: {
            sanitization: muze_utils__WEBPACK_IMPORTED_MODULE_0__["intSanitizer"],
            typeCheck: Number.isInteger
        }
    },
    height: {
        value: 0,
        meta: {
            sanitization: muze_utils__WEBPACK_IMPORTED_MODULE_0__["intSanitizer"],
            typeCheck: Number.isInteger
        }
    },
    minUnitWidth: {
        value: 50,
        meta: {
            sanitization: muze_utils__WEBPACK_IMPORTED_MODULE_0__["intSanitizer"],
            typeCheck: Number.isInteger
        }
    },
    minUnitHeight: {
        value: 50,
        meta: {
            sanitization: muze_utils__WEBPACK_IMPORTED_MODULE_0__["intSanitizer"],
            typeCheck: Number.isInteger
        }
    },
    config: {
        value: [null, null],
        meta: {
            typeCheck: 'constructor',
            typeExpected: 'Object',
            takesMultipleParams: true,
            sanitization: ([config, auxConfig = {}], oldConfig) => {
                // Stores additional config, if passed
                const { reset = false } = auxConfig;
                let oldConf = {};

                if (!reset) {
                    oldConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, config === null ? {} : oldConfig);
                }

                const defConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(oldConf, _defaults__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CONFIG"]);
                const newConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defConfig, config);
                return Object(_canvas_helper__WEBPACK_IMPORTED_MODULE_1__["fixScrollBarConfig"])(newConf);
            }

        }
    }
});


/***/ }),

/***/ "./packages/muze/src/transaction-support.js":
/*!**************************************************!*\
  !*** ./packages/muze/src/transaction-support.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransactionSupport; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");

/**
 * An Interface to be implemented if the transaction support is necessary. This class ensures reactivity to
 * global properties.
 */
class TransactionSupport {
    /**
     * Property accessor for data member of the class. Data is passed to the system by calling this method.
     */
    data () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPl);
    }

    /**
     * Property accessor for width of the class. Width is passed as an integer.
     */
    width () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPl);
    }

    /**
     * Property accessor for height of the class. Height is passed as an integer.
     */
    height () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPl);
    }

    /**
     * Property accessor for config of the class. Config is passed as an object.
     */
    config () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPl);
    }
}


/***/ }),

/***/ "./packages/transform/src/enums/transform-type.js":
/*!********************************************************!*\
  !*** ./packages/transform/src/enums/transform-type.js ***!
  \********************************************************/
/*! exports provided: IDENTITY, GROUP, STACK, FRACTURE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP", function() { return GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STACK", function() { return STACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRACTURE", function() { return FRACTURE; });
/**
 * @module Transform
 * This module exports constants that are used to reference transforms in
 * a consistent manner throughout the project.
 */
/* eslint one-var: 0 */
 const IDENTITY = 'identity';
 const GROUP = 'group';
 const STACK = 'stack';
 const FRACTURE = 'fracture';


/***/ }),

/***/ "./packages/transform/src/group-transform/index.js":
/*!*********************************************************!*\
  !*** ./packages/transform/src/group-transform/index.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * Create multiple datasets from a single dataset by grouping the data using
 * a dimensional field.
 * @param {Array} schema Name and type of fields are stored in schema
 * @param {Array} data Data array
 * @param {Object} config Configuration object
 * @return {Array} Grouped data array
 */
/* harmony default export */ __webpack_exports__["default"] = ((schema, data, config) => {
    const groupBy = config.groupBy instanceof Array ? config.groupBy : [config.groupBy];
    const groupByIndices = groupBy.map(fieldName => schema.findIndex(d => d.name === fieldName));

    if (groupByIndices.find(d => d === -1) !== undefined) {
        throw new Error(`Groupby field ${groupBy} not found in schema`);
    }

    const groupedData = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["nestCollection"])({
        keys: groupByIndices,
        data
    });

    groupedData.forEach((d) => {
        const key = d.key;
        if (muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"].isInvalid(key)) {
            d.key = muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"].getInvalidType(key);
        }
    });
    return groupedData;
});


/***/ }),

/***/ "./packages/transform/src/identity-transform/index.js":
/*!************************************************************!*\
  !*** ./packages/transform/src/identity-transform/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module Transform
 * This file exports a function that is used to implement
 * the identity transform
 */
 /* eslint no-unused-vars: 0 */
 /**
  * This function accepts data and returns the data unchanged.
  * @param {Object} schema The schema.
  * @param {Array} data The data array.
  * @param {Object} config The config object.
  * @return {Array} The unchanged data.
  */
 function identityTransform (schema, data, config) {
     return data;
 }

 /* harmony default export */ __webpack_exports__["default"] = (identityTransform);


/***/ }),

/***/ "./packages/transform/src/index.js":
/*!*****************************************!*\
  !*** ./packages/transform/src/index.js ***!
  \*****************************************/
/*! exports provided: identityTransform, stackTransform, groupTransform, transformFactory, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _stack_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stack-transform */ "./packages/transform/src/stack-transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackTransform", function() { return _stack_transform__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _group_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group-transform */ "./packages/transform/src/group-transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupTransform", function() { return _group_transform__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _identity_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity-transform */ "./packages/transform/src/identity-transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return _identity_transform__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _transform_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform-factory */ "./packages/transform/src/transform-factory/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformFactory", function() { return _transform_factory__WEBPACK_IMPORTED_MODULE_3__["default"]; });








/* harmony default export */ __webpack_exports__["default"] = ({ version: '1.0.0' });


/***/ }),

/***/ "./packages/transform/src/stack-transform/index.js":
/*!*********************************************************!*\
  !*** ./packages/transform/src/stack-transform/index.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _group_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../group-transform */ "./packages/transform/src/group-transform/index.js");



/*
    Normalize the data to a form which can be given to d3 stack for stacking the data
    ['Product', 'Sales', 'Region'],
    0 ['A', 2000, 'North'],
    1 ['A', 3000, 'South'],
    2 ['B', 3000, 'South'],
    3 ['B', 2000, 'North'],
    4 ['C', 3000, 'South'],
    5 ['C', 2000, 'North']
            |
            |
    ['Product', 'North', 'South'],
    ['A', 2000, 3000],
    ['B', 2000, 3000],
    ['C', 2000, 3000]
*/
// eslint-disable-next-line require-jsdoc
const normalizeData = (data, schema, valueField, uniqueField, groupBy) => {
    const groupedData = Object(_group_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(schema, data, {
        groupBy: uniqueField
    });
    const uniqueFieldIndex = schema.findIndex(d => d.name === uniqueField);
    const valueFieldIndex = schema.findIndex(d => d.name === valueField);
    const seriesKeyIndex = schema.findIndex(d => d.name === groupBy);
    const seriesKeys = data.map(d => d[seriesKeyIndex]).filter((item, pos, arr) => arr.indexOf(item) === pos).sort();
    const fieldNames = schema.reduce((acc, obj, i) => {
        acc[i] = obj.name;
        return acc;
    }, {});
    const dataArr = groupedData.map((arr) => {
        const tuples = {};
        const rowObj = arr.values.reduce((acc, row) => {
            acc = row.reduce((obj, value, i) => {
                if (i === seriesKeyIndex) {
                    obj[value] = row[valueFieldIndex];
                    tuples[value] = row;
                } else if (i !== valueFieldIndex) {
                    obj[fieldNames[i]] = value;
                }
                return obj;
            }, acc);
            return acc;
        }, {});
        rowObj._tuple = tuples;
            // Set missing values field to zero value
        seriesKeys.forEach((seriesKey) => {
            if (rowObj[seriesKey] === undefined) {
                rowObj[seriesKey] = 0;
                const newArr = new Array(arr.values[0].length);
                newArr[uniqueFieldIndex] = arr.key;
                newArr[seriesKeyIndex] = seriesKey;
                rowObj._tuple[seriesKey] = newArr;
            }
        });
        return rowObj;
    });

    return {
        data: dataArr,
        keys: seriesKeys
    };
};
/**
 * Generate a stacked representation of data
 * @param {Array} schema schema Array
 * @param {Array} data data array
 * @param {Object} config Configuration object
 * @return {Array} stacked data
 */
/* harmony default export */ __webpack_exports__["default"] = ((schema, data, config) => {
    const uniqueField = config.uniqueField;
    const valueField = config.value;
    const groupBy = config.groupBy;
    const sort = config.sort || 'descending';
    const normalizedData = normalizeData(data, schema, valueField, uniqueField, groupBy);
    const keys = normalizedData.keys;
    const map = {};
    const orderBy = config.orderBy;
    const orderIndex = schema.findIndex(d => d.name === orderBy);
    const groupByIndex = schema.findIndex(d => d.name === groupBy);
    if (orderIndex !== -1) {
        keys.forEach((key) => {
            const name = data.find(d => d[groupByIndex] === key);
            map[key] = name[orderIndex];
        });
        normalizedData.keys.sort((a, b) => map[a].localeCompare(map[b]));
    }

    const stackData = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["stack"])({
        keys: normalizedData.keys,
        offset: config.offset || 'diverging',
        order: sort,
        data: normalizedData.data
    });
    stackData.forEach((seriesData) => {
        seriesData.forEach((dataObj) => {
            dataObj.data = dataObj.data._tuple[seriesData.key];
        });
    });
    return stackData;
});



/***/ }),

/***/ "./packages/transform/src/transform-factory/index.js":
/*!***********************************************************!*\
  !*** ./packages/transform/src/transform-factory/index.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_transform_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/transform-type */ "./packages/transform/src/enums/transform-type.js");
/* harmony import */ var _identity_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity-transform */ "./packages/transform/src/identity-transform/index.js");
/* harmony import */ var _group_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../group-transform */ "./packages/transform/src/group-transform/index.js");
/* harmony import */ var _stack_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stack-transform */ "./packages/transform/src/stack-transform/index.js");
/**
 * @module Transform
 * This file exports the transform factory.
 */





/* istanbul ignore next */
const transformMap = {
    [_enums_transform_type__WEBPACK_IMPORTED_MODULE_0__["IDENTITY"]]: _identity_transform__WEBPACK_IMPORTED_MODULE_1__["default"],
    [_enums_transform_type__WEBPACK_IMPORTED_MODULE_0__["GROUP"]]: _group_transform__WEBPACK_IMPORTED_MODULE_2__["default"],
    [_enums_transform_type__WEBPACK_IMPORTED_MODULE_0__["STACK"]]: _stack_transform__WEBPACK_IMPORTED_MODULE_3__["default"]
};

/**
 * This function is used to retirn a transform associated
 * with the given type.
 *
 * @param {string} type The type of the transform.
 * @return {Function} The transform function.
 */
function transformFactory (type) {
    const transform = transformMap[type];
    if (typeof transform !== 'function') {
        throw new Error('Invalid transform type supplied.');
    }
    return transform;
}

/* harmony default export */ __webpack_exports__["default"] = (transformFactory);


/***/ }),

/***/ "./packages/visual-cell/src/axis-cell.js":
/*!***********************************************!*\
  !*** ./packages/visual-cell/src/axis-cell.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-cell/src/enums/constants.js");
/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony import */ var _enums_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums/defaults */ "./packages/visual-cell/src/enums/defaults.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./props */ "./packages/visual-cell/src/props.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");
/**
 * This file declares a class that represents a table cell
 * used to house an axis.
 * @module VisualCell
 */








/**
 * Computes the logical space of the an axis instance within an axis cell
 *
 * @param {Object} context Required to get the needed parameters to compute axis space
 * @return {Object} Returns the logical space for axis
 */
const computeAxisSpace = (context) => {
    let logicalWidth;
    let logicalHeight;
    const axis = context.source();
    const {
        spaceFixer,
        margin
    } = context.config();
    const {
        width,
        height
    } = axis.getLogicalSpace();
    const {
            show
        } = axis.config();
    if (show === true) {
        logicalHeight = Math.floor(height + margin.top + margin.bottom + spaceFixer);
        logicalWidth = Math.floor(width + margin.left + margin.right + spaceFixer);
    } else {
        [logicalWidth, logicalHeight] = [width, height];
    }
    return {
        width: logicalWidth,
        height: logicalHeight
    };
};

/**
 * Represents an axis cell.
 *
 * @class Axis
 */
class AxisCell extends _simple_cell__WEBPACK_IMPORTED_MODULE_2__["default"] {

    /**
     * Creates an instance of AxisCell.
     *
     * @param {Object} config The input config.
     * @memberof AxisCell
     */
    constructor (config) {
        super(config);

        this._axis = null;
        this._availHeight = null;
        this._availWidth = null;
        this._logicalSpace = null;

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_5__["PROPS"][_enums_cell_type__WEBPACK_IMPORTED_MODULE_4__["AXIS"]]);
    }

    /**
     * return the type pf SimpleCell cell.
     *
     * @readonly
     * @memberof AxisCell
     */
    get type () {
        return _enums_cell_type__WEBPACK_IMPORTED_MODULE_4__["AXIS"];
    }

    /**
     * This method return the value conatined by this SimpleCell.
     *
     * @return {SimpleAxis | ColorAxis} Instance of SimpleAxis or ColorAxis.
     * @memberof AxisCell
     */
    valueOf () {
        return this.source().id;
    }

    /**
     * This method return the unique identififer of the axis
     *
     * @return {string} Id of the axis.
     * @memberof AxisCell
     */
    get id () {
        return this._id;
    }

    static formalName () {
        return _constants__WEBPACK_IMPORTED_MODULE_6__["AXIS_CELL"];
    }

    /**
     * Retrns the serialized representation of this cell.
     *
     * @return {Object}Object with serializable props.
     * @memberof AxisCell
     */
    serialize () {
        return {
            type: _enums_cell_type__WEBPACK_IMPORTED_MODULE_4__["AXIS"],
            axis: this.source().serialize()
        };
    }

    /**
     * return the default configuration for the text cell
     *
     * @static
     * @return {Object} Default configuration of the cell
     * @memberof AxisCell
     */
    static defaultConfig () {
        return _enums_defaults__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_CONFIG"];
    }

    /**
     * return the space taken up by an axis element in the dom.
     *
     * @return {Object} Object with width and height fields.
     * @memberof AxisCell
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(computeAxisSpace(this));
        }
        return this.logicalSpace();
    }

    /**
     * This method is used to set the space availiable to render
     * the SimpleCell.
     *
     * @param {number} width The width of SimpleCell.
     * @param {number} height The height of SimpleCell.
     * @return {Instance} Returns current Instance
     * @memberof AxisCell
     */
    setAvailableSpace (width, height) {
        this.availWidth(width);
        this.availHeight(height);
        const {
            margin,
            isOffset
        } = this.config();

        if (width || height) {
            this.source().setAvailableSpace(width, height, margin, isOffset);
            this.source().logicalSpace(null);
        } else {
            this.source().resetLogicalSpace();
        }
        this.logicalSpace(null);
        return this;
    }

    /**
     * This method is used to render the axis inside the axis cell.
     *
     * @param {HTMLElement} mount The mount point.
     * @return {Selection} node where axis mounted
     * @memberof AxisCell
     */
    /* istanbul ignore next */render (mount) {
        if (!mount) {
            return this;
        }
        let actualWidth = 0;
        let actualHeight = 0;
        const axis = this.source();
        const availHeight = this.availHeight();
        const availWidth = this.availWidth();
        const {
            margin
        } = this.config();
        const {
            top,
            bottom,
            left,
            right
        } = margin;
        const {
            show,
            orientation
        } = axis.config();
        const wrapperDiv = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount), 'div', [this], `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["AXIS_CELL"]}`);
        const selection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(wrapperDiv, 'svg', [1], `${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-axis-container`);
        selection.classed(`${_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CLASSPREFIX"]}-axis-container-${orientation}`, true);

        this.mount(mount);
        if (!availWidth) {
            selection.attr(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"], `${0}px`);
        }
        if (!availHeight) {
            selection.attr(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"], `${0}px`);
        }
        actualWidth = availWidth;
        actualHeight = availHeight;
        if (!show) {
            actualWidth = (orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"] || orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) ? availWidth : 0;
            actualHeight = (orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TOP"] || orientation === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["BOTTOM"]) ? 0 : availHeight;
        }
        wrapperDiv.style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["WIDTH"], `${actualWidth}px`)
                        .style(_enums_constants__WEBPACK_IMPORTED_MODULE_1__["HEIGHT"], `${actualHeight}px`)
                        .style('margin-top', top)
                        .style('margin-bottom', bottom)
                        .style('margin-left', left)
                        .style('margin-right', right);

        axis.mount(selection.node());
        return selection;
    }

    /**
     * Disposes the cell
     *
     * @return {Instance} Current instance of AxisCell
     * @memberof AxisCell
     */
    remove () {
        this.source() && this.source().remove();
        this.mount() && this.mount().remove();
        return this;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (AxisCell);



/***/ }),

/***/ "./packages/visual-cell/src/blank-cell.js":
/*!************************************************!*\
  !*** ./packages/visual-cell/src/blank-cell.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-cell/src/enums/constants.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");
/* harmony import */ var _enums_defaults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums/defaults */ "./packages/visual-cell/src/enums/defaults.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./props */ "./packages/visual-cell/src/props.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");
/**
 * This file declares a class that represents a BLANK element in a  table.
 * @module VisualCell
 */








/**
 * Represents a table haeder.
 *
 * @class BLANK
 */
class BlankCell extends _simple_cell__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Creates an instance of BLANK.
     * @param {Object} config The input configuration.
     * @memberof BLANK
     */
    constructor (config) {
        super(config);

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_5__["PROPS"][_enums_cell_type__WEBPACK_IMPORTED_MODULE_3__["BLANK"]]);
    }

    /**
     * return the type pf SimpleCell cell.
     *
     * @readonly
     * @memberof BlankCell
     */
    get type () {
        return _enums_cell_type__WEBPACK_IMPORTED_MODULE_3__["BLANK"];
    }

    /**
     * This method return the value contained by this SimpleCell.
     *
     * @return {string} The text value contained by this cell.
     * @memberof BlankCell
     */
    valueOf () {
        return this.id;
    }

    /**
     * return the default configuration for the text cell
     *
     * @static
     * @return {Object} Default configuration of the cell
     * @memberof BlankCell
     */
    static defaultConfig () {
        return _enums_defaults__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_CONFIG"];
    }

    /**
     * This method is used to return a unique identifier for
     * the BLANK cell.
     *
     * @return {string} The unique identifier for the BLANK.
     * @memberof BlankCell
     */
    get id () {
        return this._id;
    }

    static formalName () {
        return _constants__WEBPACK_IMPORTED_MODULE_6__["BLANK_CELL"];
    }

    /**
     * This method is used to obtain a serialized representation of this instance.
     *
     * @return {Object} Object with serilizable props.
     * @memberof BLANK
     */
    serialize () {
        return {
            type: _enums_cell_type__WEBPACK_IMPORTED_MODULE_3__["BLANK"]
        };
    }

    /**
     * This method return the space taken up
     * by the text with the style applied.
     *
     * @return {Object} width and height taken up by the text.
     * @memberof BLANK
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            return {
                width: this.width || 0,
                height: this.height || 0
            };
        }
        return this.logicalSpace();
    }

    /**
     * This method is used to set the available space.
     *
     * @param {number} width The available width.
     * @param {number} height The available height.
     * @return {Instance} Returns current Instance
     * @memberof BlankCell
     */
    setAvailableSpace (width, height) {
        this.availWidth(width);
        this.availHeight(height);
        this.logicalSpace(null);
        return this;
    }

    /**
     * This method is used to render the BLANK cell inside
     * the provided mount point.
     *
     * @param {HTMLElement} mount The mount point for this cell.
     * @return {Instance} Returns current Instance
     * @memberof BLANK
     */
    /* istanbul ignore next */render (mount) {
        if (mount) {
            const { style } = this.config();
            // append span element to mount point
            this.mount(mount);
            const container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount);
            const elem = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', [this.id]);
            elem.classed(`${_enums_constants__WEBPACK_IMPORTED_MODULE_2__["CLASSPREFIX"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_2__["BLANK_CELL"]}`, true);
            elem.style('width', `${this.availWidth()}px`);
            elem.style('height', `${this.availHeight()}px`);
            elem.html('');
            // apply style on the returned element
            if (style) {
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(elem, style);
            }
        } return this;
    }

    /**
     * Removes the cell(Disposal)
     *
     * @return {Instance} Returns current Instance
     * @memberof BlankCell
     */
    remove () {
        this.mount() && this.mount().remove();
        return this;
    }

    getMinMeasures () {
        return 0;
    }
 }
/* harmony default export */ __webpack_exports__["default"] = (BlankCell);


/***/ }),

/***/ "./packages/visual-cell/src/cell-registry.js":
/*!***************************************************!*\
  !*** ./packages/visual-cell/src/cell-registry.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults */ "./packages/visual-cell/src/defaults.js");


/**
 * Creates a registry for the cells, which can be used for
 * setting a new cell or getting the registered cells
 *
 * @return {Object} Setters and getters for registered cells
 */
const cellRegistry = () => {
    const reg = _defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_PLACEHOLDERS"];
    return {
        register: (def) => {
            const key = def.formalName();
            if (key in reg) {
                reg[key] = def;
            }
            return cellRegistry;
        },
        get: () => reg
    };
};
/* harmony default export */ __webpack_exports__["default"] = (cellRegistry);


/***/ }),

/***/ "./packages/visual-cell/src/constants.js":
/*!***********************************************!*\
  !*** ./packages/visual-cell/src/constants.js ***!
  \***********************************************/
/*! exports provided: SIMPLE_CELL, TEXT_CELL, AXIS_CELL, BLANK_CELL, GEOM_CELL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIMPLE_CELL", function() { return SIMPLE_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_CELL", function() { return TEXT_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS_CELL", function() { return AXIS_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLANK_CELL", function() { return BLANK_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOM_CELL", function() { return GEOM_CELL; });
const SIMPLE_CELL = 'SimpleCell';
const TEXT_CELL = 'TextCell';
const AXIS_CELL = 'AxisCell';
const BLANK_CELL = 'BlankCell';
const GEOM_CELL = 'GeomCell';



/***/ }),

/***/ "./packages/visual-cell/src/defaults.js":
/*!**********************************************!*\
  !*** ./packages/visual-cell/src/defaults.js ***!
  \**********************************************/
/*! exports provided: DEFAULT_PLACEHOLDERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_PLACEHOLDERS", function() { return DEFAULT_PLACEHOLDERS; });
/* harmony import */ var _axis_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./axis-cell */ "./packages/visual-cell/src/axis-cell.js");
/* harmony import */ var _blank_cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blank-cell */ "./packages/visual-cell/src/blank-cell.js");
/* harmony import */ var _text_cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text-cell */ "./packages/visual-cell/src/text-cell.js");
/* harmony import */ var _geom_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geom-cell */ "./packages/visual-cell/src/geom-cell.js");
/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");








const DEFAULT_PLACEHOLDERS = {
    [_constants__WEBPACK_IMPORTED_MODULE_5__["SIMPLE_CELL"]]: _simple_cell__WEBPACK_IMPORTED_MODULE_4__["default"],
    [_constants__WEBPACK_IMPORTED_MODULE_5__["TEXT_CELL"]]: _text_cell__WEBPACK_IMPORTED_MODULE_2__["default"],
    [_constants__WEBPACK_IMPORTED_MODULE_5__["AXIS_CELL"]]: _axis_cell__WEBPACK_IMPORTED_MODULE_0__["default"],
    [_constants__WEBPACK_IMPORTED_MODULE_5__["GEOM_CELL"]]: _geom_cell__WEBPACK_IMPORTED_MODULE_3__["default"],
    [_constants__WEBPACK_IMPORTED_MODULE_5__["BLANK_CELL"]]: _blank_cell__WEBPACK_IMPORTED_MODULE_1__["default"]
};



/***/ }),

/***/ "./packages/visual-cell/src/enums/cell-type.js":
/*!*****************************************************!*\
  !*** ./packages/visual-cell/src/enums/cell-type.js ***!
  \*****************************************************/
/*! exports provided: SIMPLE, TEXT, AXIS, GEOM, BLANK */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIMPLE", function() { return SIMPLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT", function() { return TEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS", function() { return AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOM", function() { return GEOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLANK", function() { return BLANK; });
// eneum to refer to simple cell
const SIMPLE = 'simple';
// eneum to refer to header cell
const TEXT = 'text';
// enum to refer to axis cell
const AXIS = 'axis';
// enum to refer to visual cell
const GEOM = 'geom';
// enum to refer blank cell
const BLANK = 'blank';


/***/ }),

/***/ "./packages/visual-cell/src/enums/constants.js":
/*!*****************************************************!*\
  !*** ./packages/visual-cell/src/enums/constants.js ***!
  \*****************************************************/
/*! exports provided: MARGIN, LEFT, RIGHT, BOTTOM, TOP, SPACE_FIXER, CLASSPREFIX, VERTICAL_ALIGN, TEXT_ALIGN, IS_OFFSET, MIDDLE, BASELINE, SHOW, CENTER, TEXT, HEADER, HEIGHT, WIDTH, DATA, AXES, FACET_BY_FIELDS, FIELDS, TRANSFORM, LAYER_DEF, CONFIG, DETAIL_FIELDS, MAX_LINES, MIN_CHARS, ROTATION, TEXT_CELL, AXIS_CELL, GEOM_CELL, BLANK_CELL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARGIN", function() { return MARGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPACE_FIXER", function() { return SPACE_FIXER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_ALIGN", function() { return VERTICAL_ALIGN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_ALIGN", function() { return TEXT_ALIGN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_OFFSET", function() { return IS_OFFSET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIDDLE", function() { return MIDDLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASELINE", function() { return BASELINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHOW", function() { return SHOW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CENTER", function() { return CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT", function() { return TEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADER", function() { return HEADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA", function() { return DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXES", function() { return AXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACET_BY_FIELDS", function() { return FACET_BY_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIELDS", function() { return FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYER_DEF", function() { return LAYER_DEF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DETAIL_FIELDS", function() { return DETAIL_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_LINES", function() { return MAX_LINES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_CHARS", function() { return MIN_CHARS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROTATION", function() { return ROTATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_CELL", function() { return TEXT_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS_CELL", function() { return AXIS_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOM_CELL", function() { return GEOM_CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLANK_CELL", function() { return BLANK_CELL; });
/**
 * Flag to specify whether direction is vertical.
 */
const MARGIN = 'margin';
const LEFT = 'left';
const RIGHT = 'right';
const BOTTOM = 'bottom';
const TOP = 'top';
const SPACE_FIXER = 'spaceFixer';
const CLASSPREFIX = 'muze';
const VERTICAL_ALIGN = 'verticalAlign';
const TEXT_ALIGN = 'textAlign';
const IS_OFFSET = 'isOffset';
const MIDDLE = 'middle';
const BASELINE = 'baseline';
const SHOW = 'show';
const CENTER = 'center';
const TEXT = 'text';
const HEADER = 'header';
const HEIGHT = 'height';
const WIDTH = 'width';
const DATA = 'data';
const AXES = 'axes';
const FACET_BY_FIELDS = 'facetByFields';
const FIELDS = 'fields';
const TRANSFORM = 'transform';
const LAYER_DEF = 'layerDef';
const CONFIG = 'config';
const DETAIL_FIELDS = 'detailFields';
const MAX_LINES = 'maxLines';
const MIN_CHARS = 'minCharacters';
const ROTATION = 'rotation';

const TEXT_CELL = 'text-cell';
const AXIS_CELL = 'axis-cell';
const GEOM_CELL = 'geom-cell';
const BLANK_CELL = 'blank-cell';


/***/ }),

/***/ "./packages/visual-cell/src/enums/defaults.js":
/*!****************************************************!*\
  !*** ./packages/visual-cell/src/enums/defaults.js ***!
  \****************************************************/
/*! exports provided: DEFAULT_CONFIG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIG", function() { return DEFAULT_CONFIG; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/enums/constants.js");
/**
 * This file exports variables that are used as defaults for
 * the placeholders
 */


 /**
 * Default Configuration for the cells
 * @return {Object} Default configuration
 */
const DEFAULT_CONFIG = {
    [_constants__WEBPACK_IMPORTED_MODULE_0__["MARGIN"]]: {
        [_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT"]]: 0,
        [_constants__WEBPACK_IMPORTED_MODULE_0__["RIGHT"]]: 0,
        [_constants__WEBPACK_IMPORTED_MODULE_0__["TOP"]]: 0,
        [_constants__WEBPACK_IMPORTED_MODULE_0__["BOTTOM"]]: 0
    },
    [_constants__WEBPACK_IMPORTED_MODULE_0__["SPACE_FIXER"]]: 2,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["IS_OFFSET"]]: false,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTICAL_ALIGN"]]: null,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["TEXT_ALIGN"]]: _constants__WEBPACK_IMPORTED_MODULE_0__["CENTER"],
    [_constants__WEBPACK_IMPORTED_MODULE_0__["SHOW"]]: true,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["MAX_LINES"]]: 0,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["MIN_CHARS"]]: 0,
    [_constants__WEBPACK_IMPORTED_MODULE_0__["ROTATION"]]: null
};


/***/ }),

/***/ "./packages/visual-cell/src/geom-cell.js":
/*!***********************************************!*\
  !*** ./packages/visual-cell/src/geom-cell.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props */ "./packages/visual-cell/src/props.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-cell/src/enums/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");
/* harmony import */ var _enums_defaults__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enums/defaults */ "./packages/visual-cell/src/enums/defaults.js");
/**
 * This file declares a class that is used to represent a table cell
 * that houses a visual unit.
 * @module VisualCell
 */









/**
 * Calculates the logical space of the cell
 *
 * @param {Object} context Required to get the needed parameters to compute unit space
 * @return {Object} Logical space taken up by the unit
 * @memberof GeomCell
 */
const computeGeomSpace = (context) => {
    const config = context.source().config();
    const { width, height } = config;
    return {
        width: Math.ceil(width),
        height: Math.ceil(height + context.getCaptionSpace().height)
    };
};

 /**
 * This class represents a SimpleCell for visual unit.
 *
 * @class GeomCell
 */
class GeomCell extends _simple_cell__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Creates an instance of GeomCell.
     * @param {Object} config The input configuration.
     * @memberof GeomCell
     */
    constructor (config) {
        super(config);

        this._unit = null;
        this._layers = null;
        this._axes = {};
        this._datamodel = {};
        this._facetByFields = {};
        this._fields = null;
        this._transform = null;
        this._caption = null;

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_3__["PROPS"][_enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["GEOM"]]);
    }

    /**
     * return the type pf SimpleCell cell.
     *
     * @readonly
     * @memberof GeomCell
     */
    get type () {
        return _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["GEOM"];
    }

    /**
     * This method return the value contained by this cell.
     *
     * @return {VisualUnit} Instance of visual unit contained by visual unit.
     * @memberof GeomCell
     */
    valueOf () {
        return this.source();
    }

    /**
     * This method is used to return the id of the
     * visual unit housed by this cell.
     *
     * @return {string} The unique id of the visual unit.
     * @memberof GeomCell
     */
    get id () {
        return this.source().id();
    }

    static formalName () {
        return _constants__WEBPACK_IMPORTED_MODULE_5__["GEOM_CELL"];
    }

    /**
     * This method return a serialized representation of
     * this instance.
     *
     * @return {Object} Object with serializable props.
     * @memberof GeomCell
     */
    serialize () {
        return {
            type: _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["GEOM"],
            unit: this.source().serialize(),
            caption: this.caption()
        };
    }

    /**
     * return the default configuration for the geom cell
     *
     * @static
     * @return {Object} Default configuration of the cell
     * @memberof GeomCell
     */
    static defaultConfig () {
        return _enums_defaults__WEBPACK_IMPORTED_MODULE_6__["DEFAULT_CONFIG"];
    }

    /**
     * Updates the model based on the changed parameters
     *
     * @return {Instance} return instance
     * @memberof GeomCell
     */
    updateModel () {
        const unit = this.source();
        unit.clearCaching();
        [_enums_constants__WEBPACK_IMPORTED_MODULE_4__["LAYER_DEF"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["TRANSFORM"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["AXES"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["FIELDS"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["CONFIG"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["DATA"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["AXES"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["FACET_BY_FIELDS"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["DETAIL_FIELDS"]].forEach((prop) => {
            this[prop]() && unit[prop](this[prop]());
        });
        return this;
    }

    /**
     * It gives the space taken by the caption of the unit
     *
     * @return {Object} return the space taken by caption
     * @memberof GeomCell
     */
    getCaptionSpace () {
        const caption = this.caption();

        let captionSpace = { width: 0, height: 0 };
        if (caption) {
            captionSpace = caption.getLogicalSpace();
        }
        return captionSpace;
    }

    /**
     * return the space taken up by the element in the dom.
     *
     * @return {Object} Object with width and height fields.
     * @memberof GeomCell
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(computeGeomSpace(this));
        }
        return this.logicalSpace();
    }

    /**
     * This method is used to set the space available to
     * render the SimpleCell.
     *
     * @param {number} width The available width.
     * @param {number} height The available height.
     * @return {Instance} Returns current Instance
     * @memberof GeomCell
     */
    setAvailableSpace (width, height) {
        const unit = this.source();

        this.availWidth(width);
        this.availHeight(height);
        unit.lockModel()
            .width(width).height(height - this.getCaptionSpace().height)
            .unlockModel();
        this.logicalSpace(null);
        return this;
    }

    /**
     * his method is used to render the visual unit inside the provided cell.
     *
     * @param {HTMLElement} mount The mountpoint in the table.
     * @return {Instance} Returns current Instance
     * @memberof GeomCell
     */
    render (mount) {
        if (mount) {
            this.mount(mount);
            const availHeight = this.availHeight();
            const availWidth = this.availWidth();
            const caption = this.caption();
            const wrapperDiv = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount), 'div', [1], `${_enums_constants__WEBPACK_IMPORTED_MODULE_4__["CLASSPREFIX"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_4__["GEOM_CELL"]}`);

            if (caption) {
                const captionDom = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(wrapperDiv, 'div', [caption], `${_enums_constants__WEBPACK_IMPORTED_MODULE_4__["CLASSPREFIX"]}-unit-caption`).node();
                caption.render(captionDom);
            }
            const selection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(wrapperDiv, 'div', [1], `${_enums_constants__WEBPACK_IMPORTED_MODULE_4__["CLASSPREFIX"]}-unit`);
            wrapperDiv.style(_enums_constants__WEBPACK_IMPORTED_MODULE_4__["WIDTH"], `${availWidth}px`).style(_enums_constants__WEBPACK_IMPORTED_MODULE_4__["HEIGHT"], `${availHeight}px`);
            selection.style(_enums_constants__WEBPACK_IMPORTED_MODULE_4__["WIDTH"], `${availWidth}px`)
                            .style(_enums_constants__WEBPACK_IMPORTED_MODULE_4__["HEIGHT"], `${availHeight - this.getCaptionSpace().height}px`);
            this.source().mount(selection.node());
        }
        return this;
    }

    /**
     * Disposes the cell
     *
     * @return {Object} Current instance
     * @memberof GeomCell
     */
    remove () {
        this.mount() && this.mount().remove();
        this.source().remove();
        return this;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (GeomCell);


/***/ }),

/***/ "./packages/visual-cell/src/index.js":
/*!*******************************************!*\
  !*** ./packages/visual-cell/src/index.js ***!
  \*******************************************/
/*! exports provided: AxisCell, BlankCell, TextCell, GeomCell, SimpleCell, cellRegistry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _axis_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./axis-cell */ "./packages/visual-cell/src/axis-cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisCell", function() { return _axis_cell__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _blank_cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blank-cell */ "./packages/visual-cell/src/blank-cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BlankCell", function() { return _blank_cell__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _text_cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text-cell */ "./packages/visual-cell/src/text-cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextCell", function() { return _text_cell__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _geom_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geom-cell */ "./packages/visual-cell/src/geom-cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeomCell", function() { return _geom_cell__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleCell", function() { return _simple_cell__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _cell_registry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cell-registry */ "./packages/visual-cell/src/cell-registry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cellRegistry", function() { return _cell_registry__WEBPACK_IMPORTED_MODULE_5__["default"]; });











/***/ }),

/***/ "./packages/visual-cell/src/props.js":
/*!*******************************************!*\
  !*** ./packages/visual-cell/src/props.js ***!
  \*******************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");



const DEFAULT_PROPS = {
    mount: {},
    availHeight: {},
    availWidth: {},
    config: {
        sanitization: (context, value) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(context._config, value)
    },
    logicalSpace: {},
    minSpacing: {},
    source: {}
};

const geomProps = {
    data: {},
    caption: {},
    config: {},
    axes: {},
    facetByFields: {},
    fields: {},
    transform: {},
    layerDef: {},
    detailFields: {}
};

const textProps = {
    smartText: {}
};
const PROPS = {
    [_enums_cell_type__WEBPACK_IMPORTED_MODULE_1__["GEOM"]]: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(geomProps, DEFAULT_PROPS),
    [_enums_cell_type__WEBPACK_IMPORTED_MODULE_1__["TEXT"]]: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(textProps, DEFAULT_PROPS),
    [_enums_cell_type__WEBPACK_IMPORTED_MODULE_1__["AXIS"]]: DEFAULT_PROPS,
    [_enums_cell_type__WEBPACK_IMPORTED_MODULE_1__["BLANK"]]: DEFAULT_PROPS
};


/***/ }),

/***/ "./packages/visual-cell/src/simple-cell.js":
/*!*************************************************!*\
  !*** ./packages/visual-cell/src/simple-cell.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");




/**
 * This file declares a class that is used as an interface to create new
 * SimpleCell elements.
 * @module SimpleCell
 */
/**
 * Base class for all table cells.
 *
 * @interface
 * @class SimpleCell
 */
class SimpleCell {

    /**
     * Creates an instance of SimpleCell.
     *
     * @param {*} config The input configuration.
     * @memberof SimpleCell
     */
    constructor (config) {
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();

        const defConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, this.constructor.defaultConfig());
        this._config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(defConfig, config || {});

        this._mount = null;
    }

    /**
     * Returns the type of the placehlder.
     *
     * @readonly
     * @memberof SimpleCell
     */
    get type () {
        return _enums_cell_type__WEBPACK_IMPORTED_MODULE_1__["SIMPLE"];
    }

    static formalName () {
        return _constants__WEBPACK_IMPORTED_MODULE_2__["SIMPLE_CELL"];
    }

    /**
     * Returns the type of the placehlder.
     *
     * @readonly
     * @memberof SimpleCell
     * @return {Object} Default config for the placeholder
     */
    static defaultConfig () {
        return {};
    }

    /**
     * Returns the value contained by the SimpleCell.
     *
     * @memberof SimpleCell
     */
    valueOf () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns a unique identifier for the instance used
     * to control selective rendering.
     *
     * @memberof SimpleCell
     */
    id () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns a serialized representation of the instance.
     *
     * @memberof SimpleCell
     */
    serialize () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns an object with width and height fields
     * specifying the space taken up by this metod.
     *
     * @memberof SimpleCell
     */
    getLogicalSpace () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Method used to set the space available to render the SimpleCell
     *
     * @param {number} width The available width.
     * @param {number} height The available height.
     * @memberof SimpleCell
     */
    setAvailableSpace () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Render the SimpleCell inthe supplied mount point.
     *
     * @param {HTMLElement} mount The mount point to render in.
     * @memberof SimpleCell
     */
    render () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Render the SimpleCell inthe supplied mount point.
     *
     * @param {HTMLElement} mount The mount point to render in.
     * @memberof SimpleCell
     */
    remove () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    getMinMeasures (providedMinMeasure = 0) {
        return providedMinMeasure;
    }

}

/* harmony default export */ __webpack_exports__["default"] = (SimpleCell);


/***/ }),

/***/ "./packages/visual-cell/src/text-cell.js":
/*!***********************************************!*\
  !*** ./packages/visual-cell/src/text-cell.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-cell */ "./packages/visual-cell/src/simple-cell.js");
/* harmony import */ var _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/cell-type */ "./packages/visual-cell/src/enums/cell-type.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props */ "./packages/visual-cell/src/props.js");
/* harmony import */ var _enums_defaults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enums/defaults */ "./packages/visual-cell/src/enums/defaults.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-cell/src/enums/constants.js");
/* harmony import */ var _text_cell_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./text-cell.scss */ "./packages/visual-cell/src/text-cell.scss");
/* harmony import */ var _text_cell_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_text_cell_scss__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "./packages/visual-cell/src/constants.js");
/**
 * This file declares a class that represents a Text element in a  table.
 * @module VisualCell
 */










const setSmartText = (context) => {
    const source = context.source();
    const {
        height: minHeightSpace,
        width: minWidthSpace
    } = context.minSpacing();
    const {
       margin,
       rotation
   } = context.config();
    const {
        left,
        right,
        top,
        bottom
     } = margin;
    const paddedHeight = top + bottom + minHeightSpace;
    const paddedWidth = left + right + minWidthSpace;
    const availHeight = context.availHeight() - paddedHeight;
    const availWidth = context.availWidth() - paddedWidth;
    const labelManager = context.dependencies().labelManager;

    labelManager.setStyle(context._computedStyle);

    !rotation && context.smartText(labelManager.getSmartText(source, availWidth, availHeight, false));
    rotation && context.smartText(labelManager.getSmartText(source, availHeight, availWidth, true));

    return context;
};

/**
* Computes the Logical Space for the text
*
* @param {Object} context Required to get the needed parameters to compute text space
* @return {Object} Logical space taken up by text
* @memberof TextCell
*/
const computeTextSpace = (context) => {
    const { labelManager } = context.dependencies();
    const {
        height: minHeightSpace,
        width: minWidthSpace
    } = context.minSpacing();
    const {
       margin,
       show,
       maxLines,
       minCharacters
   } = context.config();
    const {
       left,
       right,
       top,
       bottom
    } = margin;
    const paddedHeight = top + bottom + minHeightSpace;
    const paddedWidth = left + right + minWidthSpace;
    const availHeight = context.availHeight() - paddedHeight;
    const availWidth = context.availWidth() - paddedWidth;
    const source = context.source();
    const space = context.smartText();
    const minText = new Array(minCharacters).fill('W').join('');
    const _minTextSpace = labelManager.getOriSize(minText);

    context.config({ rotation: false });
    if (space.width > (availWidth || 0) && maxLines) {
        space.height = space.oriTextHeight * maxLines;
    }
    if (availWidth && availWidth < space.width) {
        space.width = _minTextSpace.width;
    }
    if (availWidth && availWidth < Math.min(_minTextSpace.width, space.oriTextWidth)) {
        const smartSpace = labelManager.getSmartText(source, availHeight, _minTextSpace.height, true);
        space.width = smartSpace.height;
        space.height = smartSpace.width;
        context.config({ rotation: true });
        context.smartText(smartSpace);
    }

    if (show) {
        return {
            width: Math.ceil(space.width) + paddedWidth,
            height: Math.ceil(space.height) + paddedHeight
        };
    } return {
        width: 0,
        height: 0
    };
};

/**
 * Represents a table haeder.
 *
 * @class Text
 */
class TextCell extends _simple_cell__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Creates an instance of Text.
     * @param {Object} config The input configuration.
     * @param {string} dependencies Dependencies for the class(labelManager)
     * @memberof Text
     */
    constructor (config, dependencies) {
        super(config);

        this._dependencies = dependencies;
        this._className = this._config.className ||
                    (this._config.type === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["HEADER"] ? `${_enums_constants__WEBPACK_IMPORTED_MODULE_5__["CLASSPREFIX"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_5__["HEADER"]}-cell` : `${_enums_constants__WEBPACK_IMPORTED_MODULE_5__["CLASSPREFIX"]}-${_enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["TEXT"]}-cell`);
        this._computedStyle = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])('body'), this._className);
        this._dependencies.labelManager.setStyle(this._computedStyle);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_3__["PROPS"][_enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["TEXT"]]);
        const space = this._dependencies.labelManager.getOriSize('w');
        this.minSpacing({ width: Math.floor(space.width * 3 / 4), height: Math.floor(space.height / 2) });
        setSmartText(this);
    }

    /**
     * return the type pf SimpleCell cell.
     *
     * @readonly
     * @memberof TextCell
     */
    get type () {
        return _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["TEXT"];
    }

    /**
     * This method return the value contained by this SimpleCell.
     *
     * @return {string} The text value contained by this cell.
     * @memberof TextCell
     */
    valueOf () {
        return this.source();
    }

    /**
     * This method is used to return a unique identifier for
     * the Text cell.
     *
     * @return {string} The unique identifier for the Text.
     * @memberof TextCell
     */
    get id () {
        return this._id;
    }

    /**
     * Returns the dependencies of the instance
     *
     * @return {Object} Dependencies needed by the class
     * @memberof TextCell
     */
    dependencies () {
        return this._dependencies;
    }

    /**
     * This method is used to obtain a serialized representation of this instance.
     *
     * @return {Object} Object with serilizable props.
     * @memberof TextCell
     */
    serialize () {
        return {
            text: this.source(),
            type: _enums_cell_type__WEBPACK_IMPORTED_MODULE_2__["TEXT"]
        };
    }

    /**
     * return the default configuration for the text cell
     *
     * @static
     * @return {Object} Default configuration of the cell
     * @memberof TextCell
     */
    static defaultConfig () {
        return _enums_defaults__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_CONFIG"];
    }

    static formalName () {
        return _constants__WEBPACK_IMPORTED_MODULE_7__["TEXT_CELL"];
    }

    /**
     * This method return the space taken up
     * by the text with the style applied.
     *
     * @return {Object} width and height taken up by the text.
     * @memberof Text
     */
    getLogicalSpace () {
        if (!this.logicalSpace()) {
            this.logicalSpace(computeTextSpace(this));
        }
        return this.logicalSpace();
    }

    /**
     * This method is used to set the available space.
     *
     * @param {number} width The available width.
     * @param {number} height The available height.
     * @return {Instance} Returns current Instance
     * @memberof TextCell
     */
    setAvailableSpace (width, height) {
        this.availWidth(width);
        this.availHeight(height);
        setSmartText(this);
        this.logicalSpace(null);
        return this;
    }

    /**
     * This method is used to render the Text cell inside
     * the provided mount point.
     *
     * @param {HTMLElement} mount The mount point for this cell.
     * @return {Instance} Returns current Instance
     * @memberof Text
     */
    render (mount) {
        const availWidth = this.availWidth();
        const availHeight = this.availHeight();
        const {
            margin,
            show,
            verticalAlign,
            textAlign,
            rotation
        } = this.config();

        this.mount(mount);
        if (show) {
            const container = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(mount);
            const elem = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'div', [this.id], `${_enums_constants__WEBPACK_IMPORTED_MODULE_5__["CLASSPREFIX"]}-${_enums_constants__WEBPACK_IMPORTED_MODULE_5__["TEXT_CELL"]}`);
            const vAlign = verticalAlign || rotation ? 'middle' : 'top';
            const {
                width,
                height
            } = this.smartText();
            const {
                height: minHeightSpace
            } = this.minSpacing();
            const translation = {
                top: width + minHeightSpace / 2,
                middle: width / 2 + minHeightSpace,
                bottom: minHeightSpace
            };

            container.style('vertical-align', vAlign);

            // Set class name
            elem.classed(this._className, true);

            // Apply styles
            elem.style('text-align', textAlign);
            elem.style('display', 'inline');
            elem.style('transform', rotation ? `translate(${height / 2}px,
                ${translation[vAlign]}px) rotate(-90deg)` : '');
            elem.style(_enums_constants__WEBPACK_IMPORTED_MODULE_5__["WIDTH"], availWidth ? `${availWidth}px` : '100%');
            [_enums_constants__WEBPACK_IMPORTED_MODULE_5__["TOP"], _enums_constants__WEBPACK_IMPORTED_MODULE_5__["BOTTOM"], _enums_constants__WEBPACK_IMPORTED_MODULE_5__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_5__["RIGHT"]].forEach((type) => {
                container.style(`margin-${type}`, `${margin[type]}px`);
            });
            elem.style('text-align', textAlign);
            elem.style('display', 'inline');
            // set the text as the innerHTML
            this._dependencies.labelManager.setStyle(this._computedStyle);
            elem.html(this._dependencies.labelManager.getSmartText(this.source(), availWidth, availHeight, true).text);
        }
        return this;
    }

    /**
     * Disposes the cell
     *
     * @return {Instance} Returns current Instance
     * @memberof TextCell
     */
    remove () {
        this.mount() && this.mount().remove();
        return this;
    }
 }

/* harmony default export */ __webpack_exports__["default"] = (TextCell);


/***/ }),

/***/ "./packages/visual-cell/src/text-cell.scss":
/*!*************************************************!*\
  !*** ./packages/visual-cell/src/text-cell.scss ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-group/src/data-type-scale-map.js":
/*!**********************************************************!*\
  !*** ./packages/visual-group/src/data-type-scale-map.js ***!
  \**********************************************************/
/*! exports provided: dataTypeScaleMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataTypeScaleMap", function() { return dataTypeScaleMap; });
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");


/**
 * Map of DataModel types to associated field types.
 */
const dataTypeScaleMap = {
    dimension: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ScaleType"].BAND,
    categorical: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ScaleType"].BAND,
    temporal: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ScaleType"].TIME,
    measure: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ScaleType"].LINEAR,
    continuous: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ScaleType"].LINEAR
};


/***/ }),

/***/ "./packages/visual-group/src/encoder/cartesian-encoder.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/encoder/cartesian-encoder.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartesianEncoder; });
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _encoder_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./encoder-helper */ "./packages/visual-group/src/encoder/encoder-helper.js");
/* harmony import */ var _group_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../group-helper */ "./packages/visual-group/src/group-helper/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _visual_encoder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./visual-encoder */ "./packages/visual-group/src/encoder/visual-encoder.js");









const CARTESIAN = muze_utils__WEBPACK_IMPORTED_MODULE_1__["COORD_TYPES"].CARTESIAN;

/**
 *
 *
 * @export
 * @class CartesianEncoder
 * @extends {VisualEncoder}
 */
class CartesianEncoder extends _visual_encoder__WEBPACK_IMPORTED_MODULE_6__["default"] {

    /**
     *
     *
     *
     * @memberof CartesianEncoder
     */
    static type () {
        return CARTESIAN;
    }

    /**
     *
     *
     * @param {*} axesCreators
     * @param {*} fieldInfo
     *
     * @memberof CartesianEncoder
     */
    createAxis (axesCreators, fieldInfo, context) {
        const geomCellAxes = {};
        const {
            axes
        } = axesCreators;
        const {
            projections,
            indices
        } = fieldInfo;
        const {
            rowFields,
            columnFields
        } = projections;
        const {
             rowIndex,
             columnIndex
        } = indices;
        const axisFields = [{
            fields: rowFields,
            index: rowIndex
        }, {
            fields: columnFields,
            index: columnIndex
        }];
        const { resolver, facetFields, geomCell } = context;
        const xAxes = axes.x || [];
        const yAxes = axes.y || [];

        [rowFields, columnFields].forEach((fields, i) => {
            const type = i === 0 ? _enums_constants__WEBPACK_IMPORTED_MODULE_5__["ROW"] : _enums_constants__WEBPACK_IMPORTED_MODULE_5__["COLUMN"];
            const axis = i === 0 ? _enums_constants__WEBPACK_IMPORTED_MODULE_5__["Y"] : _enums_constants__WEBPACK_IMPORTED_MODULE_5__["X"];

            if (fields.length > 1) {
                axesCreators.position = _enums_constants__WEBPACK_IMPORTED_MODULE_5__["BOTH"];
            } else {
                axesCreators.position = this.axisFrom()[type];
            }
            geomCellAxes[axis] = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["generateAxisFromMap"])(axis, axisFields[i], axesCreators, {
                groupAxes: axis === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["X"] ? xAxes : yAxes,
                valueParser: resolver.valueParser()
            }, indices, facetFields);
        });
        geomCell.axes(geomCellAxes);
        return geomCellAxes;
    }

    unionUnitDomains (context) {
        const store = context.store();
        const resolver = context.resolver();
        const units = resolver.units();
        const domains = {
            0: {},
            1: {}
        };
        const config = context.config();
        const fieldsObj = {
            0: {},
            1: {}
        };

        for (let rIdx = 0, len = units.length; rIdx < len; rIdx++) {
            const unitsArr = units[rIdx];
            for (let cIdx = 0, len2 = unitsArr.length; cIdx < len2; cIdx++) {
                const unit = unitsArr[cIdx];
                const axisFields = unit.fields();
                const encodingDomains = unit.dataDomain();
                ['x', 'y'].forEach((axisType, axisTypeIndex) => {
                    const fieldArr = axisFields[axisType];
                    fieldArr.forEach((field, axisIndex) => {
                        const key = !axisTypeIndex ? `0${cIdx}${axisIndex}` : `${rIdx}0${axisIndex}`;
                        const dom = encodingDomains[axisType];
                        const typeOfField = field.subtype();
                        fieldsObj[axisTypeIndex][key] = field;

                        if (dom && Object.keys(dom).length !== 0) {
                            domains[axisTypeIndex][key] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["unionDomain"])([(domains[axisTypeIndex] &&
                                domains[axisTypeIndex][key]) || [], dom[`${field}`]], typeOfField);
                        }
                    });
                });
            }
        }

        const { x: xAxes, y: yAxes } = resolver.axes();
        store.lockModel();
        [xAxes, yAxes].forEach((axesArr, axisType) => {
            axesArr.forEach((axes, idx) => {
                let key;
                let domain = [];
                let adjustedDomain = [];
                const min = [];
                const max = [];
                const typeOfAxis = axes[0].constructor.type();

                if (axes.length > 1 && typeOfAxis === _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_2__["ScaleType"].LINEAR && axes[0].config().alignZeroLine) {
                    axes.forEach((axis, i) => {
                        key = !axisType ? `0${idx}${i}` : `${idx}0${i}`;
                        domain = domains[axisType][key];
                        min[i] = domain[0];
                        max[i] = domain[1];
                    });
                    adjustedDomain = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["getAdjustedDomain"])(max, min);
                } else if (typeOfAxis === _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_2__["ScaleType"].BAND) {
                    /* Sort categorical fields to ensure consistency across all rows
                    only if sorted by user */
                    key = !axisType ? `0${idx}0` : `${idx}00`;
                    const currentFieldName = fieldsObj[axisType][key].oneVar();
                    const sortingOrder = config.sort && config.sort[currentFieldName];

                    if (sortingOrder) {
                        domains[axisType][key].sort((a, b) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["sortCategoricalField"])(sortingOrder, a, b));
                    }
                }

                axes.forEach((axis, index) => {
                    key = !axisType ? `0${idx}${index}` : `${idx}0${index}`;
                    domain = adjustedDomain[index] || domains[axisType][key];

                    domain && axis.domain(domain);
                    const type = !axisType ? 'x' : 'y';
                    store.commit(`${muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE}.domain.${type}`, domain, `${idx}${index}`);
                });
            });
        });
        store.unlockModel();
    }

    /**
     *
     *
     * @param {*} fields
     *
     * @memberof CartesianEncoder
     */
    getFacetsAndProjections (fields, type) {
        let facets = [];
        let projections = [];
        let counter = 0;
        const primaryFacets = [];
        const secondaryFacets = [];
        const primaryFields = fields[0];
        const secondaryFields = fields[1];
        const primaryLen = primaryFields.length;
        const secondaryLen = secondaryFields.length;
        const axisFrom = this.axisFrom();

        for (let i = 0; i < primaryLen; i++) {
            let projArr = [primaryFields[i]];
            const primaryField = primaryFields[i];

            if (primaryField.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["MEASURE"]) {
                const secondaryField = secondaryFields[counter];
                if (secondaryField && secondaryField.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["MEASURE"]) {
                    counter++;
                    projArr = [primaryField, secondaryField];
                }
                projections.push(projArr);
            } else {
                facets.push(primaryField);
                primaryFacets.push(primaryField);
            }
        }
        if (secondaryLen > counter) {
            for (let i = counter; i < secondaryLen; i++) {
                const secondaryField = secondaryFields[i];
                const projArr = [secondaryField];
                if (secondaryField.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["MEASURE"]) {
                    projections.push(projArr);
                } else {
                    facets.push(secondaryField);
                    secondaryFacets.push(secondaryField);
                }
            }
        }
        if ((primaryFacets.length || secondaryFacets.length) && !projections.length) {
            type = type === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["COL"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_5__["COLUMN"] : type;
            if ((axisFrom[type] === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["LEFT"] || axisFrom[type] === _enums_constants__WEBPACK_IMPORTED_MODULE_5__["TOP"]) && primaryFacets.length) {
                const axisFromIndex = primaryFacets.length - 1;
                const facet = primaryFacets[axisFromIndex];
                projections = [[facet]];
                const existIndex = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["getIndex"])(secondaryFacets, facet);
                if (existIndex > -1) {
                    projections = [[facet, facet]];
                    secondaryFacets.splice(existIndex, 1);
                }
                primaryFacets.splice(axisFromIndex, 1);
            } else {
                const axisFromIndex = 0;
                const facet = secondaryFacets[axisFromIndex];
                projections = [[facet]];
                const existIndex = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["getIndex"])(primaryFacets, facet);
                if (existIndex > -1) {
                    projections = [[facet, facet]];
                    primaryFacets.splice(existIndex, 1);
                }
                secondaryFacets.splice(axisFromIndex, 1);
            }
        }

        facets = [...primaryFacets, ...secondaryFacets];
        facets = facets.filter((el, index, self) => index === self.findIndex(t => (t.toString() === el.toString())));
        return {
            facets,
            projections
        };
    }

    /**
     *
     *
     * @param {*} datamodel
     * @param {*} config
     *
     * @memberof CartesianEncoder
     */
    fieldSanitizer (datamodel, config) {
        return super.fieldSanitizer(datamodel, config);
    }

    /**
     *
     *
     * @param {*} datamodel
     *
     * @memberof CartesianEncoder
     */
    getRetinalFieldsDomain (dataModels, encoding) {
        const groupedModel = dataModels.groupedModel;
        const domains = {};
        for (const key in encoding) {
            if ({}.hasOwnProperty.call(encoding, key)) {
                const encodingObj = encoding[key];
                const field = encodingObj.field;
                if (!encodingObj.domain && field) {
                    const domain = Object(_group_helper__WEBPACK_IMPORTED_MODULE_4__["retriveDomainFromData"])(groupedModel, field);
                    domains[field] = domain;
                }
            }
        }
        return domains;
    }

    /**
     *
     *
     * @param {*} layerArray
     * @memberof CartesianEncoder
     */
    serializeLayerConfig (layerArray) {
        const serializedLayers = [];
        // let currentLayerIndex = 0;
        layerArray.length && layerArray.forEach((layer, i) => {
            const def = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_0__["layerFactory"].sanitizeLayerConfig(layer);
            def.order = i;
            serializedLayers.push(def);
        });
        return serializedLayers;
    }

    sanitizeLayerConfig (encodingConfigs, userLayerConfig) {
        const layerConfig = [];
        userLayerConfig.forEach((config) => {
            const def = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["toArray"])(config.def);
            Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["sanitizeIndividualLayerConfig"])(encodingConfigs, def);
            layerConfig.push(config);
        });
        return layerConfig;
    }

    /**
     *
     *
     * @param {*} fields
     * @param {*} userLayerConfig
     *
     * @memberof CartesianEncoder
     */
    getLayerConfig (fields, userLayerConfig, retinalConfig) {
        const layerConfig = [];
        const {
            columnFields,
            rowFields
        } = fields;

        // let currentLayerIndex = 0;
        columnFields.forEach((colField) => {
            const colFieldName = colField.toString();
            rowFields.forEach((rowField) => {
                let configs = [];
                const rowFieldName = rowField.toString();
                const encoding = {
                    x: {
                        field: colFieldName
                    },
                    y: {
                        field: rowFieldName
                    }
                };
                const rowFieldType = rowField.subtype();
                const colFieldType = colField.subtype();
                const mark = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["getDefaultMark"])(colFieldType, rowFieldType);

                const defConfigs = [{
                    mark,
                    def: {
                        mark,
                        encoding
                    }
                }];

                const layerConfigs = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_3__["getLayerConfFromFields"])(colField.getMembers(),
                    rowField.getMembers(), userLayerConfig || []);
                if (layerConfigs.length) {
                    configs = layerConfigs.map((layerConf) => {
                        const mergedLayerConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["mergeRecursive"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["mergeRecursive"])({}, defConfigs[0].def), layerConf);
                        const serializedLayerConfig = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_0__["layerFactory"].getSerializedConf(mergedLayerConf.mark,
                            mergedLayerConf);
                        return {
                            mark: mergedLayerConf.mark,
                            order: mergedLayerConf.order,
                            def: serializedLayerConfig
                        };
                    });
                } else {
                    configs = defConfigs;
                }

                layerConfig.push(...configs);
            });
        });
        return this.sanitizeLayerConfig(retinalConfig, layerConfig);
    }
}


/***/ }),

/***/ "./packages/visual-group/src/encoder/encoder-helper.js":
/*!*************************************************************!*\
  !*** ./packages/visual-group/src/encoder/encoder-helper.js ***!
  \*************************************************************/
/*! exports provided: getAdjustedDomain, generateAxisFromMap, sanitizeIndividualLayerConfig, mutateAxesFromMap, getDefaultMark, createRetinalAxis, getIndex, getLayerConfFromFields, resolveAxisConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAdjustedDomain", function() { return getAdjustedDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateAxisFromMap", function() { return generateAxisFromMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeIndividualLayerConfig", function() { return sanitizeIndividualLayerConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mutateAxesFromMap", function() { return mutateAxesFromMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultMark", function() { return getDefaultMark; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRetinalAxis", function() { return createRetinalAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIndex", function() { return getIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerConfFromFields", function() { return getLayerConfFromFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveAxisConfig", function() { return resolveAxisConfig; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _enums_scale_maps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/scale-maps */ "./packages/visual-group/src/enums/scale-maps.js");
/* harmony import */ var _group_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../group-helper */ "./packages/visual-group/src/group-helper/index.js");
/* harmony import */ var _data_type_scale_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data-type-scale-map */ "./packages/visual-group/src/data-type-scale-map.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");








/**
 *
 *
 * @param {*} axisInfo
 * @param {*} field
 * @param {*} axesCreators
 *
 */
const getAxisConfig = (axisInfo, field, axesCreators, indices, facetFields) => {
    let axisOrientation;
    const { index, axisIndex, axisType } = axisInfo;
    const { config, position } = axesCreators;
    const { rowIndex, columnIndex } = indices;
    const rawUserAxisConfig = config.axes ? (config.axes[axisType] || {}) : {};

    // Change config object to a function if not already one
    const userAxisConfigFn = typeof rawUserAxisConfig !== 'function' ?
    () => rawUserAxisConfig : rawUserAxisConfig;
    const userAxisConfig = userAxisConfigFn(rowIndex, columnIndex, {
        axisFields: field.getMembers(),
        facetFields
    });

    // If current config does not specifes config for an axis, retain old config
    if (!userAxisConfig) {
        return {};
    }

    const {
        LEFT,
        RIGHT,
        TOP,
        BOTTOM
    } = _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__["AxisOrientation"];
    const allOrientations = axisType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["Y"] ? [LEFT, RIGHT] : [TOP, BOTTOM];

    if (position === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTH"]) {
        axisOrientation = allOrientations[axisIndex];
    } else {
        axisOrientation = position;
    }
    const axisConfig = {
        id: `${axisType}-${index}-${axisIndex}`,
        name: field.displayName(),
        field: field.toString(),
        numberFormat: field.numberFormat(),
        orientation: axisOrientation,
        showAxisName: true,
        show: true,
        type: _data_type_scale_map__WEBPACK_IMPORTED_MODULE_5__["dataTypeScaleMap"][field.subtype()]
    };
    userAxisConfig.tickValues = field.format(userAxisConfig.tickValues);
    userAxisConfig.domain = field.format(userAxisConfig.domain);

    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(axisConfig, userAxisConfig);
};

/**
 *
 *
 * @param {*} axisInfo
 * @param {*} field
 * @param {*} axesCreators
 *
 */
const createSimpleAxis = (axisConfig, field, axesCreators) => {
    const { labelManager } = axesCreators;
    const Cls = _enums_scale_maps__WEBPACK_IMPORTED_MODULE_3__["scaleMaps"][_data_type_scale_map__WEBPACK_IMPORTED_MODULE_5__["dataTypeScaleMap"][field.subtype()]];
    const simpleAxis = new Cls(axisConfig, { labelManager });
    return simpleAxis;
};

const getAdjustedDomain = (max, min) => {
    const y1ratio = max[0] / (max[0] - min[0]);
    const y2ratio = max[1] / (max[1] - min[1]);

    // adjust min/max values for positive negative values zero line etc
    let allSameSign = false;

    // if all numbers are positive set floor to zero
    if (min[0] > 0 && min[1] > 0 && min[1] > 0 && max[1] > 0) {
        allSameSign = true;
        min[0] = 0;
        min[1] = 0;
    }

    // if all numbers are negative set ceiling to zero
    if (min[0] < 0 && min[1] < 0 && min[1] < 0 && max[1] < 0) {
        allSameSign = true;
        max[0] = 0;
        max[1] = 0;
    }

    // align zero line if necessary
    if (!allSameSign && y1ratio !== y2ratio) {
        if (y1ratio < y2ratio) {
                    // adjust min[1]
            min[1] = min[0] / max[0] * max[1];
        } else {
                    // adjust min[0]
            min[0] = min[1] / max[1] * max[0];
        }
    }
    return [
        [min[0], max[0]],
        [min[1], max[1]]
    ];
};

/**
 *
 *
 * @param {*} axisType
 * @param {*} fieldInfo
 * @param {*} axesCreators
 * @param {*} groupAxes
 *
 */
const generateAxisFromMap = (axisType, fieldInfo, axesCreators, axesInfo, indices, facetFields) => {
    let axisKey;
    const { groupAxes, valueParser } = axesInfo;
    const currentAxes = [];
    const { fields, index } = fieldInfo;
    const { cacheMaps } = axesCreators;
    const map = cacheMaps[`${axisType}AxesMap`];

    const commonAxisKey = Object(_group_helper__WEBPACK_IMPORTED_MODULE_4__["getAxisKey"])(axisType, index);
    fields.forEach((field, axisIndex) => {
        axisKey = Object(_group_helper__WEBPACK_IMPORTED_MODULE_4__["getAxisKey"])(axisType, index, axisIndex, _data_type_scale_map__WEBPACK_IMPORTED_MODULE_5__["dataTypeScaleMap"][field.subtype()]);
        const axisConfig = getAxisConfig({ index, axisIndex, axisType }, field, axesCreators, indices, facetFields);

        let axis;
        if (!map.has(axisKey)) {
            axis = createSimpleAxis(axisConfig, field, axesCreators);
        } else {
            axis = map.get(axisKey);
            axis._rotationLock = false;
            axis.config(axisConfig);
        }
        axis.valueParser(valueParser);
        currentAxes.push(axis);
        map.set(axisKey, axis);
    });

    if (currentAxes.length) {
        map.set(commonAxisKey, currentAxes);
        groupAxes.add(commonAxisKey);
    }

    return currentAxes;
};

const sanitizeIndividualLayerConfig = (encodingConfigs, def) => {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["SIZE"]].forEach((axis) => {
        if (encodingConfigs[axis] && encodingConfigs[axis].field) {
            def.forEach((conf) => {
                conf.encoding = conf.encoding || {};
                !conf.encoding[axis] && (conf.encoding[axis] = {});
                conf.encoding[axis].field = encodingConfigs[axis].field;
            });
        }
    });
};

/**
 *
 *
 * @memberof MatrixResolver
 */
const mutateAxesFromMap = (cacheMaps, axes) => {
    const {
        xAxesMap,
        yAxesMap
    } = cacheMaps;
    const {
        x: xAxisSet,
        y: yAxisSet
    } = axes;
    const xAxes = [];
    const yAxes = [];

    xAxisSet.forEach((axisId) => {
        const xAxis = xAxesMap.get(axisId);
        xAxes.push(xAxis);
    });
    yAxisSet.forEach((axisId) => {
        const yAxis = yAxesMap.get(axisId);
        yAxes.push(yAxis);
    });
    return {
        xAxes, yAxes
    };
};

/**
 * return a default mark based on predefined set of rules of type and subtype of the fields
 *
 * @param {string} colFieldType dimension/measure - temporal/ordinal/nominal
 * @param {string} rowFieldType dimension/measure - temporal/ordinal/nominal
 * @return {Object} return mark type
 */
const getDefaultMark = (colFieldType, rowFieldType) => {
    let mark;

    if (colFieldType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["CATEGORICAL"] || rowFieldType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["CATEGORICAL"]) {
        mark = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BAR"];
    } else if (colFieldType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TEMPORAL"] || rowFieldType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TEMPORAL"]) {
        mark = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LINE"];
    } else {
        mark = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["POINT"];
    }

    return mark;
};

/**
 *
 *
 * @param {*} axesCreators
 * @param {*} [fieldInfo=[]]
 *
 */
const createRetinalAxis = (axesCreators, fieldProps = {}) => {
    const { axisType, fieldsConfig } = axesCreators;
    const field = fieldProps.field;
    const axis = [];
    const Cls = _enums_scale_maps__WEBPACK_IMPORTED_MODULE_3__["scaleMaps"][axisType];

    fieldProps.type = fieldProps.type ? fieldProps.type : Object(_group_helper__WEBPACK_IMPORTED_MODULE_4__["getAxisType"])(fieldsConfig, field || null);
    axis.push(new Cls(fieldProps));
    return axis;
};

/**
 *
 *
 * @param {*} arr
 * @param {*} val
 *
 */
const getIndex = (arr, val) => {
    let i = 0;
    let arrIndex = -1;

    while (arrIndex === -1 && i < arr.length) {
        if (arr[i].toString() === val.toString()) {
            arrIndex = i;
        }
        i++;
    }
    return arrIndex;
};

/**
 *
 *
 * @param {*} colFields
 * @param {*} rowFields
 * @param {*} userLayerConfig
 *
 * @memberof CartesianEncoder
 */
const getLayerConfFromFields = (colFields, rowFields, userLayerConfig) => userLayerConfig.filter((conf) => {
    const userConf = conf instanceof Array ? conf : [conf];
    const encodingArr = [].concat(...userConf.map(d => d.encoding).filter(d => d !== undefined));

    if (!encodingArr.length) {
        return true;
    }

    const xFields = [].concat(...encodingArr.map(d => [d.x && d.x.field, d.x0 && d.x0.field]))
                .filter(d => d !== undefined && d !== null);
    const yFields = [].concat(...encodingArr.map(d => [d.y && d.y.field, d.y0 && d.y0.field]))
                .filter(d => d !== undefined && d !== null);

    if (!xFields.length && !yFields.length) {
        return true;
    }

    const colFieldExist = xFields.length ? xFields.every(d => colFields.indexOf(d) !== -1) : false;
    const rowFieldExist = yFields.length ? yFields.every(d => rowFields.indexOf(d) !== -1) : false;
    if (xFields.length && yFields.length) {
        return colFieldExist && rowFieldExist;
    }
    return colFieldExist || rowFieldExist;
});

const resolveAxisConfig = (context, fieldInf, axisInfo) => {
    const { rowIndex, columnIndex, axesObj } = axisInfo;
    const { config, facetFields, resolver } = context;
    const resolverAxes = resolver.axes();
    const { RADIUS, ANGLE } = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["ENCODING"];
    [RADIUS, ANGLE, _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ANGLE0"]].forEach((enc) => {
        const axesArr = resolverAxes[enc];
        if (!axesArr[rowIndex]) {
            axesArr[rowIndex] = [];
        }
        axesArr[rowIndex][columnIndex] = axesObj[enc];
        const axisConfig = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(config.axes, enc) || {};

        axesObj[enc].forEach((axis, i) => {
            let userConfig = axisConfig;
            if (axisConfig instanceof Function) {
                userConfig = axisConfig(rowIndex, columnIndex, {
                    axisFields: [fieldInf[enc][i]],
                    facetFields
                });
            }
            axis.config(userConfig);
        });
    });
};


/***/ }),

/***/ "./packages/visual-group/src/encoder/field-sanitizer.js":
/*!**************************************************************!*\
  !*** ./packages/visual-group/src/encoder/field-sanitizer.js ***!
  \**************************************************************/
/*! exports provided: transformFields */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformFields", function() { return transformFields; });
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../variable */ "./packages/visual-group/src/variable/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");



/**
 * Gets the list of fields in a sorted order by measurement and dimension
 *
 * @param {Array} fieldList List of fields in the view
 * @param {Object} fieldMap Mapping of fields in the datamodel
 * @return {Array} fields sorted by measurement and dimensions
 */
const orderFields = (fieldArray, type) => {
    const dimensionArr = [[], []];
    const measureArr = [[], []];
    const temporalArr = [[], []];
    const categoricalArr = [[], []];

    fieldArray.forEach((fieldList, index) => {
        fieldList.forEach((field) => {
            if (field.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["DIMENSION"]) {
                dimensionArr[index].push(field);
                field.subtype() === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["TEMPORAL"] ? temporalArr[index].push(field) : categoricalArr[index].push(field);
            } else {
                measureArr[index].push(field);
            }
        });
    });

    const numOfMeasures = measureArr[0].length + (measureArr[1] ? measureArr[1].length : 0);

    // Single array of fields
    if (!fieldArray[1]) {
        // Push measures to bottom
        measureArr[1] = type === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMNS"] ? measureArr[0] : [];
        // Push measures to left
        measureArr[0] = type !== _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMNS"] ? measureArr[0] : [];
        // Bottom and right dimensions empty
        dimensionArr[1] = [];
        // Left and top filled with dimensions
        dimensionArr[0] = dimensionArr[0];
        if (numOfMeasures === 0) {
            const allDimensions = [...dimensionArr[0], ...dimensionArr[1]];
            if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMNS"]) {
                dimensionArr[1] = allDimensions[allDimensions.length - 1] ? [allDimensions[allDimensions.length - 1]]
                        : [];
                allDimensions.splice(-1, 1);
            } else {
                dimensionArr[1] = [];
            }
            dimensionArr[0] = [...allDimensions];
        }
    }

    if (dimensionArr[0].length && dimensionArr[1].length && numOfMeasures > 0) {
        dimensionArr[0] = [...dimensionArr[0], ...dimensionArr[1]];
        dimensionArr[1] = [];
    }
    return {
        fields: dimensionArr.map((list, i) => (i === 1 ?
            measureArr[i].concat(dimensionArr[i]) : dimensionArr[i].concat(measureArr[i]))),
        dimensions: [...dimensionArr[0], ...dimensionArr[1]],
        measures: [...measureArr[0], ...measureArr[1]],
        temporal: [...temporalArr[0], ...temporalArr[1]],
        categorical: [...categoricalArr[0], ...categoricalArr[1]]
    };
};

/**
 * Gets the list of normalized fields
 *
 * @param {Array} fields List of fields in the view
 * @param {Object} fieldMap Mapping of fields in the datamodel
 * @return {Array} fields normalized by measurement and dimensions
 */
const normalizeFields = (config, type) => {
    const fieldsArr = [];
    const fields = config[type];

    if (!(fields[0] instanceof Array)) {
        fieldsArr[0] = fields;
    } else {
        fieldsArr[0] = fields[0] || [];
        fieldsArr[1] = fields[1] || [];
    }
    return fieldsArr;
};

/**
 *
 *
 * @param {*} fields
 * @param {*} datamodel
 *
 */
const convertToVar = (datamodel, fields) => {
    const vars = [];

    fields && fields.forEach((field) => {
        if (field instanceof _variable__WEBPACK_IMPORTED_MODULE_0__["ComposedVars"]) {
            vars.push(field);
            field.data(datamodel);
        } else {
            vars.push(new _variable__WEBPACK_IMPORTED_MODULE_0__["SimpleVariable"](field).data(datamodel));
        }
    });
    return vars;
};

/**
 *
 *
 * @param {*} rows
 * @param {*} columns
 * @param {*} datamodel
 *
 */
const transformFields = (datamodel, config) => {
    const [rowsInfo, columnsInfo] = [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ROWS"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLUMNS"]].map((fields) => {
        const normalizedFields = normalizeFields(config, fields);
        const norFields = [convertToVar(datamodel, normalizedFields[0])];

        if (normalizedFields[1]) {
            norFields[1] = convertToVar(datamodel, normalizedFields[1]);
        }
        return orderFields(norFields, fields);
    });
    const {
        fields: rows,
        dimensions: rowDimensions,
        measures: rowMeasures,
        temporal: rowTemporalFields,
        categorical: rowCategoricalFields
    } = rowsInfo;
    const {
        fields: columns,
        dimensions: columnDimensions,
        measures: columnMeasures,
        temporal: columnTemporalFields,
        categorical: columnCategoricalFields
    } = columnsInfo;
    return {
        rows,
        rowDimensions,
        rowMeasures,
        rowTemporalFields,
        rowCategoricalFields,
        columns,
        columnTemporalFields,
        columnCategoricalFields,
        columnDimensions,
        columnMeasures
    };
};


/***/ }),

/***/ "./packages/visual-group/src/encoder/index.js":
/*!****************************************************!*\
  !*** ./packages/visual-group/src/encoder/index.js ***!
  \****************************************************/
/*! exports provided: VisualEncoder, CartesianEncoder, PolarEncoder, RetinalEncoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _visual_encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visual-encoder */ "./packages/visual-group/src/encoder/visual-encoder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisualEncoder", function() { return _visual_encoder__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _cartesian_encoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian-encoder */ "./packages/visual-group/src/encoder/cartesian-encoder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CartesianEncoder", function() { return _cartesian_encoder__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _polar_encoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polar-encoder */ "./packages/visual-group/src/encoder/polar-encoder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolarEncoder", function() { return _polar_encoder__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _retinal_encoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./retinal-encoder */ "./packages/visual-group/src/encoder/retinal-encoder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RetinalEncoder", function() { return _retinal_encoder__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./packages/visual-group/src/encoder/polar-encoder.js":
/*!************************************************************!*\
  !*** ./packages/visual-group/src/encoder/polar-encoder.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolarEncoder; });
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _visual_encoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visual-encoder */ "./packages/visual-group/src/encoder/visual-encoder.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _encoder_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./encoder-helper */ "./packages/visual-group/src/encoder/encoder-helper.js");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../variable */ "./packages/visual-group/src/variable/index.js");








const POLAR = muze_utils__WEBPACK_IMPORTED_MODULE_2__["COORD_TYPES"].POLAR;
const { RADIUS, ANGLE, ANGLE0 } = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__["ENCODING"];

const axesCls = {
    [RADIUS]: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["RadiusAxis"],
    [ANGLE]: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["AngleAxis"],
    [ANGLE0]: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["AngleAxis"]
};

const getSizeMultiplier = (sizeVal, sizeAxis) => {
    const sizeAxisDomain = sizeAxis.domain();
    const sizeMultiplier = sizeAxis.getSize(sizeVal) / (sizeAxisDomain ? sizeAxis.range()[1] : sizeAxis.config().value);
    return sizeMultiplier;
};

const setRadiusFactor = (context) => {
    const data = context.data();
    const sizeField = context.retinalFields().size.field;
    const { radius, size } = context.axes();

    if (sizeField && radius && radius.length) {
        const sizeFieldIndex = data.getFieldsConfig()[sizeField].index;
        const sizeVal = data.getData().data.reduce((acc, val) => acc + val[sizeFieldIndex], 1);
        const sizeMultiplier = getSizeMultiplier(sizeVal, size[0]);
        radius.forEach(axis => axis.setRadiusFactor(sizeMultiplier));
    }
};

/**
 *
 *
 * @export
 * @class PolarEncoder
 * @extends {VisualEncoder}
 */
class PolarEncoder extends _visual_encoder__WEBPACK_IMPORTED_MODULE_3__["default"] {

    /**
     *
     *
     * @param {*} axesCreators
     * @param {*} fieldInfo
     *
     * @memberof PolarEncoder
     */
    createAxis (axesCreators, fieldInfo, context) {
        const {
            axes
        } = axesCreators;
        const geomCellAxes = axes;
        const {
            indices
        } = fieldInfo;
        const {
            rowIndex,
            columnIndex
        } = indices;
        // Dummy axes for polar, to create blank cells
        const pieAxes = geomCellAxes.pie || [];

        pieAxes[rowIndex] = pieAxes[rowIndex] || [];
        pieAxes[rowIndex][columnIndex] = [];

        const axesObj = {};
        const { geomCell, resolver } = context;
        const layers = resolver.matrixLayers();
        const resolverAxes = resolver.axes();
        const cellLayers = layers[rowIndex][columnIndex];
        const fields = {
            radius: {},
            angle: {},
            angle0: {}
        };

        cellLayers.forEach((layerConf) => {
            const def = layerConf.def;
            [ANGLE, ANGLE0, RADIUS].forEach((enc) => {
                const field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["getObjProp"])(def.encoding, enc, 'field');
                field && (fields[enc][field] = 0);
            });
        });
        const fieldInf = {};
        const varInstances = {};

        for (const encType in fields) {
            fieldInf[encType] = Object.keys(fields[encType]);
            axesObj[encType] = [];
            varInstances[encType] = [];
            fieldInf[encType].forEach((field, i) => {
                varInstances[encType][i] = new _variable__WEBPACK_IMPORTED_MODULE_6__["SimpleVariable"](field);
                axesObj[encType][i] = new axesCls[encType]();
            });
            axesObj[encType][axesObj[encType].length] = new axesCls[encType]();
        }
        Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_5__["resolveAxisConfig"])(context, fieldInf, {
            axesObj,
            rowIndex,
            columnIndex
        });
        geomCell.axes(axesObj)
            .fields(Object.assign({}, varInstances, geomCell.fields()));
        resolverAxes.pie = pieAxes;
        return geomCellAxes;
    }

    /**
     *
     *
     * @param {*} fields
     *
     * @memberof CartesianEncoder
     */
    getFacetsAndProjections (fields) {
        let counter = 0;
        const facets = [];
        const projections = [];
        const primaryFields = fields[0];
        const secondaryFields = fields[1];
        const primaryLen = primaryFields.length;
        const secondaryLen = secondaryFields.length;

        for (let i = 0; i < primaryLen; i++) {
            const primaryField = primaryFields[i];
            if (primaryField.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["MEASURE"]) {
                const secondaryField = secondaryFields[counter++];
                const projArr = secondaryField ? [primaryField, secondaryField] : [primaryField];
                projections.push(projArr);
            } else {
                facets.push(primaryField);
            }
        }
        if (secondaryLen > counter) {
            for (let i = counter; i < secondaryLen; i++) {
                const secondaryField = secondaryFields[i];
                const projArr = [secondaryField];
                if (secondaryField.type() === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["MEASURE"]) {
                    projections.push(projArr);
                } else {
                    facets.push(secondaryField);
                }
            }
        }
        return {
            facets,
            projections
        };
    }

    unionUnitDomains (context) {
        const store = context.store();
        store.lockModel();
        const domainProps = {
            radius: [],
            angle: [],
            angle0: []
        };
        const axes = context.resolver().axes();
        context.matrixInstance().value.each((cell, rIdx, cIdx) => {
            const unit = cell.valueOf();
            const unitDomains = unit.dataDomain();
            const fields = unit.fields();
            setRadiusFactor(unit);
            [RADIUS, ANGLE, ANGLE0].forEach((encType) => {
                const encodingFields = fields[encType];
                const domains = unitDomains[encType] || {};
                encodingFields.forEach((field, i) => {
                    !domainProps[encType][rIdx] && (domainProps[encType][rIdx] = []);
                    !domainProps[encType][rIdx][cIdx] && (domainProps[encType][rIdx][cIdx] = []);
                    domainProps[encType][rIdx][cIdx][i] = domains[`${field}`] || [];
                });
            });
        });

        for (const key in domainProps) {
            const specificAxes = axes[key];
            specificAxes.forEach((axesArr, rIdx) => {
                axesArr.forEach((axisArr, cIdx) => {
                    axisArr.forEach((axis, i) => {
                        axis.domain(Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["defaultValue"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["getObjProp"])(domainProps[key], rIdx, cIdx, i), []));

                        store.commit(`${muze_utils__WEBPACK_IMPORTED_MODULE_2__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE}.domain.${key}`, domainProps[key],
                            `${rIdx}-${cIdx}`);
                    });
                });
            });
        }
        store.unlockModel();
    }

    /**
     *
     *
     *
     * @memberof PolarEncoder
     */
    setCommonDomain () {
        // No domain to be set
        return this;
    }

    /**
     *
     *
     *
     * @memberof PolarEncoder
     */
    static type () {
        return POLAR;
    }

    layers (...layers) {
        if (layers.length) {
            this._layers = layers[0];
            return this;
        }
        return this._layers;
    }

    /**
     *
     *
     * @param {*} datamodel
     * @param {*} config
     * @memberof PolarEncoder
     */
    fieldSanitizer (datamodel, config) {
        let sanitizedRows = [[], []];
        let sanitizedColumns = [[], []];
        const fields = super.fieldSanitizer(datamodel, config);
        const {
            layers
        } = config;
        const {
            rows,
            columns
        } = fields;
        const layer = layers[0];
        const encoding = layer.encoding;
        const radius = encoding && encoding.radius ? encoding.radius.field : null;
        const angle = encoding && encoding.angle ? encoding.angle.field : null;
        const sanitizedFields = [sanitizedRows, sanitizedColumns];

        [rows, columns].forEach((fieldType, typeIndex) => {
            fieldType.forEach((fieldSet, i) => fieldSet.forEach((field) => {
                if (field.toString() !== radius && field.toString() !== angle && field.type() !== _enums_constants__WEBPACK_IMPORTED_MODULE_4__["MEASURE"]) {
                    sanitizedFields[typeIndex][i].push(field);
                }
            }));
        });
        sanitizedColumns = [...new Set(sanitizedColumns)];
        sanitizedRows = [...new Set(sanitizedRows)];
        this.fieldInfo({ rows: sanitizedRows, columns: sanitizedColumns });
        return this.fieldInfo();
    }

    getRetinalFieldsDomain (dataModels, encoding, facetFields, groupBy) {
        let sizeField;
        let colorField;
        const fields = [];
        const layers = this.layers();
        const dataModel = dataModels.groupedModel;
        const fieldsConfig = dataModel.getFieldsConfig();
        const domains = {};
        if (layers && layers[0]) {
            const layer = layers[0];
            const layerEncoding = layer.def.encoding || {};

            [RADIUS, ANGLE, _enums_constants__WEBPACK_IMPORTED_MODULE_4__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["COLOR"]].forEach((encType) => {
                const field = layerEncoding[encType] ? layerEncoding[encType].field : '';
                const measureField = fieldsConfig[field] && fieldsConfig[field].def.type === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["MEASURE"];
                if (encType === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["SIZE"] && measureField) {
                    sizeField = field;
                }
                if (encType === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["COLOR"]) {
                    colorField = field;
                }
                fieldsConfig[field] && !measureField && fields.push(field);
            });
        }

        if (sizeField) {
            domains[sizeField] = dataModel.groupBy(facetFields, {
                [sizeField]: muze_utils__WEBPACK_IMPORTED_MODULE_2__["GROUP_BY_FUNCTIONS"].SUM
            }).getFieldspace().fieldsObj()[sizeField].domain();
        }

        if (colorField) {
            const dm = dataModel.groupBy([...facetFields, ...fields], groupBy.measures);
            domains[colorField] = dm.getFieldspace().fieldsObj()[colorField].domain();
        }
        return domains;
    }

    /**
     *
     *
     * @param {*} fields
     * @param {*} userLayerConfig
     *
     * @memberof PolarEncoder
     */
    getLayerConfig (fields, userLayerConfig, retinalConfig) {
        let layerConfig = [];
        const {
                columnFields,
                rowFields
            } = fields;
        const allFields = [...columnFields, ...rowFields];

        allFields.forEach(() => {
            const encoding = {};
            let config = {
                mark: _enums_constants__WEBPACK_IMPORTED_MODULE_4__["ARC"],
                def: {
                    encoding
                }
            };
            if (userLayerConfig && userLayerConfig.length > 0) {
                config = Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["mergeRecursive"])(config, userLayerConfig[0]);
            }
            layerConfig.push(config);
        });
        if (layerConfig.length === 0) {
            layerConfig = userLayerConfig;
        }
        const sanitizedConfig = this.sanitizeLayerConfig(retinalConfig, layerConfig);
        this.layers(sanitizedConfig);
        return sanitizedConfig;
    }

    /**
     *
     *
     * @param {*} layerArray
     *
     * @memberof PolarEncoder
     */
    serializeLayerConfig (layerArray) {
        const serializedLayers = [];

        layerArray.length && layerArray.forEach((layer) => {
            const def = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__["layerFactory"].getSerializedConf(layer.mark, layer);
            serializedLayers.push({
                mark: layer.mark,
                def
            });
        });
        return serializedLayers;
    }

    sanitizeLayerConfig (encodingConfigs, userLayerConfig) {
        const layerConfig = [];

        userLayerConfig.forEach((config) => {
            const def = Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["toArray"])(config.def);
            Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_5__["sanitizeIndividualLayerConfig"])(encodingConfigs, def);
            def.forEach((conf) => {
                const encoding = conf.encoding || (conf.encoding = {});
                !encoding.angle && (encoding.angle = {});
                const angleField = Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["getObjProp"])(encoding.angle, 'field');
                const angle0Field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_2__["getObjProp"])(encoding.angle0, 'field');

                if (!angleField) {
                    Object.assign(encoding.angle, {
                        field: encodingConfigs.color && encodingConfigs.color.field
                    });
                }
                if (!angle0Field) {
                    !encoding.angle0 && (encoding.angle0 = {});
                    Object.assign(encoding.angle0, {
                        field: encoding.angle.field
                    });
                }
            });

            layerConfig.push(config);
        });
        return layerConfig;
    }
}


/***/ }),

/***/ "./packages/visual-group/src/encoder/props.js":
/*!****************************************************!*\
  !*** ./packages/visual-group/src/encoder/props.js ***!
  \****************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
const PROPS = {
    layers: {},
    data: {},
    globalConfig: {}
};


/***/ }),

/***/ "./packages/visual-group/src/encoder/retinal-encoder.js":
/*!**************************************************************!*\
  !*** ./packages/visual-group/src/encoder/retinal-encoder.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RetinalEncoder; });
/* harmony import */ var _encoder_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encoder-helper */ "./packages/visual-group/src/encoder/encoder-helper.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _visual_encoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visual-encoder */ "./packages/visual-group/src/encoder/visual-encoder.js");




/**
 *
 *
 * @export
 * @class RetinalEncoder
 * @extends {VisualEncoder}
 */
class RetinalEncoder extends _visual_encoder__WEBPACK_IMPORTED_MODULE_2__["default"] {

    /**
     *
     *
     * @param {*} axesCreators
     *
     * @memberof RetinalEncoder
     */
    createAxis (axesCreators) {
        const { fieldsConfig, config } = axesCreators;
        const newAxes = {};

        [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SIZE"]].forEach((axisType) => {
            newAxes[`${axisType}`] = Object(_encoder_helper__WEBPACK_IMPORTED_MODULE_0__["createRetinalAxis"])({ axisType, fieldsConfig }, config[axisType]);
        });
        return newAxes;
    }

    /**
     *
     *
     * @static
     *
     * @memberof RetinalEncoder
     */
    static type () {
        return 'retinal';
    }

    /**
     *
     *
     * @param {*} context
     *
     * @memberof RetinalEncoder
     */
    setCommonDomain (context) {
        const { domains, axes, encoding } = context;

        Object.entries(encoding).forEach((enc) => {
            if (enc[1] && enc[1].field) {
                const encType = enc[0];
                const field = enc[1].field;

                if (field) {
                    axes[encType].forEach((axis) => {
                        const domain = domains[field];
                        !enc[1].domain && axis.updateDomain(domain);
                    });
                }
            }
        });
        return axes;
    }
}


/***/ }),

/***/ "./packages/visual-group/src/encoder/visual-encoder.js":
/*!*************************************************************!*\
  !*** ./packages/visual-group/src/encoder/visual-encoder.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VisualEncoder; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _field_sanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field-sanitizer */ "./packages/visual-group/src/encoder/field-sanitizer.js");
/* harmony import */ var _group_helper_group_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../group-helper/group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./props */ "./packages/visual-group/src/encoder/props.js");






/**
 *
 *
 * @export
 * @class VisualEncoder
 */
class VisualEncoder {

    constructor () {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, _props__WEBPACK_IMPORTED_MODULE_4__["PROPS"]);
    }

    /**
     *
     *
     * @memberof VisualEncoder
     */
    createAxis () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     *
     *
     * @memberof VisualEncoder
     */
    setCommonDomain () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     *
     *
     * @memberof VisualEncoder
     */
    getLayerConfig () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    fieldInfo (...info) {
        if (info.length) {
            this._fieldInfo = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(this._fieldInfo || {}, info[0]);
            return this;
        }
        return this._fieldInfo;
    }

    /**
     *
     *
     * @param {*} datamodel
     * @param {*} config
     *
     * @memberof VisualEncoder
     */
    fieldSanitizer (datamodel, config) {
        this.fieldInfo(Object(_field_sanitizer__WEBPACK_IMPORTED_MODULE_1__["transformFields"])(datamodel, config));
        return this.fieldInfo();
    }

    /**
     *
     *
     * @param {*} params
     *
     * @memberof VisualEncoder
     */
    axisFrom (...params) {
        if (params.length) {
            this._axisFrom = params[0];
            return this;
        }
        return this._axisFrom;
    }

    /**
     *
     *
     * @param {*} params
     *
     * @memberof VisualEncoder
     */
    headerFrom (...params) {
        if (params.length) {
            this._headerFrom = params[0];
            return this;
        }
        return this.__headerFrom;
    }

    /**
     *
     *
     * @param {*} axisFrom
     *
     * @memberof CartesianEncoder
     */
    setAxisAndHeaders (axisFrom = {}, fields) {
        const [rowHeader, rowAxis] = Object(_group_helper_group_utils__WEBPACK_IMPORTED_MODULE_2__["getHeaderAxisFrom"])(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ROW"], fields.rows, axisFrom);
        const [colHeader, colAxis] = Object(_group_helper_group_utils__WEBPACK_IMPORTED_MODULE_2__["getHeaderAxisFrom"])(_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLUMN"], fields.columns, axisFrom);

        this.axisFrom({
            row: rowAxis,
            column: colAxis
        });
        this.headerFrom({
            row: rowHeader,
            column: colHeader
        });
        return this;
    }
}


/***/ }),

/***/ "./packages/visual-group/src/enums/constants.js":
/*!******************************************************!*\
  !*** ./packages/visual-group/src/enums/constants.js ***!
  \******************************************************/
/*! exports provided: X, Y, WIDTH, HEIGHT, MEASUREMENT, CONFIG, MIN_UNIT_WIDTH, MIN_UNIT_HEIGHT, DIMENSIONS, MEASURES, DIMENSION, MEASURE, PIVOT, FORMAT, MOUNT, HAS_DATA_UPDATED, ROWS, COLUMNS, COL, ROW, COLUMN, COLOR, SHAPE, SIZE, DETAIL, LAYERS, TRANSFORM, ORDINAL, LINEAR, LEFT, RIGHT, TOP, BOTTOM, RETINAL, CELL, X_AXES, Y_AXES, ENTRY_CELLS, INITIALIZED, EXIT_CELLS, AXIS, UNIT, UPDATED, BEFORE_UPDATE, VALUE_MATRIX, FACET_HEADERS, RADIUS, ANGLE, ANGLE0, ARC, CATEGORICAL, TEMPORAL, BAR, LINE, POINT, PRIMARY, SECONDARY, BOTH, INTERACTION, GRID_LINES, GRID_BANDS, HEADER, FACET, ASCENDING, DESCENDING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASUREMENT", function() { return MEASUREMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_UNIT_WIDTH", function() { return MIN_UNIT_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_UNIT_HEIGHT", function() { return MIN_UNIT_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIMENSIONS", function() { return DIMENSIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASURES", function() { return MEASURES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIMENSION", function() { return DIMENSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASURE", function() { return MEASURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PIVOT", function() { return PIVOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FORMAT", function() { return FORMAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNT", function() { return MOUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS_DATA_UPDATED", function() { return HAS_DATA_UPDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROWS", function() { return ROWS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMNS", function() { return COLUMNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COL", function() { return COL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROW", function() { return ROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLUMN", function() { return COLUMN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPE", function() { return SHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIZE", function() { return SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DETAIL", function() { return DETAIL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERS", function() { return LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDINAL", function() { return ORDINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT", function() { return LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RIGHT", function() { return RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOP", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTTOM", function() { return BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RETINAL", function() { return RETINAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL", function() { return CELL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXES", function() { return X_AXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXES", function() { return Y_AXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENTRY_CELLS", function() { return ENTRY_CELLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INITIALIZED", function() { return INITIALIZED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXIT_CELLS", function() { return EXIT_CELLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS", function() { return AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT", function() { return UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UPDATED", function() { return UPDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BEFORE_UPDATE", function() { return BEFORE_UPDATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VALUE_MATRIX", function() { return VALUE_MATRIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACET_HEADERS", function() { return FACET_HEADERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANGLE", function() { return ANGLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANGLE0", function() { return ANGLE0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARC", function() { return ARC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CATEGORICAL", function() { return CATEGORICAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEMPORAL", function() { return TEMPORAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAR", function() { return BAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINE", function() { return LINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT", function() { return POINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PRIMARY", function() { return PRIMARY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDARY", function() { return SECONDARY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BOTH", function() { return BOTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERACTION", function() { return INTERACTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_LINES", function() { return GRID_LINES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_BANDS", function() { return GRID_BANDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEADER", function() { return HEADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACET", function() { return FACET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASCENDING", function() { return ASCENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DESCENDING", function() { return DESCENDING; });
/**
 * This file exports constants that are used as enums in the
 *  crosstab group implementation.
 */
/**
 * Width of the crosstab.
 */
const X = 'x';
/**
 * Width of the crosstab.
 */
const Y = 'y';
/**
 * Width of the crosstab.
 */
const WIDTH = 'width';

/**
 * Height of the crosstab.
 */
const HEIGHT = 'height';

/**
 * Field referring to object storing measurement configuration.
 */
const MEASUREMENT = 'measurement';

/**
 * Field referring to object storing configuration properties.
 */
const CONFIG = 'config';

/**
 * Width of visual unit in crosstab.
 */
const MIN_UNIT_WIDTH = 'minUnitWidth';

/**
 * Height of visual unit.
 */
const MIN_UNIT_HEIGHT = 'minUnitHeight';

/**
 * Field to store the array of dimensions to facet by.
 */
const DIMENSIONS = 'dimensions';

/**
 * Field to store array of measures to use as x axis.
 */
const MEASURES = 'measures';

/**
 * Field to store the array of dimensions to facet by.
 */
const DIMENSION = 'dimension';

/**
 * Field to store array of measures to use as x axis.
 */
const MEASURE = 'measure';

/**
 * Flag to specify if model should be pivoted.
 */
const PIVOT = 'pivot';

/**
 * Flag to specify format
 */
const FORMAT = 'format';

/**
 * Mount point where the variable will be hosted
 */
const MOUNT = 'mount';

/**
 * Data update flag
 */
const HAS_DATA_UPDATED = 'hasDataUpdated';

/**
 * Field referring to object storing set of rows
 */
const ROWS = 'rows';

/**
 * Field referring to object storing set of columns
 */
const COLUMNS = 'columns';

/**
 * Field referring to object storing set of columns
 */
const COL = 'col';

/**
 * Field referring to object storing set of rows
 */
const ROW = 'row';

/**
 * Field referring to object storing set of columns
 */
const COLUMN = 'column';

/**
 * Field referring to object storing color field
 */
const COLOR = 'color';

/**
 * Field referring to object storing shape field
 */
const SHAPE = 'shape';

/**
 * Field referring to object storing size field
 */
const SIZE = 'size';

/**
 * Field referring to object storing detail field
 */
const DETAIL = 'detail';

/**
 * Field referring to object storing set of layers
 */
const LAYERS = 'layers';

/**
 * Field referring to object storing the transforms
 */
const TRANSFORM = 'transform';

/**
 * Field referring to object storing the transforms
 */
const ORDINAL = 'ordinal';

/**
 * Field referring to object storing the transforms
 */
const LINEAR = 'linear';
/**
 * Field referring to object storing the transforms
 */
const LEFT = 'left';
/**
 * Field referring to object storing the transforms
 */
const RIGHT = 'right';
/**
 * Field referring to object storing the transforms
 */
const TOP = 'top';
/**
 * Field referring to object storing the transforms
 */
const BOTTOM = 'bottom';

/**
 * Field referring to object storing the transforms
 */
const RETINAL = 'retinal';
/**
 * Field referring to object storing the transforms
 */
const CELL = 'cell';
/**
 * Field referring to object storing the transforms
 */
const X_AXES = 'xAxes';
/**
 * Field referring to object storing the transforms
 */
const Y_AXES = 'yAxes';
/**
 * Field referring to object storing the transforms
 */
const ENTRY_CELLS = 'entryCell';
/**
 * Field referring to object storing the transforms
 */
const INITIALIZED = 'initialized';
/**
 * Field referring to object storing the transforms
 */
const EXIT_CELLS = 'exitCell';
/**
 * Field referring to object storing the transforms
 */
const AXIS = 'axis';
/**
 * Field referring to object storing the transforms
 */
const UNIT = 'unit';
/**
 * Field referring to object storing the transforms
 */
const UPDATED = 'updated';
/**
 * Field referring to object storing the transforms
 */
const BEFORE_UPDATE = 'beforeupdate';
/**
 * Field referring to object storing the transforms
 */
const VALUE_MATRIX = 'valueMatrix';
/**
 * Field referring to object storing the transforms
 */
const FACET_HEADERS = 'facet-headers';
/**
 * Field referring to object storing the transforms
 */
const RADIUS = 'radius';
/**
 * Field referring to object storing the transforms
 */
const ANGLE = 'angle';

const ANGLE0 = 'angle0';
/**
 * Field referring to object storing the transforms
 */
const ARC = 'arc';
/**
 * Field referring to object storing the transforms
 */
const CATEGORICAL = 'categorical';
/**
 * Field referring to object storing the transforms
 */
const TEMPORAL = 'temporal';
/**
 * Field referring to object storing the transforms
 */
const BAR = 'bar';
/**
 * Field referring to object storing the transforms
 */
const LINE = 'line';
/**
 * Field referring to object storing the transforms
 */
const POINT = 'point';
/**
 * Field referring to object storing the transforms
 */
const PRIMARY = 'Primary';
/**
 * Field referring to object storing the transforms
 */
const SECONDARY = 'Secondary';
/**
 * Field referring to object storing the transforms
 */
const BOTH = 'both';
/**
 * Field referring to object storing the transforms
 */
const INTERACTION = 'interaction';
/**
 * Field referring to object storing the transforms
 */
const GRID_LINES = 'gridLines';
/**
 * Field referring to object storing the transforms
 */
const GRID_BANDS = 'gridBands';
/**
 * Field referring to object storing the transforms
 */
const HEADER = 'header';
/**
 * Field referring to object storing the transforms
 */
const FACET = 'facet';
/**
 * Ordering type
 */
const ASCENDING = 'asc';
/**
 * Ordering type
 */
const DESCENDING = 'desc';


/***/ }),

/***/ "./packages/visual-group/src/enums/defaults.js":
/*!*****************************************************!*\
  !*** ./packages/visual-group/src/enums/defaults.js ***!
  \*****************************************************/
/*! exports provided: DATA_UPDATE_COUNTER, DEFAULT_LAYER_TYPE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_UPDATE_COUNTER", function() { return DATA_UPDATE_COUNTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_LAYER_TYPE", function() { return DEFAULT_LAYER_TYPE; });
/**
 * This file exports variables that are used as defaults for the crosstab group.
 */
const DATA_UPDATE_COUNTER = 0;

const DEFAULT_LAYER_TYPE = 'cartesian';



/***/ }),

/***/ "./packages/visual-group/src/enums/scale-maps.js":
/*!*******************************************************!*\
  !*** ./packages/visual-group/src/enums/scale-maps.js ***!
  \*******************************************************/
/*! exports provided: scaleMaps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMaps", function() { return scaleMaps; });
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");


const scaleMaps = {
    linear: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ContinousAxis"],
    band: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["BandAxis"],
    temporal: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["TimeAxis"],
    size: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["SizeAxis"],
    color: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ColorAxis"],
    shape: _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["ShapeAxis"]
};


/***/ }),

/***/ "./packages/visual-group/src/group-helper/cell-creator.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/group-helper/cell-creator.js ***!
  \****************************************************************/
/*! exports provided: createValueCells, generateMatrices, computeMatrices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createValueCells", function() { return createValueCells; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateMatrices", function() { return generateMatrices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeMatrices", function() { return computeMatrices; });
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _matrix_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix-model */ "./packages/visual-group/src/group-helper/matrix-model.js");
/* harmony import */ var _group_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../variable */ "./packages/visual-group/src/variable/index.js");







/**
 * Updates row and column cells with the geom cell corresponding to the facet keys
 *
 * @param {*} resolver
 * @param {*} facets
 */
const updateCells = (resolver, facets, geomCell) => {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_4__["ROW"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["COL"]].forEach((field) => {
        const cells = resolver[`${field}Cells`]();
        const facetKey = facets[`${field}Facets`][1].join();

        !cells[facetKey] && (cells[facetKey] = []);
        cells[facetKey].push(geomCell);
        resolver[`${field}Cells`](cells);
    });
};

/**
 *
 *
 * @param {*} context
 * @param {*} datamodel
 * @param {*} fieldInfo
 * @param {*} facets
 *
 */
const createValueCells = (context, datamodel, fieldInfo, facets) => {
    const {
        projections,
        indices
    } = fieldInfo;
    const {
        rowFields,
        columnFields
    } = projections;
    const {
         rowIndex,
         columnIndex
    } = indices;
    const {
        suppliedLayers,
        cell: GeomCell,
        resolver,
        config,
        encoder,
        detailFields
    } = context;
    const axes = resolver.axes();
    const cacheMaps = resolver.cacheMaps();
    const matrixLayers = resolver.matrixLayers();
    const labelManager = resolver.dependencies().smartlabel;
    const horizontalAxis = resolver.horizontalAxis();
    const verticalAxis = resolver.verticalAxis();
    const datamodelTransform = resolver.datamodelTransform();
    const sortedFields = config.sort;
    const {
        entryCellMap,
        exitCellMap
    } = cacheMaps;
    const layerConfigArr = encoder.getLayerConfig({ columnFields, rowFields }, suppliedLayers || [],
        context.retinalConfig);
    const axesCreators = { config, labelManager, axes, cacheMaps };

    fieldInfo.normalizedColumns = verticalAxis.fields;
    fieldInfo.normalizedRows = horizontalAxis.fields;

    const allFacets = [
        [...facets.rowFacets[0], ...facets.colFacets[0]],
        [...facets.rowFacets[1], ...facets.colFacets[1]]
    ];
    const facetFields = allFacets.slice();
    facetFields[0] = facetFields[0].map(facetField => facetField.oneVar());

    matrixLayers[rowIndex] = matrixLayers[rowIndex] ? matrixLayers[rowIndex] : [];
    matrixLayers[rowIndex][columnIndex] = layerConfigArr;

    // return from map if already there otherwise create and put in map
    const geomCellKey = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["getCellKey"])(rowIndex, columnIndex);
    const fields = {
        y: rowFields,
        x: columnFields
    };

    const geomCell = !exitCellMap.has(geomCellKey) ? new GeomCell() : exitCellMap.get(geomCellKey);

    // Sort datamodel if user has sorted a field
    const sortConfig = Object.keys(sortedFields).map(field => [field, sortedFields[field]]);
    if (sortConfig.length) {
        datamodel = datamodel.sort(sortConfig, { saveChild: true });
    }

    geomCell.data(datamodel)
                    .fields(fields)
                    .transform(datamodelTransform)
                    .detailFields(detailFields)
                    .facetByFields(allFacets);

    encoder.createAxis(axesCreators, fieldInfo, Object.assign({}, context, { geomCell, facetFields }));
    entryCellMap.set(geomCellKey, geomCell);
    exitCellMap.delete(geomCellKey);

    updateCells(resolver, facets, geomCell);

    return entryCellMap.get(geomCellKey);
};

const extractAxisIndex = id => Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(id.match(/^[0-9]*?(?=-)/g), 0);

/**
 * Creates axis cells based on the set of axes
 *
 * @param {Selection} selection Contains a selection of the axis units
 * @param {Array} axes Actual axis units
 * @param {number} axisIndex 0-> primary axis, 1-> secondary axis(when dual axis is made)
 * @param {Object} cells Contains a collection of the cells
 * @return {Object} return either set of axis/blank cells depending on the config
 */
const createAxisCells = (selection, axes, axisIndex, cells) =>
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["createSelection"])(selection, axis => axis, axes, (item, i) => i + item.reduce((e, n) => {
        const id = n.id + axisIndex;
        return `${e}-${id}`;
    }, '')).map((currObj, axis) => {
        if (axis && axis[axisIndex]) {
            const axisInst = axis[axisIndex];
            const { orientation, show } = axisInst.config();

            return new cells.AxisCell().source(axisInst).config({
                isOffset: orientation === _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["AxisOrientation"].LEFT || orientation === _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_0__["AxisOrientation"].TOP,
                show
            });
        }
        return new cells.BlankCell().config({ show: false });
    }).sort((a, b) => extractAxisIndex(a[0]) - extractAxisIndex(b[0]));

/**
 *
 *
 * @param {*} context
 * @param {*} selectionObj
 * @param {*} cells
 * @retur
 */
const axisPlaceholderGn = (context, selObj, cells) => {
    const {
        matrices
    } = context;
    const {
        axesMatrix
    } = matrices;

    return (type, axisFrom) => {
        const axes = axesMatrix[`${type}`];

        if (axes && axes.length) {
            if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["X"] || type === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["Y"]) {
                const fieldNames = type === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["Y"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_4__["ROWS"] : _enums_constants__WEBPACK_IMPORTED_MODULE_4__["COLUMNS"];

                [_enums_constants__WEBPACK_IMPORTED_MODULE_4__["PRIMARY"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["SECONDARY"]].forEach((fieldType, index) => {
                    const selObjProp = `${fieldNames}${fieldType}`;
                    let axisIndex = index;
                    let axesForDraw = axes;
                    if (axisFrom === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["RIGHT"] || axisFrom === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["BOTTOM"]) {
                        axisIndex = 1 - axisIndex;
                    }
                    if (!Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(axes, 0, axisIndex)) {
                        axesForDraw = [];
                    }
                    selObj[selObjProp] = createAxisCells(selObj[selObjProp], axesForDraw, axisIndex, cells);
                });
            } else {
                selObj.rowsPrimary = createAxisCells(selObj.rowPrime, axes.map(() => []), 0, cells);
                selObj.rowsSecondary = createAxisCells(selObj.rowSec, axes.map(() => []), 0, cells);
                selObj.columnsPrimary = createAxisCells(selObj.colPrime, axes[0], 0, cells);
                selObj.columnsSecondary = createAxisCells(selObj.colSec, axes[0], 0, cells);
            }
        }
        return selObj;
    };
};

/**
 * Creates header cells based on the set of headers
 *
 * @param {Object} selection Contains a selection of the header units
 * @param {string} headers Contains a list of the headers
 * @param {Object} cells Contains a collection of the cells
 * @param {Object} labelManager smart label instance
 * @return {Object} return either set of header cells depending on the config
 */
const createTextCells = (selection, headers, cells, labelManager) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["createSelection"])(selection,
        (label) => {
            const textCell = new cells.TextCell({}, { labelManager });
            textCell.source(label);
            return textCell;
        }, headers, (key, i) => key + i);

const extractFacetIndex = id => id.split('-').pop();

/**
 *
 *
 * @param {*} context
 * @param {*} selectionObj
 * @param {*} cells
 * @param {*} labelManager
 *
 */
const headerPlaceholderGn = (context, selectionObj, cells, labelManager) => {
    const {
        axis,
        keys,
        type,
        facet
    } = context;
    const counter = axis.length / keys.length;
    const selectionKeys = keys.length ? axis.map((d, i) => keys[Math.floor(i / counter)]) : [];

    const selObjUpdater = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["createSelection"])(selectionObj[`${type}Headers`], keySet => keySet, selectionKeys,
    (keySet, i) => `${keySet.join(',')}-${i}`)
        .sort((a, b) => extractFacetIndex(a[0]) - extractFacetIndex(b[0]));

    return selObjUpdater.map((keySet, data) => {
        let textCells = createTextCells(null, data, cells, labelManager);
        textCells = textCells.map((cell, k) => cell.source(k).config(facet));
        return textCells;
    });
};

/**
 * Creates a set of placeholders as a part of selection object
 *
 * @param {Array} normalizedOptions contains normalized rows and columns
 * @param {Array} matrices contains axis and value matrices
 * @param {aArrayny} projections contains set of row and column projections
 * @param {Object} cells Contains a collection of the cells
 * @param {Object} labelManager smart label instance
 * @return {Object} Creates a set of placeholders as a part of selections
 */
const generatePlaceholders = (context, cells, labelManager) => {
    let selectionObj;
    const {
        matrices,
        fields,
        facetsAndProjections,
        selection,
        facet,
        encoders,
        resolver
    } = context;
    const {
        rows,
        columns
    } = fields;
    const {
        valuesMatrix
    } = matrices;
    const {
        rowProjections,
        colProjections
    } = facetsAndProjections;
    const {
        rowKeys,
        columnKeys
    } = valuesMatrix;
    const takeAxisFrom = encoders.simpleEncoder._axisFrom;
    const takeHeaderFrom = encoders.simpleEncoder._headerFrom;

    selectionObj = selection || {};

    ['pie', _enums_constants__WEBPACK_IMPORTED_MODULE_4__["X"], _enums_constants__WEBPACK_IMPORTED_MODULE_4__["Y"]].forEach((axis) => {
        const axisFrom = axis === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["X"] ? takeAxisFrom.column : takeAxisFrom.row;
        selectionObj = axisPlaceholderGn(context, selectionObj, cells)(axis, axisFrom);
    });

    const {
        rowsPrimary,
        rowsSecondary,
        columnsPrimary,
        columnsSecondary
    } = selectionObj;

    const rowAxis = rowsPrimary && rowsPrimary.getObjects().length ? rowsPrimary.getObjects() :
        (rowsSecondary && rowsSecondary.getObjects().length ? rowsSecondary.getObjects() : []);
    const colAxis = columnsPrimary && columnsPrimary.getObjects().length ? columnsPrimary.getObjects() :
        (columnsSecondary && columnsSecondary.getObjects().length ? columnsSecondary.getObjects() : []);

    const headerConfig = [
        { type: _enums_constants__WEBPACK_IMPORTED_MODULE_4__["LEFT"], section: rows[0], axis: rowAxis, headerFrom: takeHeaderFrom.row },
        { type: _enums_constants__WEBPACK_IMPORTED_MODULE_4__["RIGHT"], section: rows[1], axis: rowAxis, headerFrom: takeHeaderFrom.row },
        { type: _enums_constants__WEBPACK_IMPORTED_MODULE_4__["TOP"], section: columns[0], axis: colAxis, headerFrom: takeHeaderFrom.column },
        { type: _enums_constants__WEBPACK_IMPORTED_MODULE_4__["BOTTOM"], section: columns[1], axis: colAxis, headerFrom: takeHeaderFrom.column }
    ];

    headerConfig.forEach((config, index) => {
        let keys;
        let length;
        const {
            type,
            section,
            axis,
            headerFrom
        } = config;

        if (index < 2) {
            keys = rowKeys;
            length = rowProjections.length > 0 ? rowProjections.length : 1;
        } else {
            keys = columnKeys;
            length = colProjections.length > 0 ? colProjections.length : 1;
        }
        keys = keys.map(arr => arr.map(val => resolver.valueParser()(val)));
        if (section.length && headerFrom === type && axis && keys.length) {
            const hContext = { axis, length, type };
            let headers = [];
            if (index < 2) {
                hContext.keys = keys;
                hContext.facet = facet.rows;
                headers = headerPlaceholderGn(hContext, selectionObj, cells, labelManager);
            } else {
                hContext.facet = facet.columns;
                hContext.keys = keys[0].map((key, i) => keys.map(e => e[i]));

                headers = headerPlaceholderGn(hContext, selectionObj, cells, labelManager);
            }
            selectionObj[`${type}Headers`] = headers;
        } else {
            selectionObj[`${type}Headers`] = null;
        }
    });
    return selectionObj;
};

/**
 * Generates matrices
 *
 * @param {Object} config Configuration to generate matrices
 * @param {Array} matrices Matrices containing the set of visual units and axes units
 * @param {Object} cells Contains a collection of the cells
 * @param {Object} labelManager smart label instance
 * @return {Object} contains a collection of matrices
 */
const generateMatrices = (context, matrices, cells, labelManager) => {
    const {
        unitHeight,
        unitWidth,
        facetsAndProjections,
        normalizedRows,
        normalizedColumns,
        selection,
        axisFrom,
        facet,
        encoders,
        resolver
     } = context;
    const placeholderContext = {
        fields: {
            rows: normalizedRows,
            columns: normalizedColumns
        },
        matrices,
        facetsAndProjections,
        selection,
        axisFrom,
        facet,
        encoders,
        resolver
    };
    // Generate placeholders for all matrices
    const selectionObj = generatePlaceholders(placeholderContext, cells, labelManager);
    const {
        columnsPrimary,
        columnsSecondary,
        rowsPrimary,
        rowsSecondary,
        leftHeaders,
        topHeaders,
        bottomHeaders,
        rightHeaders
    } = selectionObj;
    const [rowPrime, rowSec, colPrime, colSec] = [rowsPrimary, rowsSecondary, columnsPrimary, columnsSecondary]
        .map(d => (d ? d.getObjects() : []));
    const [leftFacets, rightFacets] = [leftHeaders, rightHeaders]
        .map(e => (e ? e.getObjects()
                        .map(f => f.getObjects()) : []));
    let rowPriority = rowSec.length ? 1 : -1;
    rowPrime.length && rowPriority++;
    let colPriority = colSec.length ? 1 : -1;
    colPrime.length && colPriority++;

    // Compute left matrix using left headers and the axes on the rows
    let leftMatrix = leftFacets.length ? leftFacets.map((d, i) => {
        rowPrime[i] = rowPrime[i] ? [rowPrime[i]] : [];
        return [...d, ...rowPrime[i]];
    }) : (rowPrime ? rowPrime.map(d => [d]) : []);

    // Compute right matrix using right headers and the axes on the rows
    const rightMatrix = rowSec.length ? rowSec.map((d, i) => [d, ...(rightFacets[i] || [])]) : (rightFacets.length ?
        rightFacets.map(d => [...d]) : []);

    const topMatrix = [];
    if (topHeaders) {
        const headers = topHeaders.getObjects();
        headers.forEach((e) => {
            const innerHeaders = e.getObjects();
            innerHeaders.forEach((x, i) => {
                topMatrix[i] = topMatrix[i] || [];
                topMatrix[i].push(x);
            });
        });
    }
    // Compute top matrix using the top headers and axes on the columns
    if (colPrime.length) {
        topMatrix.push(colPrime);
    }

    // Bottom and right matrices are prepared using the user config.
    let bottomMatrix = [];
    if (colSec.length) {
        bottomMatrix.push(colSec);
    }
    const currentBottomLength = bottomMatrix.length;
    if (bottomHeaders) {
        const headers = bottomHeaders.getObjects();
        headers.forEach((e) => {
            const innerHeaders = e.getObjects();
            innerHeaders.forEach((x, i) => {
                bottomMatrix[i + currentBottomLength] = bottomMatrix[i + currentBottomLength] || [];
                bottomMatrix[i + currentBottomLength].push(x);
            });
        });
    }

    if (!leftMatrix.length && !rightMatrix.length) {
        const cell = new cells.BlankCell();
        cell.setAvailableSpace(unitWidth, unitHeight);
        leftMatrix = [[cell]];
    }

    if (!topMatrix.length && (!bottomMatrix.length || !bottomMatrix[0].length)) {
        const cell = new cells.BlankCell();
        cell.setAvailableSpace(unitWidth, unitHeight);
        bottomMatrix = [[cell]];
    }

    return {
        rows: [leftMatrix, rightMatrix],
        columns: [topMatrix, bottomMatrix],
        selectionObj,
        colPriority,
        rowPriority
    };
};

const getAxisFields = (projections, fieldHolder = []) =>
                            projections.reduce((acc, item) =>
                                [...acc, ...item.reduce((ac, field) =>
                                   (field instanceof _variable__WEBPACK_IMPORTED_MODULE_5__["SimpleVariable"] ? [...ac, field.oneVar()] : ac), [])], fieldHolder);

const sortDmTemporalFields = (resolver, datamodel) => {
    let axisFields = [];
    const projections = resolver.projections();
    axisFields = getAxisFields(projections.rowProjections, getAxisFields(projections.colProjections));

    const fieldConfig = datamodel.getFieldsConfig();
    const temporalFields = axisFields.reduce((acc, field) =>
        ((fieldConfig[field].def.subtype === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["TEMPORAL"]) ? [...acc, [field]] : acc), []);
    return temporalFields.length ? datamodel.sort(temporalFields, { saveChild: true }) : datamodel;
};

const transformDataModel = (dataModel, config, resolver) => {
    let groupedModel;

    const fieldsConfig = dataModel.getFieldsConfig();
    const resolvedData = resolver.data();
    const { groupBy, suppliedLayers, facetsAndProjections } = config;

    if (resolvedData instanceof muze_utils__WEBPACK_IMPORTED_MODULE_1__["DataModel"]) {
        resolvedData.dispose();
    }

    groupedModel = dataModel.project(dataModel.getSchema().map(d => d.name));
    resolver.data(groupedModel);
    if (!groupBy.disabled) {
        const fields = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["getFieldsFromSuppliedLayers"])(suppliedLayers, groupedModel.getFieldsConfig());
        const allFields = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["extractFields"])(facetsAndProjections, fields);
        const dimensions = allFields.filter(field =>
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getObjProp"])(fieldsConfig, field, 'def', 'type') === muze_utils__WEBPACK_IMPORTED_MODULE_1__["FieldType"].DIMENSION);
        const aggregationFns = groupBy.measures;
        const measureNames = Object.keys(groupedModel.getFieldspace().getMeasure());
        const nearestAggFns = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["retrieveNearestGroupByReducers"])(groupedModel, ...measureNames);
        const resolvedAggFns = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["mergeRecursive"])(nearestAggFns, aggregationFns);

        groupedModel = groupedModel.groupBy(dimensions.length ? dimensions : [''], resolvedAggFns)
                                            .project(allFields);
    }
    // sort temporal fields if any in the given rows and columns
    groupedModel = sortDmTemporalFields(resolver, groupedModel);
    resolver.transformedData(groupedModel);
    return groupedModel;
};

/**
 * Computes matrices for a group
 *
 * @param {Object} datamodel on which the matrices are to be computed
 * @param {Object} config configuration of the matrices
 * @param {Object} layerRegistry contains the registered layers
 * @return {Object} conputed matrices
 * @memberof MatrixResolver
 */
const computeMatrices = (context, config) => {
    const {
        resolver,
        datamodel,
        componentRegistry,
        encoders
    } = context;
    const {
            globalConfig,
            selection,
            transform
        } = config;
    const groupBy = globalConfig.autoGroupBy;
    const { smartlabel: labelManager } = resolver.dependencies();
    const fieldMap = datamodel.getFieldsConfig();
    const layerConfig = resolver.layerConfig();
    const registry = resolver.registry();
    const { fields: normalizedRows } = resolver.horizontalAxis();
    const { fields: normalizedColumns } = resolver.verticalAxis();
    const otherEncodings = resolver.optionalProjections(config, layerConfig);
    const facetsAndProjections = resolver.getAllFields();
    const matrixGnContext = {
        // Configuration to be passed to generate the  different matrices.
        // A common config is used for both value matrices and other matrices
        normalizedColumns,
        normalizedRows,
        facetsAndProjections,
        layers: layerConfig,
        fieldMap,
        otherEncodings,
        encoders,
        facet: globalConfig.facet || {},
        axisFrom: globalConfig.axisFrom || {},
        selection,
        resolver
    };
    const cells = {
        GeomCell: resolver.getCellDef(registry.cells.GeomCell),
        AxisCell: resolver.getCellDef(registry.cells.AxisCell),
        BlankCell: resolver.getCellDef(registry.cells.BlankCell),
        TextCell: resolver.getCellDef(registry.cells.TextCell)
    };
    const isRowSizeEqual = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["isDistributionEqual"])(normalizedRows);
    const isColumnSizeEqual = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["isDistributionEqual"])(normalizedColumns);

    resolver.colCells({});
    resolver.rowCells({});
    resolver.datamodelTransform(transform || {});

    // Cell creation begins here
    resolver.resetSimpleAxes();

    const {
        entryCellMap
    } = resolver.cacheMaps();
    const newCacheMap = {
        exitCellMap: entryCellMap,
        entryCellMap: new Map()
    };

    resolver.cacheMaps(newCacheMap);
    const { simpleEncoder } = encoders;
    const valueCellContext = {
        config: globalConfig,
        suppliedLayers: simpleEncoder.serializeLayerConfig(resolver.layerConfig()),
        resolver,
        cell: cells.GeomCell,
        encoder: simpleEncoder,
        newCacheMap,
        detailFields: config.detail,
        retinalConfig: {
            color: config.color,
            size: config.size,
            shape: config.shape
        }
    };

    const groupedModel = transformDataModel(datamodel, {
        facetsAndProjections,
        suppliedLayers: valueCellContext.suppliedLayers,
        groupBy
    }, resolver);
    simpleEncoder.data(groupedModel);
    // return a callback function to create the cells from the matrix
    const cellCreator = resolver.valueCellsCreator(valueCellContext);
    // Creates value matrices from the datamodel and configs
    const valueMatrixInfo = Object(_matrix_model__WEBPACK_IMPORTED_MODULE_2__["getMatrixModel"])(groupedModel, facetsAndProjections, cellCreator, globalConfig);

    Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["removeExitCells"])(resolver);
    resolver.cacheMaps().exitCellMap.clear();
    resolver.valueMatrix(valueMatrixInfo.matrix);

    const { xAxes, yAxes } = Object(_group_utils__WEBPACK_IMPORTED_MODULE_3__["mutateAxesFromMap"])(resolver.cacheMaps(), resolver.axes());

    resolver.axes({
        x: xAxes,
        y: yAxes
    });

    resolver.createUnits(componentRegistry, config);

    const matrices = {
        valuesMatrix: valueMatrixInfo,
        axesMatrix: resolver.axes()
    };
    // Create all matrices
    const {
        rows,
        columns,
        selectionObj,
        rowPriority,
        colPriority
    } = generateMatrices(matrixGnContext, matrices, cells, labelManager);

    resolver.rowMatrix(rows);
    resolver.columnMatrix(columns);

    return {
        rows: resolver.rowMatrix(),
        columns: resolver.columnMatrix(),
        values: resolver.valueMatrix(),
        isColumnSizeEqual,
        isRowSizeEqual,
        priority: {
            row: rowPriority,
            col: colPriority
        },
        selection: selectionObj,
        dataModels: {
            groupedModel,
            parentModel: datamodel
        }
    };
};


/***/ }),

/***/ "./packages/visual-group/src/group-helper/group-utils.js":
/*!***************************************************************!*\
  !*** ./packages/visual-group/src/group-helper/group-utils.js ***!
  \***************************************************************/
/*! exports provided: initStore, isDistributionEqual, initializeCacheMaps, getAxisKey, getCellKey, extractUnitConfig, getHeaderText, headerCreator, findInGroup, getAxisType, retriveDomainFromData, mutateAxesFromMap, getEncoder, getHeaderAxisFrom, setFacetsAndProjections, getBorders, getFieldsFromSuppliedLayers, extractFields, sortFacetFields, removeExitCells */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initStore", function() { return initStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDistributionEqual", function() { return isDistributionEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeCacheMaps", function() { return initializeCacheMaps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisKey", function() { return getAxisKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCellKey", function() { return getCellKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractUnitConfig", function() { return extractUnitConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeaderText", function() { return getHeaderText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "headerCreator", function() { return headerCreator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findInGroup", function() { return findInGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisType", function() { return getAxisType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retriveDomainFromData", function() { return retriveDomainFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mutateAxesFromMap", function() { return mutateAxesFromMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEncoder", function() { return getEncoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeaderAxisFrom", function() { return getHeaderAxisFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFacetsAndProjections", function() { return setFacetsAndProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBorders", function() { return getBorders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFieldsFromSuppliedLayers", function() { return getFieldsFromSuppliedLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFields", function() { return extractFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortFacetFields", function() { return sortFacetFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeExitCells", function() { return removeExitCells; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-unit */ "./packages/visual-unit/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _enums_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/defaults */ "./packages/visual-group/src/enums/defaults.js");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../variable */ "./packages/visual-group/src/variable/index.js");
/* harmony import */ var _encoder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../encoder */ "./packages/visual-group/src/encoder/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");








const POLAR = muze_utils__WEBPACK_IMPORTED_MODULE_0__["COORD_TYPES"].POLAR;

/**
 * Creates an instance of a store which contains the arguments to make the class reactive
 *
 * @return {Object} instance of store
 * @memberof VisualGroup
 */
const initStore = () => new muze_utils__WEBPACK_IMPORTED_MODULE_0__["Store"]({
    [_enums_defaults__WEBPACK_IMPORTED_MODULE_3__["DATA_UPDATE_COUNTER"]]: _enums_defaults__WEBPACK_IMPORTED_MODULE_3__["DATA_UPDATE_COUNTER"]
});

/**
 *
 *
 * @param {*} arr
 */
const isDistributionEqual = arr => [...arr[0], ...arr[1]].reduce((isEqual, row) => {
    const rowType = row.type();

    if (rowType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["MEASURE"] || rowType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TEMPORAL"]) {
        isEqual = true;
    }
    return isEqual;
}, false);

/**
 *
 *
 */
const initializeCacheMaps = () => ({
    cellMap: new Map(),
    xAxesMap: new Map(),
    yAxesMap: new Map(),
    entryCellMap: new Map(),
    exitCellMap: new Map()
});

/**
 *
 *
 * @param {*} axisName
 * @param {*} id
 */
const getAxisKey = (axisName, ...params) => `${axisName}-axis-${params.join('-')}`;

/**
 *
 *
 * @param {*} rowId
 * @param {*} columnId
 */
const getCellKey = (rowId, columnId) => `cell-${rowId}-${columnId}`;

/**
 *
 *
 * @param {*} config
 *
 */
const extractUnitConfig = (config) => {
    const unitConfig = {};
    const attrNames = [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["INTERACTION"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["GRID_LINES"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["GRID_BANDS"]];

    attrNames.forEach((attr) => {
        if (config[attr] !== undefined) {
            unitConfig[attr] = config[attr];
        }
    });
    return unitConfig;
};

/**
 *
 *
 * @param {*} headers
 * @param {*} index
 * @param {*} rowLength
 *
 * @memberof MatrixResolver
 */
const getHeaderText = (headers, index, rowLength) => {
    let header = '';

    if (index === rowLength - 1 && headers.length > rowLength) {
        for (let i = index; i < headers.length - 1; i++) {
            header += `${headers[i].toString()} / `;
        }
        header += headers[headers.length - 1].toString();
        return header;
    } else if (headers[index]) {
        return headers[index].toString();
    }
    return '';
};

/**
 *
 *
 * @param {*} fields
 * @param {*} fieldHeaders
 * @param {*} TextCell
 * @param {*} labelManager
 *
 */
const headerCreator = (fields, fieldHeaders, TextCell, { classPrefix, labelManager }) => {
    const headers = fields.length > 0 ? fields[0].map((cell, i) => new TextCell({
        type: _enums_constants__WEBPACK_IMPORTED_MODULE_6__["HEADER"],
        className: `${classPrefix}-grid-headers`
    }, {
        labelManager
    }).source(getHeaderText(fieldHeaders, i, fields[0].length))
                    .config({ show: cell.config().show })) : [];
    return headers;
};

/**
 *
 *
 * @param {*} variable
 * @param {*} allFields
 *
 */
const findInGroup = (variable, allFields) => {
    let channel = null;

    [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["SHAPE"]].forEach((e) => {
        if (undefined.store.get(e) && variable === undefined.store.get(e)[0]) {
            channel = e;
        }
    });

    if (channel) {
        return { channel };
    }
    [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COL"]].forEach((facetType) => {
        allFields[`${facetType}Facets`].forEach((e) => {
            if (e.toString() === variable) {
                channel = { channel: _enums_constants__WEBPACK_IMPORTED_MODULE_6__["FACET"], type: facetType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COL"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COLUMN"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] };
            }
        });
    });

    if (channel) {
        return channel;
    }

    [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COL"]].forEach((projType) => {
        allFields[`${projType}Projections`].forEach((e) => {
            e.forEach((m) => {
                if (m.toString() === variable) {
                    channel = projType === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COL"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["X"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["Y"];
                }
            });
        });
    });

    if (channel) {
        return { channel };
    }
    return null;
};

/**
 *
 *
 * @param {*} datamodel
 * @param {*} field
 */
const getAxisType = (fieldsConfig, field) => {
    let fieldType = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ORDINAL"];

    if (field && fieldsConfig[field].def.type !== _enums_constants__WEBPACK_IMPORTED_MODULE_6__["DIMENSION"]) {
        fieldType = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LINEAR"];
    }
    return fieldType;
};

/**
 *
 *
 * @param {*} datamodel
 * @param {*} fieldName
 *
 */
const retriveDomainFromData = (datamodel, fieldName) => {
    const field = datamodel.getFieldspace().fields.find(d => d.name() === fieldName.toString());
    return field.domain();
};

/**
 *
 *
 * @memberof MatrixResolver
 */
const mutateAxesFromMap = (cacheMaps, axes) => {
    let xAxes = null;
    let yAxes = null;
    const {
        xAxesMap,
        yAxesMap
    } = cacheMaps;
    const {
        x: xAxisSet,
        y: yAxisSet
    } = axes;

    xAxisSet && xAxisSet.forEach((axisId) => {
        const xAxis = xAxesMap.get(axisId);
        xAxes = xAxes || [];
        xAxes.push(xAxis);
    });

    yAxisSet && yAxisSet.forEach((axisId) => {
        const yAxis = yAxesMap.get(axisId);
        yAxes = yAxes || [];
        yAxes.push(yAxis);
    });

    return {
        xAxes, yAxes
    };
};

const hasPolarEncodings = layerConf => layerConf.mark === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ARC"] || [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["RADIUS"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ANGLE"]].some(field =>
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(layerConf.encoding, field));

/**
 *
 *
 * @param {*} layers
 *
 */
const getEncoder = (layers) => {
    let encoder = new _encoder__WEBPACK_IMPORTED_MODULE_5__["CartesianEncoder"]();

    if (layers.length) {
        // Figuring out the kind of layers the group will have
        encoder = layers.some(layerConf => hasPolarEncodings(layerConf)) ? new _encoder__WEBPACK_IMPORTED_MODULE_5__["PolarEncoder"]() : encoder;
    }
    return encoder;
};

/**
 *
 *
 * @param {*} type
 * @param {*} fields
 * @param {*} userAxisFromConfig
 *
 */
const getHeaderAxisFrom = (type, fields, userAxisFromConfig) => {
    let axisFrom = userAxisFromConfig[type];
    let headerFrom = '';
    const options = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["RIGHT"]] : [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTTOM"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"]];
    const [firstField, secondField] = fields;
    const firstFieldType = i => (firstField.length ? firstField[i].type() : null);
    const secondFieldType = i => (secondField.length ? secondField[i].type() : null);

    if (firstFieldType(firstField.length - 1) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["DIMENSION"] && secondFieldType(0) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["DIMENSION"]) {
        headerFrom = axisFrom ? options[1 - options.indexOf(axisFrom)] : options[1];

        if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["COLUMN"] && (firstField[firstField.length - 1].toString() === secondField[0].toString())) {
            axisFrom = _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"];
        } else {
            axisFrom = axisFrom || options[0];
        }
    } else if (secondFieldType(secondField.length - 1) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["DIMENSION"]) {
        headerFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["RIGHT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTTOM"];
        axisFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["RIGHT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTTOM"];
    } else {
        headerFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"];
        axisFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"];
    }
    if (firstFieldType(firstField.length - 1) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["MEASURE"] && secondFieldType(0) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["MEASURE"]) {
        axisFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"];
    } else if (secondFieldType(0) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["MEASURE"]) {
        axisFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["RIGHT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTTOM"];
    } else if (firstFieldType(firstField.length - 1) === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["MEASURE"]) {
        axisFrom = type === _enums_constants__WEBPACK_IMPORTED_MODULE_6__["ROW"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"] : _enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"];
    }
    return [headerFrom, axisFrom];
};

/**
 *
 *
 * @param {*} type
 * @param {*} fields
 * @param {*} layers
 *
 * @memberof MatrixResolver
 */
const setFacetsAndProjections = (context, fieldInfo, encoder) => {
    const {
        fields,
        type
    } = fieldInfo;
    const { facets, projections } = encoder.simpleEncoder.getFacetsAndProjections(fields, type);

    context.facets({ [`${type}Facets`]: facets });
    context.projections({ [`${type}Projections`]: projections });

    return { facets, projections, fields };
};

const getRowBorders = (left, right) => {
    const borders = {};
    borders.top = false;
    borders.bottom = false;
    if (left.length > 1 || right.length > 1) {
        borders.top = true;
        borders.bottom = true;
    }
    return borders;
};

const getColumnsBorders = (top, bottom) => {
    const borders = {};
    borders.left = false;
    borders.right = false;
    if (top.length || bottom.length) {
        if ((top[0] && top[0].length > 1) || (bottom[0] && bottom[0].length > 1)) {
            borders.left = true;
            borders.right = true;
        }
    }
    return borders;
};

const getValueBorders = (rows, columns) => {
    const borders = { top: true, left: true, bottom: true, right: true };
    const borderTypeRow = [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["RIGHT"]];
    const borderTypeCol = [_enums_constants__WEBPACK_IMPORTED_MODULE_6__["TOP"], _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BOTTOM"]];
    rows.forEach((e, i) => {
        if (e[0] && e[0].length) {
            borders[borderTypeRow[i]] = true;
        } else {
            borders[borderTypeRow[i]] = false;
        }
    });
    columns.forEach((e, i) => {
        if (e.length) {
            borders[borderTypeCol[i]] = true;
        } else {
            borders[borderTypeCol[i]] = false;
        }
    });

    return borders;
};

const getBorders = (matrices, encoder) => {
    let showRowBorders = { top: false, bottom: false };
    let showColBorders = { left: false, right: false };
    let showValueBorders = { top: false, bottom: false, left: false, right: false };
    const {
        rows,
        columns,
        values: valueMatrix
    } = matrices;
    const [leftRows, rightRows] = rows;
    const [topColumns, bottomColumns] = columns;
    const {
        rowDimensions,
        columnDimensions,
        rowTemporalFields,
        columnTemporalFields,
        columnMeasures,
        rowMeasures
    } = encoder.fieldInfo();
    const allDimensionLength = rowDimensions.length + columnDimensions.length;
    const allMeasuresLength = rowMeasures.length + columnMeasures.length;
    const allTemporalFieldsLength = rowTemporalFields.length + columnTemporalFields.length;

    if (encoder.constructor.type() === POLAR) {
        if (!allDimensionLength) {
            return { showRowBorders, showColBorders, showValueBorders };
        }
    } else if (!allMeasuresLength && !allTemporalFieldsLength && allDimensionLength <= 2) {
        return { showRowBorders, showColBorders, showValueBorders };
    }

    showRowBorders = getRowBorders(leftRows, rightRows);
    showColBorders = getColumnsBorders(topColumns, bottomColumns);
    showValueBorders = getValueBorders([leftRows, rightRows], [topColumns, bottomColumns]);

    if (valueMatrix.length > 1) {
        showValueBorders.top = true;
        showValueBorders.bottom = true;
    }
    if (valueMatrix.length && valueMatrix[0].length > 1) {
        showValueBorders.left = true;
        showValueBorders.right = true;
    }
    return { showRowBorders, showColBorders, showValueBorders };
};

const getFieldsFromSuppliedLayers = (suppliedLayerConfig, fieldsConfig) => {
    let fields = [];
    const encodingArr = suppliedLayerConfig.map(conf => (conf.encoding || {}));
    fields = [...fields, [].concat(...encodingArr.map(enc => Object.values(enc).map(d => d.field)))];
    fields = fields.filter(field => fieldsConfig[field] && fieldsConfig[field].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);
    return fields;
};

const extractFields = (facetsAndProjections, layerFields) => {
    const fields = Object.values(facetsAndProjections).map((arr) => {
        const flattenArray = [].concat(...arr);
        return [].concat(...flattenArray.map((field) => {
            if (field instanceof _variable__WEBPACK_IMPORTED_MODULE_4__["Variable"]) {
                return field.getMembers();
            }
            return field;
        }));
    });
    return [].concat(...fields, ...layerFields);
};

/**
 * This method sorts the facets fields inplace if field is of categorical type
 * @param {Object} facets Array of facets
 * @param {Array} keys Array of the facet field values
 * @param {Object} config configuration object
 * @return {Array} Returns sorted facets
 */
const sortFacetFields = (facets, keys, config) => {
    /**
     * Check if the facet sorted by the user is plotted
     * If an incorrect field is sorted, return the keys as is
     */
    const schema = [];
    const facetNames = [];
    const sortInfo = [];
    const sortConfig = config.sort;

    facets.forEach((facet) => {
        const name = `${facet}`;
        facetNames.push(name);

        const facetSortConfig = sortConfig[name];

        if (facetSortConfig) {
            sortInfo.push([name, facetSortConfig]);
        } else {
            sortInfo.push([name, null]);
        }
        schema.push(facet.getSchemaDef());
    });

    return new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"]([facetNames, ...keys], schema).getData({ sort: sortInfo }).data;
};

const removeExitCells = (resolver) => {
    const exitCells = resolver.cacheMaps().exitCellMap;
    const store = resolver.store();
    const qualifiedStateProps = [].concat(..._chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_1__["VisualUnit"].getQualifiedStateProps(),
        ..._chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayer"].getQualifiedStateProps());
    store.lockCommits(qualifiedStateProps);
    exitCells.forEach((placeholder) => {
        placeholder.remove();
    });
    store.unlockCommits(qualifiedStateProps);
};


/***/ }),

/***/ "./packages/visual-group/src/group-helper/index.js":
/*!*********************************************************!*\
  !*** ./packages/visual-group/src/group-helper/index.js ***!
  \*********************************************************/
/*! exports provided: initStore, findInGroup, getEncoder, getAxisType, getAxisKey, retriveDomainFromData, getBorders, MatrixResolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initStore", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["initStore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findInGroup", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["findInGroup"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEncoder", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["getEncoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAxisType", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["getAxisType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAxisKey", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["getAxisKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "retriveDomainFromData", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["retriveDomainFromData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBorders", function() { return _group_utils__WEBPACK_IMPORTED_MODULE_0__["getBorders"]; });

/* harmony import */ var _matrix_resolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-resolver */ "./packages/visual-group/src/group-helper/matrix-resolver.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatrixResolver", function() { return _matrix_resolver__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./packages/visual-group/src/group-helper/matrix-model.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/group-helper/matrix-model.js ***!
  \****************************************************************/
/*! exports provided: getMatrixModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatrixModel", function() { return getMatrixModel; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _group_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");



/**
* Gets name of fields form the variables
*
* @param {*} fields1
* @param {*} [fields2=[]]
*
*/
const getFieldNames = fieldVar => fieldVar.reduce((acc, d) => {
    acc = [...acc, ...d.getMembers()];
    return acc;
}, []);

/**
*
*
* @param {*} fieldInfo
* @returns
*/
const prepareProjectionInfo = (fieldInfo) => {
    const {
        colProjections,
        rowProjections
    } = fieldInfo;
    const uniqueFields = [];
    let indices = [];
    let projections = [];

    rowProjections.forEach((rowProj, rIndex) => {
        const newRIndex = rIndex;
        colProjections.forEach((colProj, cIndex) => {
            const newCIndex = cIndex;
            const newRowProj = getFieldNames(rowProj);
            const newColProj = getFieldNames(colProj);

            uniqueFields.push([...newRowProj, ...newColProj]);
            indices.push({ rowIndex: newRIndex, colIndex: newCIndex });
            projections.push({ rowFields: rowProj, columnFields: colProj });
        });
    });
    indices = indices.length ? indices : [{ rowIndex: 0, colIndex: 0 }];
    projections = projections.length ? projections : [{ rowFields: [], columnFields: [] }];
    return { uniqueFields, indices, projections };
};

/**
*
*
* @param {*} fieldInfo
* @returns
*/
const prepareFacetInfo = (fieldInfo) => {
    const {
        rowFacets,
        colFacets
    } = fieldInfo;

    const rowFacetNames = getFieldNames(rowFacets);
    const colFacetNames = getFieldNames(colFacets);
    const allFacets = [...rowFacetNames, ...colFacetNames];

    return { rowFacetNames, colFacetNames, allFacets, rowFacets, colFacets };
};

/**
*
*
* @param {*} context
* @param {*} facetNames
* @param {*} hashMap
* @param {*} keys
* @param {*} index
* @returns
*/
const prepareHashMaps = (context, facetNames, hashMap, keys, index) => {
    const rowKey = [];
    facetNames.forEach((name) => {
        const key = context._derivation[context._derivation.length - 1].meta.keys[name];

        rowKey.push(key);
    });

    const joinedRowKey = rowKey.join(',');

    if (hashMap[joinedRowKey] === undefined) {
        hashMap[joinedRowKey] = index++;
        keys.push(rowKey);
    }
    return rowKey;
};

const createJoinedKeys = keys => keys.map(e => ({
    keyArr: e,
    joinedKey: e.join(',')
}));

/**
*
*
* @param {*} splitModels
* @param {*} facetInfo
* @returns
*/
const getSplitModelHashMap = (splitModels, facetInfo, config) => {
    const {
        rowFacetNames,
        colFacetNames,
        rowFacets,
        colFacets
    } = facetInfo;

    const rowKeyHashMap = {};
    const colKeyHashMap = {};

    const rowKeys = [];
    const colKeys = [];
    const rowIndex = 0;

    const splitModelsHashMap = {};

    splitModels.forEach((splitContext) => {
        const rowKey = prepareHashMaps(splitContext, rowFacetNames, rowKeyHashMap, rowKeys, rowIndex);
        const colKey = prepareHashMaps(splitContext, colFacetNames, colKeyHashMap, colKeys, 1);

        splitModelsHashMap[`${rowKey}-${colKey}`] = splitContext;
    });

    return {
        splitModelsHashMap,
        rowKeys: createJoinedKeys(Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["sortFacetFields"])(rowFacets, rowKeys, config)),
        colKeys: createJoinedKeys(Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["sortFacetFields"])(colFacets, colKeys, config))
    };
};

/**
 * Formats row or columns keys with the provided formatter.
 *
 * @param {Array} keys - The collection of row or column keys.
 * @param {Array} formatterList - The list of corresponding formatter.
 */
const formatKeys = (keys, formatterList) => {
    const formattedKeys = [];
    keys.forEach((rKeys, rIdx) => {
        formattedKeys[rIdx] = [];
        rKeys.forEach((key, idx) => {
            formattedKeys[rIdx][idx] = formatterList[idx](key);
        });
    });
    return formattedKeys;
};

/**
*
*
* @param {Object} context
* @param {Object} fieldInfo
* @returns
*/
const splitByColumn = (context, optionalProjections) => {
    const {
        matrix,
        dataModel,
        rowIndex,
        colIndex,
        facetInfo,
        projectionInfo,
        geomCellCreator
    } = context;
    const {
        indices,
        uniqueFields,
        projections
    } = projectionInfo;

    const commonFields = optionalProjections;

    dataModel.splitByColumn(uniqueFields, commonFields).forEach((model, i) => {
        let { rowIndex: row, colIndex: col } = indices[i];
        row += rowIndex;
        col += colIndex;

        matrix[row] = matrix[row] || [];

        const projectionIndexObject = {
            indices: {
                rowIndex: row,
                columnIndex: col
            },
            projections: projections[i]
        };

        matrix[row][col] = geomCellCreator(model, projectionIndexObject, facetInfo);
    });
    const lastIndex = indices[indices.length - 1];

    return {
        rowIndex: lastIndex.rowIndex + rowIndex,
        colIndex: lastIndex.colIndex + colIndex
    };
};

const createColumnDataModels = (colContext, fieldInfo, sourceDM) => {
    let context = {};
    const {
        rowFacets,
        colFacets
    } = fieldInfo;
    const {
        rowKeyArr,
        rowKey,
        colKeyObj,
        newRowIndex,
        splitModelsHashMap,
        currentColumnIndex
    } = colContext;

    const { keyArr: colKeyArr, joinedKey: colKey } = colKeyObj;
    const hashMapKey = splitModelsHashMap[`${rowKey}-${colKey}`];

    if (hashMapKey) {
        context = { dataModel: hashMapKey };
    } else {
        const emptyDm = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"]([], sourceDM.getData().schema);
        context = { dataModel: emptyDm };
    }

    context = {
        ...context,
        ...colContext,
        facetInfo: {
            rowFacets: [rowFacets, rowKeyArr],
            colFacets: [colFacets, colKeyArr]
        },
        rowIndex: newRowIndex,
        colIndex: currentColumnIndex
    };
    const dataModels = splitByColumn(context, fieldInfo.optionalProjections);

    return {
        columnIndex: dataModels.colIndex + 1,
        rowIndex: dataModels.rowIndex
    };
};

const createRowDataModels = (rowContext, fieldInfo, sourceDM) => {
    let currentColumnIndex = 0;
    let rowIndexForCurrentKey = 0;
    const {
        colKeys,
        rowKeyObj,
        currentRowIndex
    } = rowContext;
    const newRowIndex = currentRowIndex;
    const { keyArr: rowKeyArr, joinedKey: rowKey } = rowKeyObj;
    const colContext = {
        ...rowContext,
        rowKeyArr,
        rowKey,
        newRowIndex
    };
    rowIndexForCurrentKey = currentRowIndex;
    if (colKeys.length) {
        colKeys.forEach((colKeyObj) => {
            colContext.colKeyObj = colKeyObj;
            colContext.currentColumnIndex = currentColumnIndex;
            const { columnIndex, rowIndex } = createColumnDataModels(colContext, fieldInfo, sourceDM);

            currentColumnIndex = columnIndex;
            rowIndexForCurrentKey = rowIndex;
        });
    } else {
        colContext.colKeyObj = { keyArr: [], joinedKey: '' };
        colContext.currentColumnIndex = currentColumnIndex;

        const { columnIndex, rowIndex } = createColumnDataModels(colContext, fieldInfo, sourceDM);

        currentColumnIndex = columnIndex;
        rowIndexForCurrentKey = rowIndex;
    }
    return {
        rowIndex: ++rowIndexForCurrentKey
    };
};

/**
* Gets Matrixes for corresponding datamodel, facets and projections
*
* @param {Object} dataModel input datamodel
* @param {Object} fieldInfo Information about the fields
* @param {Function} geomCellCreator Callback executed after datamodels are prepared after sel/proj
* @return {Object} set of matrices with the corresponding row and column keys
*/
const getMatrixModel = (dataModel, fieldInfo, geomCellCreator, globalConfig) => {
    let currentRowIndex = 0;
    const matrix = [];
    const {
        rowFacets,
        colFacets
    } = fieldInfo;

    const projectionInfo = prepareProjectionInfo(fieldInfo);
    const facetInfo = prepareFacetInfo(fieldInfo);
    const allSplitModels = dataModel.splitByRow(facetInfo.allFacets);

    const {
        splitModelsHashMap,
        rowKeys,
        colKeys
    } = getSplitModelHashMap(allSplitModels, facetInfo, globalConfig);

    const generalContext = {
        matrix,
        geomCellCreator,
        projectionInfo,
        splitModelsHashMap,
        colKeys
    };
    if (rowKeys.length) {
        rowKeys.forEach((rowKeyObj) => {
            const rowContext = {
                ...generalContext,
                rowKeyObj,
                currentRowIndex
            };
            const { rowIndex } = createRowDataModels(rowContext, fieldInfo, dataModel);

            currentRowIndex = rowIndex;
        });
    } else if (colKeys.length) {
        let currentColumnIndex = 0;
        const newRowIndex = currentRowIndex;

        colKeys.forEach((colKeyObj) => {
            const colContext = {
                ...generalContext,
                rowKeyArr: [],
                rowKey: '',
                colKeyObj,
                newRowIndex,
                currentColumnIndex
            };
            const { columnIndex, rowIndex } = createColumnDataModels(colContext, fieldInfo, dataModel);
            currentRowIndex = rowIndex;
            currentColumnIndex = columnIndex;
        });
    } else {
        let currentColumnIndex = 0;
        const newRowIndex = currentRowIndex;
        const colContext = {
            ...generalContext,
            rowKeyArr: [],
            rowKey: '',
            colKeyObj: { keyArr: [], joinedKey: '' },
            newRowIndex,
            currentColumnIndex
        };
        const { columnIndex, rowIndex } = createColumnDataModels(colContext, fieldInfo, dataModel);
        currentRowIndex = rowIndex;
        currentColumnIndex = columnIndex;
    }

    const formattedColKeys = formatKeys(colKeys.map(e => e.keyArr),
        colFacets.map(facetField => facetField.rawFormat()));
    const formattedRowKeys = formatKeys(rowKeys.map(e => e.keyArr),
        rowFacets.map(facetField => facetField.rawFormat()));

     // Getting column keys
    const transposedColKeys = formattedColKeys.length > 0 ? formattedColKeys[0].map((col, i) =>
     formattedColKeys.map(row => row[i])) : formattedColKeys;

    return { matrix, rowKeys: formattedRowKeys, columnKeys: transposedColKeys };
};


/***/ }),

/***/ "./packages/visual-group/src/group-helper/matrix-resolver.js":
/*!*******************************************************************!*\
  !*** ./packages/visual-group/src/group-helper/matrix-resolver.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MatrixResolver; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _group_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony import */ var _cell_creator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cell-creator */ "./packages/visual-group/src/group-helper/cell-creator.js");
/* harmony import */ var _resolver_props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolver-props */ "./packages/visual-group/src/group-helper/resolver-props.js");






/**
 * Resolves the matrices from configuration provided
 *
 * @export
 * @class MatrixResolver
 */
class MatrixResolver {

    /**
     * Creates an instance of MatrixResolver.
     * @param {Object} dependencies needed to run the resolver
     * @memberof MatrixResolver
     */
    constructor (dependencies) {
        this._registry = {};
        this._layerConfig = [];
        this._matrixLayers = [];
        this._dependencies = dependencies;
        this._rowMatrix = [];
        this._columnMatrix = [];
        this._valueMatrix = [];
        this._facets = { rowFacets: [], colFacets: [] };
        this._projections = { rowProjections: [], colProjections: [] };
        this._datamodelTransform = {};
        this._units = [];
        this._cacheMaps = {};
        this._fireboltDeps = {};
        this._axes = {
            x: {},
            y: {},
            color: [],
            size: [],
            shape: [],
            radius: [],
            angle: [],
            angle0: []
        };
        this._placeholderInfo = {};
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, this.constructor.getterSetters());

        this.cacheMaps(Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["initializeCacheMaps"])());
    }

    static getterSetters () {
        return _resolver_props__WEBPACK_IMPORTED_MODULE_4__["RESOLVER_PROPS"];
    }
    /**
     * Set:  Registers placeholders, Get: return {Object} those placeholders
     *
     * @param {Object} placeholders cells that will construct the group
     * @return {Object} Either current instance or the set of placeholders
     * @memberof MatrixResolver
     */
    registry (...placeholders) {
        if (placeholders.length) {
            Object.entries(placeholders[0]).forEach((val) => {
                this._registry[val[0]] = val[1];
            });
            return this;
        }
        return this._registry;
    }

    /**
     * Used to set the layer config from outside or get current layer info
     *
     * @param {Object} type configuration of layer provided externally
     * @return {Object} either the layer or current instance
     * @memberof MatrixResolver
     */
    cacheMaps (...maps) {
        if (maps.length) {
            [_enums_constants__WEBPACK_IMPORTED_MODULE_2__["CELL"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["X_AXES"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["Y_AXES"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["ENTRY_CELLS"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["EXIT_CELLS"]].forEach((e) => {
                this._cacheMaps[`${e}Map`] = maps[0][`${e}Map`] || this._cacheMaps[`${e}Map`];
            });
            return this;
        }
        return this._cacheMaps;
    }

    /**
     * Used to set the layer config from outside or get current layer info
     *
     * @param {Object} type configuration of layer provided externally
     * @return {Object} either the layer or current instance
     * @memberof MatrixResolver
     */
    axes (...axes) {
        if (axes.length) {
            this._axes = Object.assign({}, this._axes, axes[0]);
            return this;
        }
        return this._axes;
    }

    facets (...facets) {
        if (facets.length) {
            Object.entries(facets[0]).forEach((e) => {
                this._facets[e[0]] = e[1];
            });
            return this;
        }
        return this._facets;
    }

    projections (...projections) {
        if (projections.length) {
            Object.entries(projections[0]).forEach((e) => {
                this._projections[e[0]] = e[1];
            });
            return this;
        }
        return this._projections;
    }

    optionalProjections (config, layerConfig) {
        const otherEncodings = {};
        const optionalProjections = [];
        const otherEncodingTypes = [_enums_constants__WEBPACK_IMPORTED_MODULE_2__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["SHAPE"]];

        otherEncodingTypes.forEach((type) => {
            if (config[type] && config[type].field) {
                const enc = config[type];
                otherEncodings[type] = enc.field;
                optionalProjections.push(enc.field);
            }
        });

        if (config[_enums_constants__WEBPACK_IMPORTED_MODULE_2__["DETAIL"]]) {
            optionalProjections.push(...config.detail);
        }

        if (layerConfig.length) {
            layerConfig.forEach((layer) => {
                if (layer.encoding) {
                    Object.values(layer.encoding).forEach((enc) => {
                        if (enc && optionalProjections.indexOf(enc.field) === -1) {
                            optionalProjections.push(enc.field ? enc.field : enc);
                        }
                    });
                }
            });
        }
        this.projections({ optionalProjections });
        return otherEncodings;
    }

    /**
     * return the normalized set of rows and facets and projections
     *
     * @param {Object} rows parameters needed to set horizontal axis consisiting of rows
     * @return {Object} facets, projections and normalized rows
     * @memberof MatrixResolver
     */
    horizontalAxis (rows, encoder) {
        if (rows) {
            this._horizontalAxis = Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["setFacetsAndProjections"])(this, { type: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["ROW"], fields: rows }, encoder);
            return this;
        }
        return this._horizontalAxis;
    }

    /**
     * return the normalized set of columns and facets and projections
     *
     * @param {Object} columns parameters needed to set vertical axis consisiting of columns
     * @return {Object} facets, projections and normalized columns
     * @memberof MatrixResolver
     */
    verticalAxis (columns, encoder) {
        if (columns) {
            this._verticalAxis = Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["setFacetsAndProjections"])(this, { type: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["COL"], fields: columns }, encoder);
            return this;
        }
        return this._verticalAxis;
    }

    /**
     * Gets the class definition of a particular cell type(if the particular type has been extended, that particular
     * definition is returned)
     *
     * @param {Object} cell cell whose class definition is to be retrieved
     * @return {Object} cell definition
     * @memberof MatrixResolver
     */
    getCellDef (cell) {
        const registry = this.registry().cells;

        Object.values(registry).forEach((e) => {
            if (e.prototype instanceof cell) {
                cell = e;
            }
        });
        return cell;
    }

    /**
     * return a visual cell creator along with its axis information to be injected to the datamodel creation
     * function
     *
     * @param {Object} GeomCell Type of cell to be created
     * @return {Object} Created cell
     * @memberof MatrixResolver
     */
    valueCellsCreator (context) {
        // reset matrix layers
        this.matrixLayers([]);

        return (datamodel, fieldInfo, facets) => Object(_cell_creator__WEBPACK_IMPORTED_MODULE_3__["createValueCells"])(context, datamodel, fieldInfo, facets);
    }

    /**
     * Callback to be applied on each cell of a matrix of a particular type
     *
     * @param {string} matrixType type of matrix on which callback is to be applied
     * @param {Function} callback function to be applied to each cell
     * @memberof MatrixResolver
     */
    forEach (matrixType, callback) {
        this[matrixType]().forEach((row, rIndex) => {
            row.forEach((col, cIndex) => {
                callback(rIndex, cIndex, col);
            });
        });
    }

    getAllFields () {
        const retObj = this.projections();

        Object.entries(this.facets()).forEach((e) => {
            retObj[e[0]] = e[1];
        });
        return retObj;
    }

    resetSimpleAxes () {
        return this.axes({
            x: new Set(),
            y: new Set(),
            radius: [],
            angle: [],
            angle0: [],
            pie: []
        });
    }

    setFireboltDependencies (prop, deps) {
        Object.assign(this._fireboltDeps, {
            [prop]: deps
        });
        return this;
    }

    /**
     *
     *
     * @param {*} componentRegistry
     * @param {*} config
     * @memberof MatrixResolver
     */
    createUnits (componentRegistry, config) {
        const {
            globalConfig,
            alias,
            coord
        } = config;
        const {
            layerRegistry,
            sideEffectRegistry
        } = componentRegistry;
        const {
            smartlabel: smartLabel,
            lifeCycleManager,
            throwback
        } = this.dependencies();
        const fireboltDeps = this._fireboltDeps;

        // Provide the source for the matrix
        const units = [[]];
        // Setting unit configuration
        const unitConfig = Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["extractUnitConfig"])(globalConfig || {});
        const store = this.store();
        store.lockModel();
        const { VisualUnit } = this.registry();

        this.forEach(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["VALUE_MATRIX"], (i, j, el) => {
            let unit = el.source();
            if (!unit) {
                const namespace = `unit${i}-${j}-${Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])()}`;

                unit = VisualUnit.create({
                    layerRegistry,
                    sideEffectRegistry
                }, {
                    smartLabel,
                    lifeCycleManager,
                    throwback,
                    fireboltDeps
                });
                unit.metaInf({
                    rowIndex: i,
                    colIndex: j,
                    namespace
                });
                unit.store(store);
                unit.coord(coord);
                el.source(unit);
            }
            !units[i] && (units[i] = []);
            units[i][j] = unit;
            unit.parentAlias(alias)
                .valueParser(this.valueParser())
                .coord(coord);
            el.config(unitConfig);
        });
        store.unlockModel();
        lifeCycleManager.notify({ client: units, action: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["INITIALIZED"], formalName: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["UNIT"] });
        return this.units(units);
    }

    /**
     *
     *
     * @param {*} config
     * @memberof MatrixResolver
     */
    setRetinalAxisDomain (config, datamodel, encoders) {
        const {
            color,
            shape,
            size,
            globalConfig
        } = config;
        const groupBy = globalConfig.autoGroupBy;
        const {
            rowFacets,
            colFacets
        } = this.getAllFields();
        const encoding = {
            color,
            shape,
            size
        };
        const facetFields = [...rowFacets.map(e => e.toString()), ...colFacets.map(e => e.toString())];
        const retContext = {
            domains: encoders.simpleEncoder.getRetinalFieldsDomain(datamodel, encoding, facetFields, groupBy),
            axes: this.getRetinalAxes(),
            encoding
        };
        encoders.retinalEncoder.setCommonDomain(retContext);
        return this;
    }

    resetFacetsAndProjections () {
        this._facets = {};
        this._projections = {};
        return this;
    }

    getRetinalAxes () {
        const {
            color,
            shape,
            size
        } = this.axes();

        return {
            color: [...color],
            shape: [...shape],
            size: [...size]
        };
    }

    getSimpleAxes (type) {
        return this.axes()[`${type}`];
    }

    createRetinalAxes (fieldsConfig, config, encoders) {
        const layerConfig = this.layerConfig();
        this.optionalProjections(config, layerConfig);
        const retinalAxes = encoders.retinalEncoder.createAxis({
            fieldsConfig,
            config,
            axes: this.axes()
        });

        this.axes(retinalAxes);

        this.updateVisualUnit(config);

        return this;
    }

    createHeaders (placeholders, fieldNames, config) {
        let bottomLeft = [];
        let bottomRight = [];
        const {
            rows,
            columns
        } = placeholders;
        const {
            smartlabel: labelManager,
            lifeCycleManager
        } = this.dependencies();
        const {
            showHeaders,
            classPrefix
        } = config;
        const { TextCell, BlankCell } = this.registry().cells;
        const [leftRows, rightRows] = rows;
        const [topCols, bottomCols] = columns;
        const rowHeaders = fieldNames.rows;
        const blankCellCreator = cell => new BlankCell().config({ show: cell.config().show });

        // Headers and footers are created based on the rows. Thereafter, using the column information
        // they are tabularized into the current structure
        const headers = {
            left: Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["headerCreator"])(leftRows, rowHeaders[0], showHeaders ? TextCell : BlankCell,
                { classPrefix, labelManager }),
            right: Object(_group_utils__WEBPACK_IMPORTED_MODULE_1__["headerCreator"])(rightRows, rowHeaders[1], showHeaders ? TextCell : BlankCell,
                { classPrefix, labelManager })
        };
        const footers = {
            left: leftRows.length > 0 ? leftRows[0].map(blankCellCreator) : [],
            right: rightRows.length > 0 ? rightRows[0].map(blankCellCreator) : []
        };
        const [topLeft, topRight] = [_enums_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"]].map(type => topCols.map((col, i) => {
            if (i === topCols.length - 1) {
                return headers[type];
            }
            return footers[type];
        }));

        // Creating only bottom matrices if there is no information on the top
        if (topCols.length === 0) {
            [bottomLeft, bottomRight] = [_enums_constants__WEBPACK_IMPORTED_MODULE_2__["LEFT"], _enums_constants__WEBPACK_IMPORTED_MODULE_2__["RIGHT"]].map(type => bottomCols.map((col, i) => {
                if (i === 0) {
                    return headers[type];
                }
                return footers[type];
            }));
        } else {
            bottomLeft = bottomCols.map(() => (leftRows.length > 0 ? leftRows[0].map(blankCellCreator) : []));
            bottomRight = bottomCols.map(() => (rightRows.length > 0 ? rightRows[0].map(blankCellCreator) : []));
        }

        lifeCycleManager.notify({
            client: [topLeft, topRight, bottomLeft, bottomRight],
            action: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["INITIALIZED"],
            formalName: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["FACET_HEADERS"]
        });

        return { topLeft, topRight, bottomLeft, bottomRight };
    }

    updateVisualUnit (retinalConfig) {
        const retinalAxes = this.getRetinalAxes();

        const { lifeCycleManager } = this.dependencies();
        lifeCycleManager.notify({ client: this.axes(), action: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["INITIALIZED"], formalName: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["AXIS"] });
        lifeCycleManager.notify({ client: this.units(), action: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BEFORE_UPDATE"], formalName: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["UNIT"] });

        const units = [];
        const matrixLayers = this.matrixLayers();

        const props = [`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE}.domain`,
            `${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].UNIT_GLOBAL_NAMESPACE}.domain`];
        const store = this.store();
        store.lockCommits(props);
        store.lockModel();

        this.forEach(_enums_constants__WEBPACK_IMPORTED_MODULE_2__["VALUE_MATRIX"], (i, j, el) => {
            el.axes(Object.assign(el.axes(), retinalAxes));
            el.source() && el.source().retinalFields(retinalConfig);
            el.layerDef(matrixLayers[i][j]);
            el.updateModel();

            units.push(el.source());
        });

        store.unlockModel()
            .unlockCommits([props[0]])
            .unlockCommits([props[1]]);
        lifeCycleManager.notify({ client: units, action: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["UPDATED"], formalName: _enums_constants__WEBPACK_IMPORTED_MODULE_2__["UNIT"] });
        return this;
    }

    getMatrices (datamodel, config, componentRegistry, encoders) {
        const context = {
            datamodel,
            componentRegistry,
            encoders,
            resolver: this
        };

        this._placeholderInfo = Object(_cell_creator__WEBPACK_IMPORTED_MODULE_3__["computeMatrices"])(context, config);

        return this._placeholderInfo;
    }

    clear () {
        const cacheMaps = this._cacheMaps;

        for (const key in cacheMaps) {
            cacheMaps[key].clear();
        }
    }

}


/***/ }),

/***/ "./packages/visual-group/src/group-helper/resolver-props.js":
/*!******************************************************************!*\
  !*** ./packages/visual-group/src/group-helper/resolver-props.js ***!
  \******************************************************************/
/*! exports provided: RESOLVER_PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVER_PROPS", function() { return RESOLVER_PROPS; });
const RESOLVER_PROPS = {
    dependencies: {},
    units: {},
    datamodelTransform: {},
    layerConfig: {},
    matrixLayers: {},
    colCells: {},
    rowCells: {},
    rowMatrix: {},
    columnMatrix: {},
    valueMatrix: {},
    encoder: {},
    valueParser: {},
    data: {},
    transformedData: {},
    store: {}
};


/***/ }),

/***/ "./packages/visual-group/src/index.js":
/*!********************************************!*\
  !*** ./packages/visual-group/src/index.js ***!
  \********************************************/
/*! exports provided: VisualGroup, SimpleGroup, ComposedVars, SimpleVariable, ValueMatrix, Encoders, encoderHelpers, groupUtils, enums */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encoder */ "./packages/visual-group/src/encoder/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Encoders", function() { return _encoder__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _encoder_encoder_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encoder/encoder-helper */ "./packages/visual-group/src/encoder/encoder-helper.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "encoderHelpers", function() { return _encoder_encoder_helper__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _group_helper_group_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./group-helper/group-utils */ "./packages/visual-group/src/group-helper/group-utils.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "groupUtils", function() { return _group_helper_group_utils__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-group/src/enums/constants.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "enums", function() { return _enums_constants__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _visual_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./visual-group */ "./packages/visual-group/src/visual-group/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisualGroup", function() { return _visual_group__WEBPACK_IMPORTED_MODULE_4__["VisualGroup"]; });

/* harmony import */ var _simple_group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simple-group */ "./packages/visual-group/src/simple-group/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleGroup", function() { return _simple_group__WEBPACK_IMPORTED_MODULE_5__["SimpleGroup"]; });

/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./variable */ "./packages/visual-group/src/variable/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposedVars", function() { return _variable__WEBPACK_IMPORTED_MODULE_6__["ComposedVars"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleVariable", function() { return _variable__WEBPACK_IMPORTED_MODULE_6__["SimpleVariable"]; });

/* harmony import */ var _visual_group_value_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./visual-group/value-matrix */ "./packages/visual-group/src/visual-group/value-matrix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ValueMatrix", function() { return _visual_group_value_matrix__WEBPACK_IMPORTED_MODULE_7__["default"]; });












/***/ }),

/***/ "./packages/visual-group/src/simple-group/index.js":
/*!*********************************************************!*\
  !*** ./packages/visual-group/src/simple-group/index.js ***!
  \*********************************************************/
/*! exports provided: SimpleGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _simple_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-group */ "./packages/visual-group/src/simple-group/simple-group.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleGroup", function() { return _simple_group__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/visual-group/src/simple-group/simple-group.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/simple-group/simple-group.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * Interfaces for VisualGroup. Any new VisualGroup has to implement this class.
 * @class  SimpleGroup
 */
class SimpleGroup {

    /**
     * This method is used to set or get the DataModel instance.
     *
     * @param {DataModel | undefined} dataModel Instance of datamodel.

     * @memberof  SimpleGroup
     */
    data () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * This method is used to set or get the group specific configuration
     * properties
     *
     * @param {Object | undefined} configObj The input configuration.
     *                                or instance of visual group.
     * @memberof  SimpleGroup
     */
    config () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * This method is used to return a serialized representation of the
     * instance's properties.
     *
     * @memberof  SimpleGroup
     */
    serialize () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * This method is used to get or set the measurement object which houses
     * layout properties like width and height.
     *
     * @param {Object  | undefined} mObj The measurement properties.
     * @memberof  SimpleGroup
     */
    measurement () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleGroup);


/***/ }),

/***/ "./packages/visual-group/src/variable/composed-vars.js":
/*!*************************************************************!*\
  !*** ./packages/visual-group/src/variable/composed-vars.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variable */ "./packages/visual-group/src/variable/variable.js");


/**
 * This is a wrapper on top of multiple variables which are of same type but they are shown in the same axis.This is
 * required in case of range plots or ohlc plots where one plot is mapped to multiple measure fields. At that time,
 * we need to create a composed variable from multiple variables. This class just wraps them into one variable instance
 * and provides methods to get the type and other common functionalities which can be performed on a simple variable
 * instance.
 *
 * @public
 * @class ComposeVars
 */
class ComposedVars extends _variable__WEBPACK_IMPORTED_MODULE_0__["default"] {

    /**
     * Creates an instance of ComposeVars.
     *
     * @param {Array} vars Array of SimpleVars.
     */
    constructor (...vars) {
        super();
        this.vars(vars);
    }

    vars (...params) {
        if (params.length) {
            this._vars = params[0];
            return this;
        }
        return this._vars;
    }

    data (...dm) {
        if (dm.length) {
            this.vars().forEach(d => d.data(dm[0]));
            this._data = dm[0];
            return this;
        }
        return this._data;
    }

    /**
     * Get all the field names from composed variable instance.
     *
     * @public
     * @return {Array} Array of field names.
     */
    getMembers () {
        const vars = this.vars();
        return vars.map(member => member.getMembers()[0]);
    }

    /**
     * Type of field associated with this composed variable.
     *
     * @return {string} Type of variable (Measure/Dimension).
     */
    type () {
        return this.vars()[0].type();
    }

    toString () {
        return this.vars().map(d => d.toString()).join(',');
    }

    /**
     * Returns the number formatter function of the variable.
     *
     * @return {Function} Number formatter function of the variable.
     */
    numberFormat () {
        return this.vars()[0].numberFormat();
    }

    format (values) {
        return this.vars()[0].format(values);
    }

    getSchemaDef () {
        return this.data().getFieldsConfig()[this.vars()[0]].def;
    }

    /**
     * Returns the subtype of the fields associated with this variable instance.
     *
     * @public
     * @return {string} Subtype of the variable.
     */
    subtype () {
        return this.vars()[0].subtype();
    }

    /**
     * Returns the consecutive minimum difference of the field values.
     *
     * @public
     * @return {number} Minimum consecutive difference.
     */
    getMinDiff () {
        return this.vars()[0].getMinDiff();
    }

    /**
     * Returns the display name of the fields.
     *
     * @return {string} returns the display name.
     */
    displayName () {
        return this.vars().map(d => d.displayName()).join(',');
    }
}

/* harmony default export */ __webpack_exports__["default"] = (ComposedVars);


/***/ }),

/***/ "./packages/visual-group/src/variable/index.js":
/*!*****************************************************!*\
  !*** ./packages/visual-group/src/variable/index.js ***!
  \*****************************************************/
/*! exports provided: ComposedVars, SimpleVariable, Variable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _composed_vars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./composed-vars */ "./packages/visual-group/src/variable/composed-vars.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComposedVars", function() { return _composed_vars__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _simple_var__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-var */ "./packages/visual-group/src/variable/simple-var.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleVariable", function() { return _simple_var__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variable */ "./packages/visual-group/src/variable/variable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return _variable__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./packages/visual-group/src/variable/simple-var.js":
/*!**********************************************************!*\
  !*** ./packages/visual-group/src/variable/simple-var.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SimpleVariable; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _variable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./variable */ "./packages/visual-group/src/variable/variable.js");



/**
 * This is a wrapper on top of fields passed in rows or columns in canvas. This is used to get the type of field or
 * get min difference from the field values.
 *
 * @public
 * @class SimpleVariable
 */
class SimpleVariable extends _variable__WEBPACK_IMPORTED_MODULE_1__["default"] {

    /**
     * Creates an instance of simple variable instance.
     *
     * @param {string} name Field name.
     */
    constructor (name) {
        super();
        this.oneVar(name);
    }

    /**
     * Gets the field name associated with this variable instance.
     *
     * @public
     * @return {string} Name of the field.
     */
    oneVar (...oneV) {
        if (oneV.length) {
            this._oneVar = oneV[0];
            return this;
        }
        return this._oneVar;
    }

    data (...dm) {
        if (dm.length) {
            this._data = dm[0];
            return this;
        }
        return this._data;
    }

    toString () {
        return this.oneVar();
    }

    /**
     * Gets the number formatter function of this variable.
     *
     * @public
     * @return {Function} Number formatter function.
     */
    numberFormat () {
        if (this.type() === 'measure') {
            const formatter = this.data().getFieldspace().getMeasure()[this.oneVar()];
            return formatter.numberFormat();
        } return val => val;
    }

    format (values) {
        if (values && this.subtype() === 'temporal') {
            const formatter = this.data().getFieldspace().getDimension()[this.oneVar()].schema().format;
            const dtFormat = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DateTimeFormatter"](formatter);
            values = values.map(e => dtFormat.getNativeDate(e));
        }
        return values;
    }

    /**
     * Returns a formatter function which transforms the input value to its original form.
     *
     * @public
     * @return {Function} Returns raw formatter function.
     */
    rawFormat () {
        if (this.subtype() === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
            const dateFormat = this.data().getFieldspace().getDimension()[this.oneVar()].schema().format;
            return val => muze_utils__WEBPACK_IMPORTED_MODULE_0__["DateTimeFormatter"].formatAs(val, dateFormat);
        }
        return val => val;
    }

    /**
     * Return the field names associated with this variable instance.
     *
     * @public
     * @return {Array} Array of fields.
     */
    getMembers () {
        return [this.oneVar()];
    }

    /**
     * Returns the type of the variable. Whether it is measure or dimension.
     *
     * @public
     * @return {string} Type of variable.
     */
    type () {
        const fieldDef = this.data().getFieldsConfig()[this.oneVar()].def;
        return fieldDef.type;
    }

    /**
     * Returns the subtype of the variable. Subtype can be categorical or temporal. If no subtype is found, then it
     * returns the type of the variable.
     *
     * @public
     * @return {string} Subtype of variable.
     */
    subtype () {
        const fieldDef = this.data().getFieldsConfig()[this.oneVar()].def;
        return fieldDef.subtype || fieldDef.type;
    }

    /**
     * Returns the minimum consecutive difference between the data values of this variable.
     *
     * @return {number} Minimum consecutive difference.
     */
    getMinDiff () {
        const fieldSpace = this.data().getFieldspace();
        return fieldSpace.fieldsObj()[this.oneVar()].minimumConsecutiveDifference();
    }

    /**
     * Returns true if two variable instances are same.If both variable has the same field names, they are equal.
     *
     * @return {Boolean} Whether two variable instances are same.
     */
    equals (varInst) {
        return this.oneVar() === varInst.oneVar();
    }

    /**
     * Returns the display name of the field.
     *
     * @return {string} returns the display name.
     */
    displayName () {
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveFieldDisplayName"])(this.data(), this.oneVar());
    }

    /**
     * Returns the schema defination of the field.
     *
     * @return {Object} schema def
     */
    getSchemaDef () {
        return this.data().getFieldsConfig()[this.oneVar()].def;
    }
}


/***/ }),

/***/ "./packages/visual-group/src/variable/variable.js":
/*!********************************************************!*\
  !*** ./packages/visual-group/src/variable/variable.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Variable; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 *
 *
 * @export
 * @class Variable
 */
class Variable {

    /**
     *
     *
     * @memberof Variable
     */
    type () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     *
     *
     * @memberof Variable
     */
    toString () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

}


/***/ }),

/***/ "./packages/visual-group/src/visual-group/change-listener.js":
/*!*******************************************************************!*\
  !*** ./packages/visual-group/src/visual-group/change-listener.js ***!
  \*******************************************************************/
/*! exports provided: setupChangeListeners, registerDomainChangeListener, unsubscribeChangeListeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupChangeListeners", function() { return setupChangeListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerDomainChangeListener", function() { return registerDomainChangeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsubscribeChangeListeners", function() { return unsubscribeChangeListeners; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const setupChangeListeners = (context) => {
    const store = context.store();
    const stores = {
        throwback: context._dependencies.throwback,
        store
    };

    ['x', 'y'].forEach((axisType) => {
        store.registerChangeListener([`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE}.domain.${axisType}`], () => {
            const groupAxes = context.resolver().axes();
            groupAxes[axisType].forEach(axes => axes.forEach((axis) => {
                axis.render();
            }));
        });
    });
    const { VisualUnit, layerRegistry } = context.registry();
    const { base: BaseLayer } = layerRegistry;
    [VisualUnit, BaseLayer].forEach((comp) => {
        const formalName = comp.formalName();
        ['store', 'throwback'].forEach((type) => {
            const listeners = comp.getListeners()[type];
            const storeInst = stores[type];
            listeners.forEach((listenerInf) => {
                storeInst[listenerInf.type](listenerInf.props, listenerInf.listener, false, {
                    namespace: formalName,
                    subNamespace: listenerInf.subNamespace
                });
            });
        });
    });
};

const registerDomainChangeListener = (context) => {
    const store = context.store();
    store.registerChangeListener([`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].UNIT_GLOBAL_NAMESPACE}.domain`], () => {
        context.resolver().encoder().unionUnitDomains(context);
    }, false, {
        key: 'unionDomain'
    });
};

const unsubscribeChangeListeners = (context) => {
    context.store().unsubscribe({
        key: 'unionDomain'
    });
};


/***/ }),

/***/ "./packages/visual-group/src/visual-group/helper.js":
/*!**********************************************************!*\
  !*** ./packages/visual-group/src/visual-group/helper.js ***!
  \**********************************************************/
/*! exports provided: createUnitState, initializeGlobalState, createLayerState, setMatrixInstances, createMatrices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createUnitState", function() { return createUnitState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeGlobalState", function() { return initializeGlobalState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLayerState", function() { return createLayerState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixInstances", function() { return setMatrixInstances; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMatrices", function() { return createMatrices; });
/* harmony import */ var _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-unit */ "./packages/visual-unit/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _group_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../group-helper */ "./packages/visual-group/src/group-helper/index.js");
/* harmony import */ var _encoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../encoder */ "./packages/visual-group/src/encoder/index.js");
/* harmony import */ var _change_listener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./change-listener */ "./packages/visual-group/src/visual-group/change-listener.js");
/* harmony import */ var _value_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./value-matrix */ "./packages/visual-group/src/visual-group/value-matrix.js");








const createUnitState = (context) => {
    const [globalState, localState] = _chartshq_visual_unit__WEBPACK_IMPORTED_MODULE_0__["VisualUnit"].getState();
    const store = context.store();
    store.append(muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_GLOBAL_NAMESPACE, globalState)
        .append(muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_LOCAL_NAMESPACE, localState);
};

const initializeGlobalState = (context) => {
    const globalState = context.constructor.getState()[0];
    const store = context.store();
    store.append(muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE, globalState);
};

const createLayerState = (context) => {
    const [globalState, localState] = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayer"].getState();
    context.store().append(muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE, globalState)
        .append(muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].LAYER_LOCAL_NAMESPACE, localState);
};

const sanitizeRetinalConfig = (retinalConf) => {
    const conf = {};
    for (const key in retinalConf) {
        const confValue = retinalConf[key];
        if (typeof confValue === 'string' || !confValue) {
            conf[key] = {
                field: retinalConf[key]
            };
        } else {
            conf[key] = confValue;
        }
    }
    return conf;
};

const setMatrixInstances = (context, placeholder) => {
    let {
        values,
        rows,
        columns
    } = placeholder;
    values = values || [];
    rows = rows || [];
    columns = columns || [];
    context._composition.matrices = {
        value: new _value_matrix__WEBPACK_IMPORTED_MODULE_6__["default"](values),
        left: new _value_matrix__WEBPACK_IMPORTED_MODULE_6__["default"](rows[0]),
        right: new _value_matrix__WEBPACK_IMPORTED_MODULE_6__["default"](rows[1]),
        top: new _value_matrix__WEBPACK_IMPORTED_MODULE_6__["default"](columns[0]),
        bottom: new _value_matrix__WEBPACK_IMPORTED_MODULE_6__["default"](columns[1])
    };

    context._dependencies.throwback.commit(muze_utils__WEBPACK_IMPORTED_MODULE_1__["CommonProps"].MATRIX_CREATED, true);
    return context;
};

const createMatrices = (context) => {
    const rows = context.rows();
    const columns = context.columns();
    const color = context.color();
    const datamodel = context.data();
    const size = context.size();
    const detail = context.detail();
    const layers = context.layers();
    const transform = context.transform();
    const config = context.config();
    const shape = context.shape();

    // Get the resolver for the matrices
    const resolver = context.resolver();
    resolver.store(context.store());
    resolver.valueParser(context.valueParser());
    // Prepare configuration for matrix preparation
    let matrixConfig = {
        selection: context.selection(),
        alias: context.alias(),
        globalConfig: config || {},
        rows,
        columns,
        detail,
        layers,
        transform
    };

    Object(_change_listener__WEBPACK_IMPORTED_MODULE_5__["unsubscribeChangeListeners"])(context);

    const retinalConfig = sanitizeRetinalConfig({
        color,
        shape,
        size
    });

    matrixConfig = Object.assign(matrixConfig, retinalConfig);
    // Create the encoders for the group
    const encoders = {};
    encoders.retinalEncoder = new _encoder__WEBPACK_IMPORTED_MODULE_4__["RetinalEncoder"]();
    encoders.simpleEncoder = context.createEncoderInstance();
    matrixConfig.coord = encoders.simpleEncoder.constructor.type();
    resolver.encoder(encoders.simpleEncoder);

    // Set the group type
    context.groupType(encoders.simpleEncoder.constructor.type());

    // Get sanitized fields as instances of the Vars Class
    const fields = encoders.simpleEncoder.fieldSanitizer(datamodel, matrixConfig);
    encoders.simpleEncoder.setAxisAndHeaders(config ? config.axisFrom : {}, fields);
    // Setting layers for the code
    layers && resolver.layerConfig(layers);
    // Set the row and column axes
    resolver.horizontalAxis(fields.rows, encoders).verticalAxis(fields.columns, encoders);
    // Getting the placeholders
    const placeholderInfo = resolver.getMatrices(datamodel, matrixConfig, context.registry(), encoders);
    context._groupedDataModel = placeholderInfo.dataModels.groupedModel;
    // Set the selection object
    context.selection(placeholderInfo.selection);

    // Create retinal axes
    resolver.createRetinalAxes(placeholderInfo.dataModels.parentModel.getFieldsConfig(), retinalConfig,
            encoders);

    // Domains are evaluated for each of the axes for commonality
    resolver.setRetinalAxisDomain(matrixConfig, placeholderInfo.dataModels, encoders);

    // Create matrix instances
    setMatrixInstances(context, placeholderInfo);

    // Prepare corner matrices
    context.cornerMatrices(resolver.createHeaders(placeholderInfo, fields, config));

    // Set placeholder information
    context.placeholderInfo(placeholderInfo);

    context._composition.axes = resolver.axes();
    context.metaData({
        border: Object(_group_helper__WEBPACK_IMPORTED_MODULE_3__["getBorders"])(placeholderInfo, encoders.simpleEncoder)
    });

    resolver.encoder().unionUnitDomains(context);

    Object(_change_listener__WEBPACK_IMPORTED_MODULE_5__["registerDomainChangeListener"])(context);
    return context;
};


/***/ }),

/***/ "./packages/visual-group/src/visual-group/index.js":
/*!*********************************************************!*\
  !*** ./packages/visual-group/src/visual-group/index.js ***!
  \*********************************************************/
/*! exports provided: VisualGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _visual_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visual-group */ "./packages/visual-group/src/visual-group/visual-group.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisualGroup", function() { return _visual_group__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/visual-group/src/visual-group/local-options.js":
/*!*****************************************************************!*\
  !*** ./packages/visual-group/src/visual-group/local-options.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");


/**
 * This is the local options semantics based on which setters getters are created and reactivity is initiated.
 * This local object is only valid for Artboard.
 * Artboard merges global and local object both to the model
 *
 * Format
 *  PROPERTRY_NAME: {
 *      value: // default value of the property,
 *      meta: {
 *          typeCheck: // The setter value will be checked using this. If the value is function then the setter value
 *                     // is passed as args.
 *          typeExpected: // The output of typecheck action will be tested against this. Truthy value will set the
 *                       // value to the setter
 *          sanitizaiton: // Need for sanitization before type is checked
 *      }
 *  }
 *
 * @module
 */

/* harmony default export */ __webpack_exports__["default"] = ({
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CONFIG"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROWS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMNS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLOR"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SIZE"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["DETAIL"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LAYERS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TRANSFORM"]]: {}
});


/***/ }),

/***/ "./packages/visual-group/src/visual-group/props.js":
/*!*********************************************************!*\
  !*** ./packages/visual-group/src/visual-group/props.js ***!
  \*********************************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");


const PROPS = {
    alias: {},
    data: {},
    cornerMatrices: {
        defaultValue: {
            topLeft: [],
            topRight: [],
            bottomLeft: [],
            bottomRight: []
        }
    },
    groupType: {},

    metaData: {
        defaultValue: {
            border: {}
        }
    },
    placeholderInfo: {
        defaultValue: {}
    },
    resolver: {},
    valueParser: {
        defaultValue: val => val
    },
    registry: {
        sanitization: (context, value) => {
            if (context.resolver) {
                context.resolver().registry({
                    cells: value.cellRegistry,
                    VisualUnit: value.VisualUnit
                });
            }
            return value;
        }
    },
    selection: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CONFIG"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["ROWS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLUMNS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["COLOR"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SHAPE"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["SIZE"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["DETAIL"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["LAYERS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_0__["TRANSFORM"]]: {}
};


/***/ }),

/***/ "./packages/visual-group/src/visual-group/value-matrix.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/visual-group/value-matrix.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * This is a wrapper class over the matrix of cells which gets created in visual group. Visual Group creates left,
 * right, bottom and top and center matrices and wraps them using this class.
 *
 * @public
 * @class ValueMatrix
 */
class ValueMatrix {

    /**
     * Creates an instance of ValueMatrix.
     *
     * @param {Array} matrixArr Matrix array.
     */
    constructor (matrixArr) {
        const instancesById = {};

        this.matrix(matrixArr || []);
        this.filter(() => true);

        this.each((el, rIdx, cIdx) => {
            const cellValue = el.valueOf();
            if (cellValue && cellValue.id) {
                const id = cellValue.id();
                instancesById[id] = {
                    instance: cellValue,
                    rowIndex: rIdx,
                    colIndex: cIdx
                };
            }
        });

        this.instancesById(instancesById);
    }

    instancesById (...id) {
        if (id.length) {
            this._instancesById = id[0];
            return this;
        }
        return this._instancesById;
    }

    /**
     * Returns the array of matrices contained in this instance.
     *
     * @public
     * @return {Array} Array of matrices.
     */
    matrix (...matrix) {
        if (matrix.length) {
            this._matrix = matrix[0];
            return this;
        }
        return this._matrix;
    }

    /**
     * Sets a filter criteria. This filter criteria gets applied when each function is called.
     *
     * @public
     * @param {Function} fn Filter function.
     *
     * @return {ValueMatrix} Instance of value matrix.
     */
    filter (...fn) {
        if (fn.length) {
            this._filterFn = fn[0];
            return this;
        }
        return this._filterFn;
    }

    /**
     * Returns the total width occupied by all the cells of the matrix.
     *
     * @return {Number} Width of the matrix.
     */
    width () {
        let rowWidth = 0;

        this.matrix().forEach((row) => {
            let currentRowWidth = 0;
            row.forEach((cell) => {
                currentRowWidth += cell.getLogicalSpace().width;
            });
            rowWidth = Math.max(rowWidth, currentRowWidth);
        });
        return rowWidth;
    }

    /**
     * Returns the total width occupied by all the cells of the matrix.
     *
     * @return {Number} Width of the matrix.
     */
    height () {
        let rowHeight = 0;

        this.matrix().forEach((row) => {
            let currentRowHeight = 0;
            row.forEach((cell) => {
                currentRowHeight = Math.max(currentRowHeight, cell.getLogicalSpace().height);
            });
            rowHeight += currentRowHeight;
        });
        return rowHeight;
    }

    /**
     * Iterates through the two dimensional matrix array and calls the given callback function with the cell instance,
     * row index, column index and the matrix array.
     *
     * @param {Function} fn Callback function which will get called for every cell.
     * @return {ValueMatrix} Instance of the value matrix.
     */
    each (fn) {
        const matrix = this.matrix();
        const filterFn = this.filter();

        matrix.forEach((row, rIndex) => {
            row.forEach((col, cIndex) => {
                if (filterFn(col)) {
                    fn(col, rIndex, cIndex, matrix);
                }
            });
        });
        return this;
    }

    findPlaceHolderById (id) {
        return this.instancesById()[id];
    }

    clear () {
        this.each(cell => cell.remove());
        this.matrix([]);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (ValueMatrix);


/***/ }),

/***/ "./packages/visual-group/src/visual-group/visual-group.js":
/*!****************************************************************!*\
  !*** ./packages/visual-group/src/visual-group/visual-group.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _local_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./local-options */ "./packages/visual-group/src/visual-group/local-options.js");
/* harmony import */ var _simple_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../simple-group */ "./packages/visual-group/src/simple-group/index.js");
/* harmony import */ var _group_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../group-helper */ "./packages/visual-group/src/group-helper/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper */ "./packages/visual-group/src/visual-group/helper.js");
/* harmony import */ var _change_listener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./change-listener */ "./packages/visual-group/src/visual-group/change-listener.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./props */ "./packages/visual-group/src/visual-group/props.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-group/src/enums/constants.js");









/**
 * VisualGroup is instantiated by canvas for creating {@link VisualUnit} and axes instances.It creates the
 * the matrix of visual units and axes. It also creates the layout instance which manages the allocation
 * of space of matrices.
 *
 * To get instance of visual group,
 * ```
 *      const visualGroup = canvas.composition().visualGroup;
 * ```
 * @public
 *
 * @class VisualGroup
 */
class VisualGroup extends _simple_group__WEBPACK_IMPORTED_MODULE_2__["SimpleGroup"] {

    /**
     * Creates an instance of VisualGroup. Requires dependencies and other registry options for placeholders
     * and layers that create individual units.
     *
     * @param {Object} registry Key value pair of compostions for the group
     * @param {Object} dependencies Dependencies needed to run the group
     * @memberof VisualGroup
     */
    constructor (registry, dependencies) {
        super();

        const {
            components,
            componentSubRegistry
        } = registry;

        this._dependencies = dependencies;
        // Generate getter/setter methods for all properties of the class
        // One can get each property by calling the method and can set it
        // by passing paramaters for the same. Thus, one can chain setter
        // getter methods.
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, this.constructor.getterSetters());
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, this.constructor.localOptions());
        // Populate the store with default values
        // initialize group compositions
        this._composition = {};
        // store reference to data
        this._data = [];
        // store reference to mountpoint
        this._mount = null;
        // selection object that takes care of updating of components
        this._selection = {};
        // Create instance of matrix resolver
        this.createMatrixResolver();
        // matrix instance store each of the matrices
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["setMatrixInstances"])(this, {});
         // Getting indiviual registered items
        this.registry({
            layerRegistry: componentSubRegistry.layerRegistry.get(),
            cellRegistry: componentSubRegistry.cellRegistry.get(),
            VisualUnit: components.VisualUnit
        });
    }

    static getState () {
        return [{
            domain: {
                x: null,
                y: null,
                radius: null,
                angle: null,
                angle0: null
            }
        }, {}];
    }

    store (...params) {
        if (params.length) {
            this._store = params[0];
            Object(_helper__WEBPACK_IMPORTED_MODULE_4__["initializeGlobalState"])(this);
            Object(_helper__WEBPACK_IMPORTED_MODULE_4__["createUnitState"])(this);
            Object(_helper__WEBPACK_IMPORTED_MODULE_4__["createLayerState"])(this);
            // Register listeners
            Object(_change_listener__WEBPACK_IMPORTED_MODULE_5__["setupChangeListeners"])(this);
            return this;
        }
        return this._store;
    }

    static formalName () {
        return 'VisualGroup';
    }

    static localOptions () {
        return _local_options__WEBPACK_IMPORTED_MODULE_1__["default"];
    }
    static getterSetters () {
        return _props__WEBPACK_IMPORTED_MODULE_6__["PROPS"];
    }

    /**
     * Return the instances of matrices created by the visual group.
     *
     * @return {Object} Instance of matrices.
     */
    matrixInstance (...matrices) {
        if (matrices.length) {
            return this;
        }
        return this.composition().matrices;
    }

    /**
     * Returns the composition of visual group.
     *
     * @public
     *
     * @return {Object} Composition of visual group. It contains instance of matrices {@link ValueMatrix}
     * and instances of axis.
     * ```
     *          {
     *              matrices: {
     *                  value: // Instance of center value matrix.
     *                  left: // Instance of left value matrix
     *                  right: // Instance of right value matrix
     *                  bottom: // Instance of bottom value matrix
     *                  top: // Instance of top value matrix.
     *              },
     *              axes: {
     *                  x: // Array of x axis.
     *                  y: // Array of y axis
     *                  color: // Array of color axis
     *                  shape: // Array of shape axis
     *                  size: // Array of size axis.
     *              }
     *          }
     * ```
     */
    composition (...params) {
        if (params.length) {
            return this;
        }
        return this._composition;
    }

    /**
     * Locks the model to prevent change listeners to be triggered until unlocked
     *
     * @return {Object} Instance of class VisualGroup
     * @memberof VisualGroup
     */
    lockModel () {
        this.store().model.lock();
        return this;
    }

    /**
     * Unlocks the model so that all change listeners can be triggered
     *
     * @return {Object} Instance of class VisualGroup
     */
    unlockModel () {
        this.store().model.unlock();
        return this;
    }

    /**
     * Returns the channel name of the variable. Channels are rows, columns, color, shape and size.
     *
     * @public
     * @param {string} variable Name of the variable.
     *
     * @return {string} Name of the channel.
     */
    where (variable) {
        return Object(_group_helper__WEBPACK_IMPORTED_MODULE_3__["findInGroup"])(variable, this.resolver().getAllFields());
    }

    /**
     * Gets the axis instances of the visual group based on the given axis type.
     *
     * @public
     * @param {string} type Type of axis. X,Y or retinal axes.
     *
     * @return {Array} Array of axis instances.
     */
    getAxes (type) {
        if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_7__["RETINAL"]) {
            return this.resolver().getRetinalAxes();
        }
        return this.resolver().getSimpleAxes(type);
    }

    /**
     * Returns the instances of cells based on the given type. Type can be given as `row' or `col`.
     *
     * @public
     * @return {Array} Two dimensional array of cells.
     */
    getCells (type) {
        return this.resolver()[`${type}Cells`]();
    }

    getFieldsFromChannel (channel) {
        const {
            rowProjections,
            colProjections
        } = this.resolver().getAllFields();
        return channel === _enums_constants__WEBPACK_IMPORTED_MODULE_7__["Y"] ? rowProjections : colProjections;
    }

    getCellsByFacetKey (facetKey) {
        const resolver = this.resolver();
        const cells = resolver.rowCells()[facetKey] || resolver.colCells()[facetKey] || [];
        return cells;
    }

    getAxesByFacetKey (axisType, facetKey) {
        const resolver = this.resolver();
        const cells = resolver.rowCells()[facetKey] || resolver.colCells()[facetKey];
        const axes = cells[0].valueOf().axes()[axisType] || [];

        return axes;
    }

    /**
     * This method is used to return a serialized representation of the instance's properties.
     *
     * @return {Object} Object with config proprties.
     * @memberof VisualGroup
     */
    serialize () {
        const store = this.store();

        return {
            [_enums_constants__WEBPACK_IMPORTED_MODULE_7__["CONFIG"]]: store.get(_enums_constants__WEBPACK_IMPORTED_MODULE_7__["CONFIG"]),
            [_enums_constants__WEBPACK_IMPORTED_MODULE_7__["MOUNT"]]: store.get(_enums_constants__WEBPACK_IMPORTED_MODULE_7__["MOUNT"])
        };
    }

    /**
     * Returns the grouped datamodel prepared by visual group. If there is no group by performed, then it returns the
     * original data model passed to visual group.
     *
     * @return {DataModel} Grouped data model.
     */
    getGroupByData () {
        return this._groupedDataModel;
    }

    createMatrices () {
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["createMatrices"])(this);
    }

    remove () {
        this.matrixInstance().value.clear();
        this.resolver().clear();
        const info = this.placeholderInfo();
        info.rows = null;
        info.columns = null;
        info.values = null;
    }

    createEncoderInstance () {
        const layers = this.layers();

        return Object(_group_helper__WEBPACK_IMPORTED_MODULE_3__["getEncoder"])(layers);
    }

    createMatrixResolver () {
        this.resolver(new _group_helper__WEBPACK_IMPORTED_MODULE_3__["MatrixResolver"](this._dependencies));

        return this;
    }
}

/* harmony default export */ __webpack_exports__["default"] = (VisualGroup);


/***/ }),

/***/ "./packages/visual-layer/src/base-layer/base-layer.js":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/base-layer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _simple_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../simple-layer */ "./packages/visual-layer/src/simple-layer/index.js");
/* harmony import */ var _base_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-mixin */ "./packages/visual-layer/src/base-layer/base-mixin.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-layer/src/enums/constants.js");





/**
 * An abstract class which gives definition of common layer functionality like
 * - transforming data for various modes. Supported modes: identity, group and stack.
 * - calculating data domain
 * - linking dependent layers
 * - merging policy of configuration
 * - interaction sideffect helpers
 * - retrieving dom elements from data using id
 * - retrieving the physical dimensions of marks
 * - disposing layer
 *
 * Every layer has to extend base layer and give concrete definition.
 * This layer does not have any default visual. A new layer has to define the logic of `render` for rendering the
 * visuals
 *
 * @public
 * @class
 * @module BaseLayer
 */
class BaseLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_simple_layer__WEBPACK_IMPORTED_MODULE_1__["SimpleLayer"]).with(_base_mixin__WEBPACK_IMPORTED_MODULE_2__["BaseLayerMixin"]) {
    /**
     * Determines a name for a layer. This name of the layer is used in the input data to refer to this layer.
     * ```
     *  .layers([
     *      mark: 'bar',
     *      encoding: { ... }
     *  ])
     * ```
     *
     * @static
     * @public
     *
     * @return {string} name of layer
     */
    static formalName () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["BASE_LAYER"];
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/base-layer/base-mixin.js":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/base-mixin.js ***!
  \************************************************************/
/*! exports provided: BaseLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseLayerMixin", function() { return BaseLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/props */ "./packages/visual-layer/src/enums/props.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./props */ "./packages/visual-layer/src/base-layer/props.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _local_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./local-options */ "./packages/visual-layer/src/base-layer/local-options.js");
/* harmony import */ var _listener_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./listener-map */ "./packages/visual-layer/src/base-layer/listener-map.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-layer/src/enums/constants.js");








const layerNs = [muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE, muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_LOCAL_NAMESPACE];
const groupNs = muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE;

const BaseLayerMixin = (superclass) => {
    return class extends superclass {

        /**
         * Creates a layer using a configuration and data.
         *
         * @public
         * @constructor
         * @param {DataModel} data Instance of DataModel to be used. This DataModel instance serves as the data for a layer.
         * @param {Object} axes Axes instances to be used for rendering the layer. Axes are used for mapping data from
         *      value to px.
         * @param {SimpleAxis} axes.x X axis of the layer. Based on the type of variable it gets instance of BandAxis,
         *      TimeAxis, ContinuousAxis
         * @param {SimpleAxis} axes.y X axis of the layer. Based on the type of variable it gets instance of BandAxis,
         *      TimeAxis, ContinuousAxis
         * @param {ColorAxis} axes.color Axis for coloring a layer using color interpolators
         * @param {ShapeAxis} axes.shape Axis for providing a shape
         * @param {SizeAxis} axes.size Axis for determining size of a mark using size interpolator
         * @param {LayerConfig} config Configuration of the layer
         * @param {Object} dependencies Dependencies of the layer
         * @param {SmartLabel} dependencies.smartLabel Smartlabel singleton instance
         */
        constructor () {
            super();

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["generateGetterSetters"])(this, this.constructor.getterSetters());
            this.axes({});
            this.alias(this.constructor.formalName() + Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])());
            this._points = [];
            this._cachedData = [];
            this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getUniqueId"])();
            this._measurement = {};
            this._animationDonePromises = [];
            this._graphicElems = {};
            this._customConfig = null;
        }

        static getState () {
            return [
                {
                    domain: null
                },
                Object.keys(this.localOptions()).reduce((acc, v) => {
                    acc[v] = _local_options__WEBPACK_IMPORTED_MODULE_4__["localOptions"][v].value;
                    return acc;
                }, {})
            ];
        }

        static getListeners () {
            return {
                store: [..._listener_map__WEBPACK_IMPORTED_MODULE_5__["listenerMap"], {
                    type: 'registerChangeListener',
                    props: this.getRenderProps(),
                    listener: (context) => {
                        Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["renderLayer"])(context);
                    },
                    subNamespace: (context) => {
                        const { unitRowIndex, unitColIndex, namespace } = context.metaInf();
                        return {
                            [`${layerNs[1]}.${_enums_props__WEBPACK_IMPORTED_MODULE_1__["DATA"]}`]: namespace,
                            [`${groupNs}.domain.x`]: `${unitColIndex}0`,
                            [`${groupNs}.domain.y`]: `${unitRowIndex}0`,
                            [`${groupNs}.domain.radius`]: `${unitRowIndex}-${unitColIndex}`
                        };
                    }
                }],
                throwback: []
            };
        }

        static getQualifiedStateProps () {
            const layerState = this.getState();
            return layerState.map((state, i) => Object.keys(state).map(prop => `${layerNs[i]}.${prop}`));
        }

        store (...params) {
            if (params.length) {
                const store = this._store = params[0];
                const { namespace } = this.metaInf();
                store.addSubNamespace(namespace, _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BASE_LAYER"], this);

                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["transactor"])(this, this.constructor.localOptions(), store, {
                    subNamespace: namespace,
                    namespace: `${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_LOCAL_NAMESPACE}`
                });
                return this;
            }
            return this._store;
        }

        domain (...dom) {
            const prop = `${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE}.${_enums_props__WEBPACK_IMPORTED_MODULE_1__["DOMAIN"]}`;
            const store = this.store();
            if (dom.length) {
                const { parentNamespace, namespace } = this.metaInf();
                const domain = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(store.get(prop, parentNamespace), {});
                domain[namespace] = dom[0];
                this.store().commit(prop, domain, parentNamespace);
                return this;
            }
            return this.store().get(prop, this.metaInf().namespace);
        }

        /**
         * Creates a layer instance
         * @return {BaseLayer} Instance of a layer
         */
        static create (...params) {
            return new this(...params);
        }

        /**
         * Default configuration of the layer. This configuration gets merged to the user passed configuration using a
         * plolicy. Base layer only returns part of configuraion, any layer overridding base layer should return its own
         * configuration.
         *
         * @public
         * @static
         *
         * @return {Object} Default configuration
         */
        static defaultConfig () {
            return {
                transform: {
                    type: 'identity'
                }
            };
        }

        static getterSetters () {
            return _props__WEBPACK_IMPORTED_MODULE_2__["props"];
        }

        static localOptions () {
            return _local_options__WEBPACK_IMPORTED_MODULE_4__["localOptions"];
        }
        /**
         * Policy defines how user config gets merged to default config. The default policy here does a deep copy
         * operation.
         * Any policy which does more than deep copying should define the policy as a static member.
         *
         * @static
         * @public
         *
         * @param {LayerConfig} conf Configuration with which the user config will be merged
         * @param {LayerConfig} userConf Configuration given by the user
         *
         * @return {LayerConfig} Merged layer configuration
         */
        static defaultPolicy (conf, userConf) {
            return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(conf, userConf);
        }

        /**
         * Provides a alias for a layer. Like it's possible to have same layer (like bar) multiple times, but among multiple
         * layers of same type if one layer has to be referred, alias is used. If no alias is given then `formalName` is set
         * as the alias name.
         *
         *
         * If used as setter
         * @param  {string} alias Name of the alias
         * @return {BaseLayer} Instance of current base layer
         *
         * If used as getter
         * @return {string} Alias of the current layer
         *
         * @public
         */
        alias (...params) {
            if (params.length) {
                this._alias = params[0];
                return this;
            }
            return this._alias || this.constructor.formalName();
        }

        enableCaching () {
            this._cacheEnabled = true;
            return this;
        }

        clearCaching () {
            this._cacheEnabled = false;
            return this.data(this._cachedData[0]);
        }

        /**
         * Serialize the schema. Merge config is used for serialization.
         *
         * @public
         *
         * @return {LayerConfig} Serialized schema
         */
        serialize () {
            return this.config();
        }

        /**
         * Returns the unique identifier of this layer. Id is auto generated during the creation proceess of a schema.
         *
         * @public
         *
         * @return {string} id of the layer
         */
        id () {
            return this._id;
        }

        /**
         * Returns the transformed data based on given transform type.
         * It first gets the transform method from transform factory based on type of transform. It then calls the
         * transform method with the data and passes the configuration parameters of transform such as
         * groupBy, value field, etc.
         *
         * @param {DataModel} dataModel Instance of DataModel
         * @param {Object} config Configuration for transforming data
         * @return {Array.<Array>} Transformed data.
         */
        getTransformedData (dataModel, config, transformType, encodingFieldsInf) {
            return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["transformData"])(dataModel, config, transformType, encodingFieldsInf);
        }

        /**
         * Calculates the domain from the data.
         * It checks the type of field and calculates the domain based on that. For example, if it
         * is a quantitative or temporal field, then it calculates the min and max from the data or
         * if it is a categorical field then it gets all the values from the data of that field.
         * @param {Array} data DataArray
         * @param {Object} fieldsConfig Configuration of fields
         * @return {Array} Domain values array.
         */
        calculateDomainFromData (data) {
            let domains = {};
            const isEmpty = this.data().isEmpty();

            if (!isEmpty) {
                domains = _helpers__WEBPACK_IMPORTED_MODULE_3__["domainCalculator"][this.coord()](data, this);
            }
            return domains;
        }

        static shouldDrawAnchors () {
            return false;
        }

        /**
         * Returns the domain for the axis.
         *
         * @param {string} encodingType type of encoding x, y, etc.
         * @return {Object} Axis domains
         */
        getDataDomain (encodingType) {
            const { parentNamespace, namespace } = this.metaInf();
            const domains = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(this.store()
                .get(`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE}.${_enums_props__WEBPACK_IMPORTED_MODULE_1__["DOMAIN"]}`, parentNamespace), namespace);
            return encodingType !== undefined ? domains[encodingType] || [] : domains;
        }

        /**
         * Normalizes the transformed data and returns it.
         *
         * @param {string} encodingType type of encoding x, y, etc.
         * @return {Object} Axis domains
         */
        getNormalizedData (transformedData) {
            return Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getNormalizedData"])(transformedData, this);
        }

        /**
         * Gets the nearest point closest to the given x and y coordinate. If no nearest point is found, then it returns
         * null.
         *
         * @public
         *
         * @param {number} x X Coordinate.
         * @param {number} y Y Coordinate.
         *
         * @return {Object} Information of the nearest point.
         * ```
         *      {
         *          // id property contains the field names and their corresponding values in a 2d array. This is the data
         *          // associated with the nearest point.
         *          id: // Example data: [['Origin'], ['USA']],
         *          dimensions: // Physical dimensions of the point.
         *          layerId: // Id of the layer instance.
         *      }
         * ```
         */
        getNearestPoint () {
            return null;
        }

        applyInteractionStyle (interactionType, selectionSet, apply, styles) {
            const interactionConfig = this.config().interaction || {};

            let interactionStyles = interactionConfig[interactionType];
            interactionStyles = styles || interactionStyles;
            if (interactionStyles) {
                Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["applyInteractionStyle"])(this, selectionSet, interactionStyles, {
                    apply,
                    interactionType
                });
            }
        }

        resolveTransformType () {
            this._transformType = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getValidTransform"])(this);
        }

        transformType () {
            return this._transformType;
        }

        /**
         * Renders the layer
         * @return {BaseLayer} Instance of the layer.
         */
        render () {
            return this;
        }

        elemType () {
            return 'g';
        }

        /**
         * Disposes the entire layer.
         *
         * @return {BaseLayer} Instance of layer.
         */
        remove () {
            const { namespace, parentNamespace } = this.metaInf();
            const store = this.store();
            store.removeSubNamespace(namespace, _enums_constants__WEBPACK_IMPORTED_MODULE_6__["BASE_LAYER"]);
            const layersDomain = store.get(`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE}.domain`);
            const unitDom = layersDomain[parentNamespace];
            unitDom && (delete unitDom[namespace]);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this.mount()).remove();
            return this;
        }

        /**
         * Stores point in an object with key as the categorical value or temporal value
         *
         * @param {string} key categorical value or temporal value
         * @param {Object} data Information of the data point
         * @return {BarLayer} Instance of bar layer
         */
        cachePoint (key, data) {
            if (key === null) {
                return this;
            }
            const pointMap = this._pointMap;
            !pointMap[key] && (pointMap[key] = []);
            pointMap[key].push(data);
            return this;
        }

        /**
         *
         *
         * @param {*} data
         * @param {*} id
         *
         * @memberof BaseLayer
         */
        getIdentifiersFromData (data) {
            const schema = this.data().getSchema();
            const fieldsConfig = this.data().getFieldsConfig();
            const identifiers = [[], []];
            const {
                    xFieldType,
                    yFieldType,
                    xField,
                    yField
                } = this.encodingFieldsInf();

            const [xMeasure, yMeasure] = [xFieldType, yFieldType].map(type => type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE);
            schema.forEach((d, i) => {
                const name = d.name;
                if (fieldsConfig[name].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION) {
                    identifiers[0].push(name);
                    identifiers[1].push(data[i]);
                }
            });

            if (xMeasure && yMeasure) {
                const xMeasureIndex = fieldsConfig[xField].index;
                const yMeasureIndex = fieldsConfig[yField].index;
                identifiers[0].push(...[xField, yField]);
                identifiers[1].push(...[data[xMeasureIndex], data[yMeasureIndex]]);
            }
            return identifiers;
        }

        hasPlotSpan () {
            return false;
        }

        getPlotSpan () {
            return {
                x: 0,
                y: 0
            };
        }

        getPlotPadding () {
            return {
                x: 0,
                y: 0
            };
        }

        /**
         * Returns the information of the marks corresponding to the supplied identifiers. Identifiers are a set of field
         * names and their corresponding values in an array. It can also be an instance of datamodel.
         *
         * For example,
         * ```
         *  const identifiers = [
         *      ['Origin', 'Cylinders'],
         *      ['USA', '8']
         *  ];
         *  const points = barLayer.getPointsFromIdentifiers(identifiers);
         * ```
         * @public
         * @param {Array|DataModel} identifiers Identifiers of the marks.
         * @param {Object} config Optional configuration which describes how to get the information.
         * @param {boolean} config.getAllAttrs If true, then returns all the information of the points, else returns only
         * the positions of the points.
         * @param {boolean} config.getBBox If true, then returns the bounding box of all the marks.
         *
         * @return {Array} Array of points contains
         */
        getPointsFromIdentifiers (identifiers, config = {}) {
            const getAllAttrs = config.getAllAttrs;
            const getBBox = config.getBBox;
            if (!this.data()) {
                return [];
            }
            let fieldNames;
            let values;
            if (identifiers instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"]) {
                const dataObj = identifiers.getData();
                fieldNames = dataObj.schema.map(d => d.name);
                values = dataObj.data;
            } else {
                fieldNames = identifiers[0];
                values = identifiers.slice(1, identifiers.length);
            }

            const points = this._points;
            const fieldsConfig = this.data().getFieldsConfig();

            const filteredPoints = [].concat(...points).filter((point) => {
                const { source, rowId } = point;

                return fieldNames.every((field, idx) => {
                    if (field in fieldsConfig && fieldsConfig[field].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION) {
                        return values.findIndex(d => d[idx] === source[fieldsConfig[field].index]) !== -1;
                    } else if (field === muze_utils__WEBPACK_IMPORTED_MODULE_0__["ReservedFields"].ROW_ID) {
                        return values.findIndex(d => d[idx] === rowId) !== -1;
                    } return true;
                });
            });
            return getAllAttrs ? filteredPoints : filteredPoints.map((d) => {
                const obj = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(d);
                if (getBBox) {
                    const update = obj.update || obj;
                    if (obj.size !== undefined) {
                        const sizeVal = Math.sqrt(obj.size / Math.PI) * 2;
                        update.width = sizeVal;
                        update.height = sizeVal;
                        update.x -= sizeVal / 2;
                        update.y -= sizeVal / 2;
                    } else {
                        if (update.width === undefined) {
                            update.width = 2;
                        }
                        if (update.height === undefined) {
                            update.height = 2;
                        }
                    }
                }

                return obj.update || obj;
            }).sort((a, b) => a.y - b.y);
        }

        getTransformedDataFromIdentifiers (identifiers) {
            const { data: identifierData, schema: identifierSchema } = identifiers.getData();
            const normalizedData = this._normalizedData;
            const fieldsConfig = this.data().getFieldsConfig();
            const {
                yField,
                xField,
                yFieldType,
                xFieldType
            } = this.encodingFieldsInf();
            let measureIndex;
            let enc;
            if (xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE) {
                measureIndex = fieldsConfig[xField].index;
                enc = 'x';
            } else if (yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE) {
                measureIndex = fieldsConfig[yField].index;
                enc = 'y';
            }

            const transformedData = [];
            normalizedData.forEach((dataArr) => {
                dataArr.forEach((dataObj) => {
                    const tupleArr = dataObj.source;
                    const exist = identifierSchema.every((obj, i) =>
                        identifierData.findIndex(d => tupleArr[fieldsConfig[obj.name].index] === d[i]) !== -1);
                    if (exist) {
                        const transformedVal = dataObj[enc];
                        const row = dataObj.source;
                        const tuple = {};
                        for (const key in fieldsConfig) {
                            const index = fieldsConfig[key].index;
                            tuple[key] = row[index];
                            if (index === measureIndex) {
                                tuple[key] = transformedVal;
                            }
                        }
                        transformedData.push(tuple);
                    }
                });
            });

            return [transformedData, this.data().getSchema()];
        }

        /**
         * Returns the dom elements associated with the supplied set of row ids.
         * Each element in the layer is mapped with a row of the datamodel. When given an array of row ids, it returns all
         * the elements which is mapped with those row ids.
         *
         * @public
         * @param {Array} set Array of row ids
         *
         * @return {Selection} D3 Selection of dom elements.
         */
        getPlotElementsFromSet (set) {
            const graphicElems = this._graphicElems;
            const elems = [];
            for (let i = 0, len = set.length; i < len; i++) {
                const elem = graphicElems[set[i]];
                if (elem) {
                    elems.push(elem);
                }
            }
            return elems;
        }

        /**
         * Notifies when all animations/transitions of the layer are completed.
         *
         * @public
         * @return {Promise} Returns a promise to notify the animation completion.
         */
        animationDone () {
            return Promise.all(this._animationDonePromises);
        }

        registerAnimationDoneHook () {
            let resolveFn;
            const promise = new Promise((resolve) => {
                resolveFn = resolve;
            });
            this._animationDonePromises.push(promise);

            return () => {
                resolveFn();
            };
        }

        /**
         * Called when the layer datamodel is set.
         *
         * @param {Array} arr Old and new datamodel instance.
         * @param {DataModel} arr[0] Previous datamodel instance.
         * @param {DataModel} arr[1] Current datamodel instance.
         *
         * @return {BaseLayer} Instance of layer.
         */
        dataDidSet ([, data]) {
            const config = this.config();

            if (data && config) {
                if (this._cacheEnabled) {
                    this._cachedData.push(data);
                } else {
                    this._cachedData = [data];
                }
                const encodingValue = config.encoding;
                if (encodingValue) {
                    const fieldsConfig = data.getFieldsConfig();
                    const encodingFieldsInf = this.retrieveEncodingFields(encodingValue, this.coord(), data);
                    this.encodingFieldsInf(encodingFieldsInf);
                    this.resolveTransformType();
                    this._transformedData = this.getTransformedData(data, config,
                        this.transformType(), encodingFieldsInf);
                    this._normalizedData = this.getNormalizedData(this._transformedData, fieldsConfig);
                    if (config.calculateDomain !== false) {
                        const domain = this.calculateDomainFromData(this._normalizedData,
                            this.encodingFieldsInf(), this.data().getFieldsConfig());
                        this.domain(domain);
                    }
                }
            }
            return this;
        }

        retrieveEncodingFields (encoding, coord, data) {
            const fieldsConfig = data.getFieldsConfig();

            return _helpers__WEBPACK_IMPORTED_MODULE_3__["encodingFieldInfRetriever"][coord](encoding, fieldsConfig);
        }

        static getRenderProps () {
            return [`${layerNs[1]}.${_enums_props__WEBPACK_IMPORTED_MODULE_1__["DATA"]}`,
                        ...['x', 'y', 'radius'].map(type => `${groupNs}.domain.${type}`)];
        }
    }
};

/***/ }),

/***/ "./packages/visual-layer/src/base-layer/index.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/index.js ***!
  \*******************************************************/
/*! exports provided: BaseLayer, BaseLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-layer */ "./packages/visual-layer/src/base-layer/base-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseLayer", function() { return _base_layer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _base_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-mixin */ "./packages/visual-layer/src/base-layer/base-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseLayerMixin", function() { return _base_mixin__WEBPACK_IMPORTED_MODULE_1__["BaseLayerMixin"]; });





/***/ }),

/***/ "./packages/visual-layer/src/base-layer/listener-map.js":
/*!**************************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/listener-map.js ***!
  \**************************************************************/
/*! exports provided: listenerMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenerMap", function() { return listenerMap; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/props */ "./packages/visual-layer/src/enums/props.js");



const listenerMap = [
    {
        props: [`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].LAYER_LOCAL_NAMESPACE}.${_enums_props__WEBPACK_IMPORTED_MODULE_1__["DATA"]}`],
        type: 'registerImmediateListener',
        listener: (context, [prevData, data]) => {
            context.dataDidSet([prevData, data]);
        },
        namespace: context => context.metaInf().namespace
    }
];


/***/ }),

/***/ "./packages/visual-layer/src/base-layer/local-options.js":
/*!***************************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/local-options.js ***!
  \***************************************************************/
/*! exports provided: localOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localOptions", function() { return localOptions; });
/* harmony import */ var _enums_props__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/props */ "./packages/visual-layer/src/enums/props.js");


const localOptions = {
    [_enums_props__WEBPACK_IMPORTED_MODULE_0__["DATA"]]: {
        value: null
    }
};


/***/ }),

/***/ "./packages/visual-layer/src/base-layer/props.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/base-layer/props.js ***!
  \*******************************************************/
/*! exports provided: props */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "props", function() { return props; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/props */ "./packages/visual-layer/src/enums/props.js");



const { CARTESIAN } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["COORD_TYPES"];
const props = {
    axes: {},
    mount: {},
    measurement: {},
    metaInf: {},
    valueParser: {
        defaultValue: val => val
    },
    coord: {
        defaultValue: CARTESIAN
    },
    [_enums_props__WEBPACK_IMPORTED_MODULE_1__["CONFIG"]]: {
        value: null,
        sanitization: (context, config) => {
            context._customConfig = config;
            const constructor = context.constructor;
            const newConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, constructor.defaultConfig());

            return constructor.defaultPolicy(newConf, config);
        }
    },
    encodingTransform: {},
    encodingFieldsInf: {},
    dependencies: {},
    dataProps: {}
};


/***/ }),

/***/ "./packages/visual-layer/src/defaults.js":
/*!***********************************************!*\
  !*** ./packages/visual-layer/src/defaults.js ***!
  \***********************************************/
/*! exports provided: DEFAULT_LAYERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_LAYERS", function() { return DEFAULT_LAYERS; });
/* harmony import */ var _layers_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layers/area */ "./packages/visual-layer/src/layers/area/index.js");
/* harmony import */ var _layers_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers/arc */ "./packages/visual-layer/src/layers/arc/index.js");
/* harmony import */ var _layers_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layers/line */ "./packages/visual-layer/src/layers/line/index.js");
/* harmony import */ var _layers_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layers/text */ "./packages/visual-layer/src/layers/text/index.js");
/* harmony import */ var _layers_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layers/point */ "./packages/visual-layer/src/layers/point/index.js");
/* harmony import */ var _layers_bar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layers/bar */ "./packages/visual-layer/src/layers/bar/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _enums_layer_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums/layer-types */ "./packages/visual-layer/src/enums/layer-types.js");
/* harmony import */ var _layers_tick__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./layers/tick */ "./packages/visual-layer/src/layers/tick/index.js");










const DEFAULT_LAYERS = {
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["AREA_LAYER"]]: _layers_area__WEBPACK_IMPORTED_MODULE_0__["AreaLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["ARC_LAYER"]]: _layers_arc__WEBPACK_IMPORTED_MODULE_1__["ArcLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["LINE_LAYER"]]: _layers_line__WEBPACK_IMPORTED_MODULE_2__["LineLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["TEXT_LAYER"]]: _layers_text__WEBPACK_IMPORTED_MODULE_3__["TextLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["POINT_LAYER"]]: _layers_point__WEBPACK_IMPORTED_MODULE_4__["PointLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["TICK_LAYER"]]: _layers_tick__WEBPACK_IMPORTED_MODULE_8__["TickLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["BAR_LAYER"]]: _layers_bar__WEBPACK_IMPORTED_MODULE_5__["BarLayer"],
    [_enums_layer_types__WEBPACK_IMPORTED_MODULE_7__["BASE_LAYER"]]: _base_layer__WEBPACK_IMPORTED_MODULE_6__["BaseLayer"]
};


/***/ }),

/***/ "./packages/visual-layer/src/enums/constants.js":
/*!******************************************************!*\
  !*** ./packages/visual-layer/src/enums/constants.js ***!
  \******************************************************/
/*! exports provided: CLASSPREFIX, STACK, GROUP, IDENTITY, ANGLE, RADIUS, SIZE, COLOR, SHAPE, TEXT, OUTER_RADIUS_VALUE, TEXT_ANCHOR_MIDDLE, ENCODING, ASCENDING, AGG_FN_SUM, AREA_LAYER, ARC_LAYER, LINE_LAYER, TEXT_LAYER, POINT_LAYER, BAR_LAYER, TICK_LAYER, SIMPLE_LAYER, BASE_LAYER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STACK", function() { return STACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP", function() { return GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANGLE", function() { return ANGLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIZE", function() { return SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHAPE", function() { return SHAPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT", function() { return TEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OUTER_RADIUS_VALUE", function() { return OUTER_RADIUS_VALUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_ANCHOR_MIDDLE", function() { return TEXT_ANCHOR_MIDDLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENCODING", function() { return ENCODING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASCENDING", function() { return ASCENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AGG_FN_SUM", function() { return AGG_FN_SUM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AREA_LAYER", function() { return AREA_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARC_LAYER", function() { return ARC_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINE_LAYER", function() { return LINE_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_LAYER", function() { return TEXT_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LAYER", function() { return POINT_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAR_LAYER", function() { return BAR_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TICK_LAYER", function() { return TICK_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIMPLE_LAYER", function() { return SIMPLE_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASE_LAYER", function() { return BASE_LAYER; });
const CLASSPREFIX = 'muze';
const STACK = 'stack';
const GROUP = 'group';
const IDENTITY = 'identity';
const ANGLE = 'angle';
const RADIUS = 'radius';
const SIZE = 'size';
const COLOR = 'color';
const SHAPE = 'shape';
const TEXT = 'text';
const OUTER_RADIUS_VALUE = 'outerRadiusValue';
const TEXT_ANCHOR_MIDDLE = 'middle';
const ENCODING = {
    X: 'x',
    Y: 'y',
    X0: 'x0',
    Y0: 'y0',
    RADIUS: 'radius',
    RADIUS0: 'radius0',
    ANGLE: 'angle',
    ANGLE0: 'angle0',
    COLOR: 'color',
    SHAPE: 'shape',
    SIZE: 'size',
    TEXT: 'text'
};

const ASCENDING = 'asc';

const AGG_FN_SUM = 'sum';

const AREA_LAYER = 'area';
const ARC_LAYER = 'arc';
const LINE_LAYER = 'line';
const TEXT_LAYER = 'text';
const POINT_LAYER = 'point';
const BAR_LAYER = 'bar';
const TICK_LAYER = 'tick';
const SIMPLE_LAYER = 'simple';
const BASE_LAYER = 'base';


/***/ }),

/***/ "./packages/visual-layer/src/enums/index.js":
/*!**************************************************!*\
  !*** ./packages/visual-layer/src/enums/index.js ***!
  \**************************************************/
/*! exports provided: PROPS, LAYER_TYPES, CONSTANTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./props */ "./packages/visual-layer/src/enums/props.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return _props__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _layer_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer-types */ "./packages/visual-layer/src/enums/layer-types.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "LAYER_TYPES", function() { return _layer_types__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "CONSTANTS", function() { return _constants__WEBPACK_IMPORTED_MODULE_2__; });







/***/ }),

/***/ "./packages/visual-layer/src/enums/layer-types.js":
/*!********************************************************!*\
  !*** ./packages/visual-layer/src/enums/layer-types.js ***!
  \********************************************************/
/*! exports provided: AREA_LAYER, ARC_LAYER, LINE_LAYER, TEXT_LAYER, POINT_LAYER, BAR_LAYER, TICK_LAYER, SIMPLE_LAYER, BASE_LAYER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AREA_LAYER", function() { return AREA_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARC_LAYER", function() { return ARC_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINE_LAYER", function() { return LINE_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_LAYER", function() { return TEXT_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LAYER", function() { return POINT_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAR_LAYER", function() { return BAR_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TICK_LAYER", function() { return TICK_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SIMPLE_LAYER", function() { return SIMPLE_LAYER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASE_LAYER", function() { return BASE_LAYER; });
const AREA_LAYER = 'area';
const ARC_LAYER = 'arc';
const LINE_LAYER = 'line';
const TEXT_LAYER = 'text';
const POINT_LAYER = 'point';
const BAR_LAYER = 'bar';
const TICK_LAYER = 'tick';
const SIMPLE_LAYER = 'simple';
const BASE_LAYER = 'base';


/***/ }),

/***/ "./packages/visual-layer/src/enums/props.js":
/*!**************************************************!*\
  !*** ./packages/visual-layer/src/enums/props.js ***!
  \**************************************************/
/*! exports provided: DATA, CONFIG, MEASUREMENT, DOMAIN, MOUNT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA", function() { return DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEASUREMENT", function() { return MEASUREMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMAIN", function() { return DOMAIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNT", function() { return MOUNT; });
const DATA = 'data';
const CONFIG = 'config';
const MEASUREMENT = 'measurement';
const DOMAIN = 'domain';
const MOUNT = 'mount';


/***/ }),

/***/ "./packages/visual-layer/src/helpers/index.js":
/*!****************************************************!*\
  !*** ./packages/visual-layer/src/helpers/index.js ***!
  \****************************************************/
/*! exports provided: applyInteractionStyle, retrieveEncodingInf, encodingFieldInfRetriever, transformData, getIndividualClassName, dataNormalizers, getNormalizedData, domainCalculator, attachDataToVoronoi, updateStyle, animateGroup, positionPoints, getGroupSpan, getPlotMeasurement, renderLayer, resolveInvalidTransformType, getValidTransform, getValidTransformForAggFn, getMarkId, resolveEncodingValues, getColorMetaInf, toCartesianCoordinates, sortData, getSuperLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyInteractionStyle", function() { return applyInteractionStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveEncodingInf", function() { return retrieveEncodingInf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodingFieldInfRetriever", function() { return encodingFieldInfRetriever; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformData", function() { return transformData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIndividualClassName", function() { return getIndividualClassName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataNormalizers", function() { return dataNormalizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNormalizedData", function() { return getNormalizedData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "domainCalculator", function() { return domainCalculator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachDataToVoronoi", function() { return attachDataToVoronoi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateStyle", function() { return updateStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animateGroup", function() { return animateGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionPoints", function() { return positionPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGroupSpan", function() { return getGroupSpan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlotMeasurement", function() { return getPlotMeasurement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLayer", function() { return renderLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveInvalidTransformType", function() { return resolveInvalidTransformType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValidTransform", function() { return getValidTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValidTransformForAggFn", function() { return getValidTransformForAggFn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMarkId", function() { return getMarkId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveEncodingValues", function() { return resolveEncodingValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColorMetaInf", function() { return getColorMetaInf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCartesianCoordinates", function() { return toCartesianCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortData", function() { return sortData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSuperLayers", function() { return getSuperLayers; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _chartshq_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/transform */ "./packages/transform/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-layer/src/enums/constants.js");





const BAND = _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__["ScaleType"].BAND;
const { POLAR, CARTESIAN } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["COORD_TYPES"];

const transformColor = (colorAxis, datum, styleType, intensity) => {
    const meta = datum.meta;
    const stateColor = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(meta.stateColor[styleType], meta.originalColor[styleType]);
    const colorInfo = colorAxis.transformColor(stateColor, intensity);

    meta.stateColor[styleType] = colorInfo.hsla;
    return colorInfo;
};

const applyInteractionStyle = (context, selectionSet, interactionStyles, config) => {
    const elements = context.getPlotElementsFromSet(selectionSet);
    const axes = context.axes();
    const colorAxis = axes.color;
    const apply = config.apply;
    const interactionType = config.interactionType;
    interactionStyles.forEach((style) => {
        const styleType = style.type;
        elements.forEach((elem) => {
            elem.style(styleType, ((d) => {
                const { colorTransform, stateColor, originalColor } = d.meta;
                colorTransform[interactionType] = colorTransform[interactionType] || {};
                if (apply && !colorTransform[interactionType][styleType]) {
                    // fade selections
                    colorTransform[interactionType][styleType] = style.intensity;
                    const color = transformColor(colorAxis, d, styleType, style.intensity).color;
                    return color;
                }
                if (!apply && colorTransform[interactionType][styleType]) {
                     // unfade selections
                    colorTransform[interactionType][styleType] = null;
                    return transformColor(colorAxis, d, styleType, style.intensity.map(e => -e)).color;
                }
                const [h, s, l, a] = stateColor[styleType] ? stateColor[styleType] : originalColor[styleType];
                return `hsla(${h * 360},${s * 100}%,${l * 100}%, ${a})`;
            }));
        });
    });
};

const retrieveEncodingInf = (encoding, fieldsConfig, encodingNames) => {
    const encodingInf = {};

    encodingNames
        .forEach((e) => {
            const field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(encoding, e, 'field');
            encodingInf[`${e}Field`] = field;
            encodingInf[`${e}FieldIndex`] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, field, 'index');
            encodingInf[`${e}FieldType`] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, field, 'def', 'type');
            encodingInf[`${e}FieldSubType`] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, field, 'def', 'subtype');
        });
    return encodingInf;
};

const encodingFieldInfRetriever = {
    [POLAR]: (encoding, fieldsConfig) => {
        const fields = [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].RADIUS, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].RADIUS0, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].ANGLE, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].ANGLE0, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["TEXT"]];
        return retrieveEncodingInf(encoding, fieldsConfig, fields);
    },
    [CARTESIAN]: (encoding, fieldsConfig) => {
        const fields = [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].X, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].X0, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y0, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["TEXT"]];
        return retrieveEncodingInf(encoding, fieldsConfig, fields);
    }
};

/**
 *
 *
 * @param {*} dataModel
 * @param {*} config
 * @param {*} transformType
 *
 */
const transformData = (dataModel, config, transformType, encodingFieldInf) => {
    const data = dataModel.getData({ withUid: true });
    const schema = data.schema;
    const transform = config.transform;
    const {
        xField,
        yField,
        xFieldType,
        yFieldType
    } = encodingFieldInf;
    const uniqueField = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE ? yField : xField;

    return Object(_chartshq_transform__WEBPACK_IMPORTED_MODULE_2__["transformFactory"])(transformType)(schema, data.data, {
        groupBy: transform.groupBy,
        uniqueField,
        sort: transform.sort || 'none',
        offset: transform.offset,
        orderBy: transform.orderBy,
        value: yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE ? yField : xField
    }, data.uids);
};

const getIndividualClassName = (d, i, data, context) => {
    const className = context.config().individualClassName;
    let classNameStr = '';
    if (className instanceof Function) {
        classNameStr = className(d, i, data, context);
    }
    return classNameStr;
};

const dataNormalizers = {
    [POLAR]: (transformedData, encodingFieldInf, fieldsConfig) => {
        const {
            radiusFieldIndex,
            angleFieldIndex,
            radius0FieldIndex,
            angle0FieldIndex
        } = encodingFieldInf;
        const fieldsLen = Object.keys(fieldsConfig).length;

        /**
         * Returns normalized data from transformed data. It recursively traverses through
         * the transformed data if there it is nested.
         */
        return transformedData.map(data => data.map((d) => {
            const pointObj = {
                radius: d[radiusFieldIndex],
                angle: angleFieldIndex !== undefined ? d[angleFieldIndex] : 1,
                radius0: d[radius0FieldIndex],
                angle0: d[angle0FieldIndex]
            };
            [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["TEXT"]].forEach((enc) => {
                pointObj[enc] = d[encodingFieldInf[`${enc}FieldIndex`]];
            });
            pointObj.source = d;
            pointObj.rowId = d[fieldsLen];
            return pointObj;
        })).filter(d => d.length);
    },
    [CARTESIAN]: (transformedData, encodingFieldInf, fieldsConfig, transformType) => {
        const {
            xFieldType,
            xFieldIndex,
            yFieldIndex,
            x0FieldIndex,
            y0FieldIndex
        } = encodingFieldInf;
        const fieldsLen = Object.keys(fieldsConfig).length;
        /**
         * Returns normalized data from transformed data. It recursively traverses through
         * the transformed data if there it is nested.
         */
        return transformedData.map((data) => {
            const values = transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GROUP"] ? data.values : data;
            return values.map((d) => {
                let pointObj = {};
                let tuple;
                if (transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STACK"]) {
                    tuple = d.data || [];
                    let y;
                    let y0;
                    let x;
                    let x0;
                    if (d[1] >= d[0]) {
                        y = x0 = d[1];
                        x = y0 = d[0];
                    } else {
                        y = x0 = d[0];
                        x = y0 = d[1];
                    }

                    pointObj = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE ? {
                        x,
                        x0,
                        y: tuple[yFieldIndex],
                        y0: tuple[yFieldIndex]
                    } : {
                        x: tuple[xFieldIndex],
                        x0: tuple[xFieldIndex],
                        y,
                        y0
                    };
                    pointObj.source = tuple;
                    pointObj.rowId = tuple[fieldsLen];
                    [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["TEXT"]].forEach((enc) => {
                        pointObj[enc] = tuple[encodingFieldInf[`${enc}FieldIndex`]];
                    });
                } else {
                    pointObj = {
                        x: d[xFieldIndex],
                        y: d[yFieldIndex],
                        x0: d[x0FieldIndex],
                        y0: d[y0FieldIndex]
                    };
                    pointObj.source = d;
                    pointObj.rowId = d[fieldsLen];
                    [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SHAPE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["SIZE"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["TEXT"]].forEach((enc) => {
                        pointObj[enc] = d[encodingFieldInf[`${enc}FieldIndex`]];
                    });
                }
                return pointObj;
            });
        }).filter(d => d.length);
    }
};
/*
 * This method resolves the x, y, x0 and y0 values from the transformed data.
 * It also checks the type of transformed data for example, if it is a stacked data
 * then it fetches the y and y0 values from the stacked data.
 * @param {Array.<Array>} transformedData transformed data
 * @param {Object} fieldsConfig field definitions
 * @param {string} transformType type of transformed data - stack, group or identity.
 * @return {Array.<Object>} Normalized data
*/
const getNormalizedData = (transformedData, context) => {
    const transformType = context.transformType();
    const transformedDataArr = transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"] ? [transformedData] : transformedData;
    const encodingFieldInf = context.encodingFieldsInf();
    const fieldsConfig = context.data().getFieldsConfig();
    return dataNormalizers[context.coord()](transformedDataArr, encodingFieldInf, fieldsConfig, transformType);
};

const domainCalculator = {
    [POLAR]: (data, layerInst) => {
        const config = layerInst.config();
        const { sort } = config;
        let angleValues = data[0];
        const radius0Field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(config.encoding.radius0, 'field');
        if (sort) {
            angleValues = angleValues.sort((a, b) => (sort === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ASCENDING"] ? a.radius - b.radius : b.radius - a.radius));
        }
        const radiusDomain = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDomainFromData"])(data, [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].RADIUS, radius0Field ?
            _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].RADIUS0 : _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].RADIUS]);
        return {
            radius: radiusDomain,
            angle: angleValues.map(d => d.angle),
            angle0: angleValues.map(d => d.angle0)
        };
    },
    [CARTESIAN]: (data, layerInst) => {
        const transformType = layerInst.transformType();
        const encodingFieldInf = layerInst.encodingFieldsInf();
        const {
            xFieldSubType,
            yFieldSubType,
            xField,
            yField,
            x0Field,
            y0Field
        } = encodingFieldInf;
        const domains = {};
        const yEnc = _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y;
        const xEnc = _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].X;
        if (xField) {
            domains.x = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDomainFromData"])(data, x0Field || transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STACK"] ? [xEnc, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].X0] : [xEnc, xEnc],
                xFieldSubType);
        }
        if (yField) {
            domains.y = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDomainFromData"])(data, y0Field || transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STACK"] ? [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y0, _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y] :
                [yEnc, yEnc], yFieldSubType);
        }

        return domains;
    }
};

const attachDataToVoronoi = (voronoi, points) => {
    voronoi.data([].concat(...points).filter(d => d.rowId !== undefined).map((d) => {
        const point = d.update;
        return {
            x: point.x,
            y: point.y,
            data: d
        };
    }));
};

/**
 *
 *
 * @param {*} target
 * @param {*} styles
 * @param {*} remove
 */
const updateStyle = (target, styles, remove) => {
    for (const key in styles) {
        if ({}.hasOwnProperty.call(styles, key)) {
            target.style(key, remove ? null : styles[key]);
        }
    }
};

/**
 *
 *
 * @param {*} mount
 * @param {*} context
 */
const animateGroup = (mount, context) => {
    let groupTransition;
    let update;
    const { transition, groupAnimateStyle } = context;
    const { duration, effect, disabled } = transition;
    if (groupAnimateStyle) {
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(mount.node(), groupAnimateStyle.enter);
        update = groupAnimateStyle.update;
        if (!disabled) {
            groupTransition = mount.transition()
                .ease(muze_utils__WEBPACK_IMPORTED_MODULE_0__["easeFns"][effect])
                .duration(duration)
                .on('end', function () {
                    updateStyle(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this), update, true);
                });
        } else {
            groupTransition = mount;
        }
        updateStyle(groupTransition, update);
    }
};

const positionPoints = (context, points) => {
    const positioner = context.encodingTransform();
    if (positioner) {
        return positioner(points, context, { smartLabel: context._dependencies.smartLabel });
    }
    return points;
};

/**
  * Gets the width of each group. It gets the width from axis if it is available for
  * example when the scale is nominal else it calculates the width from the
  * range of the axis and number of data points.
  *
  * @param {SimpleAxis} axis instance of axis
  * @param {number} minDiff Minimum difference between data points
  * @return {number} width of each bar
  * @private
*/
const getGroupSpan = (axis, minDiff) => {
    let groupSpan;
    const width = axis.getUnitWidth();
    const scale = axis.scale();
    const range = scale.range();
    const domain = scale.domain();
    !width ? groupSpan = (Math.abs(range[1] - range[0]) / Math.abs(domain[1] - domain[0])) * minDiff :
        (groupSpan = width);

    return groupSpan;
};

const getPlotMeasurement = (context, dimensionalValues) => {
    const fieldInfo = context.encodingFieldsInf();
    const axes = context.axes();
    const transformType = context.transformType();
    const config = context.config();
    const bandScale = context._bandScale;

    return ['x', 'y'].map((type) => {
        let span = 0;
        let groupSpan = 0;
        let padding = 0;
        let offsetValues = [];
        if (fieldInfo[`${type}FieldType`] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION) {
            let actualGroupWidth;
            const isTemporal = fieldInfo[`${type}FieldSubType`] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL;
            const timeDiff = isTemporal ? context.dataProps().timeDiffs[type] : 0;
            const axis = axes[type];
            const pad = config[`pad${type.toUpperCase()}`];
            const innerPadding = config.innerPadding;
            const keys = dimensionalValues;
            const scale = axis.scale();
            groupSpan = getGroupSpan(axis, timeDiff);
            const isAxisBandScale = axis.constructor.type() === BAND;
            const axisPadding = axis.config().padding;
            // If it is a grouped bar then the width of each bar in a grouping is retrieved from
            // a band scale. The band scale will have range equal to width of one group of bars and
            // the domain is set to series keys.
            if (transformType === 'group') {
                const groupPadding = isAxisBandScale ? 0 : axisPadding * groupSpan / 2;
                bandScale.range([groupPadding, groupSpan - groupPadding]).domain(keys).paddingInner(innerPadding);
                span = bandScale.bandwidth();
                actualGroupWidth = groupSpan - (isAxisBandScale ? 0 : axisPadding * groupSpan);
                offsetValues = keys.map(key => bandScale(key) - (isAxisBandScale ? 0 : (groupSpan / 2)));
            } else if (pad !== undefined) {
                let offset;
                if (isAxisBandScale) {
                    const step = scale.step();
                    offset = scale.padding() * step;
                    span = scale.bandwidth() + offset;
                } else {
                    span = groupSpan;
                }
                offsetValues = keys.map(() => (isAxisBandScale ? -(offset / 2) : -(span / 2)));
            } else {
                padding = isAxisBandScale ? 0 : axisPadding * groupSpan;
                span = groupSpan - padding;
                actualGroupWidth = span;
                offsetValues = keys.map(() => (isAxisBandScale ? 0 : -(span / 2)));
            }

            groupSpan = actualGroupWidth;
            padding = isAxisBandScale ? axisPadding * axis.scale().step() : axisPadding * groupSpan;
        }

        return {
            span,
            offsetValues,
            groupSpan,
            padding
        };
    });
};

const renderLayer = (context) => {
    const mount = context.mount();
    if (mount) {
        context.render(mount);
        context.dependencies().throwback.commit(muze_utils__WEBPACK_IMPORTED_MODULE_0__["CommonProps"].ON_LAYER_DRAW, true, context.metaInf().parentNamespace);
    }
};

const transformResolverPredicates = (encodingFieldInf, context, groupByField) => {
    const fieldsConfig = context.data().getFieldsConfig();
    const { xField, yField, xFieldType, yFieldType } = encodingFieldInf;
    const dimensionField = ['xField', 'yField'].find(type =>
        encodingFieldInf[`${type}Type`] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION);

    return [
        !xField,
        !yField,
        !groupByField,
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig[groupByField], 'def', 'type') === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE,
        xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION && yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION,
        dimensionField && encodingFieldInf[dimensionField] === groupByField
    ];
};

const resolveInvalidTransformType = (context) => {
    const encodingFieldInf = context.encodingFieldsInf();
    const groupByField = context.config().transform.groupBy;

    if (transformResolverPredicates(encodingFieldInf, context, groupByField).some(value => value)) {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"];
    }
    return null;
};

const getValidTransform = context => resolveInvalidTransformType(context) || context.config().transform.type;

const getValidTransformForAggFn = (context) => {
    const resolvedInvalidTransformType = resolveInvalidTransformType(context);
    if (resolvedInvalidTransformType) {
        return resolvedInvalidTransformType;
    }

    const {
        xField,
        yField,
        xFieldType,
        yFieldType
    } = context.encodingFieldsInf();
    const groupByField = context.config().transform.groupBy;
    const isCustomTransformTypeProvided = !!Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(context._customConfig, 'transform', 'type');
    let transformType = context.config().transform.type;

    if (!isCustomTransformTypeProvided && groupByField && xFieldType !== yFieldType) {
        const measureField = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE ? xField : yField;
        const { [measureField]: aggFn } = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["retrieveNearestGroupByReducers"])(context.data(), measureField);
        transformType = aggFn === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["AGG_FN_SUM"] ? _enums_constants__WEBPACK_IMPORTED_MODULE_3__["STACK"] : _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GROUP"];
    }

    return transformType;
};

const getMarkId = (source, schema) => source.filter((val, i) => schema[i] &&
    schema[i].type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION).join();

const resolveEncodingValues = (data, i, dataArr, layerInst) => {
    const transformedValues = {};
    const values = data.values;
    const encoding = layerInst.config().encoding;
    for (const key in values) {
        const value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(encoding[key], 'value');
        if (value instanceof Function) {
            transformedValues[key] = value(values, i, dataArr, layerInst);
        } else {
            transformedValues[key] = values[key];
        }
    }
    return transformedValues;
};

const getColorMetaInf = (colorInf, colorAxis) => ({
    originalColor: Object.keys(colorInf).reduce((acc, key) => {
        if (colorInf[key]) {
            acc[key] = colorAxis.getHslArray(colorInf[key]);
        }
        return acc;
    }, {}),
    stateColor: {},
    colorTransform: {}
});

const getCoordValue = (radius, trig, angle, offset) => radius * Math[trig](angle) + offset;

const coordValueGetter = (radius, angle, xOffset, yOffset) => ({
    x: getCoordValue(radius, 'cos', angle, xOffset),
    y: getCoordValue(radius, 'sin', angle, yOffset)
});

const toCartesianCoordinates = (points, measurement, rangePlot = false) => {
    const xOffset = measurement.width / 2;
    const yOffset = measurement.height / 2;
    for (let i = 0, len = points.length; i < len; i++) {
        const point = points[i];
        const { angle, radius, radius0, angle0 } = point.update;
        point.update = coordValueGetter(radius, angle, xOffset, yOffset);
        if (rangePlot) {
            const update = point.update = coordValueGetter(radius0, angle0, xOffset, yOffset);
            const { x: x0, y: y0 } = coordValueGetter(radius, angle, xOffset, yOffset);
            update.x0 = x0;
            update.y0 = y0;
        }
    }
    return points;
};

const sortData = (data, axes) => {
    const { x: xAxis, y: yAxis } = axes;
    const axisArr = [xAxis, yAxis];
    for (let i = 0, len = axisArr.length; i < len; i++) {
        const axis = axisArr[i];
        if (axis.constructor.type() === BAND) {
            const key = i ? 'y' : 'x';
            const dom = axis.domain();
            const indices = dom.reduce((acc, v, idx) => {
                acc[v] = idx;
                return acc;
            }, {});
            data.sort((a, b) => indices[a[key]] - indices[b[key]]);
            break;
        }
    }
    return data;
};

const getSuperLayers = (context, layerRegistry) => {
    const self = context.self();
    const superLayers = self._superLayers;

    if (!superLayers && layerRegistry) {
        const superLayerNames = self.getSuperLayerNames();
        context._superLayers = superLayerNames.reduce((instances, name) => {
            instances[name] = new layerRegistry[name](self, {
                layerRegistry
            });
            return instances;
        }, {});
        return context;
    }

    return superLayers;
};


/***/ }),

/***/ "./packages/visual-layer/src/index.js":
/*!********************************************!*\
  !*** ./packages/visual-layer/src/index.js ***!
  \********************************************/
/*! exports provided: BaseLayer, BarLayer, LineLayer, AreaLayer, PointLayer, ArcLayer, TextLayer, TickLayer, layerFactory, SimpleLayer, layerRegistry, LAYER_TYPES, ENCODING, helpers, enums, layerMixins */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "helpers", function() { return helpers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerMixins", function() { return layerMixins; });
/* harmony import */ var _layers_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layers/area */ "./packages/visual-layer/src/layers/area/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AreaLayer", function() { return _layers_area__WEBPACK_IMPORTED_MODULE_0__["AreaLayer"]; });

/* harmony import */ var _layers_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers/arc */ "./packages/visual-layer/src/layers/arc/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcLayer", function() { return _layers_arc__WEBPACK_IMPORTED_MODULE_1__["ArcLayer"]; });

/* harmony import */ var _layers_line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layers/line */ "./packages/visual-layer/src/layers/line/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineLayer", function() { return _layers_line__WEBPACK_IMPORTED_MODULE_2__["LineLayer"]; });

/* harmony import */ var _layers_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layers/text */ "./packages/visual-layer/src/layers/text/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextLayer", function() { return _layers_text__WEBPACK_IMPORTED_MODULE_3__["TextLayer"]; });

/* harmony import */ var _layers_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layers/point */ "./packages/visual-layer/src/layers/point/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLayer", function() { return _layers_point__WEBPACK_IMPORTED_MODULE_4__["PointLayer"]; });

/* harmony import */ var _layers_bar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./layers/bar */ "./packages/visual-layer/src/layers/bar/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarLayer", function() { return _layers_bar__WEBPACK_IMPORTED_MODULE_5__["BarLayer"]; });

/* harmony import */ var _layers_tick__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./layers/tick */ "./packages/visual-layer/src/layers/tick/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TickLayer", function() { return _layers_tick__WEBPACK_IMPORTED_MODULE_6__["TickLayer"]; });

/* harmony import */ var _simple_layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./simple-layer */ "./packages/visual-layer/src/simple-layer/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleLayer", function() { return _simple_layer__WEBPACK_IMPORTED_MODULE_7__["SimpleLayer"]; });

/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseLayer", function() { return _base_layer__WEBPACK_IMPORTED_MODULE_8__["BaseLayer"]; });

/* harmony import */ var _enums_layer_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./enums/layer-types */ "./packages/visual-layer/src/enums/layer-types.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "LAYER_TYPES", function() { return _enums_layer_types__WEBPACK_IMPORTED_MODULE_9__; });
/* harmony import */ var _layer_factory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./layer-factory */ "./packages/visual-layer/src/layer-factory/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layerFactory", function() { return _layer_factory__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _layer_registry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./layer-registry */ "./packages/visual-layer/src/layer-registry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layerRegistry", function() { return _layer_registry__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENCODING", function() { return _enums_constants__WEBPACK_IMPORTED_MODULE_12__["ENCODING"]; });

/* harmony import */ var _layers_point_helper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./layers/point/helper */ "./packages/visual-layer/src/layers/point/helper.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./enums */ "./packages/visual-layer/src/enums/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "enums", function() { return _enums__WEBPACK_IMPORTED_MODULE_15__; });

















const helpers = Object.assign(_helpers__WEBPACK_IMPORTED_MODULE_14__, {
    pointLayerHelpers: _layers_point_helper__WEBPACK_IMPORTED_MODULE_13__
});

const layerMixins = {
    BarLayerMixin: _layers_bar__WEBPACK_IMPORTED_MODULE_5__["BarLayerMixin"],
    BaseLayerMixin: _base_layer__WEBPACK_IMPORTED_MODULE_8__["BaseLayerMixin"],
    LineLayerMixin: _layers_line__WEBPACK_IMPORTED_MODULE_2__["LineLayerMixin"],
    AreaLayerMixin: _layers_area__WEBPACK_IMPORTED_MODULE_0__["AreaLayerMixin"],
    PointLayerMixin: _layers_point__WEBPACK_IMPORTED_MODULE_4__["PointLayerMixin"],
    TextLayerMixin: _layers_text__WEBPACK_IMPORTED_MODULE_3__["TextLayerMixin"],
    TickLayerMixin: _layers_tick__WEBPACK_IMPORTED_MODULE_6__["TickLayerMixin"],
    ArcLayerMixin: _layers_arc__WEBPACK_IMPORTED_MODULE_1__["ArcLayerMixin"]
};




/***/ }),

/***/ "./packages/visual-layer/src/layer-factory/index.js":
/*!**********************************************************!*\
  !*** ./packages/visual-layer/src/layer-factory/index.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layer_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layer-factory */ "./packages/visual-layer/src/layer-factory/layer-factory.js");


/* harmony default export */ __webpack_exports__["default"] = (_layer_factory__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./packages/visual-layer/src/layer-factory/layer-factory.js":
/*!******************************************************************!*\
  !*** ./packages/visual-layer/src/layer-factory/layer-factory.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const parseLayerDefinition = (sink, definition, layerDef, layerType) => {
    for (const key in definition) {
        if (Object.hasOwnProperty.call(definition, key)) {
            let strs;
            let propValue;
            const def = definition[key];
            if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(def)) {
                sink[key] = {};
                parseLayerDefinition(sink[key], def, layerDef, layerType);
            } else if (typeof def === 'string' && (strs = def.split('.')) && strs[0] === layerType) {
                propValue = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(layerDef, ...strs.slice(1, strs.length));
                if (propValue !== undefined) {
                    sink[key] = propValue;
                }
            } else {
                sink[key] = def;
            }
        }
    }
};

const sanitizeEncoding = (encoding) => {
    // Create object for each encoding value if encoding value is a string
    for (const key in encoding) {
        if (typeof encoding[key] === 'string') {
            encoding[key] = {
                field: encoding[key]
            };
        }
    }
};

/**
 * Layer Factory creates layers based on the layer type. All types of layers needs to register in
 * the layer factory. For getting a layer instance, getLayer method needs to invoked with the
 * layerType and other arguments. It also registers the definition of composite layers.
 *
 * @public
 *
 * @module LayerFactory
 */
const layerFactory = (() => {
    const compositeLayers = {};
    const factoryObj = {
        setLayerRegistry: (reg) => {
            factoryObj._layerRegistry = reg;
        },
        getSerializedConf: (mark, layerDef) => {
            let serializedDefs;
            const defs = compositeLayers[mark];
            const newConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, layerDef);

                // If it is a composite layer then resolve all the definitions of each unit layer
            if (defs) {
                serializedDefs = defs.map((unitLayerDef) => {
                    const sDef = {};
                    parseLayerDefinition(sDef, unitLayerDef, newConf, mark);
                    sanitizeEncoding(sDef.encoding);
                    return sDef;
                });
            } else {
                const encoding = newConf.encoding;
                // Create object for each encoding value if encoding value is a string
                sanitizeEncoding(encoding);
                serializedDefs = newConf;
            }

            return serializedDefs;
        },
        getLayerInstance: (layerDef, ...params) => {
            const layerRegistry = factoryObj._layerRegistry;
            layerDef = !(layerDef instanceof Array) ? [layerDef] : layerDef;
            const instances = layerDef.map((layerObj) => {
                const layerConstructor = layerRegistry[layerObj.mark];
                return layerConstructor.create(...params);
            });
            return instances.length === 1 ? instances[0] : instances;
        },
        getLayerClass: mark => factoryObj._layerRegistry[mark],
        /**
         * Registers a new composite layer definition in the layer factory.
         *
         * @public
         *
         * @param {string} layerType Mark type of the new composite layer.
         * @param {Array} layerDefs Layer definitions of the composite layer.
         */
        composeLayers: (layerType, layerDefs) => {
            compositeLayers[layerType] = layerDefs;
        },
        sanitizeLayerConfig: (layerDef) => {
            const newConf = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, layerDef);
            sanitizeEncoding(newConf.encoding);
            return newConf;
        }
    };
    return factoryObj;
})();

/* harmony default export */ __webpack_exports__["default"] = (layerFactory);


/***/ }),

/***/ "./packages/visual-layer/src/layer-registry.js":
/*!*****************************************************!*\
  !*** ./packages/visual-layer/src/layer-registry.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults */ "./packages/visual-layer/src/defaults.js");


/* harmony default export */ __webpack_exports__["default"] = ((layers = _defaults__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_LAYERS"]) => {
    const reg = Object.assign({}, layers);
    const regObj = {
        register: (def) => {
            const key = def.formalName();

            reg[key] = def;
            return regObj;
        },
        get: () => reg
    };
    return regObj;
});


/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/arc-helper.js":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/arc-helper.js ***!
  \************************************************************/
/*! exports provided: getPreviousPoint, tweenPie, tweenExitPie, getFieldIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPreviousPoint", function() { return getPreviousPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenPie", function() { return tweenPie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenExitPie", function() { return tweenExitPie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFieldIndices", function() { return getFieldIndices; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");



const getPreviousPoint = (prevData, currIndex, context) => {
    const prevArc = prevData[currIndex - 1];
    const nextArc = prevData[currIndex];
    const [startAngle, endAngle] = context.axes().angle.range();
    if (prevArc && nextArc) {
        return {
            update: {
                angle0: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(prevArc, 'update', 'angle'),
                angle: Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(nextArc, 'update', 'angle0')
            }
        };
    } else if (!nextArc) {
        return {
            update: {
                angle0: (endAngle - 90) * Math.PI * 2 / 360,
                angle: (endAngle - 90) * Math.PI * 2 / 360
            }
        };
    }
    return {
        update: {
            angle0: (startAngle - 90) * Math.PI * 2 / 360,
            angle: (startAngle - 90) * Math.PI * 2 / 360
        }
    };
};

const tweenPie = (path, b) => {
    const datum = b[0];
    return function (t) {
        return path(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["interpolator"])()(datum._previousInfo, datum)(t));
    };
};

const tweenExitPie = (consecutiveExits, transition, path) => {
    if (consecutiveExits.length > 0) {
        consecutiveExits.forEach((consecutiveExitArr) => {
            const startAngle = consecutiveExitArr[0].datum.update.angle0;
            const endAngle = consecutiveExitArr[consecutiveExitArr.length - 1].datum.update.angle;
            const mid = (Math.PI * 2 * startAngle) / ((Math.PI * 2) + startAngle - endAngle);

            consecutiveExitArr.forEach((e) => {
                const { elem, datum } = e;

                elem.each(function () {
                    const gElem = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                    gElem.selectAll('path')
                                    .transition()
                                    .duration(transition.duration)
                                    .attrTween('d', () => function (t) {
                                        return path(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["interpolator"])()(datum, {
                                            update: {
                                                angle0: mid,
                                                angle: mid,
                                                radius: datum.radius,
                                                radius0: datum.radius0
                                            }
                                        })(t));
                                    })
                                    .remove();
                    gElem.remove();
                });
            });
        });
    }
};

const getFieldIndices = (encoding, fieldsConfig) => {
    const [angleField, radiusField, colorField, sizeField] = [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ANGLE"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["RADIUS"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["COLOR"], _enums_constants__WEBPACK_IMPORTED_MODULE_1__["SIZE"]]
            .map(e => encoding[e].field);
    const [angleIndex, sizeIndex, radiusIndex] = [angleField, sizeField, radiusField]
        .map((e) => {
            const conf = fieldsConfig[e];
            if (conf && conf.def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE) {
                return conf.index;
            }
            return null;
        });
    const colorIndex = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, colorField, 'index');
    return {
        angleIndex,
        sizeIndex,
        radiusIndex,
        colorIndex
    };
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/arc-mixin.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/arc-mixin.js ***!
  \***********************************************************/
/*! exports provided: ArcLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcLayerMixin", function() { return ArcLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/arc/default-config.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _arc_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./arc-helper */ "./packages/visual-layer/src/layers/arc/arc-helper.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/arc/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);







const arc = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].arc;

const ArcLayerMixin = (superclass) => {
    return class extends superclass {
        constructor (data, axes, config, dependencies) {
            super(data, axes, config, dependencies);
            this._prevPieData = {};
        }

        /**
        * returns the default configuration of the layer
        *
        * @static
        * @return {Object} Default configuration for arc layer
        * @memberof ArcLayer
        */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_1__["defaultConfig"];
        }

        static formalName () {
            return 'arc';
        }

        elemType () {
            return 'path';
        }

        getNearestPoint (x, y, config = {}) {
            const dataPoint = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(config.event.target).data()[0];
            if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(dataPoint)) {
                const { source, rowId } = dataPoint;
                return {
                    id: this.getIdentifiersFromData(source, rowId),
                    layerId: this.id()
                };
            }
            return null;
        }

        translatePoints (data) {
            const { angle, color: colorAxis, radius: radiusAxis } = this.axes();
            const pieIndex = {};
            const prevData = this._points[0] || [];
            const points = [];
            const angleV = {};

            this._prevPieData = {};
            prevData.forEach((e, index) => {
                this._prevPieData[e.rowId] = [e, index];
                pieIndex[e.index] = e;
            });
            data.forEach((d, i) => {
                const angles = angle.getScaleValue(d.angle);
                if (angles) {
                    !angleV[d.angle] && (angleV[d.angle] = 0);
                    const { startAngle, endAngle } = angles[angleV[d.angle]++];
                    const uid = d.rowId;
                    const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["resolveEncodingValues"])({
                        values: {
                            radius: radiusAxis.getOuterRadius(d.radius),
                            radius0: radiusAxis.getInnerRadius(d.radius0),
                            color: colorAxis.getColor(d.color),
                            angle0: startAngle,
                            angle: endAngle,
                            startAngle,
                            endAngle,
                            startAngle0: startAngle,
                            endAngle0: endAngle
                        },
                        data: d
                    }, i, data, this);
                    const color = resolvedEncodings.color;
                    points.push({
                        source: d.source,
                        index: i,
                        enter: {},
                        update: {
                            angle0: resolvedEncodings.angle0,
                            angle: resolvedEncodings.angle,
                            radius0: resolvedEncodings.radius0,
                            radius: resolvedEncodings.radius
                        },
                        color,
                        meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getColorMetaInf"])({
                            fill: color
                        }, colorAxis),
                        rowId: uid,
                        _previousInfo: this._prevPieData[uid] ? this._prevPieData[uid][0] :
                            Object(_arc_helper__WEBPACK_IMPORTED_MODULE_4__["getPreviousPoint"])(pieIndex, i, this)
                    });
                }
            });
            return points;
        }

        render (container) {
            const measurement = this.measurement();
            const {
                classPrefix,
                defClassName,
                cornerRadius,
                padAngle,
                padRadius,
                transition
            } = this.config();
            const qualClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(defClassName, this.id(), classPrefix);
            // This returns a function that generates the arc path based on the datum provided
            const path = this._arcFn = arc()
                    .cornerRadius(cornerRadius)
                    .startAngle(d => d.update.angle0 + Math.PI / 2)
                    .endAngle(d => d.update.angle + Math.PI / 2)
                    .padAngle(padAngle)
                    .padRadius(padRadius)
                    .outerRadius(d => d.update.radius)
                    .innerRadius(d => d.update.radius0);

            this._points = this._normalizedData.map(arr => this.translatePoints(arr));
            const graphicElems = this._graphicElems = {};
            // Creating the group that holds all the arcs
            const g = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container), 'g', this._points, `${qualClassName[0]}-group`)
                    .classed(`${qualClassName[1]}-group`, true)
                    .attr('transform', `translate(${measurement.width / 2},
                        ${measurement.height / 2})`);
            const tween = (elem) => {
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(elem, 'path', d => [d], `${qualClassName[0]}-path`)
                    .style('fill', d => d.color)
                    .each(function (d) {
                        graphicElems[d.rowId] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                    })
                    .transition()
                    .duration(transition.duration)
                    .on('end', this.registerAnimationDoneHook())
                    .attrTween('d', (...params) => Object(_arc_helper__WEBPACK_IMPORTED_MODULE_4__["tweenPie"])(path, params))
                    .attr('class', (d, i) => {
                        const individualClass = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getIndividualClassName"])(d, i, this._points, this);
                        return `${qualClassName[0]}-path ${qualClassName[1]}-path-${d.index}
                            ${individualClass}`;
                    });
            };
            const consecutiveExits = [];
            let exitCounter = 0;
            const tweenExit = (elem, d) => {
                let exitArr = consecutiveExits[exitCounter];
                const oldExitCounter = exitCounter;
                if (!exitArr) {
                    exitArr = [{ elem, datum: d }];
                } else if (exitArr[exitArr.length - 1].datum.index === d.index - 1) {
                    exitArr.push({ elem, datum: d });
                } else {
                    exitCounter++;
                }
                consecutiveExits[oldExitCounter] = exitArr;
            };
            // Creating groups for all the arcs present individually
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(g, 'g', d => d, `${qualClassName[0]}`,
                {
                    update: tween,
                    exit: tweenExit
                })
                            .attr('class', (d, i) => `${qualClassName[0]} ${qualClassName[1]}-${i}`);
            Object(_arc_helper__WEBPACK_IMPORTED_MODULE_4__["tweenExitPie"])(consecutiveExits, transition, path);
            return this;
        }

        getPointsFromIdentifiers (identifiers) {
            if (!this.data()) {
                return [];
            }
            const fieldNames = identifiers[0];
            const values = identifiers.slice(1, identifiers.length);
            const pieSlices = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this.mount()).selectAll('path').data();
            const fieldsConfig = this.data().getFieldsConfig();

            const filteredPies = pieSlices.filter((tData) => {
                const { source, rowId } = tData;
                return fieldNames.every((field, idx) => {
                    if (field in fieldsConfig && fieldsConfig[field].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION) {
                        return values.findIndex(d => d[idx] === source[fieldsConfig[field].index]) !== -1;
                    } else if (field === muze_utils__WEBPACK_IMPORTED_MODULE_0__["ReservedFields"].ROW_ID) {
                        return values.findIndex(d => d[idx] === rowId) !== -1;
                    } return true;
                });
            });

            const pieSliceInf = filteredPies[0];
            if (pieSliceInf) {
                const measurement = this.measurement();
                const centroid = this._arcFn.centroid(pieSliceInf);
                return [{
                    x: centroid[0] + measurement.width / 2,
                    y: centroid[1] + measurement.height / 2,
                    width: 2,
                    height: 2
                }];
            }
            return [];
        }
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/arc.js":
/*!*****************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/arc.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ArcLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _arc_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arc-mixin */ "./packages/visual-layer/src/layers/arc/arc-mixin.js");




/**
 * Arc Layer creates a plot with polar coordinates.
 *
 * @public
 *
 * @class
 * @module ArcLayer
 * @extends BaseLayer
 */
class ArcLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayerMixin"], _arc_mixin__WEBPACK_IMPORTED_MODULE_2__["ArcLayerMixin"]) {
    static formalName () {
        return 'arc';
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/default-config.js":
/*!****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/default-config.js ***!
  \****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'layer-arc',
    padding: { top: 1, bottom: 1, left: 1, right: 1 },
    className: '',
    interaction: {
        highlight: [{
            type: 'fill',
            intensity: [0, 0, -15, 0]
        }],
        fade: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }],
        focus: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }]
    },
    height: 100,
    width: 100,
    sort: '',
    colors: ['#F44336', 'blue', 'green', 'yellow', 'orange', 'purple'],
    transform: {
        type: 'identity'
    },
    encoding: {
        'stroke-width': {
            value: '2px'
        },
        'stroke-linejoin': {
            value: 'round'
        },
        angle: {
            value: '1'
        },
        radius: {
            value: '1'
        },
        opacity: {
            value: '1'
        },
        color: {
            value: '1'
        },
        shape: {
            value: '1'
        },
        size: {
            value: '1'
        }
    },
    transition: {
        effect: 'cubic',
        duration: 500
    },
    states: {
        highlight: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-arc-highlight`
        },
        fadeout: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-arc-fadeout`
        },
        selected: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-arc-selected`
        }
    }
};



/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/index.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/index.js ***!
  \*******************************************************/
/*! exports provided: ArcLayer, ArcLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc */ "./packages/visual-layer/src/layers/arc/arc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcLayer", function() { return _arc__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _arc_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arc-mixin */ "./packages/visual-layer/src/layers/arc/arc-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcLayerMixin", function() { return _arc_mixin__WEBPACK_IMPORTED_MODULE_1__["ArcLayerMixin"]; });





/***/ }),

/***/ "./packages/visual-layer/src/layers/arc/styles.scss":
/*!**********************************************************!*\
  !*** ./packages/visual-layer/src/layers/arc/styles.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/area/area-mixin.js":
/*!*************************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/area-mixin.js ***!
  \*************************************************************/
/*! exports provided: AreaLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLayerMixin", function() { return AreaLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/area/default-config.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/area/renderer.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/area/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");







/**
 * Area layer renders a closed path. The mark type of this layer is ```area```. This layer can be used
 * to create stacked or multi-series areas and vertical range area plots by using the encoding properties.
 *
 * To create this layer using layer configuration from canvas,
 * ```
 *      canvas.layers([{
 *          mark: 'area',
 *          transform: {
 *              type: 'stack' // Produces a stacked area.
 *          }
 *      }]);
 * ```
 *
 * @public
 *
 * @class
 * @module AreaLayer
 * @extends LineLayer
 */
const AreaLayerMixin = (superclass) => {
    return class extends superclass {

        /** Default configuration of area layer
         *
         * @return {Object} Default configuration of layer
        */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_1__["defaultConfig"];
        }

        /**
         * Calculates the domain from data. It calls its parent class's method which is line layer
         * to get the domain and overwrites the domain according to its need.
         * @return {Array} Domain values
         */
        calculateDomainFromData (data, encodingFieldsInf, fieldsConfig) {
            const domains = super.calculateDomainFromData(data, fieldsConfig);
            [_enums_constants__WEBPACK_IMPORTED_MODULE_4__["ENCODING"].X, _enums_constants__WEBPACK_IMPORTED_MODULE_4__["ENCODING"].Y].forEach((type) => {
                const { [`${type}FieldType`]: fieldType } = encodingFieldsInf;
                if (fieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE && Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(domains[type], 'length')) {
                    domains[type][0] = Math.min(domains[type][0], 0);
                    domains[type][1] = Math.max(0, domains[type][1]);
                }
            });
            return domains;
        }

        /**
         * Returns the drawing method of this layer
         * @return {Function} Draw method
         */
        getDrawFn () {
            return _renderer__WEBPACK_IMPORTED_MODULE_2__["default"];
        }

        /**
         * Generates the x and y positions for each point
         * @param {Array} data Data Array
         * @param {Object} encoding Visual Encodings of the layer
         * @param {Object} axes Contains the axis
         * @return {Array} Array of points
         */
        translatePoints (data) {
            let points = [];
            const transformType = this.transformType();
            const axes = this.axes();
            const colorAxis = axes.color;
            const config = this.config();
            const fieldsConfig = this.data().getFieldsConfig();
            const { xField, yField, y0Field } = this.encodingFieldsInf();
            const { x: xAxis, y: yAxis } = axes;
            const classNameFn = config.individualClassName;
            const isXDim = fieldsConfig[xField] && fieldsConfig[xField].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
            const isYDim = fieldsConfig[yField] && fieldsConfig[yField].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
            const key = isXDim ? 'x' : (isYDim ? 'y' : null);
            const minYVal = yAxis.domain()[0];
            const basePos = minYVal < 0 ? yAxis.getScaleValue(0) : yAxis.getScaleValue(minYVal);
            Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["sortData"])(data, axes);
            points = data.map((d, i) => {
                let color;
                const xPx = xAxis.getScaleValue(d.x) + xAxis.getUnitWidth() / 2;
                const yPx = yAxis.getScaleValue(d.y);
                const y0Px = (y0Field || transformType === _enums_constants__WEBPACK_IMPORTED_MODULE_4__["STACK"]) ? yAxis.getScaleValue(d.y0) : basePos;
                color = colorAxis.getColor(d.color);
                const invalidY = d.y instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"];
                const invalidY0 = d.y0 instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"];
                const resolvedValues = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["resolveEncodingValues"])({
                    values: {
                        x: xPx,
                        y: yPx,
                        y0: y0Px,
                        color
                    },
                    data: d
                }, i, data, this);
                color = resolvedValues.color;
                const style = {
                    fill: color
                };

                const point = {
                    enter: {
                        x: xPx,
                        y: invalidY ? null : basePos,
                        y0: invalidY0 ? null : basePos
                    },
                    update: {
                        x: xPx,
                        y: invalidY ? null : resolvedValues.y,
                        y0: invalidY0 ? null : resolvedValues.y0
                    },
                    source: d.source,
                    rowId: d.rowId,
                    className: classNameFn ? classNameFn(d, i, data, this) : '',
                    style,
                    meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getColorMetaInf"])(style, colorAxis)
                };
                point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getIndividualClassName"])(d, i, data, this);
                this.cachePoint(d[key], point);
                return point;
            });
            points = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["positionPoints"])(this, points);
            points = points.filter((point) => {
                const update = point.update;
                return !isNaN(update.x) && !isNaN(update.y);
            });
            return points;
        }

        resolveTransformType () {
            this._transformType = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getValidTransformForAggFn"])(this);
        }

        /**
         * Get the css styles need to be applied on the line path
         * @param {string} color Color value
         * @return {Object} Path styles
         */
        getPathStyle (color) {
            return {
                fill: color
            };
        }
    }
}



/***/ }),

/***/ "./packages/visual-layer/src/layers/area/area.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/area.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AreaLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _line_line_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../line/line-mixin */ "./packages/visual-layer/src/layers/line/line-mixin.js");
/* harmony import */ var _area_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./area-mixin */ "./packages/visual-layer/src/layers/area/area-mixin.js");






/**
 * Area layer renders a closed path. The mark type of this layer is ```area```. This layer can be used
 * to create stacked or multi-series areas and vertical range area plots by using the encoding properties.
 *
 * To create this layer using layer configuration from canvas,
 * ```
 *      canvas.layers([{
 *          mark: 'area',
 *          transform: {
 *              type: 'stack' // Produces a stacked area.
 *          }
 *      }]);
 * ```
 *
 * @public
 *
 * @class
 * @module AreaLayer
 * @extends LineLayer
 */
class AreaLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayerMixin"], _line_line_mixin__WEBPACK_IMPORTED_MODULE_3__["LineLayerMixin"], _area_mixin__WEBPACK_IMPORTED_MODULE_4__["AreaLayerMixin"]) {
    static formalName () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_1__["AREA_LAYER"];
    }
}



/***/ }),

/***/ "./packages/visual-layer/src/layers/area/default-config.js":
/*!*****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/default-config.js ***!
  \*****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'layer-area',
    className: '',
    interpolate: 'linear',
    transform: {
        type: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["STACK"]
    },
    interaction: {

    },
    nearestPointThreshold: 10,
    encoding: {
        color: {},
        x: {},
        y: {},
        y0: {},
        strokeOpacity: {
            value: 1
        }
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    connectNullData: false
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/area/index.js":
/*!********************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/index.js ***!
  \********************************************************/
/*! exports provided: AreaLayer, AreaLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area */ "./packages/visual-layer/src/layers/area/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AreaLayer", function() { return _area__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _area_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area-mixin */ "./packages/visual-layer/src/layers/area/area-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AreaLayerMixin", function() { return _area_mixin__WEBPACK_IMPORTED_MODULE_1__["AreaLayerMixin"]; });




/***/ }),

/***/ "./packages/visual-layer/src/layers/area/renderer.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/renderer.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const area = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].area;
/**
 * Draws a line from the points
 * Generates a svg path string
 * @param {Object} params Contains container, points and interpolate attribute.
 */
const /* istanbul ignore next */ drawArea = (params) => {
    let filteredPoints;
    const { layer, container, points, style, transition, className, connectNullData, interpolate } = params;

    const { effect: easeEffect, duration } = transition;
    const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
    const curveInterpolatorFn = muze_utils__WEBPACK_IMPORTED_MODULE_0__["pathInterpolators"][interpolate];
    const selection = mount.selectAll('path').data(points.length ? [points[0].className] : []);
    const [enterAreaPath, updateAreaPath] = ['enter', 'update'].map(e => area().curve(curveInterpolatorFn)
                    .x(d => d[e].x)
                    .y1(d => d[e].y)
                    .y0(d => d[e].y0)
                    .defined(d => d[e].y !== null
            ));

    filteredPoints = points;
    mount.attr('class', className);
    if (connectNullData) {
        filteredPoints = points.filter(d => d.update.y !== null);
    }
    const selectionEnter = selection.enter().append('path').attr('d', enterAreaPath(filteredPoints));
    selection.merge(selectionEnter).transition().ease(muze_utils__WEBPACK_IMPORTED_MODULE_0__["easeFns"][easeEffect])
                    .duration(duration)
                    .on('end', layer.registerAnimationDoneHook())
                    .attr('d', updateAreaPath(filteredPoints))
                    .each(function (d) {
                        const element = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                        element.attr('class', d);
                        Object.keys(style).forEach(key => element.style(key, style[key]));
                    });
};

/* harmony default export */ __webpack_exports__["default"] = (drawArea);


/***/ }),

/***/ "./packages/visual-layer/src/layers/area/styles.scss":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/area/styles.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/bar-helper.js":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/bar-helper.js ***!
  \************************************************************/
/*! exports provided: getTranslatedPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslatedPoints", function() { return getTranslatedPoints; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");




const positionRetriever = {
    x: (xPx, isNegativeVal, barBasePos) => (isNegativeVal ? [xPx, barBasePos] : [barBasePos, xPx]),
    y: (yPx, isNegativeVal, barBasePos) => (isNegativeVal ? [barBasePos, yPx] : [yPx, barBasePos])
};

/**
 *
 *
 * @param {*} type
 * @param {*} fieldInfo
 * @param {*} config
 * @param {*} data
 *
 */
const resolveDimByField = (type, axesInfo, config, data) => {
    const spaceType = type === 'x' ? 'width' : 'height';
    const [fieldType, axis] = [config[`${type}FieldType`], axesInfo[`${type}Axis`]];
    const {
        transformType,
        sizeEncoding,
        sizeConfig,
        measurement
    } = config;

    const sizeValue = sizeEncoding.value;
    let enter = 0;
    let pos;
    let space = 0;
    let enterSpace = 0;
    if (fieldType !== undefined) {
        if (config[`${type}0Field`]) {
            const minVal = data[type];
            const maxVal = data[`${type}0`];
            let min;
            let max;
            if (minVal === null || maxVal === null) {
                return {
                    enterSpace: undefined,
                    enter: undefined,
                    pos: undefined,
                    space: undefined
                };
            } else if (fieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS || fieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
                min = Math.min(minVal, maxVal);
                max = Math.max(minVal, maxVal);
            } else {
                min = minVal;
                max = maxVal;
            }
            const scales = type === 'x' ? [min, max] : [max, min];
            pos = axis.getScaleValue(scales[0]) + axis.getUnitWidth() / 2;
            space = Math.abs(axis.getScaleValue(scales[1]) - pos) + axis.getUnitWidth() / 2;

            enter = pos;
            enterSpace = 0;
        } else if (fieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL || fieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
            pos = axis.getScaleValue(data[type]) +
                (sizeConfig[type === 'x' ? 'barWidthOffset' : 'barHeightOffset'] || 0);

            space = sizeConfig[type === 'x' ? 'barWidth' : 'barHeight'];
            if (sizeValue !== undefined) {
                const diffPx = sizeValue * space;
                space -= diffPx;
                pos += diffPx / 2;
            }
            enter = pos;
            enterSpace = space;
        } else {
            const minDomVal = axis.domain()[0];
            const barBasePos = minDomVal < 0 ? axis.getScaleValue(0) : axis.getScaleValue(minDomVal);
            pos = axis.getScaleValue(data[type]);
            let endPos = axis.getScaleValue(data[`${type}0`]);

            enterSpace = 0;
            const isNegativeVal = data[type] < 0;
            if (transformType !== _enums_constants__WEBPACK_IMPORTED_MODULE_1__["STACK"]) {
                [pos, endPos] = positionRetriever[type](pos, isNegativeVal, barBasePos);
            }
            space = Math.abs(pos - endPos);
            enter = barBasePos;
        }
    } else {
        pos = 0;
        space = measurement[spaceType];
    }

    return {
        enterSpace,
        enter,
        pos,
        space
    };
};

/**
 *
 *
 * @param {*} data
 * @param {*} config
 * @param {*} axes
 *
 */
const resolveDimensions = (data, config, axes) => {
    const axesInfo = {
        xAxis: axes.x,
        yAxis: axes.y
    };
    const {
        enterSpace: enterWidth,
        enter: enterX,
        pos: xPos,
        space: width
    } = resolveDimByField('x', axesInfo, config, data);

    const {
        enterSpace: enterHeight,
        enter: enterY,
        pos: yPos,
        space: height
    } = resolveDimByField('y', axesInfo, config, data);
    return {
        enter: {
            x: enterX,
            y: enterY,
            width: enterWidth,
            height: enterHeight
        },
        update: {
            x: xPos,
            y: yPos,
            width,
            height
        }
    };
};

/**
 * Generates an array of objects containing x, y, width and height of the bars from the data
 * @param  {Array.<Array>} data Data Array
 * @param  {Object} encoding  Config
 * @param  {Object} axes     Axes object
 * @param {Object} conf config object for point generation
 * @return {Array.<Object>}  Array of points
 */
const getTranslatedPoints = (context, data, sizeConfig) => {
    let points = [];
    const encoding = context.config().encoding;
    const axes = context.axes();
    const colorAxis = axes.color;
    const sizeEncoding = encoding.size || {};
    const {
            x0Field,
            y0Field,
            xFieldSubType,
            yFieldSubType
        } = context.encodingFieldsInf();
    const measurement = context.measurement();
    const isXDim = xFieldSubType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL || xFieldSubType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL;
    const isYDim = yFieldSubType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL || yFieldSubType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL;
    const key = isXDim ? 'x' : (isYDim ? 'y' : null);
    const transformType = context.transformType();

    for (let i = 0, len = data.length; i < len; i++) {
        const d = data[i];
        const dimensions = resolveDimensions(d, {
            xFieldType: xFieldSubType,
            yFieldType: yFieldSubType,
            x0Field,
            y0Field,
            transformType,
            measurement,
            sizeConfig,
            sizeEncoding
        }, axes);

        let color = colorAxis.getColor(d.color);

        const update = dimensions.update;
        const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["resolveEncodingValues"])({
            values: {
                x: update.x,
                y: update.y,
                width: update.width,
                height: update.height,
                color
            },
            data: d
        }, i, data, context);
        color = resolvedEncodings.color;
        const { x, y, width, height } = resolvedEncodings;
        const style = {
            fill: color
        };

        if (!isNaN(x) && !isNaN(y) && d.rowId !== undefined) {
            let point = null;
            point = {
                enter: dimensions.enter,
                update: {
                    x,
                    y,
                    width,
                    height
                },
                source: d.source,
                rowId: d.rowId,
                style,
                meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["getColorMetaInf"])(style, colorAxis)
            };
            point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["getIndividualClassName"])(d, i, data, context);
            points.push(point);
            // Store each point in a hashmap with key as the dimensional or temporal field value
            context.cachePoint(d[key], point);
        }
    }

    points = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["positionPoints"])(context, points);
    return points;
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/bar-mixin.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/bar-mixin.js ***!
  \***********************************************************/
/*! exports provided: BarLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BarLayerMixin", function() { return BarLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/bar/renderer.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/bar/default-config.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/bar/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _bar_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bar-helper */ "./packages/visual-layer/src/layers/bar/bar-helper.js");








const { MEASURE } = muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"];

const BarLayerMixin = (superclass) => {
    return class  extends superclass {
        /**
         * Creates an instance of bar layer
         */
        constructor (...params) {
            super(...params);
            this._bandScale = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Scales"].band();
            this._plotPadding = {
                x: 0,
                y: 0
            };
            this._plotSpan = {
                x: 0,
                y: 0
            };
            this._pointMap = {};
        }

        elemType () {
            return 'rect';
        }


        /**
         * Returns the default configuration of the bar layer
         * @return {Object} Default configuration of the bar layer
         */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_3__["defaultConfig"];
        }

        static defaultPolicy (conf, userConf) {
            const config = _base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"].defaultPolicy(conf, userConf);
            const encoding = config.encoding;
            const colorField = encoding.color.field;
            const transform = config.transform;

            if (colorField) {
                transform.groupBy = colorField;
            }
            return config;
        }

        calculateDomainFromData (data, encodingFieldInf, fieldsConfig) {
            const domain = super.calculateDomainFromData(data, encodingFieldInf, fieldsConfig);
            ['x', 'y'].forEach((d) => {
                if (encodingFieldInf[`${d}FieldType`] === MEASURE && Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(domain[d], 'length')) {
                    if (encodingFieldInf[`${d}0Field`]) {
                        domain[d] = domain[d].sort((a, b) => a - b);
                    } else {
                        domain[d][0] = Math.min(domain[d][0], 0);
                        domain[d][1] = Math.max(0, domain[d][1]);
                    }
                }
            });
            return domain;
        }

        /**
         * Generates an array of objects containing x, y, width and height of the bars from the data
         * @param  {Array.<Array>} data Data Array
         * @param  {Object} encoding  Config
         * @param  {Object} axes     Axes object
         * @param {Object} conf config object for point generation
         * @return {Array.<Object>}  Array of points
         */
        translatePoints (data, sizeConfig) {
            return Object(_bar_helper__WEBPACK_IMPORTED_MODULE_6__["getTranslatedPoints"])(this, data, sizeConfig);
        }

        /**
         * Renders the plot in the given container
         * @param  {SVGGroup} container SVGGroup where plot will be rendered.
         * @return {BarLayer} Instance of bar layer.
         */
        render (container) {
            const config = this.config();
            const transition = config.transition;
            const normalizedDataArr = this._normalizedData;
            const transformedData = this._transformedData;
            const keys = transformedData.map(d => d.key);
            const fieldsConfig = this.data().getFieldsConfig();
            const axes = this.axes();
            const height = axes.y && axes.y.scale().range()[0];
            const width = axes.x && axes.x.scale().range()[1];
            const defClassName = config.defClassName;
            const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(defClassName, this.id(), config.classPrefix);
            const className = config.className;
            const containerSelection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
            const dimensions = Object.values(fieldsConfig).filter(e => e.def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION)
                .map(e => e.index);
            containerSelection.classed(qualifiedClassName.join(' '), true);
            containerSelection.classed(className, true);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["clipElement"])(container, {
                x: 0,
                y: 0,
                width,
                height
            }, `id-${this.id()}`);

            this._points = this.generateDataPoints(normalizedDataArr, keys);
            this._graphicElems = {};

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["createElements"])({
                data: this._points,
                container,
                selector: 'g',
                append: 'g',
                each: (points, group, i) => {
                    const seriesClassName = `${qualifiedClassName[0]}-${keys[i] || i}`.toLowerCase();
                    group.style('display', 'block');
                    Object(_renderer__WEBPACK_IMPORTED_MODULE_2__["drawRects"])({
                        layer: this,
                        container: group.node(),
                        points,
                        className: seriesClassName,
                        transition,
                        style: {},
                        keyFn: d => dimensions.map(key => d.source[key]).join('-')
                    });
                }
            });
            return this;
        }

        generateDataPoints (normalizedData, keys) {
            const [barWidthMetrics, barHeightMetrics] = Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["getPlotMeasurement"])(this, keys);
            const barWidthOffsets = barWidthMetrics.offsetValues || [];
            const barHeightOffsets = barHeightMetrics.offsetValues || [];
            this._plotSpan = {
                x: barWidthMetrics.groupSpan || 0,
                y: barHeightMetrics.groupSpan || 0
            };
            this._plotPadding = {
                x: barWidthMetrics.padding || 0,
                y: barHeightMetrics.padding || 0
            };

            this._pointMap = {};
            return normalizedData.map((data, i) => this.translatePoints(data,
                {
                    barWidth: barWidthMetrics.span,
                    barWidthOffset: barWidthOffsets[i] || 0,
                    barHeight: barHeightMetrics.span,
                    barHeightOffset: barHeightOffsets[i] || 0
                }));
        }

        getPlotPadding () {
            return this._plotPadding;
        }

        resolveTransformType () {
            this._transformType = Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["getValidTransformForAggFn"])(this);
        }

        /**
         * Gets the nearest point of the position passed.
         * @param {number} x x position
         * @param {number} y y position
         * @return {Object} Nearest point.
         */
        getNearestPoint (x, y) {
            if (!this.data()) {
                return null;
            }
            let axis;
            let value;
            let points;
            let uniqueFieldType;
            let uniqueFieldIndex;
            let filterData;
            let identifiers;
            let pointFound = null;
            const dataModel = this.data();
            const dataObj = dataModel.getData();
            const fieldsConfig = dataModel.getFieldsConfig();
            const axes = this.axes();
            const data = dataObj.data;
            const pointMap = this._pointMap;
            const {
                    xField,
                    yField,
                    xFieldSubType,
                    yFieldSubType
                } = this.encodingFieldsInf();

            if (xFieldSubType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS) {
                axis = axes.y;
                value = axis.invert(y);
                uniqueFieldIndex = fieldsConfig[yField].index;
                uniqueFieldType = yFieldSubType;
            } else {
                axis = axes.x;
                value = axis.invert(x);
                uniqueFieldIndex = fieldsConfig[xField].index;
                uniqueFieldType = xFieldSubType;
            }

            if (uniqueFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL) {
                points = pointMap[value];
            }

            if (uniqueFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
                filterData = [...new Set(data.map(d => d[uniqueFieldIndex]))];
                value = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getNearestValue"])(filterData, value);
                points = pointMap[value];
            }
            const len = points && points.length;
            points && points.sort((p1, p2) => p1.update.y - p2.update.y);
            for (let i = 0; i < len; i++) {
                const point = points[i];
                const update = point.update;
                if (x >= update.x && x <= (update.width + update.x) && y >= update.y && y <= (update.height + update.y)) {
                    pointFound = point;
                    break;
                }
                pointFound = null;
            }

            const values = pointFound && pointFound.source;
            if (values) {
                identifiers = this.getIdentifiersFromData(values, pointFound.rowId);
            }
            return pointFound ? {
                dimensions: [pointFound.update],
                id: identifiers,
                layerId: this.id()
            } : pointFound;
        }

        getPlotSpan () {
            return this._plotSpan;
        }

        hasPlotSpan () {
            return true;
        }
    }
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/bar.js":
/*!*****************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/bar.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BarLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _bar_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bar-mixin */ "./packages/visual-layer/src/layers/bar/bar-mixin.js");
/* harmony import */ var _base_layer_base_mixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../base-layer/base-mixin */ "./packages/visual-layer/src/base-layer/base-mixin.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/bar/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);








/**
 * Bar layer creates rectangle marks. The mark type of this layer is ```bar```. This layer can be used
 * to create stacked or grouped bars, range bars, heatmap plots and also reference bands by using
 * the encoding properties.
 *
 * @public
 *
 * @class
 * @module BarLayer
 * @extends BaseLayer
 */
class BarLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"]).with(_base_layer_base_mixin__WEBPACK_IMPORTED_MODULE_4__["BaseLayerMixin"], _bar_mixin__WEBPACK_IMPORTED_MODULE_3__["BarLayerMixin"]) {
    static formalName () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_2__["BAR_LAYER"];
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/default-config.js":
/*!****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/default-config.js ***!
  \****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'layer-bar',
    className: '',
    interaction: {
        highlight: [{
            type: 'fill',
            intensity: [0, 0, -15, 0]
        }],
        fade: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }],
        focus: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }]
    },
    transform: {
        type: 'stack'
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    innerPadding: 0.1,
    encoding: {
        color: {},
        x: {},
        y: {},
        x0: {},
        y0: {}
    },
    states: {
        highlight: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-bar-highlight`
        },
        fadeout: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-bar-fadeout`
        },
        selected: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-bar-selected`
        }
    }
};



/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/index.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/index.js ***!
  \*******************************************************/
/*! exports provided: BarLayer, BarLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bar */ "./packages/visual-layer/src/layers/bar/bar.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarLayer", function() { return _bar__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _bar_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bar-mixin */ "./packages/visual-layer/src/layers/bar/bar-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarLayerMixin", function() { return _bar_mixin__WEBPACK_IMPORTED_MODULE_1__["BarLayerMixin"]; });




/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/renderer.js":
/*!**********************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/renderer.js ***!
  \**********************************************************/
/*! exports provided: drawRects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawRects", function() { return drawRects; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 *
 *
 * @param {*} elem
 * @param {*} datum
 * @param {*} index
 * @param {*} context
 */
const transitionBars = (layer, elem, datum, index, context) => {
    const { transition } = context;
    const { duration, disabled, effect } = transition;
    const selection = elem;

    const selTransition = disabled ? selection :
        selection.transition()
        .duration(duration)
        .ease(muze_utils__WEBPACK_IMPORTED_MODULE_0__["easeFns"][effect])
        .on('end', layer.registerAnimationDoneHook());
    const update = datum.update || datum;
    const updateStyle = datum.style || {};
    datum.className && selection.classed(datum.className, true);
    Object.entries(update).forEach(attr => (!isNaN(attr[1]) && selTransition.attr(attr[0], attr[1])));
    Object.entries(updateStyle).forEach(styleObj => selection.style(styleObj[0], styleObj[1]));
};

/**
 *
 *
 * @param {*} elem
 * @param {*} d
 */
const barEnterFn = (elem, d) => {
    const selection = elem;
    const enter = d.enter || {};
    Object.entries(enter).forEach(attr => (!isNaN(attr[1]) && selection.attr(attr[0], attr[1])));
};

/**
 * Draws rectangles by using d3 selection
 * @param  {Object} params Contains container element and points
 * @return {Selection} Bar Selection
 */
/* istanbul ignore next */ const drawRects = (params) => {
    const { layer, points, container, keyFn } = params;
    const graphicElems = layer._graphicElems;
    const updateFns = {
        enter (elem, d) { barEnterFn(elem, d); },
        update (elem, d, i) {
            graphicElems[d.rowId] = elem;
            transitionBars(layer, elem, d, i, params);
        }
    };
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'rect', points, null, updateFns, keyFn);
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/bar/styles.scss":
/*!**********************************************************!*\
  !*** ./packages/visual-layer/src/layers/bar/styles.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/line/default-config.js":
/*!*****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/default-config.js ***!
  \*****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'layer-line',
    className: '',
    interpolate: 'linear',
    transform: {
        type: 'group'
    },
    interaction: {
        highlight: [{
            type: 'stroke',
            intensity: [0, 0, -15, 0]
        }],
        fade: [{
            type: 'stroke',
            intensity: [0, 0, +15, 0]
        }],
        focus: [{
            type: 'stroke',
            intensity: [0, 0, +15, 0]
        }]
    },
    nearestPointThreshold: 20,
    encoding: {
        color: {},
        x: {},
        y: {},
        strokeOpacity: {
            value: 1
        }
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    connectNullData: false
};



/***/ }),

/***/ "./packages/visual-layer/src/layers/line/index.js":
/*!********************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/index.js ***!
  \********************************************************/
/*! exports provided: LineLayer, LineLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line */ "./packages/visual-layer/src/layers/line/line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineLayer", function() { return _line__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _line_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line-mixin */ "./packages/visual-layer/src/layers/line/line-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineLayerMixin", function() { return _line_mixin__WEBPACK_IMPORTED_MODULE_1__["LineLayerMixin"]; });




/***/ }),

/***/ "./packages/visual-layer/src/layers/line/line-mixin.js":
/*!*************************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/line-mixin.js ***!
  \*************************************************************/
/*! exports provided: LineLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLayerMixin", function() { return LineLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/line/renderer.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/line/default-config.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/line/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);








/**
 * This layer is used to render straight or smoothed line paths. The mark type of this layer is ```line```.
 *
 * @public
 *
 * @class
 * @module LineLayer
 * @extends BaseLayer
 */
const LineLayerMixin = (superclass) => {
    return class extends superclass {
        /**
         * Creates an instance of LineLayer.
         *
         * @param {*} args
         * @memberof LineLayer
         */
        constructor (...args) {
            super(...args);
            this._voronoi = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["Voronoi"]();
        }

        static formalName () {
            return 'line';
        }

        elemType () {
            return 'path';
        }

        /**
         * Default configuration of line layer
         * @return {Object} Default configuration of layer
         */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"];
        }

        static defaultPolicy (conf, userConf) {
            const config = super.defaultPolicy(conf, userConf);
            const encoding = config.encoding;
            const transform = config.transform;
            const colorField = encoding.color && encoding.color.field;

            if (colorField && !transform.groupBy) {
                transform.groupBy = colorField;
            }
            return config;
        }

        /**
         * Returns the draw method for line
         * @return {Function} Draw method of line layer
         */
        getDrawFn () {
            return _renderer__WEBPACK_IMPORTED_MODULE_1__["drawLine"];
        }

        static shouldDrawAnchors () {
            return true;
        }

        /**
         * Generates the x and y positions for each point
         * @param {Array} data Data Array
         * @param {Object} encoding Visual Encodings of the layer
         * @param {Object} axes Contains the axis
         * @param {number} seriesIndex index of series
         * @return {Array} Array of points
         */
        translatePoints (data) {
            let points = [];
            const axes = this.axes();
            const xAxis = axes.x;
            const yAxis = axes.y;
            const colorAxis = axes.color;
            const { xFieldType, yFieldType } = this.encodingFieldsInf();
            const isXDim = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
            const isYDim = yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
            const key = isXDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].X : (isYDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_3__["ENCODING"].Y : null);
            Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["sortData"])(data, axes);
            points = data.map((d, i) => {
                const xPx = xAxis.getScaleValue(d.x) + xAxis.getUnitWidth() / 2;
                const yPx = yAxis.getScaleValue(d.y) + yAxis.getUnitWidth() / 2;
                const color = colorAxis.getColor(d.color);

                const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["resolveEncodingValues"])({
                    values: {
                        x: xPx,
                        y: yPx,
                        color
                    },
                    data: d
                }, i, data, this);

                const point = {
                    enter: {},
                    update: {
                        x: d.x instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"] ? null : resolvedEncodings.x,
                        y: d.y instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["InvalidAwareTypes"] ? null : resolvedEncodings.y
                    },
                    style: {
                        stroke: resolvedEncodings.color,
                        'fill-opacity': 0
                    },
                    rowId: d.rowId,
                    source: d.source,
                    meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["getColorMetaInf"])({
                        stroke: resolvedEncodings.color
                    }, colorAxis)
                };
                point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["getIndividualClassName"])(d, i, data, this);
                this.cachePoint(d[key], point);
                return point;
            });
            points = Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["positionPoints"])(this, points);

            points = points.filter((point) => {
                const { update } = point;
                return !isNaN(update.x) && !isNaN(update.y);
            });
            return points;
        }

        /**
         * Renders the line plot
         * @param {SVGElement} container svg element
         * @return {LineLayer} instance of line layer
         */
        render (container) {
            let points;
            let seriesClassName;
            let style;

            const config = this.config();
            const {
                encoding,
                interpolate,
                className,
                defClassName,
                transition
            } = config;
            const normalizedData = this._normalizedData;
            const transformedData = this._transformedData;
            const fieldsConfig = this.data().getFieldsConfig();
            const axes = this.axes();
            const keys = transformedData.map(d => d.key);
            const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(defClassName, this.id(), config.classPrefix);
            const containerSelection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
            const colorField = encoding.color.field;
            const colorFieldIndex = fieldsConfig[colorField] && fieldsConfig[colorField].index;

            this._points = [];
            this._pointMap = {};
            containerSelection.classed(qualifiedClassName.join(' '), true);
            containerSelection.classed(className, true);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'g', normalizedData, null, {
                enter: (group) => {
                    Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["animateGroup"])(group, {
                        transition,
                        groupAnimateStyle: {
                            enter: {
                                'stroke-opacity': 0,
                                'fill-opacity': this.getPathStyle()['fill-opacity']
                            },
                            update: {
                                'stroke-opacity': encoding.strokeOpacity.value
                            }
                        }
                    });
                },
                update: (group, dataArr, i) => {
                    points = this.translatePoints(dataArr);
                    this._points.push(points);
                    seriesClassName = `${qualifiedClassName[0]}-${keys[i] || i}`.toLowerCase();

                    let color;
                    const colorValFn = encoding.color.value;
                    const colorVal = points.find(d => d.source[colorFieldIndex] !== null &&
                            d.source[colorFieldIndex] !== undefined);

                    if (colorValFn) {
                        color = colorValFn(dataArr, i, normalizedData);
                    } else {
                        color = axes.color.getColor(colorVal && colorVal.source[colorFieldIndex]);
                    }

                    style = this.getPathStyle(color);
                    this.getDrawFn()({
                        layer: this,
                        container: group.node(),
                        interpolate,
                        points,
                        className: seriesClassName,
                        transition,
                        style: style || {},
                        connectNullData: config.connectNullData
                    });
                }
            }, d => d[0].source[colorFieldIndex] || d[0].rowId);

            Object(_helpers__WEBPACK_IMPORTED_MODULE_4__["attachDataToVoronoi"])(this._voronoi, this._points);
            return this;
        }

        /**
         * Get the css styles need to be applied on the line path
         * @param {string} color Color value
         * @return {Object} Path styles
         */
        getPathStyle (color) {
            return {
                stroke: color,
                'fill-opacity': '0'
            };
        }

        /**
         * Gets the nearest point closest to the given position
         * @param {number} x x position
         * @param {number} y y position
         * @return {Object} Nearest point information
         */
        getNearestPoint (x, y, config) {
            let searchRadius = config.searchRadius;
            const data = this.data();

            if (!data || (data && data.isEmpty())) {
                return null;
            }

            searchRadius = searchRadius !== undefined ? searchRadius : this.config().nearestPointThreshold;
            const point = this._voronoi.find(x, y, searchRadius);
            const dimensions = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(point, 'data', 'data', 'update');

            if (point) {
                const { source, rowId } = point.data.data;
                const identifiers = this.getIdentifiersFromData(source, rowId);
                return {
                    id: identifiers,
                    dimensions: [{
                        x: dimensions.x,
                        y: dimensions.y,
                        width: 2,
                        height: 2
                    }],
                    layerId: this.id()
                };
            }
            return null;
        }
    }
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/line/line.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/line.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _line_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-mixin */ "./packages/visual-layer/src/layers/line/line-mixin.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");





/**
 * This layer is used to render straight or smoothed line paths. The mark type of this layer is ```line```.
 *
 * @public
 *
 * @class
 * @module LineLayer
 * @extends BaseLayer
 */
class LineLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayerMixin"], _line_mixin__WEBPACK_IMPORTED_MODULE_2__["LineLayerMixin"]) {
    static formalName () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_3__["LINE_LAYER"];
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/line/renderer.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/renderer.js ***!
  \***********************************************************/
/*! exports provided: drawLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLine", function() { return drawLine; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");



const line = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].line;

const filterFn = (d) => {
    const { update } = d;
    return update.y !== null && update.x !== null;
};

/**
 * Draws a line from the points
 * Generates a svg path string
 * @param {Object} params Contains container, points and interpolate attribute.
 */
const drawLine = (context) => {
    let filteredPoints;
    const { layer, container, points, interpolate, connectNullData, className, style, transition } = context;
    const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container).attr('class', className);
    const curveInterpolatorFn = muze_utils__WEBPACK_IMPORTED_MODULE_0__["pathInterpolators"][interpolate];
    const linepath = line()
                .curve(curveInterpolatorFn)
                .x(d => d.update.x)
                .y(d => d.update.y)
                .defined(filterFn);

    filteredPoints = points;
    if (connectNullData) {
        filteredPoints = points.filter(filterFn);
    }

    Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["updateStyle"])(mount, style);
    let element = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'path', points.length ? [points[0].className] : []);
    element.attr('class', d => d);
    if (!transition.disabled) {
        element = element.transition()
        .duration(transition.duration)
        .on('end', layer.registerAnimationDoneHook());
    }
    element.attr('d', linepath(filteredPoints))
                    .style('fill-opacity', 0);
    return element;
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/line/styles.scss":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/line/styles.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/point/default-config.js":
/*!******************************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/default-config.js ***!
  \******************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    defClassName: 'layer-point',
    className: '',
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defColorStyle: 'stroke',
    interaction: {
        highlight: [{
            type: 'stroke',
            intensity: [0, 0, 0, +1]
        }],
        fade: [{
            type: 'fill',
            intensity: [0, 0, +20, 0]
        }],
        focus: [{
            type: 'fill',
            intensity: [0, 0, +20, 0]
        }
        ]
    },
    innerPadding: 0.1,
    nearestPointThreshold: 10,
    transform: {
        type: 'identity'
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    encoding: {
        size: {
            value: 30
        },
        color: {},
        stroke: {
            value: 'hsla(0,0%,0%,0)'
        },
        fill: {},
        shape: {
            value: 'circle'
        },
        x: {},
        y: {},
        strokeOpacity: {
            value: 0.5
        },
        fillOpacity: {
            value: 0.5
        }
    },
    shapes: ['circle', 'cross', 'diamond', 'square', 'star', 'wye', 'triangle'],
    sizes: [20, 30, 40, 50, 60, 70]
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/point/helper.js":
/*!**********************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/helper.js ***!
  \**********************************************************/
/*! exports provided: prepareDrawingInf, pointTranslators */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareDrawingInf", function() { return prepareDrawingInf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointTranslators", function() { return pointTranslators; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");

  
  

  const prepareDrawingInf = ({ data, datum, i, layerInst, xPx, yPx }) => {
      const axes = layerInst.axes();
      const { shape: shapeAxis, color: colorAxis, size: sizeAxis } = axes;
      let shape = shapeAxis.getShape(datum.shape);
      let size = sizeAxis.getSize(datum.size);
      let color = colorAxis.getColor(datum.color);
      const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["resolveEncodingValues"])({
          values: {
              x: xPx,
              y: yPx,
              color,
              size,
              shape,
              data: datum
          },
          data: datum
      }, i, data, layerInst);
      const layerEncoding = layerInst.config().encoding;
      const { rowId, source } = datum;
      ({ shape, size, color } = resolvedEncodings);
      const style = {
          fill: color,
          stroke: layerEncoding.stroke.value
      };
      const { x, y } = resolvedEncodings;
      const pos = { x, y };
      return {
          enter: pos,
          update: pos,
          shape,
          source,
          rowId,
          style,
          meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["getColorMetaInf"])(style, colorAxis),
          size
      };
  };

  const pointTranslators = {
      [muze_utils__WEBPACK_IMPORTED_MODULE_0__["COORD_TYPES"].CARTESIAN]: (data, config, layerInst) => {
          let points = [];
          const encoding = layerInst.config().encoding;
          const axes = layerInst.axes();
          const { x, y } = encoding;
          const xField = x.field;
          const yField = y.field;
          const fieldsConfig = layerInst.data().getFieldsConfig();
          const isXDim = fieldsConfig[xField] && fieldsConfig[xField].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
          const isYDim = fieldsConfig[yField] && fieldsConfig[yField].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
          const key = isXDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ENCODING"].X : (isYDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ENCODING"].Y : null);
          const measurement = layerInst.measurement();
          const { x: offsetX, y: offsetY } = config.offset;

          for (let i = 0, len = data.length; i < len; i++) {
              const d = data[i];

              let [xPx, yPx] = [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["ENCODING"].X, _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ENCODING"].Y].map((type) => {
                  const value = d[type] === null ? undefined : d[type];
                  const measure = type === _enums_constants__WEBPACK_IMPORTED_MODULE_1__["ENCODING"].X ? measurement.width : measurement.height;
                  return !encoding[type].field ? measure / 2 : axes[type].getScaleValue(value);
              });

              xPx += offsetX;
              yPx += offsetY;
              if (!isNaN(xPx) && !isNaN(yPx)) {
                  const point = prepareDrawingInf({
                      data,
                      datum: d,
                      i,
                      layerInst,
                      xPx,
                      yPx
                  });
                  point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["getIndividualClassName"])(d, i, data, layerInst);
                  points.push(point);
                  layerInst.cachePoint(d[key], point);
              }
          }
          points = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["positionPoints"])(layerInst, points);
          return points;
      }
  };


/***/ }),

/***/ "./packages/visual-layer/src/layers/point/index.js":
/*!*********************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/index.js ***!
  \*********************************************************/
/*! exports provided: PointLayer, PointLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ "./packages/visual-layer/src/layers/point/point.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLayer", function() { return _point__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _point_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point-mixin */ "./packages/visual-layer/src/layers/point/point-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLayerMixin", function() { return _point_mixin__WEBPACK_IMPORTED_MODULE_1__["PointLayerMixin"]; });




/***/ }),

/***/ "./packages/visual-layer/src/layers/point/point-mixin.js":
/*!***************************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/point-mixin.js ***!
  \***************************************************************/
/*! exports provided: PointLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLayerMixin", function() { return PointLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/point/renderer.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/point/default-config.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/point/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helper */ "./packages/visual-layer/src/layers/point/helper.js");










const PointLayerMixin = (superclass) => {
    return class extends superclass {
        /**
         * Creates an instance of PointLayer.
         * @param {*} args
         * @memberof PointLayer
         */
        constructor (...args) {
            super(...args);
            this._voronoi = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["Voronoi"]();
            this._bandScale = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Scales"].band();
        }

        elemType () {
            return 'g';
        }

        /**
         * Returns the default configuration of the point layer
         * @return {Object} Default configuration of the point layer
         */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_3__["defaultConfig"];
        }

        static defaultPolicy (conf, userConf) {
            const config = _base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"].defaultPolicy(conf, userConf);
            const encoding = config.encoding;
            const transform = config.transform;
            const colorField = encoding.color && encoding.color.field;

            if (colorField) {
                transform.groupBy = colorField;
            }
            return config;
        }

        static drawFn () {
            return _renderer__WEBPACK_IMPORTED_MODULE_2__["default"];
        }

        /**
         * Generates an array of objects containing x, y, width and height of the points from the data
         * @param  {Array.<Array>} data Data Array
         * @param  {Object} encoding  Config
         * @param  {Object} axes     Axes object
         * @return {Array.<Object>}  Array of points
         */
        translatePoints (data, config = {}) {
            return _helper__WEBPACK_IMPORTED_MODULE_7__["pointTranslators"][this.coord()](data, config, this);
        }

        /**
         * Renders the plot in the given container.
         *
         * @param  {SVGElement} container SVGElement which will hold the plot
         * @return {BarLayer} Instance of bar layer
         */
        render (container) {
            let maxSize = 0;
            let seriesClassName;
            const config = this.config();
            const keys = this._transformedData.map(d => d.key);
            const { transition, className, defClassName, classPrefix } = config;
            const normalizedData = this._normalizedData;
            const containerSelection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
            const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(defClassName, this.id(), classPrefix);
            this._points = [];
            this._pointMap = {};

            containerSelection.classed(qualifiedClassName.join(' '), true).classed(className, true);

            this._points = this.generateDataPoints(normalizedData, keys);
            this._graphicElems = {};

            const schema = this.data().getSchema();
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'g', this._points, null, {
                update: (group, points) => {
                    maxSize = Math.max(maxSize, ...points.map(d => d.size));
                    seriesClassName = `${qualifiedClassName[0]}`;
                    this.constructor.drawFn()({
                        layer: this,
                        container: group.node(),
                        points,
                        interpolate: config.interpolate,
                        className: seriesClassName,
                        transition,
                        keyFn: v => Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getMarkId"])(v.source, schema)
                    });
                }
            }, data => data[0].rowId);
            this._maxSize = Math.sqrt(maxSize / Math.PI) * 2;
            Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["attachDataToVoronoi"])(this._voronoi, this._points);
            return this;
        }

        generateDataPoints (normalizedData, keys) {
            const [widthMetrics, heightMetrics] = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getPlotMeasurement"])(this, keys);
            const offsetXValues = widthMetrics.offsetValues || [];
            const offsetYValues = heightMetrics.offsetValues || [];
            return normalizedData.map((dataArr, i) => {
                const measurementConf = this.getMeasurementConfig(offsetXValues[i], offsetYValues[i], widthMetrics.span,
                    heightMetrics.span);
                return this.translatePoints(dataArr, measurementConf);
            }).filter(d => d.length);
        }

        getMeasurementConfig (offsetX, offsetY, widthSpan, heightSpan) {
            return {
                offset: {
                    x: (offsetX || 0) + widthSpan / 2,
                    y: (offsetY || 0) + heightSpan / 2
                },
                span: {
                    x: widthSpan,
                    y: heightSpan
                }
            };
        }

        /**
         * Gets the nearest point from a position.
         * @param {number} x x position
         * @param {number} y y position
         * @return {Object} Point details
         */
        getNearestPoint (x, y) {
            const distanceLimit = Math.max(this._maxSize, this.config().nearestPointThreshold);

            if (!this.data()) {
                return null;
            }

            const point = this._voronoi.find(x, y, distanceLimit);
            const dimensions = point && point.data.data.update;
            const radius = point ? Math.sqrt(point.data.data.size / Math.PI) : 0;

            if (point) {
                const { source, rowId } = point.data.data;
                const identifiers = this.getIdentifiersFromData(source, rowId);
                return {
                    id: identifiers,
                    dimensions: [{
                        x: dimensions.x,
                        y: dimensions.y,
                        width: radius,
                        height: radius
                    }],
                    layerId: this.id()
                };
            }
            return null;
        }

    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/point/point.js":
/*!*********************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/point.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _point_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point-mixin */ "./packages/visual-layer/src/layers/point/point-mixin.js");





/**
 * This layer is used to create various symbols for each data point. This is commonly used in
 * scatterplot visualizations. The mark type of this layer is ```point```.
 *
 * @public
 *
 * @class
 * @module PointLayer
 * @extends BaseLayer
 */
class PointLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayerMixin"], _point_mixin__WEBPACK_IMPORTED_MODULE_3__["PointLayerMixin"]) {
    static formalName () {
        return _enums_constants__WEBPACK_IMPORTED_MODULE_2__["POINT_LAYER"];
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/point/renderer.js":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/renderer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* global Element, document  */


/**
 *
 *
 * @param {*} str
 *
 */
const checkPath = (str) => {
    if (/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(str) && /[\dz]$/i.test(str) && str.length > 4) {
        return true;
    }
    return false;
};

/**
 *
 *
 * @param {*} d
 * @param {*} elem
 */
const createShape = function (d, groupElement) {
    const { shape, size, update } = d;

    if (shape instanceof Promise) {
        shape.then((res) => {
            d.shape = res;
            createShape(d, groupElement);
        });
    } else if (shape instanceof Element) {
        let newShape = shape.cloneNode(true);

        if (newShape.nodeName.toLowerCase() === 'img') {
            const src = newShape.src || newShape.href;
            newShape = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            newShape.setAttribute('href', src);
        }
        const shapeElement = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(newShape);
        if (newShape.nodeName === 'path' || newShape.nodeName === 'image') {
            shapeElement.attr('transform', `scale(${size / 100})`);
        } else {
            shapeElement.attr('height', size);
            shapeElement.attr('width', size);
        }
        shapeElement.attr('x', -size / 2);
        shapeElement.attr('y', -size / 2);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(groupElement, () => newShape, [1]);
    } else if (typeof shape === 'string') {
        let pathStr;
        if (checkPath(shape)) {
            pathStr = shape;
        } else {
            pathStr = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSymbol"])(shape).size(size)(update);
        }
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(groupElement, 'path', data => [data]).attr('d', pathStr);
    } else {
        d.shape = 'circle';
        createShape(d, groupElement);
    }
};

/**
 * Draws symbols using d3 symbol api
 * @param {Object} params Contains the svg container, points and other symbol related attributes.
 */
/* istanbul ignore next */ const drawSymbols = (params) => {
    const { layer, container, points, transition, className } = params;
    const { duration, effect, disabled } = transition;
    const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
    const graphicElems = layer._graphicElems;
    mount.attr('class', className);
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mount, 'g', points, null, {
        enter: (group, d) => {
            const { enter } = d;
            group.attr('transform', `translate(${enter.x},${enter.y})`);
        },
        update: (group, d) => {
            createShape(d, group);
            graphicElems[d.rowId] = group;
            const { update, style } = d;
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["objectIterator"])(style, key => group.style(key, style[key]));
            group.attr('class', className);
            group.classed(d.className, true);
            if (!disabled) {
                group = group.transition()
                    .duration(transition.duration)
                    .on('end', layer.registerAnimationDoneHook());
            }
            group.attr('transform', `translate(${update.x},${update.y})`);
        },
        exit: (exitGroup) => {
            if (!disabled) {
                exitGroup.transition().ease(muze_utils__WEBPACK_IMPORTED_MODULE_0__["easeFns"][effect])
                .duration(duration)
                .on('end', () => exitGroup.remove())
                .style('fill-opacity', 0)
                .style('stroke-opacity', 0);
            } else {
                exitGroup.remove();
            }
        }
    }, params.keyFn);
};

/* harmony default export */ __webpack_exports__["default"] = (drawSymbols);


/***/ }),

/***/ "./packages/visual-layer/src/layers/point/styles.scss":
/*!************************************************************!*\
  !*** ./packages/visual-layer/src/layers/point/styles.scss ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/text/default-config.js":
/*!*****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/default-config.js ***!
  \*****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    defClassName: 'layer-text',
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    className: '',
    transform: {
        type: 'identity'
    },
    interaction: {
        highlight: [{
            type: 'fill',
            intensity: [0, 0, -15, 0]
        }],
        fade: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }],
        focus: [{
            type: 'fill',
            intensity: [0, 0, +15, 0]
        }]
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    encoding: {
        color: {},
        size: {},
        radius: {},
        angle: {},
        text: {
            value: '',
            formatter: (val, i, data, context) => {
                const valueParser = context.valueParser();
                return valueParser(val);
            },
            background: {
                padding: 10
            }
        },
        rotation: {
            value: 0
        },
        'alignment-baseline': {
            value: 'middle'
        }
    },
    states: {
        highlight: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-text-highlight`
        },
        fadeout: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-text-fadeout`
        },
        selected: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-text-selected`
        }
    }
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/text/index.js":
/*!********************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/index.js ***!
  \********************************************************/
/*! exports provided: TextLayer, TextLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text */ "./packages/visual-layer/src/layers/text/text.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextLayer", function() { return _text__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _text_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text-mixin */ "./packages/visual-layer/src/layers/text/text-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextLayerMixin", function() { return _text_mixin__WEBPACK_IMPORTED_MODULE_1__["TextLayerMixin"]; });




/***/ }),

/***/ "./packages/visual-layer/src/layers/text/renderer.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/renderer.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * Draws svg text in the specified container.
 * @param {SVGElement} container Container where labels will be appended.
 * @param {Array.<Object>} data Data of the elements.
 * @return {Selection} d3 selection of the elements.
 */
const drawText = (container, data, config, layerInst) => {
    const selection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container).selectAll('g').data(data);
    const { smartLabel } = layerInst._dependencies;
    const graphicElems = layerInst._graphicElems;

    const selectionMerge = selection.enter().append('g')
        .each(function (dataObj) {
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setAttrs"])(this, dataObj.enter);
        })
        .merge(selection);
    const style = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getSmartComputedStyle"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container), config.className);
    const fontSize = parseInt(style.fontSize, 10);

    smartLabel.setStyle(style);
    selectionMerge.each(function (dataObj) {
        const element = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
        graphicElems[dataObj.rowId] = element;
        const { update, text, color, textanchor, style: textStyle } = dataObj;
        const background = dataObj.background;
        let backgroundVal;
        if (backgroundVal = background.value) {
            const backgroundPadding = background.padding;
            let diff;
            const { width, height } = smartLabel.getOriSize(dataObj.text);
            const backgroundEl = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(element, 'rect', [1]);

            if (textanchor === 'end') {
                diff = width;
            } else if (textanchor === 'start') {
                diff = 0;
            } else {
                diff = width / 2;
            }

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setAttrs"])(backgroundEl.node(), {
                x: update.x - diff - backgroundPadding / 2,
                y: update.y - fontSize - backgroundPadding / 2,
                width: width + backgroundPadding,
                height: height + backgroundPadding
            });
            background && Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(backgroundEl, {
                background: backgroundVal
            });
        }
        const textEl = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(element, 'text', d => [d]).text(text);
        const textNode = textEl.node();
        textStyle && Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(textNode, textStyle);
        color && Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(textNode, {
            fill: color
        });
        dataObj.className && textEl.classed(dataObj.className, true);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setAttrs"])(textNode, update);
        textEl.attr('text-anchor', textanchor);
        textEl.attr('alignment-baseline', dataObj['alignment-baseline']);
        textEl.attr('transform', `rotate(${dataObj.rotation} ${update.x} ${update.y})`);
    });
    selection.exit().remove();
    return selection;
};

/* harmony default export */ __webpack_exports__["default"] = (drawText);


/***/ }),

/***/ "./packages/visual-layer/src/layers/text/styles.scss":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/styles.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/text/text-mixin.js":
/*!*************************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/text-mixin.js ***!
  \*************************************************************/
/*! exports provided: TextLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLayerMixin", function() { return TextLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/text/renderer.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/text/default-config.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/text/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_5__);








const defaultEncoding = _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"].encoding;
const alignmentBaseLine = defaultEncoding['alignment-baseline'].value;
const defRotation = defaultEncoding.rotation.value;

const pointTranslators = {
    polar: (data, config, layerInst) => {
        let points = [];
        const axes = layerInst.axes();
        const encoding = layerInst.config().encoding;
        const textEncoding = encoding.text;
        const { radius: radiusAxis, color: colorAxis, angle: angleAxis } = axes;
        const { formatter: textFormatter } = textEncoding;
        const backgroundEncoding = encoding.text.background;
        const backgroundPadding = backgroundEncoding.padding;
        const backgroundValue = backgroundEncoding.value;
        const angleV = {};
        for (let i = 0, len = data.length; i < len; i++) {
            const d = data[i];
            const source = d.source;
            const text = d.text;

            const color = colorAxis.getColor(d.color);
            const radius = radiusAxis.getOuterRadius(d.radius);
            const angles = angleAxis.getScaleValue(d.angle);
            !angleV[d.angle] && (angleV[d.angle] = 0);
            const { startAngle, endAngle } = angles[angleV[d.angle]++];

            const angle = (startAngle + endAngle) / 2;
            const resolvedVal = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["resolveEncodingValues"])({
                values: {
                    angle,
                    radius,
                    color,
                    text,
                    startAngle,
                    endAngle,
                    rotation: defRotation,
                    'alignment-baseline': alignmentBaseLine
                },
                data: d
            }, i, data, layerInst);
            const point = {
                enter: {},
                update: {
                    angle: resolvedVal.angle,
                    radius: resolvedVal.radius
                },
                text: textFormatter ? textFormatter(text, i, data, layerInst) : resolvedVal.text,
                color: resolvedVal.color,
                rotation: resolvedVal.rotation,
                background: {
                    value: backgroundValue instanceof Function ? backgroundValue(d, i, data, layerInst) : null,
                    padding: backgroundPadding
                },
                'alignment-baseline': resolvedVal['alignment-baseline'],
                meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getColorMetaInf"])({
                    fill: resolvedVal.color
                }, colorAxis),
                style: {},
                source,
                rowId: d.rowId
            };

            point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getIndividualClassName"])(d, i, data, layerInst);
            points.push(point);
        }

        points = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["toCartesianCoordinates"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["positionPoints"])(layerInst, points), layerInst.measurement());

        points = points.filter((d) => {
            const update = d.update;
            return !isNaN(update.x) && !isNaN(update.y);
        });
        return points;
    },
    cartesian: (data, config, layerInst) => {
        let points = [];
        const axes = layerInst.axes();
        const colorAxis = axes.color;
        const encoding = layerInst.config().encoding;
        const textEncoding = encoding.text;
        const { field: textField, value, formatter: textFormatter } = textEncoding;
        const fieldsConfig = layerInst.data().getFieldsConfig();

        const backgroundEncoding = encoding.text.background;
        const backgroundPadding = backgroundEncoding.padding;
        const backgroundValue = backgroundEncoding.value;
        const textFieldIndex = textField ? fieldsConfig[textField] && fieldsConfig[textField].index : -1;
        const xEnc = _enums_constants__WEBPACK_IMPORTED_MODULE_4__["ENCODING"].X;
        const yEnc = _enums_constants__WEBPACK_IMPORTED_MODULE_4__["ENCODING"].Y;
        for (let i = 0, len = data.length; i < len; i++) {
            const d = data[i];
            const row = d.source;
            const textValue = textField ? row[textFieldIndex] : value;

            const [xPx, yPx] = [xEnc, yEnc].map(type => (axes[type] ? axes[type].getScaleValue(d[type]) +
                    axes[type].getUnitWidth() / 2 : 0));

            const color = colorAxis.getColor(d.color, colorAxis);
            const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["resolveEncodingValues"])({
                values: {
                    x: xPx,
                    y: yPx,
                    text: textValue,
                    color,
                    rotation: defRotation,
                    'alignment-baseline': alignmentBaseLine
                },
                data: d
            }, i, data, layerInst);
            const point = {
                enter: {},
                update: {
                    x: resolvedEncodings.x,
                    y: resolvedEncodings.y
                },
                text: textFormatter(resolvedEncodings.text, i, data, layerInst),
                color: resolvedEncodings.color,
                background: {
                    value: backgroundValue instanceof Function ? backgroundValue(d, i, data, layerInst) : null,
                    padding: backgroundPadding
                },
                'alignment-baseline': resolvedEncodings['alignment-baseline'],
                rotation: resolvedEncodings.rotation,
                meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getColorMetaInf"])({
                    fill: resolvedEncodings.color
                }, colorAxis),
                style: {},
                source: d.source,
                rowId: d.rowId
            };

            point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["getIndividualClassName"])(d, i, data, layerInst);
            points.push(point);
        }

        points = Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["positionPoints"])(layerInst, points);
        points = points.filter((d) => {
            const update = d.update;
            return !isNaN(update.x) && !isNaN(update.y);
        });
        return points;
    }
};

/**
 * This layer is used to create labels for each data point. It has an encoding property ```text```
 * which determines from which field's data the value of the label will be taken. The text encoding
 * property is necessary for the layer to render the text.The mark type of this layer is ```text```.
 *
 * @public
 *
 * @class
 * @module TextLayer
 * @extends BaseLayer
 */
const TextLayerMixin = (superclass) => {
    return class extends superclass {
        /**
        * Returns the default configuration of the text layer
        * @return {Object} Default configuration of the text layer
        */
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"];
        }

        static formalName () {
            return 'text';
        }

        elemType () {
            return 'text';
        }

        getPointTranslator (val) {
            return pointTranslators[val];
        }

        /**
        * Generates an array of objects containing x, y, width and height of the points from the data
        * @param  {Array.<Array>} data Data Array
        * @param  {Object} encoding  Config
        * @param  {Object} axes     Axes object
        * @return {Array.<Object>}  Array of points
        */
        translatePoints (data, config = {}) {
            return pointTranslators[this.coord()](data, config, this);
        }

        /**
        * Renders the plot in the given container
        * @param  {SVGElement} container SVGElement which will hold the plot
        * @return {textLayer} Instance of text layer
        */
        render (container) {
            const config = this.config();
            const normalizedData = this._normalizedData;
            const className = config.className;
            const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getQualifiedClassName"])(config.defClassName, this.id(), config.classPrefix);
            const containerSelection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);

            containerSelection.classed(`${qualifiedClassName.join(' ')} ${className}`, true);
            this._graphicElems = {};

            Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["createElements"])({
                data: normalizedData,
                append: 'g',
                selector: 'g',
                container,
                each: (dataArr, group) => {
                    const node = group.node();
                    const points = this.translatePoints(dataArr, {}, this);
                    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["setStyles"])(node, {
                        'text-anchor': _enums_constants__WEBPACK_IMPORTED_MODULE_4__["TEXT_ANCHOR_MIDDLE"]
                    });
                    Object(_renderer__WEBPACK_IMPORTED_MODULE_1__["default"])(node, points, {
                        className: qualifiedClassName[0]
                    }, this);
                }
            });
            return this;
        }
    }
};


/***/ }),

/***/ "./packages/visual-layer/src/layers/text/text.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/text/text.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _text_mixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text-mixin */ "./packages/visual-layer/src/layers/text/text-mixin.js");




/**
 * This layer is used to create labels for each data point. It has an encoding property ```text```
 * which determines from which field's data the value of the label will be taken. The text encoding
 * property is necessary for the layer to render the text.The mark type of this layer is ```text```.
 *
 * @public
 *
 * @class
 * @module TextLayer
 * @extends BaseLayer
 */
class TextLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_1__["BaseLayerMixin"], _text_mixin__WEBPACK_IMPORTED_MODULE_2__["TextLayerMixin"]) {
    static formalName () {
        return 'text';
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/default-config.js":
/*!*****************************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/default-config.js ***!
  \*****************************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");


const defaultConfig = {
    defClassName: 'layer-tick',
    className: '',
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    interaction: {
        highlight: [{
            type: 'stroke',
            intensity: [0, 0, -15, 0]
        }],
        fade: [{
            type: 'stroke',
            intensity: [0, 0, 15, 0]
        }],
        focus: [{
            type: 'stroke',
            intensity: [0, 0, 15, 0]
        }]
    },
    innerPadding: 0.1,
    transform: {
        type: 'identity'
    },
    transition: {
        effect: 'cubic',
        duration: 1000
    },
    interpolate: 'linear',
    encoding: {
        color: { },
        x: {},
        y: {},
        x0: {},
        y0: {},
        radius: {},
        radius0: {},
        angle: {},
        angle0: {},
        strokeOpacity: {
            value: 0.5
        },
        fillOpacity: {
            value: 0.5
        }
    },
    states: {
        highlight: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-tick-highlight`
        },
        fadeout: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-tick-fadeout`
        },
        selected: {
            className: `${_enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"]}-layer-tick-selected`
        }
    }
};



/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/index.js":
/*!********************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/index.js ***!
  \********************************************************/
/*! exports provided: TickLayer, TickLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tick */ "./packages/visual-layer/src/layers/tick/tick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TickLayer", function() { return _tick__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _tick_mixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tick-mixin */ "./packages/visual-layer/src/layers/tick/tick-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TickLayerMixin", function() { return _tick_mixin__WEBPACK_IMPORTED_MODULE_1__["TickLayerMixin"]; });





/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/renderer.js":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/renderer.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const line = muze_utils__WEBPACK_IMPORTED_MODULE_0__["Symbols"].line;

/**
 * Draws ticks by using d3 selection
 * @param  {Object} params Contains container element and points
 * @return {Selection} Ticks Selection
 */
/* harmony default export */ __webpack_exports__["default"] = (/* istanbul ignore next */(params) => {
    const { points, container, keyFn, className, interpolate, layer } = params;
    const mount = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(container);
    const ticks = mount.selectAll('path').data(points, keyFn);
    const ticksEnter = ticks.enter().append('path');
    const graphicElems = layer._graphicElems;
    mount.attr('class', className || '');
    ticksEnter.each(function (d) {
        const selection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
        const enter = d.enter || {};
        Object.entries(enter).forEach(attr => (!isNaN(attr[1]) && selection.attr(attr[0], attr[1])));
    });

    ticks.exit().remove();
    return ticks.merge(ticksEnter)
                    .each(function (d) {
                        const selection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["selectElement"])(this);
                        graphicElems[d.rowId] = selection;
                        const update = d.update;
                        const updateStyle = d.style || {};
                        const x0 = update.x0 !== undefined ? update.x0 : update.x;
                        const y0 = update.y0 !== undefined ? update.y0 : update.y;
                        const curveInterpolatorFn = muze_utils__WEBPACK_IMPORTED_MODULE_0__["pathInterpolators"][interpolate];
                        const linepath = line()
                            .curve(curveInterpolatorFn)
                            .x(e => e[0])
                            .y(e => e[1]);
                        d.className && selection.classed(d.className, true);
                        selection.attr('d', linepath([[update.x, update.y], [x0, y0]]));
                        Object.entries(updateStyle).forEach(styleObj => selection.style(styleObj[0], styleObj[1]));
                    });
});



/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/styles.scss":
/*!***********************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/styles.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/tick-mixin.js":
/*!*************************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/tick-mixin.js ***!
  \*************************************************************/
/*! exports provided: TickLayerMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TickLayerMixin", function() { return TickLayerMixin; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default-config */ "./packages/visual-layer/src/layers/tick/default-config.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/constants */ "./packages/visual-layer/src/enums/constants.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer */ "./packages/visual-layer/src/layers/tick/renderer.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-layer/src/layers/tick/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../helpers */ "./packages/visual-layer/src/helpers/index.js");







const pointTranslators = {
    polar: (data, config = {}, layerInst) => {
        const axes = layerInst.axes();
        let points = [];
        const { radius: radiusAxis, angle: angleAxis, angle0: angle0Axis } = axes;
        const measurement = layerInst.measurement();

        const colorAxis = axes.color;
        const angleV = {};
        const angle0V = {};
        for (let i = 0, len = data.length; i < len; i++) {
            const d = data[i];
            const color = colorAxis.getColor(d.color);
            const angles = angleAxis.getScaleValue(d.angle);
            !angleV[d.angle] && (angleV[d.angle] = 0);
            const { startAngle, endAngle } = angles[angleV[d.angle]++];
            const angles0 = angle0Axis.getScaleValue(d.angle0);
            !angle0V[d.angle0] && (angle0V[d.angle0] = 0);
            const { startAngle: startAngle0, endAngle: endAngle0 } = angles0[angle0V[d.angle0]++];
            const radius = radiusAxis.getOuterRadius(d.radius);
            const angle = (startAngle + endAngle) / 2;
            const angle0 = (startAngle0 + endAngle0) / 2;
            const resolvedVal = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["resolveEncodingValues"])({
                values: {
                    radius,
                    radius0: radiusAxis.getInnerRadius(d.radius0),
                    color,
                    angle,
                    angle0,
                    startAngle,
                    endAngle,
                    startAngle0,
                    endAngle0
                },
                data: d
            }, i, data, layerInst);
            const style = {
                stroke: resolvedVal.color
            };

            const point = {
                enter: {},
                update: {
                    radius: resolvedVal.radius,
                    radius0: resolvedVal.radius0,
                    angle: resolvedVal.angle,
                    angle0: resolvedVal.angle0
                },
                style,
                source: d.source,
                rowId: d.rowId,
                meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getColorMetaInf"])(style, colorAxis)
            };
            point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getIndividualClassName"])(d, i, data, layerInst);
            points.push(point);
        }
        points = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["toCartesianCoordinates"])(Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["positionPoints"])(layerInst, points), measurement, true);
        return points;
    },
    cartesian: (data, config = {}, layerInst) => {
        const axes = layerInst.axes();
        let points = [];
        const { x: xAxis, y: yAxis } = axes;
        const {
                xField,
                yField,
                x0Field,
                y0Field,
                xFieldType,
                yFieldType
            } = layerInst.encodingFieldsInf();
        const isXDim = xFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
        const isYDim = yFieldType === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION;
        const key = isXDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_2__["ENCODING"].X : (isYDim ? _enums_constants__WEBPACK_IMPORTED_MODULE_2__["ENCODING"].Y : null);
        const measurement = layerInst.measurement();
        const colorAxis = axes.color;
        const { x: offsetX, y: offsetY } = config.offset;
        const { x: xSpan, y: ySpan } = config.span;
        for (let i = 0, len = data.length; i < len; i++) {
            let xPx;
            let x0Px;
            let y0Px;
            let yPx;
            const d = data[i];
            const row = d.source;
            if (xField) {
                xPx = xAxis.getScaleValue(d.x) + offsetX;
                x0Px = xPx + xSpan;
            }

            if (yField) {
                yPx = yAxis.getScaleValue(d.y) + offsetY;
                y0Px = yPx !== null ? yPx + ySpan : null;
            }

            if (!xField) {
                xPx = 0;
                x0Px = measurement.width;
                if (!isNaN(yPx)) {
                    yPx += ySpan / 2;
                    y0Px = yPx;
                }
            }

            if (!yField) {
                yPx = 0;
                y0Px = measurement.height;
                x0Px = xPx += xSpan / 2;
            }

            if (x0Field) {
                x0Px = xAxis.getScaleValue(d.x0) + xSpan;
                yPx += ySpan / 2;
                y0Px -= ySpan / 2;
            }

            if (y0Field) {
                y0Px = yAxis.getScaleValue(d.y0) + ySpan;
                xPx += xSpan / 2;
                x0Px -= xSpan / 2;
            }
            const color = colorAxis.getColor(d.color);
            const resolvedEncodings = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["resolveEncodingValues"])({
                values: {
                    x: xPx,
                    y: yPx,
                    x0: x0Px,
                    y0: y0Px,
                    color
                },
                data: d
            }, i, data, layerInst);
            const style = {
                stroke: resolvedEncodings.color
            };

            if (!isNaN(xPx) && !isNaN(yPx)) {
                const point = {
                    enter: {},
                    update: {
                        x: resolvedEncodings.x,
                        y: resolvedEncodings.y,
                        x0: resolvedEncodings.x0,
                        y0: resolvedEncodings.y0
                    },
                    style,
                    source: row,
                    rowId: d.rowId,
                    meta: Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getColorMetaInf"])(style, colorAxis)
                };
                point.className = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["getIndividualClassName"])(d, i, data, layerInst);
                points.push(point);
                layerInst.cachePoint(d[key], point);
            }
        }
        points = Object(_helpers__WEBPACK_IMPORTED_MODULE_5__["positionPoints"])(layerInst, points);
        return points;
    }
};

/**
 * This layer is used to create small lines. The orientation of the line is determined by the positional
 * encoding properties x0 and y0. The mark type of the layer is ```tick```.
 *
 * @public
 *
 * @class
 * @module TickLayer
 * @extends BaseLayer
 */
const TickLayerMixin = (superclass) => {
    return class extends superclass {
        static defaultConfig () {
            return _default_config__WEBPACK_IMPORTED_MODULE_1__["defaultConfig"];
        }

        static formalName () {
            return 'tick';
        }

        static drawFn () {
            return _renderer__WEBPACK_IMPORTED_MODULE_3__["default"];
        }

        elemType () {
            return 'path';
        }

        /**
        * Generates an array of objects containing x, y, width and height of the points from the data
        * @param  {Array.<Array>} data Data Array
        * @param  {Object} encoding  Config
        * @param  {Object} axes     Axes object
        * @return {Array.<Object>}  Array of points
        */
        translatePoints (data, config) {
            return pointTranslators[this.coord()](data, config, this);
        }

        getMeasurementConfig (offsetX, offsetY, widthSpan, heightSpan) {
            return {
                offset: {
                    x: (offsetX || 0),
                    y: (offsetY || 0)
                },
                span: {
                    x: widthSpan,
                    y: heightSpan
                }
            };
        }
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/layers/tick/tick.js":
/*!*******************************************************!*\
  !*** ./packages/visual-layer/src/layers/tick/tick.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TickLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./packages/visual-layer/src/layers/point/index.js");
/* harmony import */ var _base_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../base-layer */ "./packages/visual-layer/src/base-layer/index.js");
/* harmony import */ var _tick_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tick-mixin */ "./packages/visual-layer/src/layers/tick/tick-mixin.js");





/**
 * This layer is used to create small lines. The orientation of the line is determined by the positional
 * encoding properties x0 and y0. The mark type of the layer is ```tick```.
 *
 * @public
 *
 * @class
 * @module TickLayer
 * @extends BaseLayer
 */
class TickLayer extends Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(_base_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayer"]).with(_base_layer__WEBPACK_IMPORTED_MODULE_2__["BaseLayerMixin"], _point__WEBPACK_IMPORTED_MODULE_1__["PointLayerMixin"], _tick_mixin__WEBPACK_IMPORTED_MODULE_3__["TickLayerMixin"]) {
    static formalName () {
        return 'tick';
    }
}


/***/ }),

/***/ "./packages/visual-layer/src/simple-layer/index.js":
/*!*********************************************************!*\
  !*** ./packages/visual-layer/src/simple-layer/index.js ***!
  \*********************************************************/
/*! exports provided: SimpleLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _simple_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-layer */ "./packages/visual-layer/src/simple-layer/simple-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleLayer", function() { return _simple_layer__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./packages/visual-layer/src/simple-layer/simple-layer.js":
/*!****************************************************************!*\
  !*** ./packages/visual-layer/src/simple-layer/simple-layer.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SimpleLayer; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


/**
 * This is an interface class which any new layer class has to extend.
 *
 * @example
 * class BarLayer extends BaseLayer {
 *   update (params) {
 *       // super.update(params);
 *       // Update the bar layer
 *   }
 * }
 * @class
 */
class SimpleLayer {

    formalName () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Sets or gets the dependencies.
     * @param {Object} dependencies Dependencies needed by layer
     * @return {BaseLayer} Instance of base layer.
     */
    dependencies () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns the config of the layer
     *
     * @param {Object} config Configuration of layer
     * @return {Object} configuration of layer
     */
    config () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Acts as a getter or setter function
     * When setter
     * Returns the datamodel of the layer
     * @param { DataModel } dataModel instance of DataModel
     * @return { DataModel } DataModel instance of the layer
     */
    data () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns a serialized schema of the layer
     * @return {Object} Serialized schema
     */
    serialize () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns the unique identifier of this layer
     * @return {string} id of the layer
     */
    id () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }
    /*
     * This method resolves the x, y, x0 and y0 values from the transformed data.
     * It also checks the type of transformed data for example, if it is a stacked data
     * then it fetches the y and y0 values from the stacked data.
     * @param {Array.<Array>} transformedData transformed data
     * @param {Object} fieldMap field definitions
     * @param {string} transformType type of transformed data - stack, group or identity.
     * @return {Array.<Object>} Normalized data
     * @private
     */
    normalizeTransformedData () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Gets the transform method from transform factory based on type of transform. It then calls the
     * transform method with the data and passes the configuration parameters of transform such as
     * groupBy, value field, etc.
     *
     * @param {DataModel} dataModel Instance of dataModel
     * @param {Object} config configuration for transforming data
     * @return {Array.<Array>} Transformed data.
     * @private
     */
    getTransformedData () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Calculates the domain from the data.
     * It checks the type of field and calculates the domain based on that. For example, if it
     * is a quantitative or temporal field, then it calculates the min and max from the data or
     * if it is a nominal field then it gets all the values from the data of that field.
     * @param {Array} data DataArray
     * @return {Array} Domain values array.
     */
    _calculateDomainFromData () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Returns the domain for the axis.
     *
     * @param {string} encodingType type of encoding x, y, color, etc.
     * @return {Object} Axis domains
     */
    getDomain () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Abstract method for getting nearest point
     * @return {BaseLayer} Instance of base layer
     */
    getNearestPoint () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Abstract method for highlighting points
     * @return {BaseLayer} Instance of base layer
     */
    highlightPoint () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Abstract method for deselecting points
     * @return {BaseLayer} Instance of base layer
     */
    dehighlightPoint () {
        return this;
    }

    linkLayerStore () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    /**
     * Sets the container element for the layer to be renderered.
     * @param {SVGElement} mountPoint SVG element or group element.
     */
    mount () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }

    render () {
        throw new Error(muze_utils__WEBPACK_IMPORTED_MODULE_0__["ERROR_MSG"].INTERFACE_IMPL);
    }
}


/***/ }),

/***/ "./packages/visual-unit/src/default-config.js":
/*!****************************************************!*\
  !*** ./packages/visual-unit/src/default-config.js ***!
  \****************************************************/
/*! exports provided: defaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-unit/src/enums/constants.js");


/**
 * Returns the default configuration of the visual unit
 * @return {Object} Default configuration of visual unit
 */
const defaultConfig = {
    classPrefix: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CLASSPREFIX"],
    defClassName: 'visual-unit',
    className: '',
    trackerClassName: 'visual-unit-tracker',
    minOuterRadius: 10,
    gridLines: {
        defClassName: 'axis-grid-lines',
        className: '',
        show: true,
        color: '#efefef',
        zeroLineColor: '#b6b6b6'
    },
    gridBands: {
        defClassName: 'axis-grid-bands',
        className: '',
        show: false,
        y: {
            color: ['#fff', '#fbfbfb']
        },
        x: {
            color: ['#fff', '#f9f9f9']
        }
    },
    arcLayerClassName: 'layer-arc',
    interaction: {
        tooltip: {
            mode: _enums_constants__WEBPACK_IMPORTED_MODULE_0__["CONSOLIDATED"]
        }
    },
    sideEffectClassName: 'side-effect-container'
};


/***/ }),

/***/ "./packages/visual-unit/src/enums/constants.js":
/*!*****************************************************!*\
  !*** ./packages/visual-unit/src/enums/constants.js ***!
  \*****************************************************/
/*! exports provided: CLASSPREFIX, IDFIELD, GRID_LINE_PARENT_GROUP_CLASS, GRID_BAND_PARENT_GROUP_CLASS, GRID_PARENT_GROUP, BAND, TICK, GRID_BAND, GRID_LINE, CONSOLIDATED, FRAGMENTED, FACET_BY_FIELDS, RETINAL_FIELDS, PARENT_ALIAS, LAYERS, CACHED_DATA, STORE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASSPREFIX", function() { return CLASSPREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDFIELD", function() { return IDFIELD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_LINE_PARENT_GROUP_CLASS", function() { return GRID_LINE_PARENT_GROUP_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_BAND_PARENT_GROUP_CLASS", function() { return GRID_BAND_PARENT_GROUP_CLASS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_PARENT_GROUP", function() { return GRID_PARENT_GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BAND", function() { return BAND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TICK", function() { return TICK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_BAND", function() { return GRID_BAND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GRID_LINE", function() { return GRID_LINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLIDATED", function() { return CONSOLIDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENTED", function() { return FRAGMENTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FACET_BY_FIELDS", function() { return FACET_BY_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RETINAL_FIELDS", function() { return RETINAL_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PARENT_ALIAS", function() { return PARENT_ALIAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERS", function() { return LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CACHED_DATA", function() { return CACHED_DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STORE", function() { return STORE; });
const CLASSPREFIX = 'muze';
const IDFIELD = '__id__';
const GRID_LINE_PARENT_GROUP_CLASS = 'grid-lines';
const GRID_BAND_PARENT_GROUP_CLASS = 'grid-bands';
const GRID_PARENT_GROUP = 'grid-parent-group';
const BAND = 'band';
const TICK = 'tick';
const GRID_BAND = 'gridBands';
const GRID_LINE = 'gridLines';
const CONSOLIDATED = 'consolidated';
const FRAGMENTED = 'fragmented';
const FACET_BY_FIELDS = 'facetByFields';
const RETINAL_FIELDS = 'retinalFields';
const PARENT_ALIAS = 'parentAlias';
const LAYERS = 'layers';
const CACHED_DATA = 'cachedData';
const STORE = 'store';


/***/ }),

/***/ "./packages/visual-unit/src/enums/index.js":
/*!*************************************************!*\
  !*** ./packages/visual-unit/src/enums/index.js ***!
  \*************************************************/
/*! exports provided: REACTIVE_PROPS, CONSTANTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reactive_props__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reactive-props */ "./packages/visual-unit/src/enums/reactive-props.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "REACTIVE_PROPS", function() { return _reactive_props__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./packages/visual-unit/src/enums/constants.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "CONSTANTS", function() { return _constants__WEBPACK_IMPORTED_MODULE_1__; });






/***/ }),

/***/ "./packages/visual-unit/src/enums/reactive-props.js":
/*!**********************************************************!*\
  !*** ./packages/visual-unit/src/enums/reactive-props.js ***!
  \**********************************************************/
/*! exports provided: CONFIG, DATA, AXES, LAYERDEFS, WIDTH, HEIGHT, MOUNT, TRANSFORM, TRANSFORMEDDATA, DATADOMAIN, FIELDS, LAYERAXISINDEX, LAYERS, DOMAIN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG", function() { return CONFIG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA", function() { return DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXES", function() { return AXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERDEFS", function() { return LAYERDEFS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WIDTH", function() { return WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HEIGHT", function() { return HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUNT", function() { return MOUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORMEDDATA", function() { return TRANSFORMEDDATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATADOMAIN", function() { return DATADOMAIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIELDS", function() { return FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERAXISINDEX", function() { return LAYERAXISINDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYERS", function() { return LAYERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMAIN", function() { return DOMAIN; });
const CONFIG = 'config';
const DATA = 'data';
const AXES = 'axes';
const LAYERDEFS = 'layerDef';
const WIDTH = 'width';
const HEIGHT = 'height';
const MOUNT = 'mount';
const TRANSFORM = 'transform';
const TRANSFORMEDDATA = 'transformedData';
const DATADOMAIN = 'dataDomain';
const FIELDS = 'fields';
const LAYERAXISINDEX = 'layerAxisIndex';
const LAYERS = 'layers';
const DOMAIN = 'domain';



/***/ }),

/***/ "./packages/visual-unit/src/firebolt/action-behaviour-map.js":
/*!*******************************************************************!*\
  !*** ./packages/visual-unit/src/firebolt/action-behaviour-map.js ***!
  \*******************************************************************/
/*! exports provided: actionBehaviourMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionBehaviourMap", function() { return actionBehaviourMap; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");


const actionBehaviourMap = {
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].DRAG]: {
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].BRUSH],
        touch: false
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].HOVER]: {
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].HIGHLIGHT]
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].LONGTOUCH]: {
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].SELECT],
        touch: true
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].TOUCHDRAG]: {
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].BRUSH],
        touch: true
    },
    [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["ACTIONS"].CLICK]: {
        behaviours: [_chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["BEHAVIOURS"].SELECT],
        touch: false
    }
};


/***/ }),

/***/ "./packages/visual-unit/src/firebolt/data-propagator.js":
/*!**************************************************************!*\
  !*** ./packages/visual-unit/src/firebolt/data-propagator.js ***!
  \**************************************************************/
/*! exports provided: propagateValues */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propagateValues", function() { return propagateValues; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const getModelWithFacetData = (dm, data) => {
    const dataObj = dm.getData();
    const schema1 = dataObj.schema;
    const data1 = dataObj.data;
    const jsonData = [];
    const derivedSchema = data[0].map(d => ({
        name: `${d}`,
        type: muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION,
        subtype: d.subtype()
    }));
    const dataAtFirstPos = data[1];

    data1.forEach((d) => {
        const tuple = {};
        schema1.forEach((obj, i) => {
            tuple[obj.name] = d[i];
        });
        derivedSchema.forEach((obj, i) => {
            tuple[obj.name] = dataAtFirstPos[i];
        });
        jsonData.push(tuple);
    });

    return new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"](jsonData, [...schema1, ...derivedSchema]);
};

const propagateValues = (instance, action, config = {}) => {
    let propagationData;
    const payload = config.payload;
    const selectionSet = config.selectionSet;
    const propagationFieldInf = config.propagationFields[action] || {};
    const propagationFields = propagationFieldInf.fields || [];
    const append = propagationFieldInf.append;
    const criteria = payload.criteria;
    const context = instance.context;
    const dataModel = context.cachedData()[0];
    const sourceId = context.id();
    const sideEfffects = instance.sideEffects();
    const behaviourEffectMap = instance._behaviourEffectMap;
    const mergedModel = selectionSet.mergedEnter.model;
    const fieldsConfig = dataModel.getFieldsConfig();
    payload.sourceUnit = sourceId;
    payload.action = action;
    payload.sourceCanvas = context.parentAlias();
    const propagationBehaviourMap = instance._propagationBehaviourMap;
    const propagationBehaviour = propagationBehaviourMap[action] || action;

    let propFields = [];
    if (criteria === null) {
        propagationData = null;
    } else if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["isSimpleObject"])(criteria)) {
        propFields = Object.keys(criteria || {});
        propagationData = mergedModel ? mergedModel.project(propFields) : null;
    } else {
        propFields = criteria[0];
        propagationData = mergedModel ? mergedModel.project(propFields) : null;
    }

    const facetByFields = context.facetByFields();
    if (propagationData !== null && propagationFields.length) {
        const fields = propagationData.getData().schema.map(d => d.name);
        propagationData = getModelWithFacetData(propagationData, facetByFields);
        propFields = append ? [...fields, ...propagationFields] : propagationFields;
        propagationData = propagationData.project(propFields);
    }

    let propagateInterpolatedValues = false;
    if (propFields.length && propFields.every(field => fieldsConfig[field] &&
        fieldsConfig[field].def.type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE)) {
        propagateInterpolatedValues = true;
    }

    const groupId = context.parentAlias();
    payload.action = action;
    const behaviourInstance = instance._actions.behavioural[propagationBehaviour];
    const isMutableAction = behaviourInstance ? behaviourInstance.constructor.mutates() : false;

    const filterFn = (entry, propagationConf) => {
        const effects = behaviourEffectMap[entry.config.action];
        const mutates = entry.config.groupId ?
            effects.some(d => sideEfffects[d.name || d].constructor.mutates()) : true;
        return entry.config.groupId !== propagationConf.groupId && mutates;
    };

    const sourceBehaviour = instance._actions.behavioural[action];
    const mutates = sourceBehaviour ? sourceBehaviour.constructor.mutates() : false;
    let propConfig = {
        payload,
        action,
        criteria: propagationData,
        isMutableAction: mutates,
        propagateInterpolatedValues,
        groupId,
        sourceId: mutates ? groupId : sourceId,
        filterFn,
        enabled: (propConf, firebolt) => (action !== propagationBehaviour ?
            propConf.payload.sourceCanvas === firebolt.context.parentAlias() : true)
    };

    dataModel.propagate(propagationData, propConfig, true);

    if (action !== propagationBehaviour) {
        propConfig = {
            payload,
            sourceId: isMutableAction ? groupId : sourceId,
            criteria: propagationData,
            isMutableAction,
            propagateInterpolatedValues,
            action: propagationBehaviour,
            groupId,
            applyOnSource: action === propagationBehaviour,
            enabled: (propConf, firebolt) => propConf.payload.sourceCanvas !== firebolt.context.parentAlias(),
            filterFn
        };

        dataModel.propagate(propagationData, propConfig, true, {
            filterImmutableAction: (actionInf, propInf) => actionInf.groupId !== propInf.groupId
        });
    }
};


/***/ }),

/***/ "./packages/visual-unit/src/firebolt/helper.js":
/*!*****************************************************!*\
  !*** ./packages/visual-unit/src/firebolt/helper.js ***!
  \*****************************************************/
/*! exports provided: initSideEffects, clearActionHistory, dispatchQueuedSideEffects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initSideEffects", function() { return initSideEffects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearActionHistory", function() { return clearActionHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchQueuedSideEffects", function() { return dispatchQueuedSideEffects; });
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");


const initSideEffects = (sideEffects, firebolt) => {
    for (const key in sideEffects) {
        if ({}.hasOwnProperty.call(sideEffects, key)) {
            sideEffects[key] instanceof _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_0__["SpawnableSideEffect"] && sideEffects[key].drawingContext(() => {
                const context = firebolt.context;
                return context.getDrawingContext();
            });
            sideEffects[key].valueParser(firebolt.context.valueParser());
        }
    }
};

const clearActionHistory = (context) => {
    const actionHistory = context._actionHistory;
    for (const key in actionHistory) {
        if (actionHistory[key].isMutableAction) {
            delete context._actionHistory[key];
        }
    }
};

const dispatchQueuedSideEffects = (context) => {
    const queuedSideEffects = context._queuedSideEffects;
    Object.entries(queuedSideEffects).forEach((entry) => {
        const sideEffect = entry[1];
        context.dispatchSideEffect(sideEffect.name, ...sideEffect.params);
    });
    context._queuedSideEffects = {};
};


/***/ }),

/***/ "./packages/visual-unit/src/firebolt/index.js":
/*!****************************************************!*\
  !*** ./packages/visual-unit/src/firebolt/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UnitFireBolt; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper */ "./packages/visual-unit/src/helper/index.js");
/* harmony import */ var _payload_generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./payload-generator */ "./packages/visual-unit/src/firebolt/payload-generator.js");
/* harmony import */ var _data_propagator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-propagator */ "./packages/visual-unit/src/firebolt/data-propagator.js");






const sideEffectPolicy = (propPayload, context, propagationInf) => {
    const { sourceIdentifiers, propagationData } = propagationInf;
    const fieldsConfig = sourceIdentifiers.getFieldsConfig();
    const sourceIdentifierFields = Object.keys(fieldsConfig).filter(field =>
        fieldsConfig[field].def.type !== muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE);
    const propFields = Object.keys(propagationData[0].getFieldsConfig());
    const hasCommonCanvas = propPayload.sourceCanvas === context.parentAlias();
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["intersect"])(sourceIdentifierFields, propFields).length || hasCommonCanvas;
};

/**
 * This class manages the interactions of visual unit. It associates physical actions with
 * behavioural actions. It also propagates the behavioural actions to other datamodels.
 */
class UnitFireBolt extends _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__["Firebolt"] {
    constructor (...params) {
        super(...params);
        const {
            TOOLTIP,
            HIGHLIGHTER,
            ANCHORS,
            BRUSH_ANCHORS,
            PERSISTENT_ANCHORS
        } = _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_1__["SIDE_EFFECTS"];

        const disabledSideEffects = [TOOLTIP, HIGHLIGHTER, ANCHORS, BRUSH_ANCHORS, PERSISTENT_ANCHORS];
        disabledSideEffects.forEach((sideEffect) => {
            this.changeSideEffectStateOnPropagation(sideEffect, sideEffectPolicy, 'sourceTargetPolicy');
        });
    }
    propagate (behaviour, payload, selectionSet, sideEffects) {
        Object(_data_propagator__WEBPACK_IMPORTED_MODULE_4__["propagateValues"])(this, behaviour, {
            payload,
            selectionSet,
            sideEffects,
            propagationFields: this._propagationFields
        });
    }

    getApplicableSideEffects (sideEffects, payload, propagationInf) {
        const context = this.context;
        const unitId = context.id();
        const aliasName = context.parentAlias();
        const propagationSourceCanvas = propagationInf.propPayload && propagationInf.propPayload.sourceCanvas;
        const sourceUnitId = propagationInf.propPayload && propagationInf.propPayload.sourceUnit;
        const sourceSideEffects = this._sourceSideEffects;
        const sideEffectInstances = this.sideEffects();
        const actionOnSource = sourceUnitId ? sourceUnitId === unitId : true;

        const applicableSideEffects = payload.sideEffects ? [{
            effects: payload.sideEffects,
            behaviours: [payload.action]
        }] : sideEffects;
        applicableSideEffects.forEach((d) => {
            let mappedEffects = d.effects;
            mappedEffects = mappedEffects.filter((se) => {
                const mutates = sideEffectInstances[se.name || se].constructor.mutates();
                if (mutates && propagationInf.isMutableAction === false) {
                    return false;
                }
                if (!actionOnSource && payload.criteria !== null) {
                    const sideEffectCheckers = Object.values(sourceSideEffects[se.name || se] || {});
                    const { sourceIdentifiers, data: propagationData } = propagationInf;
                    return sideEffectCheckers.length ? sideEffectCheckers.every(checker =>
                        checker(propagationInf.propPayload, context, {
                            sourceIdentifiers,
                            propagationData
                        })) : true;
                }
                if (propagationSourceCanvas === aliasName || actionOnSource) {
                    return se.applyOnSource !== false;
                }

                return true;
            });
            d.effects = mappedEffects;
        });
        return applicableSideEffects;
    }

    shouldApplySideEffects (propagate) {
        return propagate === false;
    }

    onDataModelPropagation () {
        return (data, config) => {
            let isMutableAction = false;
            const context = this.context;
            if (!context.mount()) {
                return;
            }
            const {
                model: propagationData,
                entryRowIds,
                exitRowIds
            } = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["getSelectionRejectionModel"])(context.data(), data, Object(_helper__WEBPACK_IMPORTED_MODULE_2__["isXandYMeasures"])(context), context._cachedValuesMap());
            const {
                enabled: enabledFn,
                sourceIdentifiers,
                action,
                payload: propPayload
            } = config;

            const payloadFn = _payload_generator__WEBPACK_IMPORTED_MODULE_3__["payloadGenerator"][action] || _payload_generator__WEBPACK_IMPORTED_MODULE_3__["payloadGenerator"].__default;
            const payload = payloadFn(context, propagationData, config);
            const sourceBehaviours = this._sourceBehaviours;
            const filterFns = Object.values(sourceBehaviours[action] || sourceBehaviours['*'] || {});
            let enabled = filterFns.every(fn => fn(propPayload || {}, context, {
                sourceIdentifiers,
                propagationData
            }));

            if (enabledFn) {
                enabled = enabledFn(config, this) && enabled !== false;
            }

            if (enabled) {
                const effects = this._behaviourEffectMap[action];
                const sideEffectInstances = this.sideEffects();
                isMutableAction = config.groupId ?
                    effects.some(d => sideEffectInstances[d.name || d].constructor.mutates()) : config.isMutableAction;

                const propagationInf = {
                    propagate: false,
                    data: propagationData,
                    entryRowIds,
                    exitRowIds,
                    propPayload,
                    sourceIdentifiers,
                    persistent: false,
                    sourceId: config.propagationSourceId,
                    isMutableAction: config.isMutableAction
                };

                this._actionHistory[action] = {
                    payload,
                    propagationInf,
                    isMutableAction
                };
                this.dispatchBehaviour(action, payload, propagationInf);
            }
        };
    }

    prepareSelectionSets (behaviours) {
        const data = this.context.data();
        if (data) {
            this.createSelectionSet(data.getData().uids, behaviours);
        }
        return this;
    }

    remove () {
        this.context.cachedData()[0].unsubscribe('propagation');
        return this;
    }
}


/***/ }),

/***/ "./packages/visual-unit/src/firebolt/payload-generator.js":
/*!****************************************************************!*\
  !*** ./packages/visual-unit/src/firebolt/payload-generator.js ***!
  \****************************************************************/
/*! exports provided: payloadGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "payloadGenerator", function() { return payloadGenerator; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");


const getRangeFromData = (instance, selectionDataModel, propConfig) => {
    let criteria;
    const dataObj = selectionDataModel[0].getData();
    const propCriteria = propConfig.payload.criteria;
    const sourceIdentifiers = propConfig.sourceIdentifiers;
    const schema = dataObj.schema;
    const fieldMap = instance.data().getFieldsConfig();
    const data = dataObj.data;
    const isActionSourceSame = instance.id() === propConfig.sourceId;

    if (isActionSourceSame) {
        criteria = propCriteria;
    } else {
        criteria = (sourceIdentifiers !== null) ? schema.reduce((acc, obj, index) => {
            let range;
            const field = obj.name;
            const fieldObj = fieldMap[field];
            const type = fieldObj && (fieldObj.def.subtype ? fieldObj.def.subtype : fieldObj.def.type);
            const isDimension = type === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL;

            if (!fieldObj) {
                return acc;
            }

            if (!isDimension) {
                range = [Math.min(...data.map(d => d[index])), Math.max(...data.map(d => d[index]))];
            } else {
                range = data.map(d => d[index]);
            }
            acc[field] = range;
            return acc;
        }, {}) : null;
    }
    return criteria;
};

const payloadGenerator = {
    brush: (instance, selectionDataModel, propConfig) => {
        const propPayload = propConfig.payload;
        const criteria = getRangeFromData(instance, selectionDataModel, propConfig);
        const payload = Object.assign({}, propPayload);
        payload.criteria = criteria;
        return payload;
    },

    __default: (instance, selectionDataModel, propConfig) => {
        const propPayload = propConfig.payload;
        const sourceIdentifiers = propConfig.sourceIdentifiers;
        const dataObj = selectionDataModel[0].getData();
        let schema = dataObj.schema;
        const payload = Object.assign({}, propPayload);
        schema = dataObj.schema;
        const data = dataObj.data;
        const sourceFields = schema.map(d => d.name);
        payload.criteria = !sourceIdentifiers && selectionDataModel[0].isEmpty() ? null :
            [sourceFields, ...data];
        payload.sourceFields = sourceIdentifiers ? sourceIdentifiers.getSchema().map(d => d.name) : [];
        return payload;
    }
};



/***/ }),

/***/ "./packages/visual-unit/src/helper/grid-lines.js":
/*!*******************************************************!*\
  !*** ./packages/visual-unit/src/helper/grid-lines.js ***!
  \*******************************************************/
/*! exports provided: getGridLayerDefinitions, getGridLayerData, createGridLineLayer, attachDataToGridLineLayers, renderGridLineLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGridLayerDefinitions", function() { return getGridLayerDefinitions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGridLayerData", function() { return getGridLayerData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGridLineLayer", function() { return createGridLineLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachDataToGridLineLayers", function() { return attachDataToGridLineLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderGridLineLayers", function() { return renderGridLineLayers; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/muze-axis */ "./packages/muze-axis/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums/constants */ "./packages/visual-unit/src/enums/constants.js");





const { BAR_LAYER, TICK_LAYER } = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["LAYER_TYPES"];

const LINEAR = _chartshq_muze_axis__WEBPACK_IMPORTED_MODULE_1__["ScaleType"].LINEAR;

const getLayerDefinition = (context, axes, type, orientation) => {
    let encoding;
    const config = context.config();
    const { classPrefix, gridLines, gridBands } = config;
    const gridLineColor = gridLines.color;
    const zeroLineColor = gridLines.zeroLineColor;
    const defClassName = type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"] ? gridBands.defClassName : gridLines.defClassName;
    const gridBandColor = gridBands[orientation].color;
    const axis = axes[orientation][0];
    const isLinearScale = axis.constructor.type() === LINEAR;

    if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"] && isLinearScale) {
        encoding = {
            [orientation]: `${orientation}value`,
            [`${orientation}0`]: `${orientation}value0`
        };
    } else {
        encoding = {
            [orientation]: isLinearScale ? `${orientation}value` : `${orientation}dim`
        };
    }
    encoding.color = {
        value: (data, i) => {
            const isNegativeDomain = isLinearScale && axis.domain()[0] < 0;
            if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"]) {
                return gridBandColor[i % 2];
            }
            return isNegativeDomain && data[orientation] === 0 ? zeroLineColor : gridLineColor;
        }
    };
    const { color, shape, size } = context.axes();
    return {
        definition: {
            defClassName: `${defClassName}-${orientation}`,
            className: config.className,
            name: orientation,
            calculateDomain: false,
            individualClassName: (data, i) => {
                let className;
                const isNegativeDomain = isLinearScale && axis.domain()[0] < 0;
                if (isNegativeDomain && data.y === 0 && type !== _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"]) {
                    className = `${classPrefix}-axis-zero-line`;
                } else {
                    className = `${classPrefix}-grid-${type}-${orientation}-${i % 2}`;
                }
                return className;
            },
            [`pad${orientation.toUpperCase()}`]: type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"] ? 0 : undefined,
            encoding
        },
        axes: {
            [orientation]: axis,
            color: color[0],
            shape: shape[0],
            size: size[0]
        },
        interactive: false
    };
};

const getDefaultVisibilty = (show, axis) => {
    if (axis.constructor.type() === LINEAR) {
        return show;
    }
    return false;
};

const getGridLayerDefinitions = (context, config, type) => ['x', 'y'].map((axisType) => {
    const axes = context.axes();
    if (!axes[axisType]) {
        return null;
    }
    const show = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(config[axisType] && config[axisType].show,
        getDefaultVisibilty(config.show, axes[axisType][0]));

    return show ? getLayerDefinition(context, axes, type, axisType) : null;
}).filter(d => d !== null);

const dimensionSubTypes = Object.values(muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"]).reduce((acc, v) => {
    acc[v] = 1;
    return acc;
}, {});
const getValidSubtype = subtype => (!dimensionSubTypes[subtype] ? muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL : subtype);

const getGridLayerData = (axes, fields, fieldsConfig) => {
    const gridData = {};

    ['x', 'y'].forEach((type) => {
        let ticks = axes[type][0].getTickValues();
        const subtype = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fields, type, 0).getMembers()[0], 'def', 'subtype');
        const jsonData = [];
        const schema = [
            {
                name: 'yvalue',
                type: 'measure'
            }, {
                name: 'xvalue',
                type: 'measure'
            },
            {
                name: 'yvalue0',
                type: 'measure'
            }, {
                name: 'xvalue0',
                type: 'measure'
            }, {
                name: 'xdim',
                type: 'dimension',
                subtype: getValidSubtype(subtype)
            }, {
                name: 'ydim',
                type: 'dimension',
                subtype: getValidSubtype(subtype)
            }
        ];
        const len = Math.max(ticks.length);
        ticks = subtype === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL ? ticks.map(d => d.getTime()) : ticks;
        for (let i = 0; i < len; i += 1) {
            jsonData.push({
                [`${type}value`]: ticks[i],
                [`${type}value0`]: ticks[i + 1],
                [`${type}dim`]: ticks[i],
                [`${type}dim`]: ticks[i]
            });
        }
        gridData[type] = new muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"](jsonData, schema);
    });
    return gridData;
};

const createGridLineLayer = (context) => {
    const vuConf = context.config();
    const metaInf = context.metaInf();
    const store = context.store();
    const timeDiffs = context._timeDiffs;
    [_enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"], _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_LINE"]].forEach((type) => {
        let mark;
        let config;
        if (type === _enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND"]) {
            mark = BAR_LAYER;
            config = vuConf.gridBands;
        } else {
            mark = TICK_LAYER;
            config = vuConf.gridLines;
        }
        const definitions = getGridLayerDefinitions(context, config, type);

        const sel = `_${type}Selection`;
        context[sel] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["createSelection"])(context[sel], (atomicDef) => {
            const inst = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["layerFactory"].getLayerInstance({ mark });
            inst.dependencies(context._dependencies);
            const name = atomicDef.definition.name;
            inst.metaInf({
                unitRowIndex: metaInf.rowIndex,
                unitColIndex: metaInf.colIndex,
                namespace: `${metaInf.namespace}${type}${name}`,
                parentNamespace: metaInf.namespace
            })
                .store(store);
            return inst;
        }, definitions, atomicDef => atomicDef.definition.name);
        context[sel].each((layer, atomicDef) => {
            const definition = atomicDef.definition;
            const sConf = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_2__["layerFactory"].getSerializedConf(mark, definition);
            const axesObj = atomicDef.axes;
            layer.config(sConf)
                .dataProps({
                    timeDiffs
                })
                .axes(axesObj);
        });
        context[`_${type}`] = context[sel].getObjects();
    });
};

const attachDataToGridLineLayers = (context) => {
    const axes = context.axes();
    const gridLines = context._gridLines;
    const gridBands = context._gridBands;
    if (gridLines.length || gridBands.length) {
        const gridLayerData = getGridLayerData(axes, context.fields(), context.data().getFieldsConfig());
        [].concat(...gridBands, ...gridLines).forEach((inst) => {
            inst.data(inst.axes().x ? gridLayerData.x : gridLayerData.y);
        });
    }
};

const renderGridLineLayers = (context, container) => {
    const config = context.config();
    const classPrefix = config.classPrefix;
    const gridLines = context._gridLines;
    const gridBands = context._gridBands;
    const measurement = {
        width: context.width(),
        height: context.height()
    };
    const gridLineParentGroup = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'g', [1], `${classPrefix}-${_enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_PARENT_GROUP"]}`);

    [[gridLines, `${classPrefix}-${_enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_LINE_PARENT_GROUP_CLASS"]}`],
            [gridBands, `${classPrefix}-${_enums_constants__WEBPACK_IMPORTED_MODULE_3__["GRID_BAND_PARENT_GROUP_CLASS"]}`]].forEach((entry) => {
                const [instances, parentGroupClass] = entry;
                const mountPoint = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(gridLineParentGroup, 'g', [1], `.${parentGroupClass}`);
                const className = `${parentGroupClass}-group`;
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(mountPoint, 'g', instances, `.${className}`, {
                    update: (group, instance) => {
                        instance.dataProps({ timeDiffs: context._timeDiffs })
                            .measurement(measurement)
                            .mount(group.node());
                    }
                });
            });
};


/***/ }),

/***/ "./packages/visual-unit/src/helper/index.js":
/*!**************************************************!*\
  !*** ./packages/visual-unit/src/helper/index.js ***!
  \**************************************************/
/*! exports provided: getDimensionMeasureMap, transformDataModels, getLayerFromDef, resolveEncodingTransform, sanitizeLayerDef, attachDataToLayers, attachAxisToLayers, getLayerAxisIndex, unionDomainFromLayers, renderLayers, getNearestDimensionalValue, getLayersBy, removeLayersBy, createSideEffectGroup, createRenderPromise, getRadiusRange, setAxisRange, isXandYMeasures, getValuesMap, getSelectionRejectionModel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDimensionMeasureMap", function() { return getDimensionMeasureMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformDataModels", function() { return transformDataModels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerFromDef", function() { return getLayerFromDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveEncodingTransform", function() { return resolveEncodingTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeLayerDef", function() { return sanitizeLayerDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachDataToLayers", function() { return attachDataToLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachAxisToLayers", function() { return attachAxisToLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerAxisIndex", function() { return getLayerAxisIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unionDomainFromLayers", function() { return unionDomainFromLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLayers", function() { return renderLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNearestDimensionalValue", function() { return getNearestDimensionalValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayersBy", function() { return getLayersBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeLayersBy", function() { return removeLayersBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSideEffectGroup", function() { return createSideEffectGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRenderPromise", function() { return createRenderPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRadiusRange", function() { return getRadiusRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisRange", function() { return setAxisRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isXandYMeasures", function() { return isXandYMeasures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValuesMap", function() { return getValuesMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectionRejectionModel", function() { return getSelectionRejectionModel; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");



const getDimensionMeasureMap = (layers, fieldsConfig) => {
    const retinalEncodingsAndMeasures = {};

    layers.forEach((layer) => {
        const {
            colorField,
            sizeField,
            shapeField,
            xField,
            yField
        } = layer.encodingFieldsInf();
        const measures = [xField, yField].filter(field => fieldsConfig[field] && fieldsConfig[field].def.type ===
            muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE);
        [colorField, sizeField, shapeField].forEach((field) => {
            if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fieldsConfig, field, 'def', 'type') === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].DIMENSION && measures.length) {
                !retinalEncodingsAndMeasures[field] && (retinalEncodingsAndMeasures[field] = []);
                retinalEncodingsAndMeasures[field].push(...measures);
            }
        });
    });

    for (const key in retinalEncodingsAndMeasures) {
        if ({}.hasOwnProperty.call(retinalEncodingsAndMeasures, key)) {
            retinalEncodingsAndMeasures[key] = [...new Set(retinalEncodingsAndMeasures[key])];
        }
    }
    return retinalEncodingsAndMeasures;
};

const transformDataModels = (transform, dataModel) => {
    const dataModels = {};
    for (const key in transform) {
        if ({}.hasOwnProperty.call(transform, key)) {
            const transformVal = transform[key];
            dataModels[key] = transformVal(dataModel);
        }
    }

    return dataModels;
};

const getLayerFromDef = (context, definition, existingLayer, namespaces) => {
    let instances = existingLayer;
    const dependencies = context._dependencies;
    const metaInf = context.metaInf();
    if (!existingLayer) {
        instances = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__["layerFactory"].getLayerInstance(definition);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["toArray"])(instances).forEach((inst, i) => {
            inst.metaInf({
                unitRowIndex: metaInf.rowIndex,
                unitColIndex: metaInf.colIndex,
                namespace: namespaces[i],
                parentNamespace: metaInf.namespace
            })
                .dependencies(dependencies)
                .store(context.store());
        });
    }
    const layers = {};
    const instanceArr = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["toArray"])(instances);
    definition = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["toArray"])(definition);
    definition.reduce((acc, def, idx) => {
        const instance = instanceArr[idx];
        instance.coord(context.coord());
        instance.config(def);
        instance.valueParser(context.valueParser());
        instance.dataProps({
            timeDiffs: context._timeDiffs
        });
        if (def.name) {
            instance.alias(def.name);
        }
        layers[instance.alias()] = instance;
        return acc;
    }, {});
    return layers;
};

const resolveEncodingTransform = (layerInst, store) => {
    const encodingTransform = layerInst.config().encodingTransform || {};
    const resolvable = encodingTransform.resolvable;
    let depArr = [];
    if (resolvable) {
        const resolved = resolvable(store);
        depArr = resolved.depArr;
        layerInst.encodingTransform(resolved.fn);
    } else if (encodingTransform instanceof Function) {
        layerInst.encodingTransform(encodingTransform);
    }
    return depArr;
};

const sanitizeLayerDef = (layerDefs) => {
    const sanitizedDefs = [];
    layerDefs.forEach((layerDef, i) => {
        const def = layerDef.def;
        const mark = layerDef.mark;
        if (!def) {
            const sConf = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__["layerFactory"].getSerializedConf(layerDef.mark, layerDef);
            if (!sConf.name) {
                sConf.name = `${mark}-${i}`;
            }
            sanitizedDefs.push({
                mark: layerDef.mark,
                def: sConf
            });
        } else {
            if (!def.name) {
                def.name = `${mark}-${i}`;
            }
            sanitizedDefs.push(layerDef);
        }
    });
    return sanitizedDefs;
};

const attachDataToLayers = (layers, dm, transformedDataModels) => {
    layers.forEach((layer) => {
        const dataSource = layer.config().source;
        const dataModel = dataSource instanceof Function ? dataSource(dm) :
            (transformedDataModels[dataSource] || dm);
        layer.data(dataModel);
    });
};

const attachAxisToLayers = (axes, layers, layerAxisIndex) => {
    layers.forEach((layer) => {
        const layerId = layer.id();
        const axesObj = {};

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["objectIterator"])(axes, (key) => {
            const axisInf = layerAxisIndex[layerId];
            if (axisInf) {
                const axisArr = axes[key] || [];
                const axisIndex = axisInf[key] >= 0 ? axisInf[key] : axisArr.length - 1;
                axes[key] && (axesObj[key] = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(axes[key][axisIndex]));
            }
        });
        Object.keys(axesObj).length && layer.axes(axesObj);
    });
};

const { X, Y, RADIUS, ANGLE, ANGLE0, RADIUS0 } = _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_1__["ENCODING"];

const getLayerAxisIndex = (layers, fields) => {
    const layerAxisIndex = {};
    layers.forEach((layer) => {
        const { axis, encoding } = layer.config();
        const id = layer.id();
        [X, Y, ANGLE, ANGLE0, RADIUS].forEach((type) => {
            let index;
            const specificField = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(encoding, type, 'field');
            const encodingField = type === RADIUS ? Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(specificField, Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(encoding, RADIUS0, 'field'))
                : Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(encoding, type, 'field');
            const field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(axis, type), encodingField);
            if (fields[type] && fields[type].length) {
                index = fields[type].findIndex(fieldInst => fieldInst.getMembers().indexOf(field) !== -1);
            } else {
                index = 0;
            }
            !layerAxisIndex[id] && (layerAxisIndex[id] = {});
            layerAxisIndex[id][type] = index;
        });
    });
    return layerAxisIndex;
};

const getValidDomain = (domain, domain1, encodingType, fieldType) => {
    if (encodingType === ANGLE || encodingType === ANGLE0) {
        return domain.concat(domain1.filter(d => domain.indexOf(d) === -1));
    }
    return Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["unionDomain"])([domain, domain1], fieldType);
};

const unionDomainFromLayers = (layers, axisFields, layerAxisIndex, fieldsConfig) => {
    let domains = {};
    layers = layers.filter(layer => layer.getDataDomain() !== null);
    layers.forEach((layer) => {
        let domainValues = {};
        const config = layer.config();
        // const encoding = config.encoding;
        const layerDomain = layer.getDataDomain();
        const layerId = layer.id();

        if (layerDomain !== null && config.calculateDomain !== false) {
            domainValues = Object.entries(layerDomain);
            domains = domainValues.reduce((fieldDomain, domain) => {
                const encodingType = domain[0];
                const axisIndex = layerAxisIndex[layerId][encodingType];
                const field = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(axisFields, encodingType, axisIndex);
                !fieldDomain[encodingType] && (fieldDomain[encodingType] = {});
                const encodingDomain = fieldDomain[encodingType];
                if (field) {
                    const fieldStr = `${field}`;
                    encodingDomain[fieldStr] = encodingDomain[fieldStr] || [];
                    encodingDomain[fieldStr] = getValidDomain(encodingDomain[fieldStr],
                        domain[1], encodingType, fieldsConfig[field.getMembers()[0]].def.subtype);
                }
                return fieldDomain;
            }, domains);
        }
    });
    return domains;
};

const renderLayers = (context, container, layers, measurement) => {
    context._lifeCycleManager.notify({ client: layers, action: 'beforedraw', formalName: 'layer' });
    const config = context.config();
    const classPrefix = config.classPrefix;
    const orderedLayers = layers.sort((a, b) => a.config().order - b.config().order);
    const layerParentGroup = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'g', [1], `${classPrefix}-layer-group`);
    const layerDepOrder = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getDependencyOrder"])(context._layerDepOrder);
    const groups = {};
    Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(layerParentGroup, 'g', orderedLayers, null, {
        update: (group, layer) => {
            groups[layer.alias()] = {
                group,
                layer
            };
        }
    });

    const layerSeq = layerDepOrder.map(name => groups[name]).filter(d => d !== undefined);
    
    layerSeq.forEach((o) => {
        const layer = o.layer;
        const group = o.group;
        layer.measurement(measurement);
        layer.dataProps({
            timeDiffs: context._timeDiffs
        });
        layer.config().render !== false && layer.mount(group.node());
    });
    return undefined;
};

const getNearestDimensionalValue = (context, position) => {
    const fields = context.fields();
    if (!fields.x.length || !fields.y.length) {
        return null;
    }
    const data = context.data();
    const axes = context.axes();
    const fieldsConfig = data.getFieldsConfig();
    const xField = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fields, 'x', 0).getMembers()[0];
    const yField = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(fields, 'y', 0).getMembers()[0];
    const xFieldType = fieldsConfig[xField].def.subtype;
    const yFieldType = fieldsConfig[yField].def.subtype;

    const entryVal = [['x', xFieldType, xField], ['y', yFieldType, yField]].find(entry =>
        entry[1] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].CATEGORICAL || entry[1] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL);

    if (!entryVal || (xFieldType !== muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS && yFieldType !== muze_utils__WEBPACK_IMPORTED_MODULE_0__["MeasureSubtype"].CONTINUOUS)) {
        return null;
    }
    const field = entryVal[2];
    const index = fieldsConfig[field].index;
    let key = axes[entryVal[0]][0].invert(position[entryVal[0]]);
    if (entryVal[1] === muze_utils__WEBPACK_IMPORTED_MODULE_0__["DimensionSubtype"].TEMPORAL) {
        const filterData = [...new Set(data.getData().data.map(d => d[index]))];
        key = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getNearestValue"])(filterData, key);
    }

    return key !== undefined ? [[field], [key]] : null;
};

const getLayersBy = (layers, searchBy, value) => layers.filter((layer) => {
    const name = searchBy === 'type' ? layer.constructor.formalName() : layer.alias();
    return name === value;
});

const removeLayersBy = (layers, searchBy, value) => {
    layers.filter((inst) => {
        const name = searchBy === 'type' ? inst.config().mark : inst.alias();
        if (name === value) {
            inst.remove();
            return false;
        }
        return true;
    });
};

const createSideEffectGroup = (container, className) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["makeElement"])(container, 'g', [1], className).node();

const createRenderPromise = (unit) => {
    const renderedPromise = unit._renderedPromise;
    renderedPromise.then(() => {
        unit._renderedPromise = new Promise((resolve) => {
            unit._renderedResolve = resolve;
        });
        createRenderPromise(unit);
    });
};

const getRadiusRange = (width, height, config = {}) => {
    const {
        innerRadius,
        outerRadius
    } = config;

    return [innerRadius || 0, outerRadius || Math.min(height,
        width) / 2];
};

const setAxisRange = (context) => {
    const axes = context.axes();
    const { radius: radiusAxes } = axes;
    if (radiusAxes) {
        radiusAxes.forEach((axis) => {
            axis.range(getRadiusRange(context.width(), context.height()));
        });
    }
};

const isXandYMeasures = (context) => {
    const { x: xFields, y: yFields } = context.fields();
    const [xMeasures, yMeasures] = [xFields, yFields].map(fields => fields
        .every(field => field.type() === muze_utils__WEBPACK_IMPORTED_MODULE_0__["FieldType"].MEASURE));
    return xMeasures && yMeasures;
};

const getKey = (arr, row) => {
    let key = row[arr[0]];
    for (let i = 1, len = arr.length; i < len; i++) {
        key = `${key},${row[arr[i]]}`;
    }
    return key;
};

const getValuesMap = (model, context) => {
    const valuesMap = {};
    const { data: dataArr, schema, uids } = model.getData();
    const fieldsConfig = model.getFieldsConfig();
    const fieldIndices = isXandYMeasures(context) ? schema.map((d, i) => i) :
                            Object.keys(model.getFieldspace().getDimension()).map(d => fieldsConfig[d].index);
    dataArr.forEach((row, i) => {
        const key = getKey(fieldIndices, row);
        valuesMap[key] = uids[i];
    });
    return valuesMap;
};

const getSelectionRejectionModel = (model, propModel, measures, propValuesMap) => {
    let rejectionModel;
    const { data, schema } = propModel.getData();
    const entryRowIds = [];
    const exitRowIds = [];

    if (schema.length) {
        const fieldMap = model.getFieldsConfig();
        const rowIdsObj = {};
        const filteredSchema = measures ? schema.map((d, idx) => idx) :
            Object.keys(model.getFieldspace().getDimension()).map(d => fieldMap[d].index);
        data.forEach((row) => {
            const key = getKey(filteredSchema, row);
            const id = propValuesMap[key];
            if (key in propValuesMap) {
                entryRowIds.push(id);
                rowIdsObj[id] = 1;
            }
        });
        rejectionModel = model.select((fields, i) => {
            if (!rowIdsObj[i]) {
                exitRowIds.push(i);
                return true;
            }
            return false;
        }, {
            saveChild: false
        });
    } else {
        rejectionModel = propModel;
    }

    return {
        model: [propModel, rejectionModel],
        entryRowIds,
        exitRowIds
    };
};


/***/ }),

/***/ "./packages/visual-unit/src/index.js":
/*!*******************************************!*\
  !*** ./packages/visual-unit/src/index.js ***!
  \*******************************************/
/*! exports provided: VisualUnit, helpers, enums, UnitFireBolt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper */ "./packages/visual-unit/src/helper/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "helpers", function() { return _helper__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./packages/visual-unit/src/enums/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "enums", function() { return _enums__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _firebolt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebolt */ "./packages/visual-unit/src/firebolt/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnitFireBolt", function() { return _firebolt__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _visual_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./visual-unit */ "./packages/visual-unit/src/visual-unit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisualUnit", function() { return _visual_unit__WEBPACK_IMPORTED_MODULE_3__["default"]; });









/***/ }),

/***/ "./packages/visual-unit/src/listener-map.js":
/*!**************************************************!*\
  !*** ./packages/visual-unit/src/listener-map.js ***!
  \**************************************************/
/*! exports provided: listenerMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenerMap", function() { return listenerMap; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/reactive-props */ "./packages/visual-unit/src/enums/reactive-props.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper */ "./packages/visual-unit/src/helper/index.js");
/* harmony import */ var _helper_grid_lines__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper/grid-lines */ "./packages/visual-unit/src/helper/grid-lines.js");






const removeExitLayers = (layerDefs, context) => {
    const layersMap = context._layersMap;
    const markSet = {};
    layerDefs.forEach((layerDef, i) => {
        const id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(layerDef.name, `${layerDef.mark}-${i}`);
        markSet[id] = true;
    });

    for (const key in layersMap) {
        if (!(key in markSet)) {
            layersMap[key].forEach(layer => layer.remove());
            delete layersMap[key];
        }
    }
};

const listenerMap = [
    {
        type: 'registerImmediateListener',
        props: [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["LAYERDEFS"]],
        listener: (context, [, layerDefs]) => {
            const fieldsVal = context.fields();
            if (layerDefs && fieldsVal) {
                removeExitLayers(layerDefs, context);
                const queuedLayerDefs = context._queuedLayerDefs;
                let layerDefArr = layerDefs;
                queuedLayerDefs.forEach((defFn) => {
                    layerDefArr = [...layerDefArr, ...defFn(layerDefs)];
                });
                context.addLayer(layerDefArr);
                const adjustRange = context.layers().some(inst => inst.hasPlotSpan());
                ['x', 'y'].forEach((type) => {
                    const axisArr = Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["defaultValue"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["getObjProp"])(context.axes(), type), []);
                    axisArr.forEach((axis) => {
                        axis.config({
                            adjustRange
                        });
                    });
                });
                context._lifeCycleManager.notify({
                    client: context.layers(),
                    action: 'initialized',
                    formalName: 'layer'
                });
            }
        }
    },
    {
        type: 'registerImmediateListener',
        props: [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["DATA"]],
        listener: (context, [, dataModel]) => {
            if (dataModel) {
                const axesObj = context.axes();
                const timeDiffs = {};
                const timeDiffsByField = {};

                Object.entries(Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["temporalFields"])(dataModel)).forEach(([fieldName, fieldObj]) => {
                    timeDiffsByField[fieldName] = fieldObj.minimumConsecutiveDifference();
                });

                Object.entries(context.fields()).forEach(([type, [field]]) => {
                    if (field) {
                        const timeDiff = timeDiffsByField[`${field}`];
                        if (timeDiff) {
                            timeDiffs[type] = timeDiff;
                            axesObj[type].forEach(axis => axis.minDiff(timeDiff));
                        }
                    }
                });

                context._timeDiffsByField = timeDiffsByField;
                context._timeDiffs = timeDiffs;
                const firebolt = context.firebolt();
                const originalData = context.cachedData()[0];
                firebolt.createSelectionSet(context.data().getUids());
                firebolt.attachPropagationListener(originalData);
            }
        }
    },
    {
        type: 'registerImmediateListener',
        props: [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["CONFIG"]],
        listener: (context, [, config]) => {
            if (config) {
                context.firebolt().config(config.interaction);
                Object(_helper_grid_lines__WEBPACK_IMPORTED_MODULE_3__["createGridLineLayer"])(context);
            }
        }
    },
    {
        type: 'registerImmediateListener',
        props: [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["DATA"], _enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["TRANSFORM"]],
        listener: (context, [, dataModel], [, transform]) => {
            if (dataModel) {
                const dataModels = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["transformDataModels"])(transform, dataModel);
                const metaInf = context.metaInf();
                context.store().commit(`${muze_utils__WEBPACK_IMPORTED_MODULE_0__["STATE_NAMESPACES"].UNIT_LOCAL_NAMESPACE}.${_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["TRANSFORMEDDATA"]}`,
                    dataModels, metaInf.namespace);
            }
        }
    },
    {
        type: 'registerImmediateListener',
        props: [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["TRANSFORMEDDATA"], _enums_reactive_props__WEBPACK_IMPORTED_MODULE_1__["LAYERS"]],
        listener: (context, [, transformedData], [, layers]) => {
            const layerAxisIndexVal = context._layerAxisIndex;
            const axesVal = context.axes();
            const dataModel = context.data();
            if (transformedData && layers && axesVal && layerAxisIndexVal) {
                context._lifeCycleManager.notify({ client: layers, action: 'beforeupdate', formalName: 'layer' });
                Object(_helper__WEBPACK_IMPORTED_MODULE_2__["attachDataToLayers"])(layers, dataModel, transformedData);
                context._dimensionMeasureMap = Object(_helper__WEBPACK_IMPORTED_MODULE_2__["getDimensionMeasureMap"])(layers,
                    dataModel.getFieldsConfig(), context.retinalFields());
                Object(_helper__WEBPACK_IMPORTED_MODULE_2__["attachAxisToLayers"])(axesVal, layers, layerAxisIndexVal);
                context._lifeCycleManager.notify({ client: layers, action: 'updated', formalName: 'layer' });
            }
        }
    }
];


/***/ }),

/***/ "./packages/visual-unit/src/local-options.js":
/*!***************************************************!*\
  !*** ./packages/visual-unit/src/local-options.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _default_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default-config */ "./packages/visual-unit/src/default-config.js");
/* harmony import */ var _enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enums/reactive-props */ "./packages/visual-unit/src/enums/reactive-props.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper */ "./packages/visual-unit/src/helper/index.js");





/* harmony default export */ __webpack_exports__["default"] = ({
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["CONFIG"]]: {
        value: null,
        meta: {
            sanitization: (config, oldConfig) => (
                Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])(oldConfig || Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({}, _default_config__WEBPACK_IMPORTED_MODULE_1__["defaultConfig"]), config)
            )
        }
    },
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["LAYERDEFS"]]: {
        value: null,
        meta: {
            preset: layerDef => Object(_helper__WEBPACK_IMPORTED_MODULE_3__["sanitizeLayerDef"])(layerDef)
        }
    },
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["TRANSFORM"]]: {
        value: null
    },
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["LAYERS"]]: {
        value: null
    },
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["DATA"]]: {
        value: null,
        meta: {
            typeCheck: d => d instanceof muze_utils__WEBPACK_IMPORTED_MODULE_0__["DataModel"],
            preset: (data, context) => {
                context._cachedValuesMap = ((model) => {
                    let valuesMap = null;
                    return () => {
                        if (valuesMap) {
                            return valuesMap;
                        }
                        valuesMap = Object(_helper__WEBPACK_IMPORTED_MODULE_3__["getValuesMap"])(model, context);
                        return valuesMap;
                    };
                })(data);
                if (context._cache) {
                    const cachedData = context.cachedData();
                    context.cachedData([...cachedData, data]);
                } else {
                    const oldData = context.cachedData()[0];
                    oldData && oldData.unsubscribe('propagation');
                    context.cachedData([data]);
                }
            }
        }
    },
    [_enums_reactive_props__WEBPACK_IMPORTED_MODULE_2__["TRANSFORMEDDATA"]]: {
        value: null
    },
    width: {
        value: null
    },
    height: {
        value: null
    }
});


/***/ }),

/***/ "./packages/visual-unit/src/props.js":
/*!*******************************************!*\
  !*** ./packages/visual-unit/src/props.js ***!
  \*******************************************/
/*! exports provided: PROPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROPS", function() { return PROPS; });
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _enums_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums/constants */ "./packages/visual-unit/src/enums/constants.js");



const PROPS = {
    [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["FACET_BY_FIELDS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["RETINAL_FIELDS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["PARENT_ALIAS"]]: {},
    [_enums_constants__WEBPACK_IMPORTED_MODULE_1__["CACHED_DATA"]]: {},
    detailFields: {},
    axes: {
        defaultValue: {
            x: [],
            y: []
        }
    },
    fields: {
        defaultValue: {
            x: [],
            y: []
        },
        sanitization: (context, value) => Object(muze_utils__WEBPACK_IMPORTED_MODULE_0__["mergeRecursive"])({
            x: [],
            y: []
        }, value)
    },
    metaInf: {},
    registry: {},
    parentContainerInf: {},
    valueParser: {
        defaultValue: val => val
    },
    coord: {}
};


/***/ }),

/***/ "./packages/visual-unit/src/styles.scss":
/*!**********************************************!*\
  !*** ./packages/visual-unit/src/styles.scss ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./packages/visual-unit/src/visual-unit.js":
/*!*************************************************!*\
  !*** ./packages/visual-unit/src/visual-unit.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VisualUnit; });
/* harmony import */ var _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chartshq/visual-layer */ "./packages/visual-layer/src/index.js");
/* harmony import */ var muze_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! muze-utils */ "./packages/muze-utils/src/index.js");
/* harmony import */ var _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chartshq/muze-firebolt */ "./packages/muze-firebolt/src/index.js");
/* harmony import */ var _firebolt_action_behaviour_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./firebolt/action-behaviour-map */ "./packages/visual-unit/src/firebolt/action-behaviour-map.js");
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helper */ "./packages/visual-unit/src/helper/index.js");
/* harmony import */ var _helper_grid_lines__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helper/grid-lines */ "./packages/visual-unit/src/helper/grid-lines.js");
/* harmony import */ var _listener_map__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./listener-map */ "./packages/visual-unit/src/listener-map.js");
/* harmony import */ var _props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./props */ "./packages/visual-unit/src/props.js");
/* harmony import */ var _firebolt__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./firebolt */ "./packages/visual-unit/src/firebolt/index.js");
/* harmony import */ var _firebolt_helper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./firebolt/helper */ "./packages/visual-unit/src/firebolt/helper.js");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./styles.scss */ "./packages/visual-unit/src/styles.scss");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_styles_scss__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _local_options__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./local-options */ "./packages/visual-unit/src/local-options.js");
/* harmony import */ var _enums_reactive_props__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./enums/reactive-props */ "./packages/visual-unit/src/enums/reactive-props.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./enums */ "./packages/visual-unit/src/enums/index.js");















const FORMAL_NAME = 'VisualUnit';
const unitNs = [muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_GLOBAL_NAMESPACE, muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_LOCAL_NAMESPACE];
const groupNs = muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].GROUP_GLOBAL_NAMESPACE;

/**
 * Visual Unit is hierarchical component created by {@link VisualGroup}. This component accepts layer definitions
 * and creates concrete layer instances from them, binds data and attaches axis to them. It also retreives the domain
 * from the layers and unions them and sets them on corresponding axis instances. This also creates the parent svg
 * groups for all the layers and delegates the rendering to all the layers.
 *
 * @public
 * @module VisualUnit
 * @class
 */
class VisualUnit {

    /**
     * Creates instance of visualization unit.
     *
     * @param {Object} registry  Component registry
     * @param {Object} dependencies  Dependencies required by visual unit.
     */
    constructor (registry, dependencies) {
        this._id = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getUniqueId"])();
        this._dependencies = dependencies;
        this._renderedResolve = null;
        this._renderedPromise = new Promise((resolve) => {
            this._renderedResolve = resolve;
        });
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["createRenderPromise"])(this);
        this._lifeCycleManager = dependencies.lifeCycleManager;
        this._layersMap = {};
        this._gridLinesSelection = null;
        this._gridBandsSelection = null;
        this._gridLines = [];
        this._gridBands = [];
        this._layerAxisIndex = {};
        this._queuedLayerDefs = [];
        _chartshq_visual_layer__WEBPACK_IMPORTED_MODULE_0__["layerFactory"].setLayerRegistry(registry.layerRegistry);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["generateGetterSetters"])(this, this.constructor.getterSetters());
        this.registry(registry);
        this.cachedData([]);
    }

    static formalName () {
        return FORMAL_NAME;
    }

    static getState () {
        return [
            {
                domain: null
            },
            Object.keys((this.localOptions())).reduce((acc, v) => {
                acc[v] = _local_options__WEBPACK_IMPORTED_MODULE_11__["default"][v].value;
                return acc;
            }, {})
        ];
    }

    static getterSetters () {
        return _props__WEBPACK_IMPORTED_MODULE_7__["PROPS"];
    }

    static localOptions () {
        return _local_options__WEBPACK_IMPORTED_MODULE_11__["default"];
    }

    static getQualifiedStateProps () {
        const unitState = VisualUnit.getState();
        return unitState.map((state, i) => Object.keys(state).map(prop => `${unitNs[i]}.${prop}`));
    }

    static getListeners () {
        return {
            store: [..._listener_map__WEBPACK_IMPORTED_MODULE_6__["listenerMap"].map((d) => {
                const o = Object.assign({}, d);
                const localNs = unitNs[1];
                o.props = o.props.map(prop => `${localNs}.${prop}`);
                return o;
            }), {
                type: 'registerImmediateListener',
                props: [`${muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].LAYER_GLOBAL_NAMESPACE}.domain`],
                listener: (context) => {
                    const domain = context.calculateDomainFromData();
                    context.dataDomain(domain);
                }
            }, {
                type: 'registerImmediateListener',
                props: [`${unitNs[1]}.${_enums_reactive_props__WEBPACK_IMPORTED_MODULE_12__["WIDTH"]}`,
                    `${unitNs[1]}.${_enums_reactive_props__WEBPACK_IMPORTED_MODULE_12__["HEIGHT"]}`,
                    ...['x', 'y'].map(type => `${groupNs}.domain.${type}`)],
                listener: (context, [, width], [, height]) => {
                    if (width && height) {
                        Object(_helper_grid_lines__WEBPACK_IMPORTED_MODULE_5__["attachDataToGridLineLayers"])(context);
                    }
                },
                subNamespace: (context) => {
                    const { rowIndex, colIndex, namespace } = context.metaInf();
                    return {
                        [`${unitNs[1]}.${_enums_reactive_props__WEBPACK_IMPORTED_MODULE_12__["WIDTH"]}`]: namespace,
                        [`${unitNs[1]}.${_enums_reactive_props__WEBPACK_IMPORTED_MODULE_12__["HEIGHT"]}`]: namespace,
                        [`${groupNs}.domain.x`]: `${colIndex}0`,
                        [`${groupNs}.domain.y`]: `${rowIndex}0`
                    };
                }
            }],
            throwback: [
                {
                    type: 'registerChangeListener',
                    props: [muze_utils__WEBPACK_IMPORTED_MODULE_1__["CommonProps"].ON_LAYER_DRAW],
                    listener: (context, [, drawn]) => {
                        if (drawn) {
                            const firebolt = context.firebolt();
                            Object(_firebolt_helper__WEBPACK_IMPORTED_MODULE_9__["dispatchQueuedSideEffects"])(firebolt);
                            Object(_firebolt_helper__WEBPACK_IMPORTED_MODULE_9__["clearActionHistory"])(firebolt);
                        }
                        context._renderedResolve();
                        context._lifeCycleManager.notify({
                            client: context.layers(),
                            action: 'drawn',
                            formalName: 'layer'
                        });
                    }
                }
            ]
        };
    }

    store (...params) {
        if (params.length) {
            const store = this._store = params[0];
            const { throwback } = this._dependencies;
            const { namespace } = this.metaInf();

            store.addSubNamespace(namespace, FORMAL_NAME, this);
            throwback.addSubNamespace(namespace, FORMAL_NAME, this);
            Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["transactor"])(this, this.constructor.localOptions(), store, {
                subNamespace: namespace,
                namespace: `${muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_LOCAL_NAMESPACE}`
            });
            this.createFireboltInstance();
            return this;
        }
        return this._store;
    }

    createFireboltInstance () {
        const { fireboltDeps } = this._dependencies;

        this.firebolt(new _firebolt__WEBPACK_IMPORTED_MODULE_8__["default"](this, {
            physical: Object.assign({}, _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["physicalActions"], fireboltDeps.physicalActions),
            behavioural: Object.assign({}, _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["behaviouralActions"], fireboltDeps.behaviouralActions),
            physicalBehaviouralMap: _firebolt_action_behaviour_map__WEBPACK_IMPORTED_MODULE_3__["actionBehaviourMap"]
        }, Object.assign({}, _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["sideEffects"], fireboltDeps.sideEffects), _chartshq_muze_firebolt__WEBPACK_IMPORTED_MODULE_2__["behaviourEffectMap"]));

        return this;
    }

    /**
     * Static helper for creates a unit instance
     *
     * @param {Object} [id] optional unique identifier for a unit; , id is calculated internally
     * @param {DataModel} data instance of datamodel
     * @param {Array.<Layer>} layers layer configuration
     * @param {Object} config configurtion for the visual unit
     * @return {VisualUnit} Instance of a unit
     */
    static create (...params) {
        return new this(...params);
    }

    /**
     * Returns the instance of firebolt associated with this visual unit. Firebolt dispatches the behavioural actions
     * when any physical action happens on the elements of visual unit.
     *
     * @public
     *
     * @return {Firebolt} Instance of firebolt.
     */
    firebolt (...firebolt) {
        if (firebolt.length) {
            this._firebolt = firebolt[0];
            return this;
        }
        return this._firebolt;
    }

    /**
     * Returns the unique id of this visual unit.
     *
     * @public
     * @return {string} Unique identifier.
     */
    id () {
        return this._id;
    }

    lockModel () {
        this.store().lockModel();
        return this;
    }

    unlockModel () {
        this.store().unlockModel();
        return this;
    }

    timeDiffsByField (...params) {
        if (params.length) {
            return this;
        }
        return this._timeDiffsByField;
    }

    /**
     * Renders the visual unit. It creates the layout and renders the axes and layers.
     *
     * @return {VisualUnit} Instance of visual unit.
     */
    render (container) {
        this.createRootContainers(container);

        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["setAxisRange"])(this);
        this.renderLayers();
        const firebolt = this.firebolt();
        Object(_firebolt_helper__WEBPACK_IMPORTED_MODULE_9__["initSideEffects"])(firebolt.sideEffects(), firebolt);
        return this;
    }

    createRootContainers (container) {
        const config = this.config();
        const { className, defClassName, sideEffectClassName, classPrefix } = config;
        const qualifiedClassName = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getQualifiedClassName"])(defClassName, this.id(), config.classPrefix);
        const width = this.width();
        const height = this.height();
        const containerSelection = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["selectElement"])(container).style('position', 'relative');
        this._rootSvg = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["makeElement"])(containerSelection, 'svg', [null], className)
                        .style('width', `${width}px`).style('height', `${height}px`);

        const node = this._rootSvg.node();

        Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["setAttrs"])(node, {
            width,
            height,
            class: qualifiedClassName.join(' ')
        });

        this._sideEffectGroup = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["createSideEffectGroup"])(node, `${classPrefix}-${sideEffectClassName}`);
        return this;
    }

    renderLayers () {
        const width = this.width();
        const height = this.height();
        const node = this._rootSvg.node();

        Object(_helper_grid_lines__WEBPACK_IMPORTED_MODULE_5__["renderGridLineLayers"])(this, node);
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["renderLayers"])(this, node, this.layers(), {
            width,
            height
        });
        return this;
    }

    done () {
        return this._renderedPromise;
    }

    /**
     * Caches all the datamodels in an array from the next `data()` call on visual unit until `clearCaching()` or
     * `resetData()` is called on it.
     *
     * @public
     * @return {VisualUnit} Instance of visual unit.
     */

    enableCaching () {
        this._cache = true;
        return this;
    }

    /**
     * Clears all the previous cached data.
     *
     * @public
     * @segment VisualUnit
     * @return {VisualUnit} Instance of visual unit.
     */
    clearCaching () {
        this._cache = false;
        this.cachedData([this.cachedData()[0]]);
        return this;
    }

    /**
     * Returns the drawing information from visual unit.Drawing context contains the dimensions of unit and the svg
     * container of the visual unit.
     *
     * @public
     *
     * @return {Object} Drawing information.
     *      ```
     *          {
     *              htmlContainer: // Html container of svg container of the visual unit
     *              svgContainer: // Root svg container
     *              width: // Width of the visual unit
     *              height: // Height of the visual unit
     *              sideEffectGroup: // Svg group for drawing side effect elements.
     *              parentContainer: // Parent html container of the visual unit.
     *              xOffset: // x offset space from the starting x position of the container,
     *              yOffset: // y offset space from the starting y position of the container
     *          }
     *      ```
     */
    getDrawingContext () {
        const rootSvg = this._rootSvg && this._rootSvg.node();
        const width = this.width();
        const height = this.height();
        const { el, dimensions } = this.parentContainerInf();
        return {
            htmlContainer: this.mount(),
            svgContainer: rootSvg,
            width,
            height,
            sideEffectGroup: this._sideEffectGroup,
            parentContainer: el,
            parentContainerDimensions: dimensions,
            xOffset: 0,
            yOffset: 0
        };
    }

    /**
     * Returns the serialized configuration of visual unit.
     *
     * @return {Object} serialized configuration
     */
    serialize () {
        return {
            layers: this.layers().map(layer => layer.serialize()),
            config: this.config(),
            axes: this.axes().map(axis => axis.serialize())
        };
    }

    mount (...mount) {
        if (mount.length) {
            this._mount = mount[0];
            this.render(mount[0]);
            this.firebolt().mapActionsAndBehaviour();
            return this;
        }
        return this._mount;
    }

    /**
     * Adds a new layer to the visual unit. It takes a layer definition and creates layer instances from them. It does
     * not render the layers. It returns the layer instances in an array. If the layer definition is a composite layer,
     * then multiple layer instances will be returned in the array.
     *
     * To add a layer in the unit,
     * ```
     *      unit.addLayer({
     *          name: 'bullet',
     *          mark: 'bar',
     *          encoding: {
     *              x: 'Year',
     *              y: 'Acceleration',
     *              color: 'Origin'
     *          }
     *      });
     * ```
     * @public
     * @param {Object} layerDef Definition of new layer.
     *
     * @return {Array} Array of layer instances.
     */
    addLayer (layerDefinition) {
        if (layerDefinition instanceof Function) {
            this._queuedLayerDefs.push(layerDefinition);
            return this;
        }
        const layerDefinitions = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["sanitizeLayerDef"])(Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["toArray"])(layerDefinition));

        const layersMap = this._layersMap;
        const markSet = {};
        const store = {
            layers: {},
            components: {
                unit: this
            }
        };
        let layerIndex = 0;
        const metaInf = this.metaInf();
        const layers = layerDefinitions.sort((a, b) => a.order - b.order).reduce((layersArr, layerDef) => {
            const definition = layerDef.def;
            const markId = definition.name;
            const defArr = Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["toArray"])(definition);
            const namespaces = [];
            defArr.forEach((def) => {
                def.order = layerDef.order + layerIndex;
                const namespace = `${metaInf.namespace}-${def.mark}-${Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getUniqueId"])()}`;
                namespaces.push(namespace);
            });
            layerIndex += defArr.length;
            const instances = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["getLayerFromDef"])(this, definition, layersMap[markId], namespaces);
            store.layers = Object.assign(store.layers, instances);
            const instanceValues = Object.values(instances);
            layersArr = layersArr.concat(...instanceValues);
            layersMap[markId] = instanceValues;
            markSet[markId] = markId;
            return layersArr;
        }, []);

        store.unit = this;
        const layerdeps = {};
        const layersArr = [].concat(...Object.values(this._layersMap));
        layersArr.forEach((layer) => {
            const alias = layer.alias();
            store.layers[alias] = layer;
            layerdeps[alias] = [];
        });
        layers.forEach((layer) => {
            const depArr = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["resolveEncodingTransform"])(layer, store);
            layerdeps[layer.alias()] = depArr;
        });

        this._layerDepOrder = layerdeps;
        this._layerAxisIndex = Object.assign(this._layerAxisIndex, Object(_helper__WEBPACK_IMPORTED_MODULE_4__["getLayerAxisIndex"])(layers, this.fields()));
        this.layers(layersArr);
        return layers;
    }

    remove () {
        const formalName = this.constructor.formalName();
        const { lifeCycleManager, throwback } = this._dependencies;
        const { namespace } = this.metaInf();
        lifeCycleManager.notify({ client: this, action: 'beforeremove', formalName: 'unit' });
        const layers = this.layers();
        this.store().removeSubNamespace(namespace, formalName);
        throwback.removeSubNamespace(namespace, FORMAL_NAME);
        Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["selectElement"])(this.mount()).remove();
        this.firebolt().remove();
        // Remove layers
        lifeCycleManager.notify({ client: layers, action: 'beforeremove', formalName: 'layer' });
        [...layers, ...this._gridLines, ...this._gridBands].forEach(layer => layer.remove());
        lifeCycleManager.notify({ client: layers, action: 'removed', formalName: 'layer' });
        lifeCycleManager.notify({ client: this, action: 'removed', formalName: 'unit' });
        return this;
    }

    getDataModelFromIdentifiers (identifiers, mode, parentModel) {
        if (identifiers === null) {
            return null;
        }
        const dataModel = parentModel || this.data();
        return Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["getDataModelFromIdentifiers"])(dataModel, identifiers, mode);
    }

    /**
     * Resets the data of visual unit to original data model. It also clears the cached data.
     *
     * @public
     * @segment VisualUnit
     * @return {VisualUnit} Instance of visual unit.
     */
    resetData () {
        this.data(this.cachedData()[0]);
        return this;
    }

    getSourceInfo () {
        return {
            dimensionMeasureMap: this._dimensionMeasureMap,
            fields: this.fields(),
            data: this.data(),
            axes: this.axes()
        };
    }

    dataDomain (...params) {
        const { namespace } = this.metaInf();
        const store = this.store();
        const prop = `${muze_utils__WEBPACK_IMPORTED_MODULE_1__["STATE_NAMESPACES"].UNIT_GLOBAL_NAMESPACE}.${_enums__WEBPACK_IMPORTED_MODULE_13__["REACTIVE_PROPS"].DOMAIN}`;
        if (params.length) {
            const domain = params[0];
            store.commit(prop, domain, namespace);
        }
        return store.get(prop, namespace);
    }

    getDefaultTargetContainer () {
        const { classPrefix, defClassName } = this.config();
        return [`.${classPrefix}-${defClassName}`];
    }

    /**
     * Returns an array of layer instances which matches the supplied mark type.
     *
     * @public
     *
     * @param {string} type Mark type of layer.
     *
     * @return {Array} Array of layer instances.
     */
    getLayersByType (type) {
        const layers = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["getLayersBy"])(this.layers(), 'type', type);
        return layers;
    }

    /**
     * Returns the layer instance which matches the supplied layer name. If no layer is found, then it returns
     * undefined.
     *
     * @public
     * @param {string} name Name of layer.
     *
     * @return {VisualUnit} Layer instance.
     */
    getLayerByName (name) {
        const layers = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["getLayersBy"])(this.layers(), 'name', name);
        return layers[0];
    }

    /**
     * Returns the point located nearest to the supplied x and y position. It returns the unique identifiers of the
     * point. This function also accepts an additional configuration `getAllPoints` inside `config` object in the third
     * argument which if set to true, then it returns the identifiers of all the points which falls on the nearest
     * x value or y value if any one of the field is a dimension. Additionally, a target property is also returned
     * which contains the identifier of the nearest point. If no nearest point is found, then it returns identifier
     * as null.
     *
     * @public
     *
     * @param {number} x X Position of the point from where nearest point is to be found.
     * @param {number} y Y Position of the point from where nearest point is to be found.
     * @param {Object} config Additional configuration options.
     * @param {boolean} config.getAllPoints If true, then returns all the points nearest to the x value or y value if
     * it is dimension.
     * @param {Object} config.data Data associated with the nearest point.
     * @return {Object} Nearest point information
     * ```
     *      {
     *          id: [['Origin'], ['USA'], ['Japan']], // Identifiers of all the points closest to the x value.
     *          target: [['Origin'], ['Japan']] // Identifier of the nearest point.
     *      }
     * ```
     */
    getNearestPoint (x, y, config) {
        let pointObj = {
            id: null
        };
        const dimValue = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["getNearestDimensionalValue"])(this, {
            x,
            y
        });

        if (dimValue !== null && config.getAllPoints) {
            pointObj.id = dimValue;
            const pointInf = this.getMarkInfFromLayers(x, y, config);
            pointObj.target = pointInf && pointInf.id ? pointInf.id : pointObj.id;
            return pointObj;
        }

        const markInf = this.getMarkInfFromLayers(x, y, config) || { id: null };
        pointObj = Object.assign({}, markInf);

        pointObj.target = markInf.id;
        return pointObj;
    }

    getMarkInfFromLayers (x, y, args) {
        const layers = this.layers();
        const len = layers.length;
        let point = null;
        // Iterate through the layers array and fetch the nearest point from each layer. If a valid
        // nearest point is found from any layer, then return that point.
        for (let i = 0; i < len; i++) {
            const layer = layers[i];
            const config = layer.config();
            if (config.interactive !== false) {
                point = layer.getNearestPoint(x, y, args);
            }
            if (point) {
                return point;
            }
        }
        return point;
    }

    /**
     * Get the information of all the marks such as x, y position and size from supplied identifiers. It
     * returns an array of points whose data matches the given identifiers.
     *
     * @public
     *
     * @param {Array|Object} identifiers Field names and their corresponding values.
     * ```
     * identifiers can be given in an array of array,
     *      ['Origin', 'Name'], // Names of the fields supplied in first array
     *      ['USA', 'ford'], // Data values of each field supplied in rest of the arrays.
     *      ['Japan', 'ford']
     * or in an object,
     *      {
     *          Origin: ['USA']
     *      }
     * ```
     * @param {Object} config Optional configurations which decides which information of the mark will
     * be retrieved.
     * @param {boolean} [config.getAllAttrs = false] If true, then returns all the information of each mark.
     * @param {boolean} [config.getBBox = false] If true, then returns the bounding box of each mark.
     *
     * @return {Array} Array of objects containing the information of each point.
     * ```
     * By default, the method returns the array of points in this structure,
     *      [
     *          {
     *              x: 20,
     *              y: 100,
     *              width: 200,
     *              height: 100
     *          }
     *      ]
     * If 'config.getAllAttrs' is true, then it returns all the information of each mark,
     *      [
     *      // Positions of mark on initial state of transition.
     *          enter: {
     *              x: 0,
     *              y: 0
     *          },
     *          // Final positions of the mark
     *          update: {
     *              x: 20,
     *              y: 10
     *          },
     *          style: // css styles of each mark
     *          source: [200, 'USA'] // Row information of each mark
     *          id: 20 // Row id of each mark
     *      ]
     * ```
     */
    getPlotPointsFromIdentifiers (identifiers, config = {}) {
        let points = [];
        let parsedIdentifiers = identifiers;
        if (identifiers === null) {
            return [];
        }
        const layers = this.layers();
        const len = layers.length;
        if (Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["isSimpleObject"])(identifiers)) {
            parsedIdentifiers = [Object.keys(identifiers)];
            parsedIdentifiers = [...parsedIdentifiers, ...Object(muze_utils__WEBPACK_IMPORTED_MODULE_1__["transposeArray"])(Object.values(identifiers))];
        }
        for (let i = 0; i < len; i++) {
            const layer = layers[i];
            if (layer.config().interactive !== false) {
                points = [...points, ...layer.getPointsFromIdentifiers(parsedIdentifiers, config)];
            }
        }
        return points;
    }

    /**
     * Removes the layer instance which matches the supplied layer name.
     *
     * @public
     * @param {string} name Name of layer
     *
     * @return {VisualUnit} Instance of visual unit.
     */
    removeLayerByName (name) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["removeLayersBy"])('name', name);
        return this;
    }

    /**
     * Removes all the layer instances which matches the supplied mark type.
     *
     * @public
     * @param {string} type Mark type of layer.
     *
     * @return {VisualUnit} Instance of visual unit.
     */
    removeLayersByType (type) {
        Object(_helper__WEBPACK_IMPORTED_MODULE_4__["removeLayersBy"])('type', type);
        return this;
    }

    calculateDomainFromData () {
        const domain = Object(_helper__WEBPACK_IMPORTED_MODULE_4__["unionDomainFromLayers"])(this.layers(), this.fields(), this._layerAxisIndex,
            this.data().getFieldsConfig());
        return domain;
    }
}


/***/ })

/******/ });
});
//# sourceMappingURL=muze.js.map