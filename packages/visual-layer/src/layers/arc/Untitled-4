/* eslint-disable */
(function () {
  let env = muze();
  let DataTable = muze.DataModel,
    share = muze.Operators.share,
    html = muze.Operators.html;


  d3.json('../data/lineCrossTab.json', (data) => {
    const jsonData = data,
      schema = [{
        "name": "date",
        "type": "dimension",
        "subtype": "temporal"
      }, {
        "name": "value",
        "type": "measure",
        "defAggFn": "avg"

      }, {
        "name": "quarter",
        "type": "dimension"
      }, {
        "name": "quarterYear",
        "type": "dimension"
      }
      ]
    let rootData = new DataTable(data, schema);
    env = env.data(rootData).minUnitWidth(40);
    let mountPoint = document.getElementById('chart');
    console.log(rootData.getData())
    window.canvas = env.canvas();
    canvas
      .rows(['value'])
      .columns(['quarterYear', 'date'])
      .data(rootData.select((fields) => fields.quarter.value === 'Q1'))
      .width(850)
      .height(400)
      .detail(['quarterYear'])
      .transform({avg:(dm)=>dm.groupBy([''])})
      .layers([{
        mark: 'line',
        className: 'line-plot-item',
        interpolate: 'catmullRom'
      }, {
        mark: 'text',
        className: 'text-layer',
        source: 'avg',
        encoding: {
          x: {field:null},
          text: {
            field: 'value',
            formatter: val => Math.round(val)
          },
          color: {
            value: () => '#000'
          }
        },
        encodingTransform: require('layers', ['line', (lineLayer) => {
            return (points, layerInst, dependencies) => {
                const domain = lineLayer.data().getFieldspace().fieldsObj().value.domain();
                const maxVal = domain[1];
                const maxYPos = lineLayer.axes().y.getScaleValue(maxVal);
                const measurement = layerInst.measurement();
                points[0].update.x = measurement.width / 2;
                const smartLabel = dependencies.smartLabel;
                const textHeight = smartLabel.getOriSize(points[0].text);
                points[0].update.y = maxYPos - textHeight / 2;
                return points;
            }
        }])

      }])
      .config({
        // showHeaders: true, /* show the headers of fields used in faceting */
        // facetConfig: { rows: { verticalAlign: 'middle' } }, /* dimensional values are placed in middle */
        axes: {
          x: { show: false },
          y: {
            tickFormat: (d) => {
              if (d < 1000) return d;
              if (d > 1000 && d < 1000000) return `${d / 1000}K`
              if (d >= 1000000) return `${d / 1000000}M`
              return d
            }
          }
        },
        gridLines: {
          y: { show: true }
        },
        interaction: {
          tooltip: {
            arrow: {
              disabled: true
            },
            offset: {
              x: -85
            },
            mode: 'fragmented',
            formatter: (dataModel, context) => {
              const tooltipData = dataModel.getData().data;
              const fieldConfig = dataModel.getFieldsConfig();
              console.log(fieldConfig);
              let tooltipContent = '';
              tooltipData.forEach((dataArray) => {
                const date = fieldConfig.date.index;
                const value = fieldConfig.value.index;
                const quarterYear = fieldConfig.quarterYear.index;
                tooltipContent += `<p style = "color:white; font-size: 14px; text-align: center;"><strong>${dataArray[quarterYear]}</strong></p>`;
                tooltipContent += `<p style = "color:white; font-size: 14px;">Average Value: ${dataArray[value]}</p>`;
              });
              return html`${tooltipContent}`;
            }
          }
        }
      })
      .title('The Muze Project', { position: "top", align: "left", })
      .subtitle('Composable visualisations with a data first approach', { position: "top", align: "left" })
      .mount(mountPoint);
  })

})()